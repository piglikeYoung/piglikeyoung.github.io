{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/jacman/source/CNAME","path":"CNAME","modified":1,"renderable":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/jacman/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1472653238000},{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1472653238000},{"_id":"themes/jacman/README.md","hash":"75a5c9fbd7c9cec4d2f277042d2fee550e4936be","modified":1472653238000},{"_id":"themes/jacman/README_zh.md","hash":"d6014b16eaccc97dc54a7779c9e36003752410e1","modified":1472653238000},{"_id":"themes/jacman/_config.yml","hash":"137c0fc309edb1b06239e644db719b473a3a731e","modified":1493542879000},{"_id":"themes/jacman/.git/COMMIT_EDITMSG","hash":"ea533601d80d0cc2dcc50baf451852226e0b6149","modified":1473573492000},{"_id":"themes/jacman/.git/FETCH_HEAD","hash":"b661062d038c9375eee62bbb22fd05c692c5dede","modified":1528531399242},{"_id":"themes/jacman/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1472653238000},{"_id":"themes/jacman/.git/config","hash":"d18c0919876ad0fc3ec255e7421e8098f73694b5","modified":1473573497000},{"_id":"themes/jacman/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1472653209000},{"_id":"themes/jacman/.git/index","hash":"9bb3c7bdc4614a2ae9bdbc7c6b80a8d34d54989f","modified":1550455422000},{"_id":"themes/jacman/.git/packed-refs","hash":"1a0b16425620dc0b26bb0396ffca6a8ecfd1a73f","modified":1472653238000},{"_id":"themes/jacman/.git/sourcetreeconfig","hash":"ad4b7abb2aa2829fa52aa273e5c479cbb5a298cf","modified":1528531399453},{"_id":"source/_posts/.DS_Store","hash":"64f6f04beed543fcf88b7bd348158edfcfa0ad2e","modified":1550761741974},{"_id":"source/_posts/2017-11-11-swifter-tips-summary-1.md","hash":"a63717b8b2552bacd842686effb55269fc1b8f3e","modified":1535859036000},{"_id":"source/_posts/2017-11-26-swifter-tips-summary-2.md","hash":"63d81d5209f75a079df9d1c0c66e560a66b6f6e4","modified":1535859153287},{"_id":"source/_posts/2017-12-16-mjrefresh-analysis.md","hash":"fadcb743f807d76884adcee282aa764703ea5064","modified":1535859217379},{"_id":"source/_posts/2018-01-20-masonry-analysis.md","hash":"5ce620c3595d4143d27a93696f81930479614b70","modified":1535859302608},{"_id":"source/_posts/2018-02-24-YYCache-analysis.md","hash":"7e920dc17e5af36f820b7674ed8a8e38057edb4c","modified":1535859399906},{"_id":"source/_posts/2018-05-26-iterm2-with-oh-my-zsh.md","hash":"8982c0a191c2abb07a9bcde284fa6ec9d23416c0","modified":1535859501124},{"_id":"source/_posts/2018-06-09-MacOS10.13.5-cocoapods-solution.md","hash":"88a1e25679c74cf2b4a2db5773ef72c473fbd410","modified":1535859556409},{"_id":"source/_posts/2018-08-26-Mac上使用Charles.md","hash":"1f6af8e803f83bd15e8f6324daa4df11f8c20a5e","modified":1535867166000},{"_id":"source/_posts/2019-01-01-2018年个人总结.md","hash":"23e1bbb1281dcb59bdffb44619d4603d1e9531af","modified":1550054891000},{"_id":"source/_posts/2019-02-16-ARTS.md","hash":"ae1b47f5c9e9d99635c2505e9c408274044229f3","modified":1550766155850},{"_id":"source/_posts/AFNetworking-AFNetworkReachabilityManager-3.md","hash":"7cd7e9d8b14df997ae6b388cde3d7afbac86388a","modified":1485402469000},{"_id":"source/_posts/AFNetworking-AFSecurityPolicy-5.md","hash":"3fd0d8984855061cbf0b3024ff3466605a398f54","modified":1485489065000},{"_id":"source/_posts/AFNetworking-AFURLSerialization-4.md","hash":"c55e9951049fdbb2b550561ff81fabddf76dd1cc","modified":1485437971000},{"_id":"source/_posts/AFNetworking-AFURLSessionManager-2.md","hash":"59a28932def8307d3972091cbe0614dc4be1998a","modified":1485341834000},{"_id":"source/_posts/AFNetworking-Summary-1.md","hash":"b9b976af976fb2d14eb455bc506078132bfa384f","modified":1483790792000},{"_id":"source/_posts/Block-Chain-Syntax.md","hash":"adab287e2bd0bc1046af71a13624eea799ec0dbe","modified":1479013303000},{"_id":"source/_posts/GCD-signal-lock.md","hash":"eced1bf3a31fb663a8b4af50f9cf30db7770f9d0","modified":1473578755000},{"_id":"source/_posts/GitHub-Pages-Hexo搭建博客.md","hash":"0fed2bd0a84c12d42139bd9662ca58b82d93111b","modified":1473572471000},{"_id":"source/_posts/Learn-ReactNative-1.md","hash":"2704eb06b533b74f8086a648972850fcf98f462a","modified":1493546737000},{"_id":"source/_posts/Learn-ReactNative-2.md","hash":"346e1bfe3ec0039e69deff26074a748a2b88b4e0","modified":1493555011000},{"_id":"source/_posts/Learn-ReactNative-3.md","hash":"77aebc8c729090d8777634a08bd551327dda9424","modified":1493609837000},{"_id":"source/_posts/Learn-ReactNative-4.md","hash":"07a0dd2b9f8d2b0c917fe6931ea9bfe2e3c0b756","modified":1493613768000},{"_id":"source/_posts/Learn-ReactNative-5.md","hash":"c395fa11bf203355dbb3ffec3f0f4d4321d72337","modified":1493619487000},{"_id":"source/_posts/Learn-ReactNative-6.md","hash":"1ef56a3d0eca20480634c52e9c78eef0cca79c34","modified":1493621280000},{"_id":"source/_posts/NSInteger-NSUInteger.md","hash":"0ce7ec88beab11cab156c41d87b6c532f1ff9746","modified":1488700358000},{"_id":"source/_posts/NSTimer-1.md","hash":"120d380877dfae018d9e55f3709fe4984b5e6bf3","modified":1480229751000},{"_id":"source/_posts/NSTimer-2.md","hash":"171e14ac85621ab0056ee6adab3502c83b77c73b","modified":1480229758000},{"_id":"source/_posts/Objc-lock-1.md","hash":"502934f51f435f80065e15b2e933715fc15e7901","modified":1473916098000},{"_id":"source/_posts/Objc-lock-2.md","hash":"96e34477499d5d64566ab40ecbc1980c7bc02694","modified":1473916069000},{"_id":"source/_posts/UIDebuggingInformationOverlay.md","hash":"96c23d1f0c9ed23dafcba44ca841071630483f3e","modified":1495895785000},{"_id":"source/_posts/Using-Grand-Central-Dispatch-1.md","hash":"a94945459d00812a0f6541e87683e4c30481d253","modified":1474793340000},{"_id":"source/_posts/Using-Grand-Central-Dispatch-2.md","hash":"e7b854c6f4d3eadd86609ae015aed213f17cfc88","modified":1475655081000},{"_id":"source/_posts/Using-Grand-Central-Dispatch-3.md","hash":"23c7a00c918e123495dae011c96a40465f19a2a1","modified":1475660855000},{"_id":"source/_posts/Using-regex-in-iOS.md","hash":"b9b186cd052ba962da02e4c95b637f62738096e3","modified":1475564627000},{"_id":"source/_posts/block-tips.md","hash":"d2514e23a6be3785b837943721fa85826cf4b53c","modified":1473572410000},{"_id":"source/_posts/bool-BOOL.md","hash":"fef1a7ebc91b8ae2310bd57e0897bc68dfcea6df","modified":1488699169000},{"_id":"source/_posts/code-execution-efficiency-function.md","hash":"82b4d2943f88c2611a3eebb74e776349d173f76f","modified":1473581589000},{"_id":"source/_posts/collect-tips.md","hash":"b1d22a6449042fc97887b640196662e009efca80","modified":1509877939795},{"_id":"source/_posts/duplicate-push.md","hash":"e255898ff3560baa080f956c55b08ee17f5e3130","modified":1473602915000},{"_id":"source/_posts/learn-CALayer-1.md","hash":"96aec0ca42e256efd06fe002731eef3074592dc3","modified":1477742246000},{"_id":"source/_posts/learn-CALayer-2.md","hash":"1d2b4d55769ec3642cc10cc9041f7caceff76dfd","modified":1477752998000},{"_id":"source/_posts/learn-CALayer-3.md","hash":"c409e2e3c6a5ee9c77daa06f9e32186b33b0b94f","modified":1477813843000},{"_id":"source/_posts/localized-string.md","hash":"c46b0edfbec504bd2006d0383931f261e10eb362","modified":1474558996000},{"_id":"source/_posts/modify-mutable-array.md","hash":"b41e9d6292e3cf333fc7935bb190ba488cba4984","modified":1473572508000},{"_id":"source/_posts/moya-analysis-1.md","hash":"b3c364c028907da0c2b639112d40d816f9197c35","modified":1516448355298},{"_id":"source/_posts/moya-analysis-2.md","hash":"da1ad52d4b3b7a5fb69a4d5ca8e33269468eb6aa","modified":1516457831390},{"_id":"source/_posts/moya-analysis-3.md","hash":"8b264d952bbb048be14d073d79fec63765d8c34d","modified":1516458912113},{"_id":"source/_posts/nsstring-cropped.md","hash":"c9c4c5ac46e1f72f4f5a1c9596dd30dc8ad09279","modified":1509871976193},{"_id":"source/_posts/null-and-nil.md","hash":"16152385bf0d11d593574b7d0c840f4edbc02319","modified":1488699156000},{"_id":"source/_posts/performWithoutAnimation-cancel-implicit-animation.md","hash":"30df33995f1eda672d520bae1747ca7e5e6da992","modified":1473572534000},{"_id":"source/_posts/use-UIActivityItemSource.md","hash":"35684a446b322ef6b0a47392e13d48357ee42278","modified":1494693134000},{"_id":"source/_posts/use-fastlane.md","hash":"2b2d7ae4c104f61b3feaa050e4e0021809b44286","modified":1494746693000},{"_id":"source/_posts/work-preferredStatusBarStyle.md","hash":"ce4586a8a7ac947a4fe5f5189a2777f4afd87ca3","modified":1516416620976},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1472653238000},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1472653238000},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1472653238000},{"_id":"themes/jacman/layout/.DS_Store","hash":"773fa5c73d465b072b87297d0efef426bc48c7e6","modified":1473089729000},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1472653238000},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1472653238000},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1472653238000},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1472653238000},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1472653238000},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1472653238000},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1472653238000},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1472653238000},{"_id":"themes/jacman/source/.DS_Store","hash":"8983992a301632f377142eb0de9b7125c7a7c97a","modified":1473583252000},{"_id":"themes/jacman/source/CNAME","hash":"0e27782251150f53b7cea3e7016ee40d265eadd8","modified":1472653238000},{"_id":"themes/jacman/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1472653209000},{"_id":"themes/jacman/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1472653209000},{"_id":"themes/jacman/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1472653209000},{"_id":"themes/jacman/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1472653209000},{"_id":"themes/jacman/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1472653209000},{"_id":"themes/jacman/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1472653209000},{"_id":"themes/jacman/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1472653209000},{"_id":"themes/jacman/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1472653209000},{"_id":"themes/jacman/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1472653209000},{"_id":"themes/jacman/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1472653209000},{"_id":"themes/jacman/.git/logs/HEAD","hash":"3b6f90141b763e37445538be5a4c6adb26d47af8","modified":1473573492000},{"_id":"source/_posts/2019-02-16-ARTS/2019-02-16-ARTS-1@2x.png","hash":"5d9fb86be47e0ff5bf64d0ffd3d80536cff65ec3","modified":1550044245000},{"_id":"source/_posts/AFNetworking-AFURLSerialization-4/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1485397233000},{"_id":"source/_posts/GitHub-Pages-Hexo搭建博客/Snip20160901_2.png","hash":"1fd04aef825443007905e05794780651eed57ce0","modified":1472830780000},{"_id":"source/_posts/GitHub-Pages-Hexo搭建博客/Snip20160901_1.png","hash":"566f664f65db34f25f6de1ae9fa5ec7b503165d1","modified":1472830780000},{"_id":"source/_posts/Learn-ReactNative-3/box-model.gif","hash":"c8d19a1cfc4910bafec9109031ab3465adacf5d3","modified":1493556524000},{"_id":"source/_posts/Learn-ReactNative-3/flexBox-model.jpg","hash":"febafc75dd7729dc9359e589df39d7d26b451158","modified":1493556841000},{"_id":"source/_posts/Learn-ReactNative-4/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1493610866000},{"_id":"source/_posts/NSTimer-2/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1480223509000},{"_id":"source/_posts/NSTimer-2/Snip20161127_3.png","hash":"fc4a629fd167799e50bfc13c37e70b31be6dd0bd","modified":1480227686000},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_VCHierarchy.jpeg","hash":"7e635954f1f20f8c6fa761384b86786d9f3520fe","modified":1495892317000},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_ivarexplorer.jpeg","hash":"dc565548ad3242a5d521b4fd492efaa9f0b51dfd","modified":1495894010000},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_measure2.jpeg","hash":"56608eb62c2e330965becda3c7e99b9857356477","modified":1495893825000},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_speccomparepicker.png","hash":"e86347ecac78d62b96c86a2276dcf9782240e5ce","modified":1495893854000},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_viewhierarchyinfo.png","hash":"9be0073616515c5de0d4492a434f16ca4c5bf92f","modified":1495891594000},{"_id":"source/_posts/block-tips/Snip20160904_1.png","hash":"5db0524d0c68e396a2630a42581fb13a597de7ff","modified":1472970146000},{"_id":"source/_posts/block-tips/Snip20160904_2.png","hash":"6b332ba7f258bca8ec29a50545865bbfc8fb683c","modified":1472970181000},{"_id":"source/_posts/bool-BOOL/.DS_Store","hash":"e72cf6e8b2c4b826bb2b32223eecadae80e4f440","modified":1488703193000},{"_id":"source/_posts/bool-BOOL/Snip20170305_1.png","hash":"a9f743b87fd7a723843e42aaf2862f6b6b28dfaf","modified":1488698830000},{"_id":"source/_posts/collect-tips/AVMakeRectWithAspectRatioInsideRect.jpeg","hash":"cb94b4c84cad393c2d23258ad4a9f0af211ea36a","modified":1509877810472},{"_id":"source/_posts/collect-tips/calculate-the-number-of-calls.jpg","hash":"c1eb660259ec4ccbe2316f04e05105b959614035","modified":1509875324913},{"_id":"source/_posts/collect-tips/take-screenshot-fast.jpg","hash":"b41871faef4bf0697582dd4b3e9b367343120cf6","modified":1509875624997},{"_id":"source/_posts/collect-tips/take-screenshot.jpg","hash":"3d3bdfc18680482bd5a368d28d6b8ae93cfd1946","modified":1509875524519},{"_id":"source/_posts/learn-CALayer-1/Snip20161029_1.png","hash":"fce6db7a6df76c5926f25f7ff0398e2634738365","modified":1477734175000},{"_id":"source/_posts/learn-CALayer-3/evenodd.png","hash":"e4a87e3e97141b0372b64c0a985b8ebd9349cfc7","modified":1477804406000},{"_id":"source/_posts/learn-CALayer-3/lineCap.png","hash":"38499561813622b3dad995a4764ccefa60ceb9eb","modified":1477805549000},{"_id":"source/_posts/learn-CALayer-3/lineJoin.png","hash":"085c8bb2d495d689a2ebe43ced261f12b663a8cf","modified":1477805576000},{"_id":"source/_posts/learn-CALayer-3/nonzero.png","hash":"5864966df8193f1d26bfa24d18389037ab9ecac5","modified":1477804386000},{"_id":"source/_posts/nsstring-cropped/emoji-substring-error.jpg","hash":"9a7561b455b046c0dab92ac4db9b0f9c5f1694d6","modified":1509870321555},{"_id":"source/_posts/performWithoutAnimation-cancel-implicit-animation/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1473564686000},{"_id":"source/_posts/performWithoutAnimation-cancel-implicit-animation/Snip20160906_8.png","hash":"f3e2cee6a6a6a36e1244ea5fac66a129ba72d22b","modified":1473174908000},{"_id":"source/_posts/use-UIActivityItemSource/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1494693320000},{"_id":"source/_posts/use-fastlane/WX20170514-140038.png","hash":"5e358bb63e8e12f26ab01a88f7963b4832bd68e3","modified":1494741647000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"c703b0c25139b8a5f8f9d24a334a07905e2b7987","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"1d794906bf1b94b60888cd0a88ad64e67b9b22dd","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1472653238000},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1472653238000},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"62c20e9873221eed8d4ebbe408c991746279e7c0","modified":1472653238000},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1472653238000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1472653238000},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1472653238000},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1472653238000},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1472653238000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1472653238000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1472653238000},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1472653238000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1472653238000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1472653238000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1472653238000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1472653238000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1472653238000},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1472653238000},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1472653238000},{"_id":"themes/jacman/source/img/favicon.ico","hash":"a16034d61de21b7d1fc60ef3d6ef19862f06fb59","modified":1472653238000},{"_id":"themes/jacman/source/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1472653238000},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1472653238000},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1472653238000},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1472653238000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1472653238000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1472653238000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1472653238000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1472653238000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1472653238000},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1472653238000},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1472653238000},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1472653238000},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1472653238000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1472653238000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1472653238000},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1472653238000},{"_id":"source/_posts/AFNetworking-AFNetworkReachabilityManager-3/Snip20170125_3.png","hash":"9fe489f82b55d9b4e92e2ef58cda0a216cbebe6d","modified":1485341706000},{"_id":"source/_posts/AFNetworking-Summary-1/Snip20170107_3.png","hash":"424ee754c2535dd650a26aa962f114a6972caf4a","modified":1483785709000},{"_id":"source/_posts/GitHub-Pages-Hexo搭建博客/Snip20160902_4.png","hash":"97b330e825a7418d5865ff0cc7263823a1eca573","modified":1472830780000},{"_id":"source/_posts/Learn-ReactNative-1/Snip20170305_2.png","hash":"7e72c8bca9a9434c10c091b84cceb304a1763d1b","modified":1488703050000},{"_id":"source/_posts/Learn-ReactNative-4/WX20170501-114928@2x.png","hash":"785e1c1d73544b91422a1ea639dc44e965e149ff","modified":1493610900000},{"_id":"source/_posts/NSTimer-1/Snip20161126_2.png","hash":"8e582e8bb442ea3a18ac2d81b1493765661278b2","modified":1480141489000},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_0.png","hash":"55227976f6ef2c81308a7a153ea5191936bf470a","modified":1495890486000},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_speccompareoverlay.png","hash":"d4b04a2a2d8d6942adce84a831bc9ca33f780e5a","modified":1495893842000},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_viewhierarchy.png","hash":"c9e5c0e47f20d1c68b7a28f9d44f22d30b6f0a28","modified":1495891583000},{"_id":"source/_posts/learn-CALayer-2/CAGradientLayer-500x500.png","hash":"535049bbf3191f82c1bb0b01878792172a9f59f6","modified":1477747891000},{"_id":"source/_posts/learn-CALayer-2/CAReplicatorLayer.gif","hash":"6bd0805fc55b3d74299372d5fee3715df1c56b53","modified":1477749518000},{"_id":"source/_posts/moya-analysis-1/WechatIMG32.jpeg","hash":"9b85602f3633f9e46709f19f85433da25da102ae","modified":1516442850623},{"_id":"source/_posts/use-fastlane/WX20170514-142857.png","hash":"aea3e1f0f9a2e9300090e27ae1255de96c945048","modified":1494743492000},{"_id":"themes/jacman/source/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1472653238000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1472653238000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1472653238000},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1472653238000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1472653238000},{"_id":"themes/jacman/.git/objects/03/188357473ffa812efa5a57887097cd8b7d2fe4","hash":"ae8b1835a7178ce89791cee066e3b6700b5941fc","modified":1472985377000},{"_id":"themes/jacman/.git/objects/04/71102c501e9a269f1041aada22e501032313ea","hash":"2abae2e08c18474e639ce6de25329acf907ed7b9","modified":1472910463000},{"_id":"themes/jacman/.git/objects/14/7fd1739160d4fd814a25da2331d0b32faa7df1","hash":"a7dec44769f42a18eef1e5c66196892519088420","modified":1473090018000},{"_id":"themes/jacman/.git/objects/19/0fe04532dfce11b31271a6c595afa82cc7d241","hash":"5a4d3cd37fdd3cedf9f1cff5292a4a4be3f0afc5","modified":1472985400000},{"_id":"themes/jacman/.git/objects/22/0fc58f1dad118cbb24cda8cb20e12a680f6d46","hash":"df0ad6f43f569d0ec36b77af410e18caf8e5e8c9","modified":1472983623000},{"_id":"themes/jacman/.git/objects/23/a3769ffe5036762d80ae52d51dbe587d9f0cbc","hash":"c516d34b685c0f204cd81cfdf95aff90234c4f79","modified":1472831869000},{"_id":"themes/jacman/.git/objects/2b/9a276cc3232bc6b4f879947255362a6866fd99","hash":"e562e5434ed57cd0da6930af01056c244a221ec3","modified":1473573453000},{"_id":"themes/jacman/.git/objects/43/b55fd53a7304786d38cbaffdfb62face829489","hash":"a944e8fc70414163b10c9a48262e501cea48120e","modified":1473573492000},{"_id":"themes/jacman/.git/objects/4e/62ba7f13b69eb4b722fd71bf0aa36befd28393","hash":"a2308846bc8e616f6785a36c8d491acec24fc63a","modified":1473089946000},{"_id":"themes/jacman/.git/objects/55/6fcfcaa41d79b9de831d626b5849a8ce572017","hash":"05634a67b4ed46d61e565bdf4d9b9d06e54b355d","modified":1472985400000},{"_id":"themes/jacman/.git/objects/56/c3d657e8e728a8d503e34b545723086efda12b","hash":"c10e4776148be102f426065c59aec58d5ab3ae28","modified":1472983588000},{"_id":"themes/jacman/.git/objects/5d/08dc552f54bc1dfaf1f67a308b24b2f95cd714","hash":"7bdce95111f7f42b9e928bb2a255e9b5c0ca2ac5","modified":1472983623000},{"_id":"themes/jacman/.git/objects/69/a4e30370697d87ac2a31f9435b9ddfb4b82272","hash":"07e8f0dd3c53e1f0ce834e6d8a9afb1baf2ec754","modified":1473573492000},{"_id":"themes/jacman/.git/objects/ac/be62754e290e9f1f54c1ec9fab289b925658cc","hash":"d78166b515b7c8bb967cd175468fb53d4515617e","modified":1472910497000},{"_id":"themes/jacman/.git/objects/c8/543df671db05c30175427d9ffe609a58859a32","hash":"1b24c7a35881acd176e3e4e822eb86d265ed763e","modified":1472831706000},{"_id":"themes/jacman/.git/objects/d3/2fdb3de17330a74445a4429a433bcdbe9e8fcb","hash":"7ae1a77e5952c6dced7b280f07d3f8fd8c37b850","modified":1472910497000},{"_id":"themes/jacman/.git/objects/de/4ff8fafa79b931fb69b92f77ec4545a439f730","hash":"bdb702edc70fc840655aa7f96cbe5b0be01f4d21","modified":1473090018000},{"_id":"themes/jacman/.git/objects/e6/0511f3253baa268b2905511c33ad22491143ad","hash":"b123f23ab5aa004e0e27b35db1fba264e6aa7dc0","modified":1472831869000},{"_id":"themes/jacman/.git/objects/pack/pack-d034dbd55f91465e9f651bbc146d3569491a4a1f.idx","hash":"6a9390d99d11bc35bea99758e5fe0cdfd68ccd07","modified":1472653238000},{"_id":"themes/jacman/.git/refs/heads/master","hash":"3afc2098cd3fdab32fe1813cc851eee988718c17","modified":1473573492000},{"_id":"source/_posts/AFNetworking-AFURLSessionManager-2/Snip20170125_1.png","hash":"0d3d336fd61f54ac7ca4a603f7f4fd31dd64a418","modified":1485317885000},{"_id":"source/_posts/AFNetworking-Summary-1/Snip20170107_1.png","hash":"11c3c8cf39311bd7c38e458d5b7ac3e9c4ac47cd","modified":1483783566000},{"_id":"source/_posts/GitHub-Pages-Hexo搭建博客/Snip20160831_2.png","hash":"c85765fb06b0d6e0786e47598c49b05583109e79","modified":1472830780000},{"_id":"source/_posts/NSTimer-1/Snip20161126_3.png","hash":"f40aa468d19d12da5299c755c7bea60347815509","modified":1480141524000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"7537b3426cb5910b626865d80d554e123de637fe","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1472653238000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1472653238000},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1472653238000},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1472653238000},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1472653238000},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1472653238000},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1472653238000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1472653238000},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"fbd8d10e6dbf8c94bd09aa0fb456f23b2f02a9ea","modified":1472653238000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1472653238000},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5ea1c28a19da709af4619e0ffcbd5261c3d54669","modified":1472653238000},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1472653238000},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1472653238000},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1472653238000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1472653238000},{"_id":"source/_posts/AFNetworking-AFURLSessionManager-2/Snip20170125_2.png","hash":"a1457bca5c17e6b7911db2b149b858ab65f50300","modified":1485317898000},{"_id":"source/_posts/Using-Grand-Central-Dispatch-2/Snip20161005_1.png","hash":"68147c0359c01ae066ff12e0d8cb5e4ef43be548","modified":1475644290000},{"_id":"source/_posts/use-UIActivityItemSource/WX20170513_234019.png","hash":"e6d0be47e6dfbcc4915394b897d8a0065d92129c","modified":1494690959000},{"_id":"themes/jacman/.git/logs/refs/heads/master","hash":"3b6f90141b763e37445538be5a4c6adb26d47af8","modified":1473573492000},{"_id":"themes/jacman/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1472653238000},{"_id":"themes/jacman/.git/refs/remotes/origin/master","hash":"3afc2098cd3fdab32fe1813cc851eee988718c17","modified":1473573497000},{"_id":"source/_posts/modify-mutable-array/Snip20160911_1.png","hash":"540418d3a7e53f06a0e92e893e6dce11570f1faf","modified":1473564598000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1472653238000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1472653238000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1472653238000},{"_id":"source/_posts/NSTimer-2/Snip20161127_2.png","hash":"3e29a34e72a632036c75ff147b0519152f09ddae","modified":1480223484000},{"_id":"source/_posts/learn-CALayer-2/AxialGradientLayerType.gif","hash":"60e545e21e7d07ec524a640584b16a0f136176c4","modified":1477747111000},{"_id":"themes/jacman/.git/logs/refs/remotes/origin/HEAD","hash":"f6a4b7b5077d8ab711e50d012c21c9c1ce5af692","modified":1472653238000},{"_id":"themes/jacman/.git/logs/refs/remotes/origin/master","hash":"01dfdc7fb480fa64c7138f7151de76baf39053cf","modified":1473573497000},{"_id":"source/_posts/AFNetworking-AFURLSerialization-4/Snip20170126_3.png","hash":"b8af5007da131f31e83fc7cee3ad83d49a086381","modified":1485416800000},{"_id":"source/_posts/collect-tips/debug-frame.gif","hash":"a1edc267f5299feec578513136fa22cfca8ac4bd","modified":1509875777022},{"_id":"source/_posts/GitHub-Pages-Hexo搭建博客/Snip20160831_1.png","hash":"2e6353755a01ec1894fc97b146401c489a04a0b1","modified":1472830780000},{"_id":"themes/jacman/.git/objects/pack/pack-d034dbd55f91465e9f651bbc146d3569491a4a1f.pack","hash":"8acc6a055480f1dbef341bfcc27898f799cd3544","modified":1472653238000}],"Category":[{"name":"能工巧匠","_id":"cjseuc7kb00028jpbyeto5b8b"},{"name":"个人总结","_id":"cjseuc7kt000i8jpb3xtx8wa8"},{"name":"ARTS","_id":"cjseuc7ky000q8jpbbuwg0v5r"},{"name":"Source Code Analyze","_id":"cjseuc7l1000x8jpbxjjumjzv"},{"name":"ReactNative","_id":"cjseuc7l400148jpbiar5dv4o"},{"name":"拿来主义","_id":"cjseuc7l9001c8jpbficrawsa"},{"name":"Tips","_id":"cjseuc7lc001k8jpbrua2vapx"}],"Data":[],"Page":[],"Post":[{"title":"iTerm2 + Oh My Zsh 打造舒适终端体验","date":"2018-05-26T06:50:51.000Z","_content":"\n## iTerm2 + Oh My Zsh 打造舒适终端体验\n\n最近尝试用终端来代替图形界面，更能了解本质，使用了 **iTerm2** 来打造了一个相对友好的终端使用，看一下最终效果：\n\n![WX20180609-151847@2x](http://p44bkxib3.bkt.clouddn.com/WX20180609-151847@2x.png)\n\n### 下载iTerm2\n\n直接去官网下载 [iTerm2](https://www.iterm2.com/)\n\n安装完成后，在/bin目录下会多出一个zsh的文件。\n\nMac系统默认使用dash作为终端，可以使用命令修改默认使用zsh：\n\n```shell\nchsh -s /bin/zsh\n```\n\n如果想修改回默认dash，同样使用chsh命令即可：\n\n```shell\nchsh -s /bin/bash\n```\n更多命令查询参考链接\n\n### 安装Oh my zsh\n\n安装方法有两种，可以使用curl或wget，看自己环境或喜好：\n\n```shell\n# curl 安装方式\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n```shell\n# wget 安装方式\nsh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"\n```\n\noh-my-zsh开源地址：https://github.com/robbyrussell/oh-my-zsh\n\n安转好oh-my-zsh后，主题文件夹在 **~/.oh-my-zsh/themes**\n\n修改 **~/.zshrc** 配置文件 **ZSH_THEME=\"agnoster\"**\n\n这个主题比较好看，看个人喜好了。\n\n### 安装PowerLine\n\npowerline官网：http://powerline.readthedocs.io/en/latest/installation.html\n\n安装powerline的方式依然简单，也只需要一条命令：\n\n```shell\npip install powerline-status --user\n```\n\n没有安装pip的同学可能会碰到zsh: command not found: pip。\n\n使用命令安装pip即可：\n\n```shell\nsudo easy_install pip\n```\n\n### 安装PowerFonts\n\n安装字体库需要首先将项目git clone至本地，然后执行源码中的install.sh。\n\n下载地址 https://github.com/powerline/fonts\n\n进入文件夹执行命令：\n\n```shell\n./install.sh\n```\n\n安装好字体库之后，我们来设置iTerm2的字体，具体的操作是iTerm2 -> Preferences -> Profiles -> Text，在Font区域选中Change Font，然后找到Meslo LG字体。有L、M、S可选，看个人喜好：\n![fonts](http://p44bkxib3.bkt.clouddn.com/fonts.png)\n\n我这里设置的字体是：**14pt Meslo LG S DZ Regular for Powerline**\n\n## 配色\n\n最终配色还是需要自己喜好去配置，详细配置步骤可以去参考链接。\n\n## 参考链接\n\n[chsh命令](http://man.linuxde.net/chsh)\n[iTerm 2 && Oh My Zsh【DIY教程——亲身体验过程】](https://www.jianshu.com/p/7de00c73a2bb)\n[iterm2-with-oh-my-zsh](https://github.com/sirius1024/iterm2-with-oh-my-zsh)\n\n","source":"_posts/2018-05-26-iterm2-with-oh-my-zsh.md","raw":"---\ntitle: iTerm2 + Oh My Zsh 打造舒适终端体验\ndate: 2018-05-26 14:50:51\ntags: iTerm2\ncategory: 能工巧匠\n---\n\n## iTerm2 + Oh My Zsh 打造舒适终端体验\n\n最近尝试用终端来代替图形界面，更能了解本质，使用了 **iTerm2** 来打造了一个相对友好的终端使用，看一下最终效果：\n\n![WX20180609-151847@2x](http://p44bkxib3.bkt.clouddn.com/WX20180609-151847@2x.png)\n\n### 下载iTerm2\n\n直接去官网下载 [iTerm2](https://www.iterm2.com/)\n\n安装完成后，在/bin目录下会多出一个zsh的文件。\n\nMac系统默认使用dash作为终端，可以使用命令修改默认使用zsh：\n\n```shell\nchsh -s /bin/zsh\n```\n\n如果想修改回默认dash，同样使用chsh命令即可：\n\n```shell\nchsh -s /bin/bash\n```\n更多命令查询参考链接\n\n### 安装Oh my zsh\n\n安装方法有两种，可以使用curl或wget，看自己环境或喜好：\n\n```shell\n# curl 安装方式\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n```shell\n# wget 安装方式\nsh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"\n```\n\noh-my-zsh开源地址：https://github.com/robbyrussell/oh-my-zsh\n\n安转好oh-my-zsh后，主题文件夹在 **~/.oh-my-zsh/themes**\n\n修改 **~/.zshrc** 配置文件 **ZSH_THEME=\"agnoster\"**\n\n这个主题比较好看，看个人喜好了。\n\n### 安装PowerLine\n\npowerline官网：http://powerline.readthedocs.io/en/latest/installation.html\n\n安装powerline的方式依然简单，也只需要一条命令：\n\n```shell\npip install powerline-status --user\n```\n\n没有安装pip的同学可能会碰到zsh: command not found: pip。\n\n使用命令安装pip即可：\n\n```shell\nsudo easy_install pip\n```\n\n### 安装PowerFonts\n\n安装字体库需要首先将项目git clone至本地，然后执行源码中的install.sh。\n\n下载地址 https://github.com/powerline/fonts\n\n进入文件夹执行命令：\n\n```shell\n./install.sh\n```\n\n安装好字体库之后，我们来设置iTerm2的字体，具体的操作是iTerm2 -> Preferences -> Profiles -> Text，在Font区域选中Change Font，然后找到Meslo LG字体。有L、M、S可选，看个人喜好：\n![fonts](http://p44bkxib3.bkt.clouddn.com/fonts.png)\n\n我这里设置的字体是：**14pt Meslo LG S DZ Regular for Powerline**\n\n## 配色\n\n最终配色还是需要自己喜好去配置，详细配置步骤可以去参考链接。\n\n## 参考链接\n\n[chsh命令](http://man.linuxde.net/chsh)\n[iTerm 2 && Oh My Zsh【DIY教程——亲身体验过程】](https://www.jianshu.com/p/7de00c73a2bb)\n[iterm2-with-oh-my-zsh](https://github.com/sirius1024/iterm2-with-oh-my-zsh)\n\n","slug":"2018-05-26-iterm2-with-oh-my-zsh","published":1,"updated":"2018-09-02T03:38:21.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7k100008jpbu4w33xul","content":"<h2 id=\"iTerm2-Oh-My-Zsh-打造舒适终端体验\"><a href=\"#iTerm2-Oh-My-Zsh-打造舒适终端体验\" class=\"headerlink\" title=\"iTerm2 + Oh My Zsh 打造舒适终端体验\"></a>iTerm2 + Oh My Zsh 打造舒适终端体验</h2><p>最近尝试用终端来代替图形界面，更能了解本质，使用了 <strong>iTerm2</strong> 来打造了一个相对友好的终端使用，看一下最终效果：</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180609-151847@2x.png\" alt=\"WX20180609-151847@2x\"></p>\n<h3 id=\"下载iTerm2\"><a href=\"#下载iTerm2\" class=\"headerlink\" title=\"下载iTerm2\"></a>下载iTerm2</h3><p>直接去官网下载 <a href=\"https://www.iterm2.com/\" target=\"_blank\" rel=\"noopener\">iTerm2</a></p>\n<p>安装完成后，在/bin目录下会多出一个zsh的文件。</p>\n<p>Mac系统默认使用dash作为终端，可以使用命令修改默认使用zsh：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>\n<p>如果想修改回默认dash，同样使用chsh命令即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chsh -s /bin/bash</span><br></pre></td></tr></table></figure>\n<p>更多命令查询参考链接</p>\n<h3 id=\"安装Oh-my-zsh\"><a href=\"#安装Oh-my-zsh\" class=\"headerlink\" title=\"安装Oh my zsh\"></a>安装Oh my zsh</h3><p>安装方法有两种，可以使用curl或wget，看自己环境或喜好：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> curl 安装方式</span><br><span class=\"line\">sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> wget 安装方式</span><br><span class=\"line\">sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"</span><br></pre></td></tr></table></figure>\n<p>oh-my-zsh开源地址：<a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"noopener\">https://github.com/robbyrussell/oh-my-zsh</a></p>\n<p>安转好oh-my-zsh后，主题文件夹在 <strong>~/.oh-my-zsh/themes</strong></p>\n<p>修改 <strong>~/.zshrc</strong> 配置文件 <strong>ZSH_THEME=”agnoster”</strong></p>\n<p>这个主题比较好看，看个人喜好了。</p>\n<h3 id=\"安装PowerLine\"><a href=\"#安装PowerLine\" class=\"headerlink\" title=\"安装PowerLine\"></a>安装PowerLine</h3><p>powerline官网：<a href=\"http://powerline.readthedocs.io/en/latest/installation.html\" target=\"_blank\" rel=\"noopener\">http://powerline.readthedocs.io/en/latest/installation.html</a></p>\n<p>安装powerline的方式依然简单，也只需要一条命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install powerline-status --user</span><br></pre></td></tr></table></figure>\n<p>没有安装pip的同学可能会碰到zsh: command not found: pip。</p>\n<p>使用命令安装pip即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo easy_install pip</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装PowerFonts\"><a href=\"#安装PowerFonts\" class=\"headerlink\" title=\"安装PowerFonts\"></a>安装PowerFonts</h3><p>安装字体库需要首先将项目git clone至本地，然后执行源码中的install.sh。</p>\n<p>下载地址 <a href=\"https://github.com/powerline/fonts\" target=\"_blank\" rel=\"noopener\">https://github.com/powerline/fonts</a></p>\n<p>进入文件夹执行命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./install.sh</span><br></pre></td></tr></table></figure>\n<p>安装好字体库之后，我们来设置iTerm2的字体，具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，然后找到Meslo LG字体。有L、M、S可选，看个人喜好：<br><img src=\"http://p44bkxib3.bkt.clouddn.com/fonts.png\" alt=\"fonts\"></p>\n<p>我这里设置的字体是：<strong>14pt Meslo LG S DZ Regular for Powerline</strong></p>\n<h2 id=\"配色\"><a href=\"#配色\" class=\"headerlink\" title=\"配色\"></a>配色</h2><p>最终配色还是需要自己喜好去配置，详细配置步骤可以去参考链接。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://man.linuxde.net/chsh\" target=\"_blank\" rel=\"noopener\">chsh命令</a><br><a href=\"https://www.jianshu.com/p/7de00c73a2bb\" target=\"_blank\" rel=\"noopener\">iTerm 2 &amp;&amp; Oh My Zsh【DIY教程——亲身体验过程】</a><br><a href=\"https://github.com/sirius1024/iterm2-with-oh-my-zsh\" target=\"_blank\" rel=\"noopener\">iterm2-with-oh-my-zsh</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"iTerm2-Oh-My-Zsh-打造舒适终端体验\"><a href=\"#iTerm2-Oh-My-Zsh-打造舒适终端体验\" class=\"headerlink\" title=\"iTerm2 + Oh My Zsh 打造舒适终端体验\"></a>iTerm2 + Oh My Zsh 打造舒适终端体验</h2><p>最近尝试用终端来代替图形界面，更能了解本质，使用了 <strong>iTerm2</strong> 来打造了一个相对友好的终端使用，看一下最终效果：</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180609-151847@2x.png\" alt=\"WX20180609-151847@2x\"></p>\n<h3 id=\"下载iTerm2\"><a href=\"#下载iTerm2\" class=\"headerlink\" title=\"下载iTerm2\"></a>下载iTerm2</h3><p>直接去官网下载 <a href=\"https://www.iterm2.com/\" target=\"_blank\" rel=\"noopener\">iTerm2</a></p>\n<p>安装完成后，在/bin目录下会多出一个zsh的文件。</p>\n<p>Mac系统默认使用dash作为终端，可以使用命令修改默认使用zsh：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>\n<p>如果想修改回默认dash，同样使用chsh命令即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chsh -s /bin/bash</span><br></pre></td></tr></table></figure>\n<p>更多命令查询参考链接</p>\n<h3 id=\"安装Oh-my-zsh\"><a href=\"#安装Oh-my-zsh\" class=\"headerlink\" title=\"安装Oh my zsh\"></a>安装Oh my zsh</h3><p>安装方法有两种，可以使用curl或wget，看自己环境或喜好：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> curl 安装方式</span><br><span class=\"line\">sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> wget 安装方式</span><br><span class=\"line\">sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"</span><br></pre></td></tr></table></figure>\n<p>oh-my-zsh开源地址：<a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"noopener\">https://github.com/robbyrussell/oh-my-zsh</a></p>\n<p>安转好oh-my-zsh后，主题文件夹在 <strong>~/.oh-my-zsh/themes</strong></p>\n<p>修改 <strong>~/.zshrc</strong> 配置文件 <strong>ZSH_THEME=”agnoster”</strong></p>\n<p>这个主题比较好看，看个人喜好了。</p>\n<h3 id=\"安装PowerLine\"><a href=\"#安装PowerLine\" class=\"headerlink\" title=\"安装PowerLine\"></a>安装PowerLine</h3><p>powerline官网：<a href=\"http://powerline.readthedocs.io/en/latest/installation.html\" target=\"_blank\" rel=\"noopener\">http://powerline.readthedocs.io/en/latest/installation.html</a></p>\n<p>安装powerline的方式依然简单，也只需要一条命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install powerline-status --user</span><br></pre></td></tr></table></figure>\n<p>没有安装pip的同学可能会碰到zsh: command not found: pip。</p>\n<p>使用命令安装pip即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo easy_install pip</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装PowerFonts\"><a href=\"#安装PowerFonts\" class=\"headerlink\" title=\"安装PowerFonts\"></a>安装PowerFonts</h3><p>安装字体库需要首先将项目git clone至本地，然后执行源码中的install.sh。</p>\n<p>下载地址 <a href=\"https://github.com/powerline/fonts\" target=\"_blank\" rel=\"noopener\">https://github.com/powerline/fonts</a></p>\n<p>进入文件夹执行命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./install.sh</span><br></pre></td></tr></table></figure>\n<p>安装好字体库之后，我们来设置iTerm2的字体，具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，然后找到Meslo LG字体。有L、M、S可选，看个人喜好：<br><img src=\"http://p44bkxib3.bkt.clouddn.com/fonts.png\" alt=\"fonts\"></p>\n<p>我这里设置的字体是：<strong>14pt Meslo LG S DZ Regular for Powerline</strong></p>\n<h2 id=\"配色\"><a href=\"#配色\" class=\"headerlink\" title=\"配色\"></a>配色</h2><p>最终配色还是需要自己喜好去配置，详细配置步骤可以去参考链接。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://man.linuxde.net/chsh\" target=\"_blank\" rel=\"noopener\">chsh命令</a><br><a href=\"https://www.jianshu.com/p/7de00c73a2bb\" target=\"_blank\" rel=\"noopener\">iTerm 2 &amp;&amp; Oh My Zsh【DIY教程——亲身体验过程】</a><br><a href=\"https://github.com/sirius1024/iterm2-with-oh-my-zsh\" target=\"_blank\" rel=\"noopener\">iterm2-with-oh-my-zsh</a></p>\n"},{"title":"MacOS 10.13.5 Cocoapods 无法使用解决方案","date":"2018-06-09T08:50:51.000Z","_content":"\n## MacOS 10.13.5 Cocoapods 无法使用解决方案\n\n最近 Mac 升级到了 10.13.5 ，作为 iOS 开发照例使用 Cocoapods 执行命令发现报错了：\n\n```shell\n/Library/Ruby/Site/2.3.0/rubygems.rb:271:in `find_spec_for_exe': can't find gem cocoapods (>= 0.a) (Gem::GemNotFoundException)\n\tfrom /Library/Ruby/Site/2.3.0/rubygems.rb:299:in `activate_bin_path'\n\tfrom /usr/local/bin/pod:23:in `<main>'\n```\n\n看了报错发现系统的 Ruby 版本怎么是 2.3.0，我记不清之前的版本了，但是肯定不是 2.3.0。\n\n### 解决方法\n\n从报错了解到问题出在 Ruby 版本上，由于 MacOS 的 Ruby 版本常年不是最新的版本，所以建议安装 `RVM` 对 Ruby 的版本进行管理，安装过程具体可以参考[《RVM实用指南》](https://ruby-china.org/wiki/rvm-guide)。\n\n执行命令安装最新版 Ruby 并且切换到最新版本：\n\n```shell\nrvm install 2.5.1\n\nrvm use 2.5.1 --default \n```\n\n执行`rvm list`显示结果：\n\n```shell\nrvm rubies\n\n   ruby-2.3.0 [ x86_64 ]\n=* ruby-2.5.1 [ x86_64 ]\n\n# => - current\n# =* - current && default\n#  * - default\n```\n\n现在再升级 **gem**：\n\n```shell\ngem update --system # 这里请翻墙一下\ngem -v\n2.7.6\n```\n最后通过 **gem** 安装 Cocoapods：\n\n```shell\nsudo gem install cocoapods\npod --version\n1.5.3\n```\n\n至此 Cocoapods 又重生了。\n\n","source":"_posts/2018-06-09-MacOS10.13.5-cocoapods-solution.md","raw":"---\ntitle: MacOS 10.13.5 Cocoapods 无法使用解决方案\ndate: 2018-06-09 16:50:51\ntags: Cocoapods\ncategory: 能工巧匠\n---\n\n## MacOS 10.13.5 Cocoapods 无法使用解决方案\n\n最近 Mac 升级到了 10.13.5 ，作为 iOS 开发照例使用 Cocoapods 执行命令发现报错了：\n\n```shell\n/Library/Ruby/Site/2.3.0/rubygems.rb:271:in `find_spec_for_exe': can't find gem cocoapods (>= 0.a) (Gem::GemNotFoundException)\n\tfrom /Library/Ruby/Site/2.3.0/rubygems.rb:299:in `activate_bin_path'\n\tfrom /usr/local/bin/pod:23:in `<main>'\n```\n\n看了报错发现系统的 Ruby 版本怎么是 2.3.0，我记不清之前的版本了，但是肯定不是 2.3.0。\n\n### 解决方法\n\n从报错了解到问题出在 Ruby 版本上，由于 MacOS 的 Ruby 版本常年不是最新的版本，所以建议安装 `RVM` 对 Ruby 的版本进行管理，安装过程具体可以参考[《RVM实用指南》](https://ruby-china.org/wiki/rvm-guide)。\n\n执行命令安装最新版 Ruby 并且切换到最新版本：\n\n```shell\nrvm install 2.5.1\n\nrvm use 2.5.1 --default \n```\n\n执行`rvm list`显示结果：\n\n```shell\nrvm rubies\n\n   ruby-2.3.0 [ x86_64 ]\n=* ruby-2.5.1 [ x86_64 ]\n\n# => - current\n# =* - current && default\n#  * - default\n```\n\n现在再升级 **gem**：\n\n```shell\ngem update --system # 这里请翻墙一下\ngem -v\n2.7.6\n```\n最后通过 **gem** 安装 Cocoapods：\n\n```shell\nsudo gem install cocoapods\npod --version\n1.5.3\n```\n\n至此 Cocoapods 又重生了。\n\n","slug":"2018-06-09-MacOS10.13.5-cocoapods-solution","published":1,"updated":"2018-09-02T03:39:16.409Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7k800018jpb2i6sp80u","content":"<h2 id=\"MacOS-10-13-5-Cocoapods-无法使用解决方案\"><a href=\"#MacOS-10-13-5-Cocoapods-无法使用解决方案\" class=\"headerlink\" title=\"MacOS 10.13.5 Cocoapods 无法使用解决方案\"></a>MacOS 10.13.5 Cocoapods 无法使用解决方案</h2><p>最近 Mac 升级到了 10.13.5 ，作为 iOS 开发照例使用 Cocoapods 执行命令发现报错了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Library/Ruby/Site/2.3.0/rubygems.rb:271:in `find_spec_for_exe': can't find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException)</span><br><span class=\"line\">\tfrom /Library/Ruby/Site/2.3.0/rubygems.rb:299:in `activate_bin_path'</span><br><span class=\"line\">\tfrom /usr/local/bin/pod:23:in `&lt;main&gt;'</span><br></pre></td></tr></table></figure>\n<p>看了报错发现系统的 Ruby 版本怎么是 2.3.0，我记不清之前的版本了，但是肯定不是 2.3.0。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>从报错了解到问题出在 Ruby 版本上，由于 MacOS 的 Ruby 版本常年不是最新的版本，所以建议安装 <code>RVM</code> 对 Ruby 的版本进行管理，安装过程具体可以参考<a href=\"https://ruby-china.org/wiki/rvm-guide\" target=\"_blank\" rel=\"noopener\">《RVM实用指南》</a>。</p>\n<p>执行命令安装最新版 Ruby 并且切换到最新版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.5.1</span><br><span class=\"line\"></span><br><span class=\"line\">rvm use 2.5.1 --default</span><br></pre></td></tr></table></figure>\n<p>执行<code>rvm list</code>显示结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm rubies</span><br><span class=\"line\"></span><br><span class=\"line\">   ruby-2.3.0 [ x86_64 ]</span><br><span class=\"line\">=* ruby-2.5.1 [ x86_64 ]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> =&gt; - current</span><br><span class=\"line\"><span class=\"meta\">#</span> =* - current &amp;&amp; default</span><br><span class=\"line\"><span class=\"meta\">#</span>  * - default</span><br></pre></td></tr></table></figure>\n<p>现在再升级 <strong>gem</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem update --system # 这里请翻墙一下</span><br><span class=\"line\">gem -v</span><br><span class=\"line\">2.7.6</span><br></pre></td></tr></table></figure>\n<p>最后通过 <strong>gem</strong> 安装 Cocoapods：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install cocoapods</span><br><span class=\"line\">pod --version</span><br><span class=\"line\">1.5.3</span><br></pre></td></tr></table></figure>\n<p>至此 Cocoapods 又重生了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MacOS-10-13-5-Cocoapods-无法使用解决方案\"><a href=\"#MacOS-10-13-5-Cocoapods-无法使用解决方案\" class=\"headerlink\" title=\"MacOS 10.13.5 Cocoapods 无法使用解决方案\"></a>MacOS 10.13.5 Cocoapods 无法使用解决方案</h2><p>最近 Mac 升级到了 10.13.5 ，作为 iOS 开发照例使用 Cocoapods 执行命令发现报错了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Library/Ruby/Site/2.3.0/rubygems.rb:271:in `find_spec_for_exe': can't find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException)</span><br><span class=\"line\">\tfrom /Library/Ruby/Site/2.3.0/rubygems.rb:299:in `activate_bin_path'</span><br><span class=\"line\">\tfrom /usr/local/bin/pod:23:in `&lt;main&gt;'</span><br></pre></td></tr></table></figure>\n<p>看了报错发现系统的 Ruby 版本怎么是 2.3.0，我记不清之前的版本了，但是肯定不是 2.3.0。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>从报错了解到问题出在 Ruby 版本上，由于 MacOS 的 Ruby 版本常年不是最新的版本，所以建议安装 <code>RVM</code> 对 Ruby 的版本进行管理，安装过程具体可以参考<a href=\"https://ruby-china.org/wiki/rvm-guide\" target=\"_blank\" rel=\"noopener\">《RVM实用指南》</a>。</p>\n<p>执行命令安装最新版 Ruby 并且切换到最新版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.5.1</span><br><span class=\"line\"></span><br><span class=\"line\">rvm use 2.5.1 --default</span><br></pre></td></tr></table></figure>\n<p>执行<code>rvm list</code>显示结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm rubies</span><br><span class=\"line\"></span><br><span class=\"line\">   ruby-2.3.0 [ x86_64 ]</span><br><span class=\"line\">=* ruby-2.5.1 [ x86_64 ]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> =&gt; - current</span><br><span class=\"line\"><span class=\"meta\">#</span> =* - current &amp;&amp; default</span><br><span class=\"line\"><span class=\"meta\">#</span>  * - default</span><br></pre></td></tr></table></figure>\n<p>现在再升级 <strong>gem</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem update --system # 这里请翻墙一下</span><br><span class=\"line\">gem -v</span><br><span class=\"line\">2.7.6</span><br></pre></td></tr></table></figure>\n<p>最后通过 <strong>gem</strong> 安装 Cocoapods：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install cocoapods</span><br><span class=\"line\">pod --version</span><br><span class=\"line\">1.5.3</span><br></pre></td></tr></table></figure>\n<p>至此 Cocoapods 又重生了。</p>\n"},{"title":"Mac 上使用 Charles","date":"2018-08-26T08:50:51.000Z","_content":"\n## Mac 上使用 Charles\n\n## 前言\n\n开发网站的时候可以通过Debug模式查看网络请求状况，在做移动开发的时候通常用到 **Charles**，本文对我日常使用的功能进行总结。\n\n## 介绍\n\n**Charles** 是一个 HTTP 代理服务器，HTTP 监视器,反转代理服务器，当程序连接 Charles 的代理访问互联网时，Charles 可以监控这个程序发送和接收的所有数据。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括 request、 response 和 HTTP headers（包含 cookies 与 cache 信息）。\n\n1. 支持SSL代理。可以截取分析SSL的请求。\n\n2. 支持流量控制。可以模拟慢速网络以及等待时间（latency）较长的请求。\n\n3. 支持AJAX调试。可以自动将json或xml数据格式化，方便查看。\n\n4. 支持AMF调试。可以将Flash Remoting 或 Flex Remoting信息格式化，方便查看。\n\n5. 支持重发网络请求，方便后端调试。\n\n6. 支持修改网络请求参数。\n\n7. 支持网络请求的截获并动态修改。\n\n8. 检查HTML，CSS和RSS内容是否符合W3C标准。\n\n### 常用功能\n\n#### 将Charles设置成系统代理\n\nCharles 提供了两种查看请求的视图：\n\n1. Structure 将网络请求按访问的域名分类\n\n2. Sequence 将网络请求按访问的时间排序\n\n![WX20180902-122021@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-122021@2x.png)\n\nCharles 是通过将自己设置成代理服务器来完成抓包的，勾选系统代理后，系统本地发出去的请求都能被截取下来。如果只抓取APP的包的话，可关闭此配置，这样不会出现太多的数据。\n\n![WX20180902-122336@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-122336@2x.png)\n\n> 需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。\n\n如果使用了 **Shadowsocks** 代理，你需要做以下几步操作：\n\n* **Chrome** 安装插件 `proxy-switchyomega`，配置如图\n\n![WX20180902-123105@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-123105@2x.png)\n\n* **Charles** 的 **Proxy** 菜单下勾选 `External Proxy Settings`，将 Charles 的代理设置为 Shadowsocks 的 HTTP 监听代理地址和端口。\n\n![WX20180902-123314@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-123314@2x.png)\n\n![WX20180902-123400@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-123400@2x.png)\n\n\n#### 截取移动设备上的网络请求包\n\n我们在调试移动APP时，需要抓取APP发送的数据包，首先进行设置，Proxy -> Proxy Settings默认端口是8888，根据实际情况可修改。\n\n![WX20180902-124049@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-124049@2x.png)\n\n查看本机IP地址：Help -> Local IP Addresses\n\n![WX20180902-124124@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-124124@2x.png)\n\n然后配置手机代理\n\n![WX20180902-124230@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-124230@2x.png)\n\n\n打开要调试的APP，请求就会先发送到Charles，然后验证是否允许访问。\n当点击允许后，可以在Proxy -> Access Control Settings里看到可以访问此代理服务器列表\n\n![WX20180902-124506@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-124506@2x.png)\n\n> 如果不小心点击了拒绝，可以手动添加手机IP/Mac地址到允许访问列表，或者重启Charles，手机再次访问，会再次提示选择。 如果不想每换一个手机都要进行验证，可以配置允许所有手机访问，加入 0.0.0.0/0（IPv4）或 ::/0（IPv6）\n\n\n##### 手动重复请求（Repeat，Repeat Advanced）\n\n当我们需要对一个请求重复请求的时候，可以对某个请求右击弹出这么这个框，点击重复请求\n\n![WX20180902-130356@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-130356@2x.png)\n\n##### 手动模拟请求（Compose）\n\n![WX20180902-131039@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-131039@2x.png)\n\n\n##### 修改网络请求内容（Backpoints，Compose）\n\n通常我们需要对请求动态修改参数，我们可以通过打断点的方式来修改参数：\n\n![WX20180902-131444@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-131444@2x.png)\n\n\n#### 过滤网络请求\n\n从几十个请求里找到我们需要的观察的某个请求比较费时，那么我们就需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。\n\n有两种方式：\n\n* 在 Sequence 界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：*.zayouth.com，那么只需要在 Filter 栏中填入 zayouth 即可。（一般用于临时过滤）\n\n![WX20180902-131549@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-131549@2x.png)\n\n* 在 Charles 的菜单栏选择 \"Proxy\"->\"Recording Settings\"，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：（固定过滤地址）\n\n![WX20180902-131926@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-131926@2x.png)\n\n\n## 相关链接\n\n* [Charles 从入门到精通](https://blog.devtang.com/2015/11/14/charles-introduction/#%E6%88%AA%E5%8F%96-iPhone-%E4%B8%8A%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B0%81%E5%8C%85)\n\n\n","source":"_posts/2018-08-26-Mac上使用Charles.md","raw":"---\ntitle: Mac 上使用 Charles\ndate: 2018-08-26 16:50:51\ntags: Charles\ncategory: 能工巧匠\n---\n\n## Mac 上使用 Charles\n\n## 前言\n\n开发网站的时候可以通过Debug模式查看网络请求状况，在做移动开发的时候通常用到 **Charles**，本文对我日常使用的功能进行总结。\n\n## 介绍\n\n**Charles** 是一个 HTTP 代理服务器，HTTP 监视器,反转代理服务器，当程序连接 Charles 的代理访问互联网时，Charles 可以监控这个程序发送和接收的所有数据。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括 request、 response 和 HTTP headers（包含 cookies 与 cache 信息）。\n\n1. 支持SSL代理。可以截取分析SSL的请求。\n\n2. 支持流量控制。可以模拟慢速网络以及等待时间（latency）较长的请求。\n\n3. 支持AJAX调试。可以自动将json或xml数据格式化，方便查看。\n\n4. 支持AMF调试。可以将Flash Remoting 或 Flex Remoting信息格式化，方便查看。\n\n5. 支持重发网络请求，方便后端调试。\n\n6. 支持修改网络请求参数。\n\n7. 支持网络请求的截获并动态修改。\n\n8. 检查HTML，CSS和RSS内容是否符合W3C标准。\n\n### 常用功能\n\n#### 将Charles设置成系统代理\n\nCharles 提供了两种查看请求的视图：\n\n1. Structure 将网络请求按访问的域名分类\n\n2. Sequence 将网络请求按访问的时间排序\n\n![WX20180902-122021@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-122021@2x.png)\n\nCharles 是通过将自己设置成代理服务器来完成抓包的，勾选系统代理后，系统本地发出去的请求都能被截取下来。如果只抓取APP的包的话，可关闭此配置，这样不会出现太多的数据。\n\n![WX20180902-122336@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-122336@2x.png)\n\n> 需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。\n\n如果使用了 **Shadowsocks** 代理，你需要做以下几步操作：\n\n* **Chrome** 安装插件 `proxy-switchyomega`，配置如图\n\n![WX20180902-123105@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-123105@2x.png)\n\n* **Charles** 的 **Proxy** 菜单下勾选 `External Proxy Settings`，将 Charles 的代理设置为 Shadowsocks 的 HTTP 监听代理地址和端口。\n\n![WX20180902-123314@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-123314@2x.png)\n\n![WX20180902-123400@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-123400@2x.png)\n\n\n#### 截取移动设备上的网络请求包\n\n我们在调试移动APP时，需要抓取APP发送的数据包，首先进行设置，Proxy -> Proxy Settings默认端口是8888，根据实际情况可修改。\n\n![WX20180902-124049@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-124049@2x.png)\n\n查看本机IP地址：Help -> Local IP Addresses\n\n![WX20180902-124124@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-124124@2x.png)\n\n然后配置手机代理\n\n![WX20180902-124230@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-124230@2x.png)\n\n\n打开要调试的APP，请求就会先发送到Charles，然后验证是否允许访问。\n当点击允许后，可以在Proxy -> Access Control Settings里看到可以访问此代理服务器列表\n\n![WX20180902-124506@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-124506@2x.png)\n\n> 如果不小心点击了拒绝，可以手动添加手机IP/Mac地址到允许访问列表，或者重启Charles，手机再次访问，会再次提示选择。 如果不想每换一个手机都要进行验证，可以配置允许所有手机访问，加入 0.0.0.0/0（IPv4）或 ::/0（IPv6）\n\n\n##### 手动重复请求（Repeat，Repeat Advanced）\n\n当我们需要对一个请求重复请求的时候，可以对某个请求右击弹出这么这个框，点击重复请求\n\n![WX20180902-130356@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-130356@2x.png)\n\n##### 手动模拟请求（Compose）\n\n![WX20180902-131039@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-131039@2x.png)\n\n\n##### 修改网络请求内容（Backpoints，Compose）\n\n通常我们需要对请求动态修改参数，我们可以通过打断点的方式来修改参数：\n\n![WX20180902-131444@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-131444@2x.png)\n\n\n#### 过滤网络请求\n\n从几十个请求里找到我们需要的观察的某个请求比较费时，那么我们就需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。\n\n有两种方式：\n\n* 在 Sequence 界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：*.zayouth.com，那么只需要在 Filter 栏中填入 zayouth 即可。（一般用于临时过滤）\n\n![WX20180902-131549@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-131549@2x.png)\n\n* 在 Charles 的菜单栏选择 \"Proxy\"->\"Recording Settings\"，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：（固定过滤地址）\n\n![WX20180902-131926@2x](http://p44bkxib3.bkt.clouddn.com/WX20180902-131926@2x.png)\n\n\n## 相关链接\n\n* [Charles 从入门到精通](https://blog.devtang.com/2015/11/14/charles-introduction/#%E6%88%AA%E5%8F%96-iPhone-%E4%B8%8A%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B0%81%E5%8C%85)\n\n\n","slug":"2018-08-26-Mac上使用Charles","published":1,"updated":"2018-09-02T05:46:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7ke00048jpbeml7l18l","content":"<h2 id=\"Mac-上使用-Charles\"><a href=\"#Mac-上使用-Charles\" class=\"headerlink\" title=\"Mac 上使用 Charles\"></a>Mac 上使用 Charles</h2><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>开发网站的时候可以通过Debug模式查看网络请求状况，在做移动开发的时候通常用到 <strong>Charles</strong>，本文对我日常使用的功能进行总结。</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p><strong>Charles</strong> 是一个 HTTP 代理服务器，HTTP 监视器,反转代理服务器，当程序连接 Charles 的代理访问互联网时，Charles 可以监控这个程序发送和接收的所有数据。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括 request、 response 和 HTTP headers（包含 cookies 与 cache 信息）。</p>\n<ol>\n<li><p>支持SSL代理。可以截取分析SSL的请求。</p>\n</li>\n<li><p>支持流量控制。可以模拟慢速网络以及等待时间（latency）较长的请求。</p>\n</li>\n<li><p>支持AJAX调试。可以自动将json或xml数据格式化，方便查看。</p>\n</li>\n<li><p>支持AMF调试。可以将Flash Remoting 或 Flex Remoting信息格式化，方便查看。</p>\n</li>\n<li><p>支持重发网络请求，方便后端调试。</p>\n</li>\n<li><p>支持修改网络请求参数。</p>\n</li>\n<li><p>支持网络请求的截获并动态修改。</p>\n</li>\n<li><p>检查HTML，CSS和RSS内容是否符合W3C标准。</p>\n</li>\n</ol>\n<h3 id=\"常用功能\"><a href=\"#常用功能\" class=\"headerlink\" title=\"常用功能\"></a>常用功能</h3><h4 id=\"将Charles设置成系统代理\"><a href=\"#将Charles设置成系统代理\" class=\"headerlink\" title=\"将Charles设置成系统代理\"></a>将Charles设置成系统代理</h4><p>Charles 提供了两种查看请求的视图：</p>\n<ol>\n<li><p>Structure 将网络请求按访问的域名分类</p>\n</li>\n<li><p>Sequence 将网络请求按访问的时间排序</p>\n</li>\n</ol>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-122021@2x.png\" alt=\"WX20180902-122021@2x\"></p>\n<p>Charles 是通过将自己设置成代理服务器来完成抓包的，勾选系统代理后，系统本地发出去的请求都能被截取下来。如果只抓取APP的包的话，可关闭此配置，这样不会出现太多的数据。</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-122336@2x.png\" alt=\"WX20180902-122336@2x\"></p>\n<blockquote>\n<p>需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。</p>\n</blockquote>\n<p>如果使用了 <strong>Shadowsocks</strong> 代理，你需要做以下几步操作：</p>\n<ul>\n<li><strong>Chrome</strong> 安装插件 <code>proxy-switchyomega</code>，配置如图</li>\n</ul>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-123105@2x.png\" alt=\"WX20180902-123105@2x\"></p>\n<ul>\n<li><strong>Charles</strong> 的 <strong>Proxy</strong> 菜单下勾选 <code>External Proxy Settings</code>，将 Charles 的代理设置为 Shadowsocks 的 HTTP 监听代理地址和端口。</li>\n</ul>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-123314@2x.png\" alt=\"WX20180902-123314@2x\"></p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-123400@2x.png\" alt=\"WX20180902-123400@2x\"></p>\n<h4 id=\"截取移动设备上的网络请求包\"><a href=\"#截取移动设备上的网络请求包\" class=\"headerlink\" title=\"截取移动设备上的网络请求包\"></a>截取移动设备上的网络请求包</h4><p>我们在调试移动APP时，需要抓取APP发送的数据包，首先进行设置，Proxy -&gt; Proxy Settings默认端口是8888，根据实际情况可修改。</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-124049@2x.png\" alt=\"WX20180902-124049@2x\"></p>\n<p>查看本机IP地址：Help -&gt; Local IP Addresses</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-124124@2x.png\" alt=\"WX20180902-124124@2x\"></p>\n<p>然后配置手机代理</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-124230@2x.png\" alt=\"WX20180902-124230@2x\"></p>\n<p>打开要调试的APP，请求就会先发送到Charles，然后验证是否允许访问。<br>当点击允许后，可以在Proxy -&gt; Access Control Settings里看到可以访问此代理服务器列表</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-124506@2x.png\" alt=\"WX20180902-124506@2x\"></p>\n<blockquote>\n<p>如果不小心点击了拒绝，可以手动添加手机IP/Mac地址到允许访问列表，或者重启Charles，手机再次访问，会再次提示选择。 如果不想每换一个手机都要进行验证，可以配置允许所有手机访问，加入 0.0.0.0/0（IPv4）或 ::/0（IPv6）</p>\n</blockquote>\n<h5 id=\"手动重复请求（Repeat，Repeat-Advanced）\"><a href=\"#手动重复请求（Repeat，Repeat-Advanced）\" class=\"headerlink\" title=\"手动重复请求（Repeat，Repeat Advanced）\"></a>手动重复请求（Repeat，Repeat Advanced）</h5><p>当我们需要对一个请求重复请求的时候，可以对某个请求右击弹出这么这个框，点击重复请求</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-130356@2x.png\" alt=\"WX20180902-130356@2x\"></p>\n<h5 id=\"手动模拟请求（Compose）\"><a href=\"#手动模拟请求（Compose）\" class=\"headerlink\" title=\"手动模拟请求（Compose）\"></a>手动模拟请求（Compose）</h5><p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-131039@2x.png\" alt=\"WX20180902-131039@2x\"></p>\n<h5 id=\"修改网络请求内容（Backpoints，Compose）\"><a href=\"#修改网络请求内容（Backpoints，Compose）\" class=\"headerlink\" title=\"修改网络请求内容（Backpoints，Compose）\"></a>修改网络请求内容（Backpoints，Compose）</h5><p>通常我们需要对请求动态修改参数，我们可以通过打断点的方式来修改参数：</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-131444@2x.png\" alt=\"WX20180902-131444@2x\"></p>\n<h4 id=\"过滤网络请求\"><a href=\"#过滤网络请求\" class=\"headerlink\" title=\"过滤网络请求\"></a>过滤网络请求</h4><p>从几十个请求里找到我们需要的观察的某个请求比较费时，那么我们就需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。</p>\n<p>有两种方式：</p>\n<ul>\n<li>在 Sequence 界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：*.zayouth.com，那么只需要在 Filter 栏中填入 zayouth 即可。（一般用于临时过滤）</li>\n</ul>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-131549@2x.png\" alt=\"WX20180902-131549@2x\"></p>\n<ul>\n<li>在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：（固定过滤地址）</li>\n</ul>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-131926@2x.png\" alt=\"WX20180902-131926@2x\"></p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><ul>\n<li><a href=\"https://blog.devtang.com/2015/11/14/charles-introduction/#%E6%88%AA%E5%8F%96-iPhone-%E4%B8%8A%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B0%81%E5%8C%85\" target=\"_blank\" rel=\"noopener\">Charles 从入门到精通</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Mac-上使用-Charles\"><a href=\"#Mac-上使用-Charles\" class=\"headerlink\" title=\"Mac 上使用 Charles\"></a>Mac 上使用 Charles</h2><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>开发网站的时候可以通过Debug模式查看网络请求状况，在做移动开发的时候通常用到 <strong>Charles</strong>，本文对我日常使用的功能进行总结。</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p><strong>Charles</strong> 是一个 HTTP 代理服务器，HTTP 监视器,反转代理服务器，当程序连接 Charles 的代理访问互联网时，Charles 可以监控这个程序发送和接收的所有数据。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括 request、 response 和 HTTP headers（包含 cookies 与 cache 信息）。</p>\n<ol>\n<li><p>支持SSL代理。可以截取分析SSL的请求。</p>\n</li>\n<li><p>支持流量控制。可以模拟慢速网络以及等待时间（latency）较长的请求。</p>\n</li>\n<li><p>支持AJAX调试。可以自动将json或xml数据格式化，方便查看。</p>\n</li>\n<li><p>支持AMF调试。可以将Flash Remoting 或 Flex Remoting信息格式化，方便查看。</p>\n</li>\n<li><p>支持重发网络请求，方便后端调试。</p>\n</li>\n<li><p>支持修改网络请求参数。</p>\n</li>\n<li><p>支持网络请求的截获并动态修改。</p>\n</li>\n<li><p>检查HTML，CSS和RSS内容是否符合W3C标准。</p>\n</li>\n</ol>\n<h3 id=\"常用功能\"><a href=\"#常用功能\" class=\"headerlink\" title=\"常用功能\"></a>常用功能</h3><h4 id=\"将Charles设置成系统代理\"><a href=\"#将Charles设置成系统代理\" class=\"headerlink\" title=\"将Charles设置成系统代理\"></a>将Charles设置成系统代理</h4><p>Charles 提供了两种查看请求的视图：</p>\n<ol>\n<li><p>Structure 将网络请求按访问的域名分类</p>\n</li>\n<li><p>Sequence 将网络请求按访问的时间排序</p>\n</li>\n</ol>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-122021@2x.png\" alt=\"WX20180902-122021@2x\"></p>\n<p>Charles 是通过将自己设置成代理服务器来完成抓包的，勾选系统代理后，系统本地发出去的请求都能被截取下来。如果只抓取APP的包的话，可关闭此配置，这样不会出现太多的数据。</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-122336@2x.png\" alt=\"WX20180902-122336@2x\"></p>\n<blockquote>\n<p>需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。</p>\n</blockquote>\n<p>如果使用了 <strong>Shadowsocks</strong> 代理，你需要做以下几步操作：</p>\n<ul>\n<li><strong>Chrome</strong> 安装插件 <code>proxy-switchyomega</code>，配置如图</li>\n</ul>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-123105@2x.png\" alt=\"WX20180902-123105@2x\"></p>\n<ul>\n<li><strong>Charles</strong> 的 <strong>Proxy</strong> 菜单下勾选 <code>External Proxy Settings</code>，将 Charles 的代理设置为 Shadowsocks 的 HTTP 监听代理地址和端口。</li>\n</ul>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-123314@2x.png\" alt=\"WX20180902-123314@2x\"></p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-123400@2x.png\" alt=\"WX20180902-123400@2x\"></p>\n<h4 id=\"截取移动设备上的网络请求包\"><a href=\"#截取移动设备上的网络请求包\" class=\"headerlink\" title=\"截取移动设备上的网络请求包\"></a>截取移动设备上的网络请求包</h4><p>我们在调试移动APP时，需要抓取APP发送的数据包，首先进行设置，Proxy -&gt; Proxy Settings默认端口是8888，根据实际情况可修改。</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-124049@2x.png\" alt=\"WX20180902-124049@2x\"></p>\n<p>查看本机IP地址：Help -&gt; Local IP Addresses</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-124124@2x.png\" alt=\"WX20180902-124124@2x\"></p>\n<p>然后配置手机代理</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-124230@2x.png\" alt=\"WX20180902-124230@2x\"></p>\n<p>打开要调试的APP，请求就会先发送到Charles，然后验证是否允许访问。<br>当点击允许后，可以在Proxy -&gt; Access Control Settings里看到可以访问此代理服务器列表</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-124506@2x.png\" alt=\"WX20180902-124506@2x\"></p>\n<blockquote>\n<p>如果不小心点击了拒绝，可以手动添加手机IP/Mac地址到允许访问列表，或者重启Charles，手机再次访问，会再次提示选择。 如果不想每换一个手机都要进行验证，可以配置允许所有手机访问，加入 0.0.0.0/0（IPv4）或 ::/0（IPv6）</p>\n</blockquote>\n<h5 id=\"手动重复请求（Repeat，Repeat-Advanced）\"><a href=\"#手动重复请求（Repeat，Repeat-Advanced）\" class=\"headerlink\" title=\"手动重复请求（Repeat，Repeat Advanced）\"></a>手动重复请求（Repeat，Repeat Advanced）</h5><p>当我们需要对一个请求重复请求的时候，可以对某个请求右击弹出这么这个框，点击重复请求</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-130356@2x.png\" alt=\"WX20180902-130356@2x\"></p>\n<h5 id=\"手动模拟请求（Compose）\"><a href=\"#手动模拟请求（Compose）\" class=\"headerlink\" title=\"手动模拟请求（Compose）\"></a>手动模拟请求（Compose）</h5><p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-131039@2x.png\" alt=\"WX20180902-131039@2x\"></p>\n<h5 id=\"修改网络请求内容（Backpoints，Compose）\"><a href=\"#修改网络请求内容（Backpoints，Compose）\" class=\"headerlink\" title=\"修改网络请求内容（Backpoints，Compose）\"></a>修改网络请求内容（Backpoints，Compose）</h5><p>通常我们需要对请求动态修改参数，我们可以通过打断点的方式来修改参数：</p>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-131444@2x.png\" alt=\"WX20180902-131444@2x\"></p>\n<h4 id=\"过滤网络请求\"><a href=\"#过滤网络请求\" class=\"headerlink\" title=\"过滤网络请求\"></a>过滤网络请求</h4><p>从几十个请求里找到我们需要的观察的某个请求比较费时，那么我们就需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。</p>\n<p>有两种方式：</p>\n<ul>\n<li>在 Sequence 界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：*.zayouth.com，那么只需要在 Filter 栏中填入 zayouth 即可。（一般用于临时过滤）</li>\n</ul>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-131549@2x.png\" alt=\"WX20180902-131549@2x\"></p>\n<ul>\n<li>在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：（固定过滤地址）</li>\n</ul>\n<p><img src=\"http://p44bkxib3.bkt.clouddn.com/WX20180902-131926@2x.png\" alt=\"WX20180902-131926@2x\"></p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><ul>\n<li><a href=\"https://blog.devtang.com/2015/11/14/charles-introduction/#%E6%88%AA%E5%8F%96-iPhone-%E4%B8%8A%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B0%81%E5%8C%85\" target=\"_blank\" rel=\"noopener\">Charles 从入门到精通</a></li>\n</ul>\n"},{"title":"2018年个人总结","date":"2019-01-01T08:50:51.000Z","_content":"\n## 前言\n不知不觉，2018年快过去了，从今年开始一年一总结，因为每次一年过去了总觉得少了点什么。今年是第一年，先聊聊工作，在说些个人成长，最后复盘今年想做但是没做的事情，列一下新年的目标。\n\n## 关于个人\n\n### 工作\n2018年5月离开了工作两年的创业公司，有些无奈，也认识到了自己的不足，现在去了更加成熟的公司磨砺自己。有一点要分享的是千万别羞于谈钱，毕竟是自己的利益。\n\n在新公司做的事情和前公司差不多，也是视频直播的APP，不同的是增加了更加丰富的内容和交互，也有许多新的挑战。\n\n总结起来，自己一年的主要工作是：\n\n * 1月-5月 livestar 的整体维护和重构\n * 6月-12月 新项目的 iOS 开发\n\n### 成长\n今年的技术增长还是蛮快的，学习并掌握了：\n\n* Swift 新的开发语言\n* git脚本能力，减少图形界面的依赖，更加认识git的本质\n* 正在看 Python 语言，打算进一步提高自己的脚本能力\n* 开始学习 shell 脚本\n\n### 读书\n这一年，也看了一些书，包括：\n\n* 《软技能：代码之外的生存指南》\n* 《三体》\n* 《习惯的力量》\n\n### 旅行\n\n旅行计划其实是从2017年十一开始诞生的，之前并没有认识到出去走走和在家里宅着有什么不同，自从那次 Diana 和 Jony 组织我们几个小伙伴去美国西岸自由行后认识到了原来世界的多样性这么的丰富，从那以后开始制定自己旅游计划。\n\n今年4月再次搭上了 Jony 的便车，去了趟中国台湾，让我见识到了了台湾同胞的善良和质朴，连计程车司机说话谈吐都和内地不同。\n\n今年9月入职新公司后，恰好赶上新公司的年度旅游计划，去日本东京，日本城市干净整洁，让人感觉到这个社会强大的秩序文化，感谢公司给我们提供了这次美好的体验。\n\n### 英语\n\n2017年那次美西之旅给了我很大的冲击，出了国感觉自己变成了瞎子（看不懂菜单）、聋子（勉强听懂一些句子）、哑巴（完全不知道怎么说英语），这也是国内的环境和教育造成的，今年忙于工作和懒惰没有任何进步，2019年有个希望“英语听说能力进一步发展，达到敢说和增强词汇量”。\n\n### 健康\n\n今年上半年，身体还不错，下半年进入新公司后新的业务和环境有新的压力，精神也没之前那么足，每天都很忙碌，经常是进入 coding 状态后几个小时不休息，感觉到脑子晕沉沉后才休息，所以买了个站立办公的工作台，站立和坐着相结合，避免久坐严重影响健康。\n\n现在虽然有锻炼，但是每天工作高强度工作后，回到家什么都不想干。新的一年，希望坚持锻炼。\n\n## 未来的计划\n\n前段时间看到一个陈皓老师的专栏(@左耳朵耗子)，他发起了一个 ` ARTS ` 提高自己的活动。\n\n**ARTS** 是 Algorithm、Review、Technique、Share 的简称，即\n\n* 每周至少做一个 leetcode 的算法题\n* 阅读并点评至少一篇英文技术文章\n* 学习至少一个技术技巧\n* 至少分享一篇有观点和思考的技术文章\n\n这样至少坚持一年！\n\n以前总是“眼高手低”，被自己的懒惰击倒，2019 年准备继续捡起来，希望到 2019 年年终总结的时候不会打脸。github 上的 repo 也建立好了，强行逼自己一下。\n\n## 个人 Milestone\n\n* 入职新公司\n\n","source":"_posts/2019-01-01-2018年个人总结.md","raw":"---\ntitle: 2018年个人总结\ndate: 2019-01-01 16:50:51\ntags: 个人总结\ncategory: 个人总结\n---\n\n## 前言\n不知不觉，2018年快过去了，从今年开始一年一总结，因为每次一年过去了总觉得少了点什么。今年是第一年，先聊聊工作，在说些个人成长，最后复盘今年想做但是没做的事情，列一下新年的目标。\n\n## 关于个人\n\n### 工作\n2018年5月离开了工作两年的创业公司，有些无奈，也认识到了自己的不足，现在去了更加成熟的公司磨砺自己。有一点要分享的是千万别羞于谈钱，毕竟是自己的利益。\n\n在新公司做的事情和前公司差不多，也是视频直播的APP，不同的是增加了更加丰富的内容和交互，也有许多新的挑战。\n\n总结起来，自己一年的主要工作是：\n\n * 1月-5月 livestar 的整体维护和重构\n * 6月-12月 新项目的 iOS 开发\n\n### 成长\n今年的技术增长还是蛮快的，学习并掌握了：\n\n* Swift 新的开发语言\n* git脚本能力，减少图形界面的依赖，更加认识git的本质\n* 正在看 Python 语言，打算进一步提高自己的脚本能力\n* 开始学习 shell 脚本\n\n### 读书\n这一年，也看了一些书，包括：\n\n* 《软技能：代码之外的生存指南》\n* 《三体》\n* 《习惯的力量》\n\n### 旅行\n\n旅行计划其实是从2017年十一开始诞生的，之前并没有认识到出去走走和在家里宅着有什么不同，自从那次 Diana 和 Jony 组织我们几个小伙伴去美国西岸自由行后认识到了原来世界的多样性这么的丰富，从那以后开始制定自己旅游计划。\n\n今年4月再次搭上了 Jony 的便车，去了趟中国台湾，让我见识到了了台湾同胞的善良和质朴，连计程车司机说话谈吐都和内地不同。\n\n今年9月入职新公司后，恰好赶上新公司的年度旅游计划，去日本东京，日本城市干净整洁，让人感觉到这个社会强大的秩序文化，感谢公司给我们提供了这次美好的体验。\n\n### 英语\n\n2017年那次美西之旅给了我很大的冲击，出了国感觉自己变成了瞎子（看不懂菜单）、聋子（勉强听懂一些句子）、哑巴（完全不知道怎么说英语），这也是国内的环境和教育造成的，今年忙于工作和懒惰没有任何进步，2019年有个希望“英语听说能力进一步发展，达到敢说和增强词汇量”。\n\n### 健康\n\n今年上半年，身体还不错，下半年进入新公司后新的业务和环境有新的压力，精神也没之前那么足，每天都很忙碌，经常是进入 coding 状态后几个小时不休息，感觉到脑子晕沉沉后才休息，所以买了个站立办公的工作台，站立和坐着相结合，避免久坐严重影响健康。\n\n现在虽然有锻炼，但是每天工作高强度工作后，回到家什么都不想干。新的一年，希望坚持锻炼。\n\n## 未来的计划\n\n前段时间看到一个陈皓老师的专栏(@左耳朵耗子)，他发起了一个 ` ARTS ` 提高自己的活动。\n\n**ARTS** 是 Algorithm、Review、Technique、Share 的简称，即\n\n* 每周至少做一个 leetcode 的算法题\n* 阅读并点评至少一篇英文技术文章\n* 学习至少一个技术技巧\n* 至少分享一篇有观点和思考的技术文章\n\n这样至少坚持一年！\n\n以前总是“眼高手低”，被自己的懒惰击倒，2019 年准备继续捡起来，希望到 2019 年年终总结的时候不会打脸。github 上的 repo 也建立好了，强行逼自己一下。\n\n## 个人 Milestone\n\n* 入职新公司\n\n","slug":"2019-01-01-2018年个人总结","published":1,"updated":"2019-02-13T10:48:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7kf00058jpb032b4b3p","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>不知不觉，2018年快过去了，从今年开始一年一总结，因为每次一年过去了总觉得少了点什么。今年是第一年，先聊聊工作，在说些个人成长，最后复盘今年想做但是没做的事情，列一下新年的目标。</p>\n<h2 id=\"关于个人\"><a href=\"#关于个人\" class=\"headerlink\" title=\"关于个人\"></a>关于个人</h2><h3 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h3><p>2018年5月离开了工作两年的创业公司，有些无奈，也认识到了自己的不足，现在去了更加成熟的公司磨砺自己。有一点要分享的是千万别羞于谈钱，毕竟是自己的利益。</p>\n<p>在新公司做的事情和前公司差不多，也是视频直播的APP，不同的是增加了更加丰富的内容和交互，也有许多新的挑战。</p>\n<p>总结起来，自己一年的主要工作是：</p>\n<ul>\n<li>1月-5月 livestar 的整体维护和重构</li>\n<li>6月-12月 新项目的 iOS 开发</li>\n</ul>\n<h3 id=\"成长\"><a href=\"#成长\" class=\"headerlink\" title=\"成长\"></a>成长</h3><p>今年的技术增长还是蛮快的，学习并掌握了：</p>\n<ul>\n<li>Swift 新的开发语言</li>\n<li>git脚本能力，减少图形界面的依赖，更加认识git的本质</li>\n<li>正在看 Python 语言，打算进一步提高自己的脚本能力</li>\n<li>开始学习 shell 脚本</li>\n</ul>\n<h3 id=\"读书\"><a href=\"#读书\" class=\"headerlink\" title=\"读书\"></a>读书</h3><p>这一年，也看了一些书，包括：</p>\n<ul>\n<li>《软技能：代码之外的生存指南》</li>\n<li>《三体》</li>\n<li>《习惯的力量》</li>\n</ul>\n<h3 id=\"旅行\"><a href=\"#旅行\" class=\"headerlink\" title=\"旅行\"></a>旅行</h3><p>旅行计划其实是从2017年十一开始诞生的，之前并没有认识到出去走走和在家里宅着有什么不同，自从那次 Diana 和 Jony 组织我们几个小伙伴去美国西岸自由行后认识到了原来世界的多样性这么的丰富，从那以后开始制定自己旅游计划。</p>\n<p>今年4月再次搭上了 Jony 的便车，去了趟中国台湾，让我见识到了了台湾同胞的善良和质朴，连计程车司机说话谈吐都和内地不同。</p>\n<p>今年9月入职新公司后，恰好赶上新公司的年度旅游计划，去日本东京，日本城市干净整洁，让人感觉到这个社会强大的秩序文化，感谢公司给我们提供了这次美好的体验。</p>\n<h3 id=\"英语\"><a href=\"#英语\" class=\"headerlink\" title=\"英语\"></a>英语</h3><p>2017年那次美西之旅给了我很大的冲击，出了国感觉自己变成了瞎子（看不懂菜单）、聋子（勉强听懂一些句子）、哑巴（完全不知道怎么说英语），这也是国内的环境和教育造成的，今年忙于工作和懒惰没有任何进步，2019年有个希望“英语听说能力进一步发展，达到敢说和增强词汇量”。</p>\n<h3 id=\"健康\"><a href=\"#健康\" class=\"headerlink\" title=\"健康\"></a>健康</h3><p>今年上半年，身体还不错，下半年进入新公司后新的业务和环境有新的压力，精神也没之前那么足，每天都很忙碌，经常是进入 coding 状态后几个小时不休息，感觉到脑子晕沉沉后才休息，所以买了个站立办公的工作台，站立和坐着相结合，避免久坐严重影响健康。</p>\n<p>现在虽然有锻炼，但是每天工作高强度工作后，回到家什么都不想干。新的一年，希望坚持锻炼。</p>\n<h2 id=\"未来的计划\"><a href=\"#未来的计划\" class=\"headerlink\" title=\"未来的计划\"></a>未来的计划</h2><p>前段时间看到一个陈皓老师的专栏(@左耳朵耗子)，他发起了一个 <code>ARTS</code> 提高自己的活动。</p>\n<p><strong>ARTS</strong> 是 Algorithm、Review、Technique、Share 的简称，即</p>\n<ul>\n<li>每周至少做一个 leetcode 的算法题</li>\n<li>阅读并点评至少一篇英文技术文章</li>\n<li>学习至少一个技术技巧</li>\n<li>至少分享一篇有观点和思考的技术文章</li>\n</ul>\n<p>这样至少坚持一年！</p>\n<p>以前总是“眼高手低”，被自己的懒惰击倒，2019 年准备继续捡起来，希望到 2019 年年终总结的时候不会打脸。github 上的 repo 也建立好了，强行逼自己一下。</p>\n<h2 id=\"个人-Milestone\"><a href=\"#个人-Milestone\" class=\"headerlink\" title=\"个人 Milestone\"></a>个人 Milestone</h2><ul>\n<li>入职新公司</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>不知不觉，2018年快过去了，从今年开始一年一总结，因为每次一年过去了总觉得少了点什么。今年是第一年，先聊聊工作，在说些个人成长，最后复盘今年想做但是没做的事情，列一下新年的目标。</p>\n<h2 id=\"关于个人\"><a href=\"#关于个人\" class=\"headerlink\" title=\"关于个人\"></a>关于个人</h2><h3 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h3><p>2018年5月离开了工作两年的创业公司，有些无奈，也认识到了自己的不足，现在去了更加成熟的公司磨砺自己。有一点要分享的是千万别羞于谈钱，毕竟是自己的利益。</p>\n<p>在新公司做的事情和前公司差不多，也是视频直播的APP，不同的是增加了更加丰富的内容和交互，也有许多新的挑战。</p>\n<p>总结起来，自己一年的主要工作是：</p>\n<ul>\n<li>1月-5月 livestar 的整体维护和重构</li>\n<li>6月-12月 新项目的 iOS 开发</li>\n</ul>\n<h3 id=\"成长\"><a href=\"#成长\" class=\"headerlink\" title=\"成长\"></a>成长</h3><p>今年的技术增长还是蛮快的，学习并掌握了：</p>\n<ul>\n<li>Swift 新的开发语言</li>\n<li>git脚本能力，减少图形界面的依赖，更加认识git的本质</li>\n<li>正在看 Python 语言，打算进一步提高自己的脚本能力</li>\n<li>开始学习 shell 脚本</li>\n</ul>\n<h3 id=\"读书\"><a href=\"#读书\" class=\"headerlink\" title=\"读书\"></a>读书</h3><p>这一年，也看了一些书，包括：</p>\n<ul>\n<li>《软技能：代码之外的生存指南》</li>\n<li>《三体》</li>\n<li>《习惯的力量》</li>\n</ul>\n<h3 id=\"旅行\"><a href=\"#旅行\" class=\"headerlink\" title=\"旅行\"></a>旅行</h3><p>旅行计划其实是从2017年十一开始诞生的，之前并没有认识到出去走走和在家里宅着有什么不同，自从那次 Diana 和 Jony 组织我们几个小伙伴去美国西岸自由行后认识到了原来世界的多样性这么的丰富，从那以后开始制定自己旅游计划。</p>\n<p>今年4月再次搭上了 Jony 的便车，去了趟中国台湾，让我见识到了了台湾同胞的善良和质朴，连计程车司机说话谈吐都和内地不同。</p>\n<p>今年9月入职新公司后，恰好赶上新公司的年度旅游计划，去日本东京，日本城市干净整洁，让人感觉到这个社会强大的秩序文化，感谢公司给我们提供了这次美好的体验。</p>\n<h3 id=\"英语\"><a href=\"#英语\" class=\"headerlink\" title=\"英语\"></a>英语</h3><p>2017年那次美西之旅给了我很大的冲击，出了国感觉自己变成了瞎子（看不懂菜单）、聋子（勉强听懂一些句子）、哑巴（完全不知道怎么说英语），这也是国内的环境和教育造成的，今年忙于工作和懒惰没有任何进步，2019年有个希望“英语听说能力进一步发展，达到敢说和增强词汇量”。</p>\n<h3 id=\"健康\"><a href=\"#健康\" class=\"headerlink\" title=\"健康\"></a>健康</h3><p>今年上半年，身体还不错，下半年进入新公司后新的业务和环境有新的压力，精神也没之前那么足，每天都很忙碌，经常是进入 coding 状态后几个小时不休息，感觉到脑子晕沉沉后才休息，所以买了个站立办公的工作台，站立和坐着相结合，避免久坐严重影响健康。</p>\n<p>现在虽然有锻炼，但是每天工作高强度工作后，回到家什么都不想干。新的一年，希望坚持锻炼。</p>\n<h2 id=\"未来的计划\"><a href=\"#未来的计划\" class=\"headerlink\" title=\"未来的计划\"></a>未来的计划</h2><p>前段时间看到一个陈皓老师的专栏(@左耳朵耗子)，他发起了一个 <code>ARTS</code> 提高自己的活动。</p>\n<p><strong>ARTS</strong> 是 Algorithm、Review、Technique、Share 的简称，即</p>\n<ul>\n<li>每周至少做一个 leetcode 的算法题</li>\n<li>阅读并点评至少一篇英文技术文章</li>\n<li>学习至少一个技术技巧</li>\n<li>至少分享一篇有观点和思考的技术文章</li>\n</ul>\n<p>这样至少坚持一年！</p>\n<p>以前总是“眼高手低”，被自己的懒惰击倒，2019 年准备继续捡起来，希望到 2019 年年终总结的时候不会打脸。github 上的 repo 也建立好了，强行逼自己一下。</p>\n<h2 id=\"个人-Milestone\"><a href=\"#个人-Milestone\" class=\"headerlink\" title=\"个人 Milestone\"></a>个人 Milestone</h2><ul>\n<li>入职新公司</li>\n</ul>\n"},{"title":"2019-02-16 ARTS","date":"2019-02-16T02:50:51.000Z","_content":"\n# 2019-02-16 ARTS\n\n> what？什么是ARTS\n* Algorithm：每周至少做一个leetcode的算法题;\n* Review：阅读并点评至少一篇英文技术文章；\n* Tip/Techni：学习至少一个技术技巧；\n* Share：分享一篇有观点和思考的技术文章；\n\n\n## Algorithm\n\n```swift\n/**\n * Question Link: https://leetcode.com/problems/two-sum/\n * Primary idea: Traverse the array and store target - nums[i] in a dict\n *\n * Time Complexity: O(n), Space Complexity: O(n)\n */\n \n class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n        var dict = [Int: Int]()\n        \n        for (i, num) in nums.enumerated() {\n            if let lastIndex = dict[target - num] {\n                return [lastIndex, i]\n            }\n            \n            dict[num] = i\n        }\n        \n        fatalError(\"No valid outputs\")\n    }\n}\n```\n\n题目大意：给出 N 个数，在其中找出和为一个特定数的两个数。\n\n声明一个字典，key 是数组里某个数，value 是这个数在数组里的 index\n循环遍历数组，通过 dict[target - num] 判断字典里面是否存在**相加和的另一个数**，如果存在则获取了那个数在数组的 index，直接return\n\n如果字典内不存在，把当前遍历到的数作为 key 放入字典，value 是数在数组中的 index\n\n## Review\n\n[IGListKit Tutorial: Better UICollectionViews](https://www.raywenderlich.com/9106-iglistkit-tutorial-better-uicollectionviews)\n\n**IGListKit** 是Instagram推出的新的 **UICollectionView** 框架，使用数据驱动，旨在创造一个更快更灵活的列表控件。\n\n`Raywenderlich` 之前就出过这个库的教程，现在他们对代码进行了升级改进，如果读者有复杂多变的列表需求，根据教程来实践下吧。\n\n## Tip/Techni\n\n### Xcode 10 新特性：\n\n#### access object library quickly\n\n打开 storyboard 文件时，右上角多了个图标，点击它可以快速查找控件并创建\n\n快捷键：**command + shift + L**\n\n{% asset_img 2019-02-16-ARTS-1@2x.png 2019-02-16-ARTS %}\n\n#### multicursor editing\n\n添加多个光标同时编辑\n\n快捷键：control + shift + 鼠标(或者上下方向键)\n然后快捷键：shift + option + 上下方向键 \n\n#### column-wise changes\n\n多行选择编辑\n\n快捷键：按住 option，鼠标变成十字，然后移动鼠标进行选中编辑\n\n## Share\n\n[iOS系统中导航栏的转场解决方案与最佳实践](https://segmentfault.com/a/1190000016815365)\n\niOS 导航栏一直是个麻烦的解决点，随着业务的增长，经常会有无导航栏，滚动隐藏和显示导航栏，前个界面无导航栏后一个有导航栏的各种状况。\n\n美团技术团队提供了他们的解决方案与实践，对我们当前项目有很大的借鉴意义，在此分享下。\n","source":"_posts/2019-02-16-ARTS.md","raw":"---\ntitle: 2019-02-16 ARTS\ndate: 2019-02-16 10:50:51\ntags: ARTS\ncategory: ARTS\n---\n\n# 2019-02-16 ARTS\n\n> what？什么是ARTS\n* Algorithm：每周至少做一个leetcode的算法题;\n* Review：阅读并点评至少一篇英文技术文章；\n* Tip/Techni：学习至少一个技术技巧；\n* Share：分享一篇有观点和思考的技术文章；\n\n\n## Algorithm\n\n```swift\n/**\n * Question Link: https://leetcode.com/problems/two-sum/\n * Primary idea: Traverse the array and store target - nums[i] in a dict\n *\n * Time Complexity: O(n), Space Complexity: O(n)\n */\n \n class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n        var dict = [Int: Int]()\n        \n        for (i, num) in nums.enumerated() {\n            if let lastIndex = dict[target - num] {\n                return [lastIndex, i]\n            }\n            \n            dict[num] = i\n        }\n        \n        fatalError(\"No valid outputs\")\n    }\n}\n```\n\n题目大意：给出 N 个数，在其中找出和为一个特定数的两个数。\n\n声明一个字典，key 是数组里某个数，value 是这个数在数组里的 index\n循环遍历数组，通过 dict[target - num] 判断字典里面是否存在**相加和的另一个数**，如果存在则获取了那个数在数组的 index，直接return\n\n如果字典内不存在，把当前遍历到的数作为 key 放入字典，value 是数在数组中的 index\n\n## Review\n\n[IGListKit Tutorial: Better UICollectionViews](https://www.raywenderlich.com/9106-iglistkit-tutorial-better-uicollectionviews)\n\n**IGListKit** 是Instagram推出的新的 **UICollectionView** 框架，使用数据驱动，旨在创造一个更快更灵活的列表控件。\n\n`Raywenderlich` 之前就出过这个库的教程，现在他们对代码进行了升级改进，如果读者有复杂多变的列表需求，根据教程来实践下吧。\n\n## Tip/Techni\n\n### Xcode 10 新特性：\n\n#### access object library quickly\n\n打开 storyboard 文件时，右上角多了个图标，点击它可以快速查找控件并创建\n\n快捷键：**command + shift + L**\n\n{% asset_img 2019-02-16-ARTS-1@2x.png 2019-02-16-ARTS %}\n\n#### multicursor editing\n\n添加多个光标同时编辑\n\n快捷键：control + shift + 鼠标(或者上下方向键)\n然后快捷键：shift + option + 上下方向键 \n\n#### column-wise changes\n\n多行选择编辑\n\n快捷键：按住 option，鼠标变成十字，然后移动鼠标进行选中编辑\n\n## Share\n\n[iOS系统中导航栏的转场解决方案与最佳实践](https://segmentfault.com/a/1190000016815365)\n\niOS 导航栏一直是个麻烦的解决点，随着业务的增长，经常会有无导航栏，滚动隐藏和显示导航栏，前个界面无导航栏后一个有导航栏的各种状况。\n\n美团技术团队提供了他们的解决方案与实践，对我们当前项目有很大的借鉴意义，在此分享下。\n","slug":"2019-02-16-ARTS","published":1,"updated":"2019-02-21T16:22:35.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7kh00068jpbqw0ojbgh","content":"<h1 id=\"2019-02-16-ARTS\"><a href=\"#2019-02-16-ARTS\" class=\"headerlink\" title=\"2019-02-16 ARTS\"></a>2019-02-16 ARTS</h1><blockquote>\n<p>what？什么是ARTS</p>\n<ul>\n<li>Algorithm：每周至少做一个leetcode的算法题;</li>\n<li>Review：阅读并点评至少一篇英文技术文章；</li>\n<li>Tip/Techni：学习至少一个技术技巧；</li>\n<li>Share：分享一篇有观点和思考的技术文章；</li>\n</ul>\n</blockquote>\n<h2 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Question Link: https://leetcode.com/problems/two-sum/</span></span><br><span class=\"line\"><span class=\"comment\"> * Primary idea: Traverse the array and store target - nums[i] in a dict</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Time Complexity: O(n), Space Complexity: O(n)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(<span class=\"number\">_</span> nums: [Int], <span class=\"number\">_</span> target: Int)</span></span> -&gt; [<span class=\"type\">Int</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> dict = [<span class=\"type\">Int</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i, num) <span class=\"keyword\">in</span> nums.enumerated() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> lastIndex = dict[target - num] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [lastIndex, i]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            dict[num] = i</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"No valid outputs\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>题目大意：给出 N 个数，在其中找出和为一个特定数的两个数。</p>\n<p>声明一个字典，key 是数组里某个数，value 是这个数在数组里的 index<br>循环遍历数组，通过 dict[target - num] 判断字典里面是否存在<strong>相加和的另一个数</strong>，如果存在则获取了那个数在数组的 index，直接return</p>\n<p>如果字典内不存在，把当前遍历到的数作为 key 放入字典，value 是数在数组中的 index</p>\n<h2 id=\"Review\"><a href=\"#Review\" class=\"headerlink\" title=\"Review\"></a>Review</h2><p><a href=\"https://www.raywenderlich.com/9106-iglistkit-tutorial-better-uicollectionviews\" target=\"_blank\" rel=\"noopener\">IGListKit Tutorial: Better UICollectionViews</a></p>\n<p><strong>IGListKit</strong> 是Instagram推出的新的 <strong>UICollectionView</strong> 框架，使用数据驱动，旨在创造一个更快更灵活的列表控件。</p>\n<p><code>Raywenderlich</code> 之前就出过这个库的教程，现在他们对代码进行了升级改进，如果读者有复杂多变的列表需求，根据教程来实践下吧。</p>\n<h2 id=\"Tip-Techni\"><a href=\"#Tip-Techni\" class=\"headerlink\" title=\"Tip/Techni\"></a>Tip/Techni</h2><h3 id=\"Xcode-10-新特性：\"><a href=\"#Xcode-10-新特性：\" class=\"headerlink\" title=\"Xcode 10 新特性：\"></a>Xcode 10 新特性：</h3><h4 id=\"access-object-library-quickly\"><a href=\"#access-object-library-quickly\" class=\"headerlink\" title=\"access object library quickly\"></a>access object library quickly</h4><p>打开 storyboard 文件时，右上角多了个图标，点击它可以快速查找控件并创建</p>\n<p>快捷键：<strong>command + shift + L</strong></p>\n<img src=\"/2019/02/16/2019-02-16-ARTS/2019-02-16-ARTS-1@2x.png\" title=\"2019-02-16-ARTS\">\n<h4 id=\"multicursor-editing\"><a href=\"#multicursor-editing\" class=\"headerlink\" title=\"multicursor editing\"></a>multicursor editing</h4><p>添加多个光标同时编辑</p>\n<p>快捷键：control + shift + 鼠标(或者上下方向键)<br>然后快捷键：shift + option + 上下方向键 </p>\n<h4 id=\"column-wise-changes\"><a href=\"#column-wise-changes\" class=\"headerlink\" title=\"column-wise changes\"></a>column-wise changes</h4><p>多行选择编辑</p>\n<p>快捷键：按住 option，鼠标变成十字，然后移动鼠标进行选中编辑</p>\n<h2 id=\"Share\"><a href=\"#Share\" class=\"headerlink\" title=\"Share\"></a>Share</h2><p><a href=\"https://segmentfault.com/a/1190000016815365\" target=\"_blank\" rel=\"noopener\">iOS系统中导航栏的转场解决方案与最佳实践</a></p>\n<p>iOS 导航栏一直是个麻烦的解决点，随着业务的增长，经常会有无导航栏，滚动隐藏和显示导航栏，前个界面无导航栏后一个有导航栏的各种状况。</p>\n<p>美团技术团队提供了他们的解决方案与实践，对我们当前项目有很大的借鉴意义，在此分享下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"2019-02-16-ARTS\"><a href=\"#2019-02-16-ARTS\" class=\"headerlink\" title=\"2019-02-16 ARTS\"></a>2019-02-16 ARTS</h1><blockquote>\n<p>what？什么是ARTS</p>\n<ul>\n<li>Algorithm：每周至少做一个leetcode的算法题;</li>\n<li>Review：阅读并点评至少一篇英文技术文章；</li>\n<li>Tip/Techni：学习至少一个技术技巧；</li>\n<li>Share：分享一篇有观点和思考的技术文章；</li>\n</ul>\n</blockquote>\n<h2 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Question Link: https://leetcode.com/problems/two-sum/</span></span><br><span class=\"line\"><span class=\"comment\"> * Primary idea: Traverse the array and store target - nums[i] in a dict</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Time Complexity: O(n), Space Complexity: O(n)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(<span class=\"number\">_</span> nums: [Int], <span class=\"number\">_</span> target: Int)</span></span> -&gt; [<span class=\"type\">Int</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> dict = [<span class=\"type\">Int</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i, num) <span class=\"keyword\">in</span> nums.enumerated() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> lastIndex = dict[target - num] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [lastIndex, i]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            dict[num] = i</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"No valid outputs\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>题目大意：给出 N 个数，在其中找出和为一个特定数的两个数。</p>\n<p>声明一个字典，key 是数组里某个数，value 是这个数在数组里的 index<br>循环遍历数组，通过 dict[target - num] 判断字典里面是否存在<strong>相加和的另一个数</strong>，如果存在则获取了那个数在数组的 index，直接return</p>\n<p>如果字典内不存在，把当前遍历到的数作为 key 放入字典，value 是数在数组中的 index</p>\n<h2 id=\"Review\"><a href=\"#Review\" class=\"headerlink\" title=\"Review\"></a>Review</h2><p><a href=\"https://www.raywenderlich.com/9106-iglistkit-tutorial-better-uicollectionviews\" target=\"_blank\" rel=\"noopener\">IGListKit Tutorial: Better UICollectionViews</a></p>\n<p><strong>IGListKit</strong> 是Instagram推出的新的 <strong>UICollectionView</strong> 框架，使用数据驱动，旨在创造一个更快更灵活的列表控件。</p>\n<p><code>Raywenderlich</code> 之前就出过这个库的教程，现在他们对代码进行了升级改进，如果读者有复杂多变的列表需求，根据教程来实践下吧。</p>\n<h2 id=\"Tip-Techni\"><a href=\"#Tip-Techni\" class=\"headerlink\" title=\"Tip/Techni\"></a>Tip/Techni</h2><h3 id=\"Xcode-10-新特性：\"><a href=\"#Xcode-10-新特性：\" class=\"headerlink\" title=\"Xcode 10 新特性：\"></a>Xcode 10 新特性：</h3><h4 id=\"access-object-library-quickly\"><a href=\"#access-object-library-quickly\" class=\"headerlink\" title=\"access object library quickly\"></a>access object library quickly</h4><p>打开 storyboard 文件时，右上角多了个图标，点击它可以快速查找控件并创建</p>\n<p>快捷键：<strong>command + shift + L</strong></p>\n<img src=\"/2019/02/16/2019-02-16-ARTS/2019-02-16-ARTS-1@2x.png\" title=\"2019-02-16-ARTS\">\n<h4 id=\"multicursor-editing\"><a href=\"#multicursor-editing\" class=\"headerlink\" title=\"multicursor editing\"></a>multicursor editing</h4><p>添加多个光标同时编辑</p>\n<p>快捷键：control + shift + 鼠标(或者上下方向键)<br>然后快捷键：shift + option + 上下方向键 </p>\n<h4 id=\"column-wise-changes\"><a href=\"#column-wise-changes\" class=\"headerlink\" title=\"column-wise changes\"></a>column-wise changes</h4><p>多行选择编辑</p>\n<p>快捷键：按住 option，鼠标变成十字，然后移动鼠标进行选中编辑</p>\n<h2 id=\"Share\"><a href=\"#Share\" class=\"headerlink\" title=\"Share\"></a>Share</h2><p><a href=\"https://segmentfault.com/a/1190000016815365\" target=\"_blank\" rel=\"noopener\">iOS系统中导航栏的转场解决方案与最佳实践</a></p>\n<p>iOS 导航栏一直是个麻烦的解决点，随着业务的增长，经常会有无导航栏，滚动隐藏和显示导航栏，前个界面无导航栏后一个有导航栏的各种状况。</p>\n<p>美团技术团队提供了他们的解决方案与实践，对我们当前项目有很大的借鉴意义，在此分享下。</p>\n"},{"title":"AFNetworking 概述（一）","date":"2016-12-03T09:33:15.000Z","_content":"\n## 前言\n\n先借用大神的话\n> 我花费了大量的时间阅读和学习各种开源的代码、研究其中的实现原理、尝试自己实现相关技术、尝试在工作中使用，这使得我在 iOS 开发技术上进步很快。 -- ibireme\n\n我准备开启一个系列文章，会对 **AFNetworking** 的源码进行分析，了解它是如何构建，平时我们是如何使用它发送HTTP请求。\n\n`本系列的AFNetworking版本为：3.1.0`\n\n## 概述\n\n[AFNetworking](https://github.com/AFNetworking/AFNetworking) 是 iOS 和 MacOS 开发中不可或缺的网络请求库，是由无数开源爱好者共同贡献的code形成的开源库。\n\n这是我对 AFNetworking 工程目录架构的归纳，之后会一一展开。\n\n{% asset_img Snip20170107_1.png AFN-arh %}\n\n这篇文章，先介绍**AFNetworking** 的使用。\n\n## NSURLSession\n\nNSURLSession 是 iOS 7之后苹果推出提供网络请求，下载内容的类，提供了丰富的API，并且支持后台下载。\n\n简单的使用：\n\n```objc\nNSURLRequest *request = [[NSURLRequest alloc] initWithURL:[[NSURL alloc] initWithString:@\"https://github.com\"]];\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *task = [session dataTaskWithRequest:request\n                                       completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {\n                                           NSString *dataString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n                                           NSLog(@\"%@\", dataString);\n                                       }];\n[task resume];\n```\n1. 实例化一个 **NSURLRequest/NSMutableURLRequest**，赋值 URL\n2. 通过 **- sharedSession** 获取 NSURLSession 单例\n3. 然后调用 **- dataTaskWithRequest:completionHandler:** 方法，会返回一个 **NSURLSessionDataTask** 对象\n4. data task 调用 **- resume** 开始执行任务\n5. 请求结束后 **completionHandler** 中会返回请求结果 NSData\n\n## AFNetworking\n\nAFNetworking 是对 NSURLSession 的封装，让请求更加简单好用：\n\n```objc\nAFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[[NSURL alloc] initWithString:@\"hostname\"]];\n[manager GET:@\"relative_url\" parameters:nil progress:nil\n    success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        NSLog(@\"%@\" ,responseObject);\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        NSLog(@\"%@\", error);\n    }];\n```\n> iOS 9之后，苹果默认支持 https，如果请求的链接是 http 的，需要在 info.plist 中加入兼容的键值对，才能发出请求\n{% asset_img Snip20170107_3.png https %}\n\n\nAFHTTPSessionManager 的 初始化方法 **- initWithBaseURL:**，观察它的调用栈：\n\n```objc\n- [AFHTTPSessionManager initWithBaseURL:]\n    - [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]\n        - [AFURLSessionManager initWithSessionConfiguration:]\n            - [NSURLSession sessionWithConfiguration:delegate:delegateQueue:]\n            - [AFJSONResponseSerializer serializer] // 负责序列化响应\n            - [AFSecurityPolicy defaultPolicy] // 负责身份认证\n            - [AFNetworkReachabilityManager sharedManager] // 查看网络连接情况\n        - [AFHTTPRequestSerializer serializer] // 负责序列化请求\n        - [AFJSONResponseSerializer serializer] // 负责序列化响应\n```\n观察调用栈可以看出：\n* AFHTTPSessionManager 是 AFURLSessionManager 的子类（它在父类的基础上封装 http 的常用请求：GET，POST，PUT，PATCH，HEAD，DELETE等等）。\n* AFURLSessionManager 初始化 **NSURLSession** 实例，同时创建了 **AFJSONResponseSerializer** 来系列化响应，还有 **AFSecurityPolicy** 和 **AFNetworkReachabilityManager** 来保证请求安全和监控网络连接状态\n* AFHTTPSessionManager 还有自己的 **AFHTTPRequestSerializer** 和 **AFJSONResponseSerializer** 来序列化请求和响应\n\n接下来观察**GET:parameters:process:success:failure:**的调用栈：\n\n```objc\n- [AFHTTPSessionManager GET:parameters:process:success:failure:]\n    - [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] // 返回 NSURLSessionDataTask #1\n        - [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] // 返回 NSMutableURLRequest\n        - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] // 返回 NSURLSessionDataTask #2\n            - [NSURLSession dataTaskWithRequest:] // 返回 NSURLSessionDataTask #3\n            - [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]\n                - [AFURLSessionManagerTaskDelegate init]\n                - [AFURLSessionManager setDelegate:forTask:]\n    - [NSURLSessionDataTask resume]\n```\n* \\#1，\\#2，\\#3 都是通过 NSURLSession 生成的 data task，返回的 data task 调用 **- resume** 方法执行请求。\n* 在**addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:** 方法中，将某些执行的block回调告诉**AFURLSessionManagerTaskDelegate**，比如上传的**uploadProgress**，下载的**downloadProgress**，所有的请求完成的**completionHandler**\n\n## 总结\n\nAFNetworking 其实就是对 NSURLSession 的高度封装提供简单易用的API给开发者使用。\n\n本章只是简单的对 NSURLSession -> AFURLSessionManager -> AFHTTPSessionManager 的简单概述，下一章将会深入了解。\n\n## 参考链接\n* [AFNetworking](https://github.com/AFNetworking/AFNetworking)\n* [AFNetworking 概述（一）](https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/AFNetworking%20%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.md)\n\n\n","source":"_posts/AFNetworking-Summary-1.md","raw":"---\ntitle: AFNetworking 概述（一）\ndate: 2016-12-03 17:33:15\ntags: AFNetworking\ncategory: Source Code Analyze\n---\n\n## 前言\n\n先借用大神的话\n> 我花费了大量的时间阅读和学习各种开源的代码、研究其中的实现原理、尝试自己实现相关技术、尝试在工作中使用，这使得我在 iOS 开发技术上进步很快。 -- ibireme\n\n我准备开启一个系列文章，会对 **AFNetworking** 的源码进行分析，了解它是如何构建，平时我们是如何使用它发送HTTP请求。\n\n`本系列的AFNetworking版本为：3.1.0`\n\n## 概述\n\n[AFNetworking](https://github.com/AFNetworking/AFNetworking) 是 iOS 和 MacOS 开发中不可或缺的网络请求库，是由无数开源爱好者共同贡献的code形成的开源库。\n\n这是我对 AFNetworking 工程目录架构的归纳，之后会一一展开。\n\n{% asset_img Snip20170107_1.png AFN-arh %}\n\n这篇文章，先介绍**AFNetworking** 的使用。\n\n## NSURLSession\n\nNSURLSession 是 iOS 7之后苹果推出提供网络请求，下载内容的类，提供了丰富的API，并且支持后台下载。\n\n简单的使用：\n\n```objc\nNSURLRequest *request = [[NSURLRequest alloc] initWithURL:[[NSURL alloc] initWithString:@\"https://github.com\"]];\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *task = [session dataTaskWithRequest:request\n                                       completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {\n                                           NSString *dataString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n                                           NSLog(@\"%@\", dataString);\n                                       }];\n[task resume];\n```\n1. 实例化一个 **NSURLRequest/NSMutableURLRequest**，赋值 URL\n2. 通过 **- sharedSession** 获取 NSURLSession 单例\n3. 然后调用 **- dataTaskWithRequest:completionHandler:** 方法，会返回一个 **NSURLSessionDataTask** 对象\n4. data task 调用 **- resume** 开始执行任务\n5. 请求结束后 **completionHandler** 中会返回请求结果 NSData\n\n## AFNetworking\n\nAFNetworking 是对 NSURLSession 的封装，让请求更加简单好用：\n\n```objc\nAFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[[NSURL alloc] initWithString:@\"hostname\"]];\n[manager GET:@\"relative_url\" parameters:nil progress:nil\n    success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        NSLog(@\"%@\" ,responseObject);\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        NSLog(@\"%@\", error);\n    }];\n```\n> iOS 9之后，苹果默认支持 https，如果请求的链接是 http 的，需要在 info.plist 中加入兼容的键值对，才能发出请求\n{% asset_img Snip20170107_3.png https %}\n\n\nAFHTTPSessionManager 的 初始化方法 **- initWithBaseURL:**，观察它的调用栈：\n\n```objc\n- [AFHTTPSessionManager initWithBaseURL:]\n    - [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]\n        - [AFURLSessionManager initWithSessionConfiguration:]\n            - [NSURLSession sessionWithConfiguration:delegate:delegateQueue:]\n            - [AFJSONResponseSerializer serializer] // 负责序列化响应\n            - [AFSecurityPolicy defaultPolicy] // 负责身份认证\n            - [AFNetworkReachabilityManager sharedManager] // 查看网络连接情况\n        - [AFHTTPRequestSerializer serializer] // 负责序列化请求\n        - [AFJSONResponseSerializer serializer] // 负责序列化响应\n```\n观察调用栈可以看出：\n* AFHTTPSessionManager 是 AFURLSessionManager 的子类（它在父类的基础上封装 http 的常用请求：GET，POST，PUT，PATCH，HEAD，DELETE等等）。\n* AFURLSessionManager 初始化 **NSURLSession** 实例，同时创建了 **AFJSONResponseSerializer** 来系列化响应，还有 **AFSecurityPolicy** 和 **AFNetworkReachabilityManager** 来保证请求安全和监控网络连接状态\n* AFHTTPSessionManager 还有自己的 **AFHTTPRequestSerializer** 和 **AFJSONResponseSerializer** 来序列化请求和响应\n\n接下来观察**GET:parameters:process:success:failure:**的调用栈：\n\n```objc\n- [AFHTTPSessionManager GET:parameters:process:success:failure:]\n    - [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] // 返回 NSURLSessionDataTask #1\n        - [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] // 返回 NSMutableURLRequest\n        - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] // 返回 NSURLSessionDataTask #2\n            - [NSURLSession dataTaskWithRequest:] // 返回 NSURLSessionDataTask #3\n            - [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]\n                - [AFURLSessionManagerTaskDelegate init]\n                - [AFURLSessionManager setDelegate:forTask:]\n    - [NSURLSessionDataTask resume]\n```\n* \\#1，\\#2，\\#3 都是通过 NSURLSession 生成的 data task，返回的 data task 调用 **- resume** 方法执行请求。\n* 在**addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:** 方法中，将某些执行的block回调告诉**AFURLSessionManagerTaskDelegate**，比如上传的**uploadProgress**，下载的**downloadProgress**，所有的请求完成的**completionHandler**\n\n## 总结\n\nAFNetworking 其实就是对 NSURLSession 的高度封装提供简单易用的API给开发者使用。\n\n本章只是简单的对 NSURLSession -> AFURLSessionManager -> AFHTTPSessionManager 的简单概述，下一章将会深入了解。\n\n## 参考链接\n* [AFNetworking](https://github.com/AFNetworking/AFNetworking)\n* [AFNetworking 概述（一）](https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/AFNetworking%20%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.md)\n\n\n","slug":"AFNetworking-Summary-1","published":1,"updated":"2017-01-07T12:06:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7kk000a8jpbihq7uv7s","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>先借用大神的话</p>\n<blockquote>\n<p>我花费了大量的时间阅读和学习各种开源的代码、研究其中的实现原理、尝试自己实现相关技术、尝试在工作中使用，这使得我在 iOS 开发技术上进步很快。 – ibireme</p>\n</blockquote>\n<p>我准备开启一个系列文章，会对 <strong>AFNetworking</strong> 的源码进行分析，了解它是如何构建，平时我们是如何使用它发送HTTP请求。</p>\n<p><code>本系列的AFNetworking版本为：3.1.0</code></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a> 是 iOS 和 MacOS 开发中不可或缺的网络请求库，是由无数开源爱好者共同贡献的code形成的开源库。</p>\n<p>这是我对 AFNetworking 工程目录架构的归纳，之后会一一展开。</p>\n<img src=\"/2016/12/03/AFNetworking-Summary-1/Snip20170107_1.png\" title=\"AFN-arh\">\n<p>这篇文章，先介绍<strong>AFNetworking</strong> 的使用。</p>\n<h2 id=\"NSURLSession\"><a href=\"#NSURLSession\" class=\"headerlink\" title=\"NSURLSession\"></a>NSURLSession</h2><p>NSURLSession 是 iOS 7之后苹果推出提供网络请求，下载内容的类，提供了丰富的API，并且支持后台下载。</p>\n<p>简单的使用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> *request = [[<span class=\"built_in\">NSURLRequest</span> alloc] initWithURL:[[<span class=\"built_in\">NSURL</span> alloc] initWithString:<span class=\"string\">@\"https://github.com\"</span>]];</span><br><span class=\"line\"><span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request</span><br><span class=\"line\">                                       completionHandler:^(<span class=\"built_in\">NSData</span> * _Nullable data, <span class=\"built_in\">NSURLResponse</span> * _Nullable response, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\">                                           <span class=\"built_in\">NSString</span> *dataString = [[<span class=\"built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">                                           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, dataString);</span><br><span class=\"line\">                                       &#125;];</span><br><span class=\"line\">[task resume];</span><br></pre></td></tr></table></figure>\n<ol>\n<li>实例化一个 <strong>NSURLRequest/NSMutableURLRequest</strong>，赋值 URL</li>\n<li>通过 <strong>- sharedSession</strong> 获取 NSURLSession 单例</li>\n<li>然后调用 <strong>- dataTaskWithRequest:completionHandler:</strong> 方法，会返回一个 <strong>NSURLSessionDataTask</strong> 对象</li>\n<li>data task 调用 <strong>- resume</strong> 开始执行任务</li>\n<li>请求结束后 <strong>completionHandler</strong> 中会返回请求结果 NSData</li>\n</ol>\n<h2 id=\"AFNetworking\"><a href=\"#AFNetworking\" class=\"headerlink\" title=\"AFNetworking\"></a>AFNetworking</h2><p>AFNetworking 是对 NSURLSession 的封装，让请求更加简单好用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[[<span class=\"built_in\">NSURL</span> alloc] initWithString:<span class=\"string\">@\"hostname\"</span>]];</span><br><span class=\"line\">[manager GET:<span class=\"string\">@\"relative_url\"</span> parameters:<span class=\"literal\">nil</span> progress:<span class=\"literal\">nil</span></span><br><span class=\"line\">    success:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nonnull task, <span class=\"keyword\">id</span>  _Nullable responseObject) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span> ,responseObject);</span><br><span class=\"line\">    &#125; failure:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nullable task, <span class=\"built_in\">NSError</span> * _Nonnull error) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, error);</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>iOS 9之后，苹果默认支持 https，如果请求的链接是 http 的，需要在 info.plist 中加入兼容的键值对，才能发出请求<br><img src=\"/2016/12/03/AFNetworking-Summary-1/Snip20170107_3.png\" title=\"https\"></p>\n</blockquote>\n<p>AFHTTPSessionManager 的 初始化方法 <strong>- initWithBaseURL:</strong>，观察它的调用栈：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- [AFHTTPSessionManager initWithBaseURL:]</span><br><span class=\"line\">    - [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]</span><br><span class=\"line\">        - [AFURLSessionManager initWithSessionConfiguration:]</span><br><span class=\"line\">            - [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:delegate:delegateQueue:]</span><br><span class=\"line\">            - [AFJSONResponseSerializer serializer] <span class=\"comment\">// 负责序列化响应</span></span><br><span class=\"line\">            - [AFSecurityPolicy defaultPolicy] <span class=\"comment\">// 负责身份认证</span></span><br><span class=\"line\">            - [AFNetworkReachabilityManager sharedManager] <span class=\"comment\">// 查看网络连接情况</span></span><br><span class=\"line\">        - [AFHTTPRequestSerializer serializer] <span class=\"comment\">// 负责序列化请求</span></span><br><span class=\"line\">        - [AFJSONResponseSerializer serializer] <span class=\"comment\">// 负责序列化响应</span></span><br></pre></td></tr></table></figure>\n<p>观察调用栈可以看出：</p>\n<ul>\n<li>AFHTTPSessionManager 是 AFURLSessionManager 的子类（它在父类的基础上封装 http 的常用请求：GET，POST，PUT，PATCH，HEAD，DELETE等等）。</li>\n<li>AFURLSessionManager 初始化 <strong>NSURLSession</strong> 实例，同时创建了 <strong>AFJSONResponseSerializer</strong> 来系列化响应，还有 <strong>AFSecurityPolicy</strong> 和 <strong>AFNetworkReachabilityManager</strong> 来保证请求安全和监控网络连接状态</li>\n<li>AFHTTPSessionManager 还有自己的 <strong>AFHTTPRequestSerializer</strong> 和 <strong>AFJSONResponseSerializer</strong> 来序列化请求和响应</li>\n</ul>\n<p>接下来观察<strong>GET:parameters:process:success:failure:</strong>的调用栈：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- [AFHTTPSessionManager GET:parameters:process:success:failure:]</span><br><span class=\"line\">    - [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] <span class=\"comment\">// 返回 NSURLSessionDataTask #1</span></span><br><span class=\"line\">        - [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] <span class=\"comment\">// 返回 NSMutableURLRequest</span></span><br><span class=\"line\">        - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] <span class=\"comment\">// 返回 NSURLSessionDataTask #2</span></span><br><span class=\"line\">            - [<span class=\"built_in\">NSURLSession</span> dataTaskWithRequest:] <span class=\"comment\">// 返回 NSURLSessionDataTask #3</span></span><br><span class=\"line\">            - [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</span><br><span class=\"line\">                - [AFURLSessionManagerTaskDelegate init]</span><br><span class=\"line\">                - [AFURLSessionManager setDelegate:forTask:]</span><br><span class=\"line\">    - [<span class=\"built_in\">NSURLSessionDataTask</span> resume]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>#1，#2，#3 都是通过 NSURLSession 生成的 data task，返回的 data task 调用 <strong>- resume</strong> 方法执行请求。</li>\n<li>在<strong>addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:</strong> 方法中，将某些执行的block回调告诉<strong>AFURLSessionManagerTaskDelegate</strong>，比如上传的<strong>uploadProgress</strong>，下载的<strong>downloadProgress</strong>，所有的请求完成的<strong>completionHandler</strong></li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>AFNetworking 其实就是对 NSURLSession 的高度封装提供简单易用的API给开发者使用。</p>\n<p>本章只是简单的对 NSURLSession -&gt; AFURLSessionManager -&gt; AFHTTPSessionManager 的简单概述，下一章将会深入了解。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a></li>\n<li><a href=\"https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/AFNetworking%20%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.md\" target=\"_blank\" rel=\"noopener\">AFNetworking 概述（一）</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>先借用大神的话</p>\n<blockquote>\n<p>我花费了大量的时间阅读和学习各种开源的代码、研究其中的实现原理、尝试自己实现相关技术、尝试在工作中使用，这使得我在 iOS 开发技术上进步很快。 – ibireme</p>\n</blockquote>\n<p>我准备开启一个系列文章，会对 <strong>AFNetworking</strong> 的源码进行分析，了解它是如何构建，平时我们是如何使用它发送HTTP请求。</p>\n<p><code>本系列的AFNetworking版本为：3.1.0</code></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a> 是 iOS 和 MacOS 开发中不可或缺的网络请求库，是由无数开源爱好者共同贡献的code形成的开源库。</p>\n<p>这是我对 AFNetworking 工程目录架构的归纳，之后会一一展开。</p>\n<img src=\"/2016/12/03/AFNetworking-Summary-1/Snip20170107_1.png\" title=\"AFN-arh\">\n<p>这篇文章，先介绍<strong>AFNetworking</strong> 的使用。</p>\n<h2 id=\"NSURLSession\"><a href=\"#NSURLSession\" class=\"headerlink\" title=\"NSURLSession\"></a>NSURLSession</h2><p>NSURLSession 是 iOS 7之后苹果推出提供网络请求，下载内容的类，提供了丰富的API，并且支持后台下载。</p>\n<p>简单的使用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> *request = [[<span class=\"built_in\">NSURLRequest</span> alloc] initWithURL:[[<span class=\"built_in\">NSURL</span> alloc] initWithString:<span class=\"string\">@\"https://github.com\"</span>]];</span><br><span class=\"line\"><span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request</span><br><span class=\"line\">                                       completionHandler:^(<span class=\"built_in\">NSData</span> * _Nullable data, <span class=\"built_in\">NSURLResponse</span> * _Nullable response, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\">                                           <span class=\"built_in\">NSString</span> *dataString = [[<span class=\"built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">                                           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, dataString);</span><br><span class=\"line\">                                       &#125;];</span><br><span class=\"line\">[task resume];</span><br></pre></td></tr></table></figure>\n<ol>\n<li>实例化一个 <strong>NSURLRequest/NSMutableURLRequest</strong>，赋值 URL</li>\n<li>通过 <strong>- sharedSession</strong> 获取 NSURLSession 单例</li>\n<li>然后调用 <strong>- dataTaskWithRequest:completionHandler:</strong> 方法，会返回一个 <strong>NSURLSessionDataTask</strong> 对象</li>\n<li>data task 调用 <strong>- resume</strong> 开始执行任务</li>\n<li>请求结束后 <strong>completionHandler</strong> 中会返回请求结果 NSData</li>\n</ol>\n<h2 id=\"AFNetworking\"><a href=\"#AFNetworking\" class=\"headerlink\" title=\"AFNetworking\"></a>AFNetworking</h2><p>AFNetworking 是对 NSURLSession 的封装，让请求更加简单好用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[[<span class=\"built_in\">NSURL</span> alloc] initWithString:<span class=\"string\">@\"hostname\"</span>]];</span><br><span class=\"line\">[manager GET:<span class=\"string\">@\"relative_url\"</span> parameters:<span class=\"literal\">nil</span> progress:<span class=\"literal\">nil</span></span><br><span class=\"line\">    success:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nonnull task, <span class=\"keyword\">id</span>  _Nullable responseObject) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span> ,responseObject);</span><br><span class=\"line\">    &#125; failure:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nullable task, <span class=\"built_in\">NSError</span> * _Nonnull error) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, error);</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>iOS 9之后，苹果默认支持 https，如果请求的链接是 http 的，需要在 info.plist 中加入兼容的键值对，才能发出请求<br><img src=\"/2016/12/03/AFNetworking-Summary-1/Snip20170107_3.png\" title=\"https\"></p>\n</blockquote>\n<p>AFHTTPSessionManager 的 初始化方法 <strong>- initWithBaseURL:</strong>，观察它的调用栈：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- [AFHTTPSessionManager initWithBaseURL:]</span><br><span class=\"line\">    - [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]</span><br><span class=\"line\">        - [AFURLSessionManager initWithSessionConfiguration:]</span><br><span class=\"line\">            - [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:delegate:delegateQueue:]</span><br><span class=\"line\">            - [AFJSONResponseSerializer serializer] <span class=\"comment\">// 负责序列化响应</span></span><br><span class=\"line\">            - [AFSecurityPolicy defaultPolicy] <span class=\"comment\">// 负责身份认证</span></span><br><span class=\"line\">            - [AFNetworkReachabilityManager sharedManager] <span class=\"comment\">// 查看网络连接情况</span></span><br><span class=\"line\">        - [AFHTTPRequestSerializer serializer] <span class=\"comment\">// 负责序列化请求</span></span><br><span class=\"line\">        - [AFJSONResponseSerializer serializer] <span class=\"comment\">// 负责序列化响应</span></span><br></pre></td></tr></table></figure>\n<p>观察调用栈可以看出：</p>\n<ul>\n<li>AFHTTPSessionManager 是 AFURLSessionManager 的子类（它在父类的基础上封装 http 的常用请求：GET，POST，PUT，PATCH，HEAD，DELETE等等）。</li>\n<li>AFURLSessionManager 初始化 <strong>NSURLSession</strong> 实例，同时创建了 <strong>AFJSONResponseSerializer</strong> 来系列化响应，还有 <strong>AFSecurityPolicy</strong> 和 <strong>AFNetworkReachabilityManager</strong> 来保证请求安全和监控网络连接状态</li>\n<li>AFHTTPSessionManager 还有自己的 <strong>AFHTTPRequestSerializer</strong> 和 <strong>AFJSONResponseSerializer</strong> 来序列化请求和响应</li>\n</ul>\n<p>接下来观察<strong>GET:parameters:process:success:failure:</strong>的调用栈：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- [AFHTTPSessionManager GET:parameters:process:success:failure:]</span><br><span class=\"line\">    - [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] <span class=\"comment\">// 返回 NSURLSessionDataTask #1</span></span><br><span class=\"line\">        - [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] <span class=\"comment\">// 返回 NSMutableURLRequest</span></span><br><span class=\"line\">        - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] <span class=\"comment\">// 返回 NSURLSessionDataTask #2</span></span><br><span class=\"line\">            - [<span class=\"built_in\">NSURLSession</span> dataTaskWithRequest:] <span class=\"comment\">// 返回 NSURLSessionDataTask #3</span></span><br><span class=\"line\">            - [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</span><br><span class=\"line\">                - [AFURLSessionManagerTaskDelegate init]</span><br><span class=\"line\">                - [AFURLSessionManager setDelegate:forTask:]</span><br><span class=\"line\">    - [<span class=\"built_in\">NSURLSessionDataTask</span> resume]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>#1，#2，#3 都是通过 NSURLSession 生成的 data task，返回的 data task 调用 <strong>- resume</strong> 方法执行请求。</li>\n<li>在<strong>addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:</strong> 方法中，将某些执行的block回调告诉<strong>AFURLSessionManagerTaskDelegate</strong>，比如上传的<strong>uploadProgress</strong>，下载的<strong>downloadProgress</strong>，所有的请求完成的<strong>completionHandler</strong></li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>AFNetworking 其实就是对 NSURLSession 的高度封装提供简单易用的API给开发者使用。</p>\n<p>本章只是简单的对 NSURLSession -&gt; AFURLSessionManager -&gt; AFHTTPSessionManager 的简单概述，下一章将会深入了解。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a></li>\n<li><a href=\"https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/AFNetworking%20%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.md\" target=\"_blank\" rel=\"noopener\">AFNetworking 概述（一）</a></li>\n</ul>\n"},{"title":"Objective-C 链式语法的实现","date":"2016-11-05T05:37:40.000Z","_content":"\n## 前言\n每次朋友看到我写OC代码都说方法名怎么这么长，简直可以写文章了！对应OC的语法，喜欢的人说它接近自然语言，可读性强，不用看文档或者注释也能知道方法的大概使用，不喜欢的人会觉得太啰嗦了，太麻烦了。\n\n其实 OC 也可以实现类似别的语言那样的`点链式语法`。[Masonry](https://github.com/SnapKit/Masonry)这个鼎鼎大名的第三方自动布局库就是OC`点链式语法`开创者。\n\n## Block\n本文重点不在介绍 **Block**，想要了解的同学可以戳底部参考文章。\n我们先了解链式语法：\n\n```objc\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top).with.offset(padding.top);\n    make.left.equalTo(superview.mas_left).with.offset(padding.left);\n    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);\n    make.right.equalTo(superview.mas_right).with.offset(-padding.right);\n}];\n```\n\n从 **Masonry** 的示例代码中可以看出链式语法包含：`点语法`，`小括号调用`，`连续调用`。\n\n- 点语法: 在别的语言中常见的调用方法的方式，OC中常用的是属性访问，比如访问frame，self.frame\n- 小括号调用: OC中调用方法一般使用中括号`[]`来实现，但是 Block 可以使用小括号`()`来调用\n- 连续调用: Block 可以看看成是有自动变量的匿名函数，匿名函数可以有返回值的。要实现连续调用，可以每次调用方法后，返回当前实例本身，即 self.method1() 返回 self ，这样又可以调用 self.method2()。\n\n> 这样我们可以对外配置一些只读Block属性，返回 Block 本身，实现 Block 属性的 getter 方法。\n\n## 链式调用计算器\n那么我们实践一下：\n创建个链式调用计算器\n\n`JHCalculator.h`\n```objc\n\n@interface JHCalculator : NSObject\n\n/**\n 计算结果\n */\n@property (nonatomic, readonly, assign) NSInteger resultValue;\n\n// Block NSInteger 类型参数， 返回当前 JHCalculator 类型\n\n/**\n 加\n */\n@property (readonly, nonatomic, copy) JHCalculator * (^add)(NSInteger num);\n\n/**\n 减\n */\n@property (readonly, nonatomic, copy) JHCalculator * (^minus)(NSInteger num);\n\n/**\n 乘\n */\n@property (readonly, nonatomic, copy) JHCalculator * (^multiply)(NSInteger num);\n\n/**\n 除\n */\n@property (readonly, nonatomic, copy) JHCalculator * (^divide)(NSInteger num);\n\n```\n\n`JHCalculator.m`\n\n```objc\n- (JHCalculator * (^)(NSInteger num)) add {\n    return ^(NSInteger num) {\n        _resultValue += num;\n        return self;\n    };\n}\n\n- (JHCalculator * (^)(NSInteger num)) minus {\n    return ^(NSInteger num) {\n        _resultValue -= num;\n        return self;\n    };\n}\n\n- (JHCalculator * (^)(NSInteger num)) multiply {\n    return ^id(NSInteger num) {\n        _resultValue *= num;\n        return self;\n    };\n}\n\n- (JHCalculator * (^)(NSInteger num)) divide {\n    return ^(NSInteger num) {\n        NSAssert(num != 0, @\"除数不能为零！\");\n        _resultValue /= num;\n        return self;\n    };\n}\n```\n\n使用：\n\n```objc\nJHCalculator *calculator = [JHCalculator new];\ncalculator.add(10).minus(5).multiply(3).divide(5);\n    \nNSLog(@\"%zd\", calculator.resultValue);// print 3\n```\n\n### 分析\n上面每次调用加减乘除都会访问对应的属性，比如调用 add 就是访问 add 的getter方法，即[calculator add] 方法，它会返回一个Block。\n\n```objc\nreturn ^(NSInteger num) {\n   _resultValue += num;\n   return self;\n};\n```\nblock 返回 JHCalculator 类型，所以直接返回 self 。\n\n详细流程是这样：\n1. calculator.add 获取一个 Block\n2. calculator.add(10) 执行了 Block，返回了self，即当前 JHCalculator 实例\n3. 然后通过返回的 self 可以继续访问 JHCalculator 中的其他属性，一步步点下去\n\n## 更简洁的实现\n上述方法是[《objective-c 一个链式加法计算器实现》](http://www.cnblogs.com/longling2344/p/5126021.html)这篇文章中的实现方式，每次都需要增加一个属性，并实现该属性的getter方法，但是在 Masonry 中有更简洁的实现方式。\n\n其实在OC中点语法的本质是：`将 classInstance.XXX 转换成 [classInstance XXX] 来实现方法调用的`。\n\n* 点语法其实只是表面现象，**classInstance.XXX** 在等号右边是**getter**方法， 会编译成**[classInstance XXX]** ，**classInstance.XXX** 在等号左边是 **setter** 方法，会编译成 **[classInstance setXXX:value]**。\n* 既然在编译时 **classInstance.XXX** 会转换成 **[classInstance XXX]**，那就和OC的方法调用是一样的，那么我们只需要创建一个 XXX 的方法，也能顺利的调用。\n\n### 优化后\n`JHCalculator2.h`\n\n```objc\n@interface JHCalculator2 : NSObject\n\n/**\n 计算结果\n */\n@property (nonatomic, readonly, assign) NSInteger resultValue;\n\n- (JHCalculator2 * (^)(NSInteger num)) add;\n\n- (JHCalculator2 * (^)(NSInteger num)) minus;\n\n- (JHCalculator2 * (^)(NSInteger num)) multiply;\n\n- (JHCalculator2 * (^)(NSInteger num)) divide;\n\n@end\n```\n.m文件内容不变，.h文件不需要写属性了，直接通过方法调用，比之前简洁了很多。\n\n## 总结\nOC链式语法总的来说是通过 **Block特性** 与 **OC点语法本质** 结合共同实现的，不过在Xcode上有个小问题，就是代码不会补全**()**，相比方便简洁的方法调用来说，这个小问题可以忽略了。\n\n[Demo地址](https://github.com/piglikeYoung/BlockCalculator)\n\n## 参考资料\n* [黑幕背后的__block修饰符](http://chun.tips/blog/2014/11/13/hei-mu-bei-hou-de-blockxiu-shi-fu/)\n* [Block技巧与底层解析](http://www.jianshu.com/p/51d04b7639f1)\n* [神奇的Block](http://www.jianshu.com/p/4b1cfd7e6361)\n* [用Block实现链式编程](http://www.tuicool.com/articles/qQJfYn3)\n* [objective-c 一个链式加法计算器实现](http://www.cnblogs.com/longling2344/p/5126021.html)\n\n","source":"_posts/Block-Chain-Syntax.md","raw":"---\ntitle: Objective-C 链式语法的实现\ndate: 2016-11-5 13:37:40\ntags: Block\ncategory: 能工巧匠\n---\n\n## 前言\n每次朋友看到我写OC代码都说方法名怎么这么长，简直可以写文章了！对应OC的语法，喜欢的人说它接近自然语言，可读性强，不用看文档或者注释也能知道方法的大概使用，不喜欢的人会觉得太啰嗦了，太麻烦了。\n\n其实 OC 也可以实现类似别的语言那样的`点链式语法`。[Masonry](https://github.com/SnapKit/Masonry)这个鼎鼎大名的第三方自动布局库就是OC`点链式语法`开创者。\n\n## Block\n本文重点不在介绍 **Block**，想要了解的同学可以戳底部参考文章。\n我们先了解链式语法：\n\n```objc\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top).with.offset(padding.top);\n    make.left.equalTo(superview.mas_left).with.offset(padding.left);\n    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);\n    make.right.equalTo(superview.mas_right).with.offset(-padding.right);\n}];\n```\n\n从 **Masonry** 的示例代码中可以看出链式语法包含：`点语法`，`小括号调用`，`连续调用`。\n\n- 点语法: 在别的语言中常见的调用方法的方式，OC中常用的是属性访问，比如访问frame，self.frame\n- 小括号调用: OC中调用方法一般使用中括号`[]`来实现，但是 Block 可以使用小括号`()`来调用\n- 连续调用: Block 可以看看成是有自动变量的匿名函数，匿名函数可以有返回值的。要实现连续调用，可以每次调用方法后，返回当前实例本身，即 self.method1() 返回 self ，这样又可以调用 self.method2()。\n\n> 这样我们可以对外配置一些只读Block属性，返回 Block 本身，实现 Block 属性的 getter 方法。\n\n## 链式调用计算器\n那么我们实践一下：\n创建个链式调用计算器\n\n`JHCalculator.h`\n```objc\n\n@interface JHCalculator : NSObject\n\n/**\n 计算结果\n */\n@property (nonatomic, readonly, assign) NSInteger resultValue;\n\n// Block NSInteger 类型参数， 返回当前 JHCalculator 类型\n\n/**\n 加\n */\n@property (readonly, nonatomic, copy) JHCalculator * (^add)(NSInteger num);\n\n/**\n 减\n */\n@property (readonly, nonatomic, copy) JHCalculator * (^minus)(NSInteger num);\n\n/**\n 乘\n */\n@property (readonly, nonatomic, copy) JHCalculator * (^multiply)(NSInteger num);\n\n/**\n 除\n */\n@property (readonly, nonatomic, copy) JHCalculator * (^divide)(NSInteger num);\n\n```\n\n`JHCalculator.m`\n\n```objc\n- (JHCalculator * (^)(NSInteger num)) add {\n    return ^(NSInteger num) {\n        _resultValue += num;\n        return self;\n    };\n}\n\n- (JHCalculator * (^)(NSInteger num)) minus {\n    return ^(NSInteger num) {\n        _resultValue -= num;\n        return self;\n    };\n}\n\n- (JHCalculator * (^)(NSInteger num)) multiply {\n    return ^id(NSInteger num) {\n        _resultValue *= num;\n        return self;\n    };\n}\n\n- (JHCalculator * (^)(NSInteger num)) divide {\n    return ^(NSInteger num) {\n        NSAssert(num != 0, @\"除数不能为零！\");\n        _resultValue /= num;\n        return self;\n    };\n}\n```\n\n使用：\n\n```objc\nJHCalculator *calculator = [JHCalculator new];\ncalculator.add(10).minus(5).multiply(3).divide(5);\n    \nNSLog(@\"%zd\", calculator.resultValue);// print 3\n```\n\n### 分析\n上面每次调用加减乘除都会访问对应的属性，比如调用 add 就是访问 add 的getter方法，即[calculator add] 方法，它会返回一个Block。\n\n```objc\nreturn ^(NSInteger num) {\n   _resultValue += num;\n   return self;\n};\n```\nblock 返回 JHCalculator 类型，所以直接返回 self 。\n\n详细流程是这样：\n1. calculator.add 获取一个 Block\n2. calculator.add(10) 执行了 Block，返回了self，即当前 JHCalculator 实例\n3. 然后通过返回的 self 可以继续访问 JHCalculator 中的其他属性，一步步点下去\n\n## 更简洁的实现\n上述方法是[《objective-c 一个链式加法计算器实现》](http://www.cnblogs.com/longling2344/p/5126021.html)这篇文章中的实现方式，每次都需要增加一个属性，并实现该属性的getter方法，但是在 Masonry 中有更简洁的实现方式。\n\n其实在OC中点语法的本质是：`将 classInstance.XXX 转换成 [classInstance XXX] 来实现方法调用的`。\n\n* 点语法其实只是表面现象，**classInstance.XXX** 在等号右边是**getter**方法， 会编译成**[classInstance XXX]** ，**classInstance.XXX** 在等号左边是 **setter** 方法，会编译成 **[classInstance setXXX:value]**。\n* 既然在编译时 **classInstance.XXX** 会转换成 **[classInstance XXX]**，那就和OC的方法调用是一样的，那么我们只需要创建一个 XXX 的方法，也能顺利的调用。\n\n### 优化后\n`JHCalculator2.h`\n\n```objc\n@interface JHCalculator2 : NSObject\n\n/**\n 计算结果\n */\n@property (nonatomic, readonly, assign) NSInteger resultValue;\n\n- (JHCalculator2 * (^)(NSInteger num)) add;\n\n- (JHCalculator2 * (^)(NSInteger num)) minus;\n\n- (JHCalculator2 * (^)(NSInteger num)) multiply;\n\n- (JHCalculator2 * (^)(NSInteger num)) divide;\n\n@end\n```\n.m文件内容不变，.h文件不需要写属性了，直接通过方法调用，比之前简洁了很多。\n\n## 总结\nOC链式语法总的来说是通过 **Block特性** 与 **OC点语法本质** 结合共同实现的，不过在Xcode上有个小问题，就是代码不会补全**()**，相比方便简洁的方法调用来说，这个小问题可以忽略了。\n\n[Demo地址](https://github.com/piglikeYoung/BlockCalculator)\n\n## 参考资料\n* [黑幕背后的__block修饰符](http://chun.tips/blog/2014/11/13/hei-mu-bei-hou-de-blockxiu-shi-fu/)\n* [Block技巧与底层解析](http://www.jianshu.com/p/51d04b7639f1)\n* [神奇的Block](http://www.jianshu.com/p/4b1cfd7e6361)\n* [用Block实现链式编程](http://www.tuicool.com/articles/qQJfYn3)\n* [objective-c 一个链式加法计算器实现](http://www.cnblogs.com/longling2344/p/5126021.html)\n\n","slug":"Block-Chain-Syntax","published":1,"updated":"2016-11-13T05:01:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7kn000b8jpbr8i06rku","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>每次朋友看到我写OC代码都说方法名怎么这么长，简直可以写文章了！对应OC的语法，喜欢的人说它接近自然语言，可读性强，不用看文档或者注释也能知道方法的大概使用，不喜欢的人会觉得太啰嗦了，太麻烦了。</p>\n<p>其实 OC 也可以实现类似别的语言那样的<code>点链式语法</code>。<a href=\"https://github.com/SnapKit/Masonry\" target=\"_blank\" rel=\"noopener\">Masonry</a>这个鼎鼎大名的第三方自动布局库就是OC<code>点链式语法</code>开创者。</p>\n<h2 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h2><p>本文重点不在介绍 <strong>Block</strong>，想要了解的同学可以戳底部参考文章。<br>我们先了解链式语法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.equalTo(superview.mas_top).with.offset(padding.top);</span><br><span class=\"line\">    make.left.equalTo(superview.mas_left).with.offset(padding.left);</span><br><span class=\"line\">    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);</span><br><span class=\"line\">    make.right.equalTo(superview.mas_right).with.offset(-padding.right);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>从 <strong>Masonry</strong> 的示例代码中可以看出链式语法包含：<code>点语法</code>，<code>小括号调用</code>，<code>连续调用</code>。</p>\n<ul>\n<li>点语法: 在别的语言中常见的调用方法的方式，OC中常用的是属性访问，比如访问frame，self.frame</li>\n<li>小括号调用: OC中调用方法一般使用中括号<code>[]</code>来实现，但是 Block 可以使用小括号<code>()</code>来调用</li>\n<li>连续调用: Block 可以看看成是有自动变量的匿名函数，匿名函数可以有返回值的。要实现连续调用，可以每次调用方法后，返回当前实例本身，即 self.method1() 返回 self ，这样又可以调用 self.method2()。</li>\n</ul>\n<blockquote>\n<p>这样我们可以对外配置一些只读Block属性，返回 Block 本身，实现 Block 属性的 getter 方法。</p>\n</blockquote>\n<h2 id=\"链式调用计算器\"><a href=\"#链式调用计算器\" class=\"headerlink\" title=\"链式调用计算器\"></a>链式调用计算器</h2><p>那么我们实践一下：<br>创建个链式调用计算器</p>\n<p><code>JHCalculator.h</code><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">JHCalculator</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 计算结果</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> resultValue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Block NSInteger 类型参数， 返回当前 JHCalculator 类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) JHCalculator * (^add)(<span class=\"built_in\">NSInteger</span> num);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 减</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) JHCalculator * (^minus)(<span class=\"built_in\">NSInteger</span> num);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 乘</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) JHCalculator * (^multiply)(<span class=\"built_in\">NSInteger</span> num);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 除</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) JHCalculator * (^divide)(<span class=\"built_in\">NSInteger</span> num);</span><br></pre></td></tr></table></figure></p>\n<p><code>JHCalculator.m</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (JHCalculator * (^)(<span class=\"built_in\">NSInteger</span> num)) add &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^(<span class=\"built_in\">NSInteger</span> num) &#123;</span><br><span class=\"line\">        _resultValue += num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator * (^)(<span class=\"built_in\">NSInteger</span> num)) minus &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^(<span class=\"built_in\">NSInteger</span> num) &#123;</span><br><span class=\"line\">        _resultValue -= num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator * (^)(<span class=\"built_in\">NSInteger</span> num)) multiply &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^<span class=\"keyword\">id</span>(<span class=\"built_in\">NSInteger</span> num) &#123;</span><br><span class=\"line\">        _resultValue *= num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator * (^)(<span class=\"built_in\">NSInteger</span> num)) divide &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^(<span class=\"built_in\">NSInteger</span> num) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSAssert</span>(num != <span class=\"number\">0</span>, <span class=\"string\">@\"除数不能为零！\"</span>);</span><br><span class=\"line\">        _resultValue /= num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JHCalculator *calculator = [JHCalculator new];</span><br><span class=\"line\">calculator.add(<span class=\"number\">10</span>).minus(<span class=\"number\">5</span>).multiply(<span class=\"number\">3</span>).divide(<span class=\"number\">5</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%zd\"</span>, calculator.resultValue);<span class=\"comment\">// print 3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>上面每次调用加减乘除都会访问对应的属性，比如调用 add 就是访问 add 的getter方法，即[calculator add] 方法，它会返回一个Block。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> ^(<span class=\"built_in\">NSInteger</span> num) &#123;</span><br><span class=\"line\">   _resultValue += num;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>block 返回 JHCalculator 类型，所以直接返回 self 。</p>\n<p>详细流程是这样：</p>\n<ol>\n<li>calculator.add 获取一个 Block</li>\n<li>calculator.add(10) 执行了 Block，返回了self，即当前 JHCalculator 实例</li>\n<li>然后通过返回的 self 可以继续访问 JHCalculator 中的其他属性，一步步点下去</li>\n</ol>\n<h2 id=\"更简洁的实现\"><a href=\"#更简洁的实现\" class=\"headerlink\" title=\"更简洁的实现\"></a>更简洁的实现</h2><p>上述方法是<a href=\"http://www.cnblogs.com/longling2344/p/5126021.html\" target=\"_blank\" rel=\"noopener\">《objective-c 一个链式加法计算器实现》</a>这篇文章中的实现方式，每次都需要增加一个属性，并实现该属性的getter方法，但是在 Masonry 中有更简洁的实现方式。</p>\n<p>其实在OC中点语法的本质是：<code>将 classInstance.XXX 转换成 [classInstance XXX] 来实现方法调用的</code>。</p>\n<ul>\n<li>点语法其实只是表面现象，<strong>classInstance.XXX</strong> 在等号右边是<strong>getter</strong>方法， 会编译成<strong>[classInstance XXX]</strong> ，<strong>classInstance.XXX</strong> 在等号左边是 <strong>setter</strong> 方法，会编译成 <strong>[classInstance setXXX:value]</strong>。</li>\n<li>既然在编译时 <strong>classInstance.XXX</strong> 会转换成 <strong>[classInstance XXX]</strong>，那就和OC的方法调用是一样的，那么我们只需要创建一个 XXX 的方法，也能顺利的调用。</li>\n</ul>\n<h3 id=\"优化后\"><a href=\"#优化后\" class=\"headerlink\" title=\"优化后\"></a>优化后</h3><p><code>JHCalculator2.h</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">JHCalculator2</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 计算结果</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> resultValue;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator2 * (^)(<span class=\"built_in\">NSInteger</span> num)) add;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator2 * (^)(<span class=\"built_in\">NSInteger</span> num)) minus;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator2 * (^)(<span class=\"built_in\">NSInteger</span> num)) multiply;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator2 * (^)(<span class=\"built_in\">NSInteger</span> num)) divide;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m文件内容不变，.h文件不需要写属性了，直接通过方法调用，比之前简洁了很多。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>OC链式语法总的来说是通过 <strong>Block特性</strong> 与 <strong>OC点语法本质</strong> 结合共同实现的，不过在Xcode上有个小问题，就是代码不会补全<strong>()</strong>，相比方便简洁的方法调用来说，这个小问题可以忽略了。</p>\n<p><a href=\"https://github.com/piglikeYoung/BlockCalculator\" target=\"_blank\" rel=\"noopener\">Demo地址</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://chun.tips/blog/2014/11/13/hei-mu-bei-hou-de-blockxiu-shi-fu/\" target=\"_blank\" rel=\"noopener\">黑幕背后的__block修饰符</a></li>\n<li><a href=\"http://www.jianshu.com/p/51d04b7639f1\" target=\"_blank\" rel=\"noopener\">Block技巧与底层解析</a></li>\n<li><a href=\"http://www.jianshu.com/p/4b1cfd7e6361\" target=\"_blank\" rel=\"noopener\">神奇的Block</a></li>\n<li><a href=\"http://www.tuicool.com/articles/qQJfYn3\" target=\"_blank\" rel=\"noopener\">用Block实现链式编程</a></li>\n<li><a href=\"http://www.cnblogs.com/longling2344/p/5126021.html\" target=\"_blank\" rel=\"noopener\">objective-c 一个链式加法计算器实现</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>每次朋友看到我写OC代码都说方法名怎么这么长，简直可以写文章了！对应OC的语法，喜欢的人说它接近自然语言，可读性强，不用看文档或者注释也能知道方法的大概使用，不喜欢的人会觉得太啰嗦了，太麻烦了。</p>\n<p>其实 OC 也可以实现类似别的语言那样的<code>点链式语法</code>。<a href=\"https://github.com/SnapKit/Masonry\" target=\"_blank\" rel=\"noopener\">Masonry</a>这个鼎鼎大名的第三方自动布局库就是OC<code>点链式语法</code>开创者。</p>\n<h2 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h2><p>本文重点不在介绍 <strong>Block</strong>，想要了解的同学可以戳底部参考文章。<br>我们先了解链式语法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.equalTo(superview.mas_top).with.offset(padding.top);</span><br><span class=\"line\">    make.left.equalTo(superview.mas_left).with.offset(padding.left);</span><br><span class=\"line\">    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);</span><br><span class=\"line\">    make.right.equalTo(superview.mas_right).with.offset(-padding.right);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>从 <strong>Masonry</strong> 的示例代码中可以看出链式语法包含：<code>点语法</code>，<code>小括号调用</code>，<code>连续调用</code>。</p>\n<ul>\n<li>点语法: 在别的语言中常见的调用方法的方式，OC中常用的是属性访问，比如访问frame，self.frame</li>\n<li>小括号调用: OC中调用方法一般使用中括号<code>[]</code>来实现，但是 Block 可以使用小括号<code>()</code>来调用</li>\n<li>连续调用: Block 可以看看成是有自动变量的匿名函数，匿名函数可以有返回值的。要实现连续调用，可以每次调用方法后，返回当前实例本身，即 self.method1() 返回 self ，这样又可以调用 self.method2()。</li>\n</ul>\n<blockquote>\n<p>这样我们可以对外配置一些只读Block属性，返回 Block 本身，实现 Block 属性的 getter 方法。</p>\n</blockquote>\n<h2 id=\"链式调用计算器\"><a href=\"#链式调用计算器\" class=\"headerlink\" title=\"链式调用计算器\"></a>链式调用计算器</h2><p>那么我们实践一下：<br>创建个链式调用计算器</p>\n<p><code>JHCalculator.h</code><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">JHCalculator</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 计算结果</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> resultValue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Block NSInteger 类型参数， 返回当前 JHCalculator 类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 加</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) JHCalculator * (^add)(<span class=\"built_in\">NSInteger</span> num);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 减</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) JHCalculator * (^minus)(<span class=\"built_in\">NSInteger</span> num);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 乘</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) JHCalculator * (^multiply)(<span class=\"built_in\">NSInteger</span> num);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 除</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) JHCalculator * (^divide)(<span class=\"built_in\">NSInteger</span> num);</span><br></pre></td></tr></table></figure></p>\n<p><code>JHCalculator.m</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (JHCalculator * (^)(<span class=\"built_in\">NSInteger</span> num)) add &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^(<span class=\"built_in\">NSInteger</span> num) &#123;</span><br><span class=\"line\">        _resultValue += num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator * (^)(<span class=\"built_in\">NSInteger</span> num)) minus &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^(<span class=\"built_in\">NSInteger</span> num) &#123;</span><br><span class=\"line\">        _resultValue -= num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator * (^)(<span class=\"built_in\">NSInteger</span> num)) multiply &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^<span class=\"keyword\">id</span>(<span class=\"built_in\">NSInteger</span> num) &#123;</span><br><span class=\"line\">        _resultValue *= num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator * (^)(<span class=\"built_in\">NSInteger</span> num)) divide &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^(<span class=\"built_in\">NSInteger</span> num) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSAssert</span>(num != <span class=\"number\">0</span>, <span class=\"string\">@\"除数不能为零！\"</span>);</span><br><span class=\"line\">        _resultValue /= num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JHCalculator *calculator = [JHCalculator new];</span><br><span class=\"line\">calculator.add(<span class=\"number\">10</span>).minus(<span class=\"number\">5</span>).multiply(<span class=\"number\">3</span>).divide(<span class=\"number\">5</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%zd\"</span>, calculator.resultValue);<span class=\"comment\">// print 3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>上面每次调用加减乘除都会访问对应的属性，比如调用 add 就是访问 add 的getter方法，即[calculator add] 方法，它会返回一个Block。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> ^(<span class=\"built_in\">NSInteger</span> num) &#123;</span><br><span class=\"line\">   _resultValue += num;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>block 返回 JHCalculator 类型，所以直接返回 self 。</p>\n<p>详细流程是这样：</p>\n<ol>\n<li>calculator.add 获取一个 Block</li>\n<li>calculator.add(10) 执行了 Block，返回了self，即当前 JHCalculator 实例</li>\n<li>然后通过返回的 self 可以继续访问 JHCalculator 中的其他属性，一步步点下去</li>\n</ol>\n<h2 id=\"更简洁的实现\"><a href=\"#更简洁的实现\" class=\"headerlink\" title=\"更简洁的实现\"></a>更简洁的实现</h2><p>上述方法是<a href=\"http://www.cnblogs.com/longling2344/p/5126021.html\" target=\"_blank\" rel=\"noopener\">《objective-c 一个链式加法计算器实现》</a>这篇文章中的实现方式，每次都需要增加一个属性，并实现该属性的getter方法，但是在 Masonry 中有更简洁的实现方式。</p>\n<p>其实在OC中点语法的本质是：<code>将 classInstance.XXX 转换成 [classInstance XXX] 来实现方法调用的</code>。</p>\n<ul>\n<li>点语法其实只是表面现象，<strong>classInstance.XXX</strong> 在等号右边是<strong>getter</strong>方法， 会编译成<strong>[classInstance XXX]</strong> ，<strong>classInstance.XXX</strong> 在等号左边是 <strong>setter</strong> 方法，会编译成 <strong>[classInstance setXXX:value]</strong>。</li>\n<li>既然在编译时 <strong>classInstance.XXX</strong> 会转换成 <strong>[classInstance XXX]</strong>，那就和OC的方法调用是一样的，那么我们只需要创建一个 XXX 的方法，也能顺利的调用。</li>\n</ul>\n<h3 id=\"优化后\"><a href=\"#优化后\" class=\"headerlink\" title=\"优化后\"></a>优化后</h3><p><code>JHCalculator2.h</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">JHCalculator2</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 计算结果</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> resultValue;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator2 * (^)(<span class=\"built_in\">NSInteger</span> num)) add;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator2 * (^)(<span class=\"built_in\">NSInteger</span> num)) minus;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator2 * (^)(<span class=\"built_in\">NSInteger</span> num)) multiply;</span><br><span class=\"line\"></span><br><span class=\"line\">- (JHCalculator2 * (^)(<span class=\"built_in\">NSInteger</span> num)) divide;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m文件内容不变，.h文件不需要写属性了，直接通过方法调用，比之前简洁了很多。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>OC链式语法总的来说是通过 <strong>Block特性</strong> 与 <strong>OC点语法本质</strong> 结合共同实现的，不过在Xcode上有个小问题，就是代码不会补全<strong>()</strong>，相比方便简洁的方法调用来说，这个小问题可以忽略了。</p>\n<p><a href=\"https://github.com/piglikeYoung/BlockCalculator\" target=\"_blank\" rel=\"noopener\">Demo地址</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://chun.tips/blog/2014/11/13/hei-mu-bei-hou-de-blockxiu-shi-fu/\" target=\"_blank\" rel=\"noopener\">黑幕背后的__block修饰符</a></li>\n<li><a href=\"http://www.jianshu.com/p/51d04b7639f1\" target=\"_blank\" rel=\"noopener\">Block技巧与底层解析</a></li>\n<li><a href=\"http://www.jianshu.com/p/4b1cfd7e6361\" target=\"_blank\" rel=\"noopener\">神奇的Block</a></li>\n<li><a href=\"http://www.tuicool.com/articles/qQJfYn3\" target=\"_blank\" rel=\"noopener\">用Block实现链式编程</a></li>\n<li><a href=\"http://www.cnblogs.com/longling2344/p/5126021.html\" target=\"_blank\" rel=\"noopener\">objective-c 一个链式加法计算器实现</a></li>\n</ul>\n"},{"title":"GCD信号锁","date":"2016-09-11T04:53:58.000Z","_content":"\n## 前言\n在多线程环境下，需要处理的一个很大的问题就是`资源竞争`。在项目中我也遇到了多线程操作同一个数据源的问题，经常会遇到意想不到的Crash，在iOS中有同步锁，互斥锁的方式解决这个问题。\n\n一般情况下的锁有：`NSLock`, `@synchronized`, `pthread_mutex_t`等等，来保证线程的安全。\n\n## 问题\n使用锁有很大的问题：加锁和解锁的操作非常昂贵，对性能会有影响。\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    \nNSMutableSet *items = [NSMutableSet set];\n    \nNSLock *lock = [[NSLock alloc] init];\n    \nuint64_t start = mach_absolute_time();\n    \ndispatch_apply(50, queue, ^(size_t index) {\n   for (NSInteger i = 0; i<10000; i++) {\n       [lock lock];\n       [items addObject:@\"hello\"];\n       [lock unlock];\n   }\n});\n    \nuint64_t stop = mach_absolute_time();\n    \nNSLog(@\"%f\", subtractTimes(stop, start));\n```\n上面这段代码在我的机器上输出是1.7+s的时间。\n\n## 优化\n实际上频繁的加解锁是不必要的，我们可以借用GCD提供的信号量来优化这种操作。在我们创建一个信号量时，如果将信号的个数设置为1，则可以实现类似于锁的功能。\n\n```objc\nNSMutableSet *items = [NSMutableSet set];\n    \ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\ndispatch_semaphore_t itemLock = dispatch_semaphore_create(1);\n    \nuint64_t start = mach_absolute_time();\n    \ndispatch_apply(50, queue, ^(size_t index) {\n   for (NSInteger i = 0; i<10000; i++) {\n       dispatch_semaphore_wait(itemLock, DISPATCH_TIME_FOREVER);\n       [items addObject:@\"hello\"];\n       dispatch_semaphore_signal(itemLock);\n   }\n});\n    \nuint64_t stop = mach_absolute_time();\n    \nNSLog(@\"%f\", subtractTimes(stop, start));\n```\n优化后的代码在我的机器上输出是0.1+s的时间，执行时间上，两者相差10+倍。\n\n### 简单介绍GCD semaphore\n* `dispatch_semaphore_create` 创建一个信号量，参数就是信号个数\n* `dispatch_semaphore_signal` 发送一个信号，会让信号总量+1\n* `dispatch_semaphore_wait` 等待信号，当信号总量≤0的时候就会一直等待，当信号总量>0的时候，正常执行，并且信号总量-1。\n\n通过这样的方式，我们就可以快速创建一个线程锁控制资源访问和并发。\n\n## 参考链接\n[南峰子_老驴#iOS知识小集](http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501)\n\n","source":"_posts/GCD-signal-lock.md","raw":"---\ntitle: GCD信号锁\ndate: 2016-09-11 12:53:58\ntags: GCD\ncategory: 能工巧匠\n---\n\n## 前言\n在多线程环境下，需要处理的一个很大的问题就是`资源竞争`。在项目中我也遇到了多线程操作同一个数据源的问题，经常会遇到意想不到的Crash，在iOS中有同步锁，互斥锁的方式解决这个问题。\n\n一般情况下的锁有：`NSLock`, `@synchronized`, `pthread_mutex_t`等等，来保证线程的安全。\n\n## 问题\n使用锁有很大的问题：加锁和解锁的操作非常昂贵，对性能会有影响。\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    \nNSMutableSet *items = [NSMutableSet set];\n    \nNSLock *lock = [[NSLock alloc] init];\n    \nuint64_t start = mach_absolute_time();\n    \ndispatch_apply(50, queue, ^(size_t index) {\n   for (NSInteger i = 0; i<10000; i++) {\n       [lock lock];\n       [items addObject:@\"hello\"];\n       [lock unlock];\n   }\n});\n    \nuint64_t stop = mach_absolute_time();\n    \nNSLog(@\"%f\", subtractTimes(stop, start));\n```\n上面这段代码在我的机器上输出是1.7+s的时间。\n\n## 优化\n实际上频繁的加解锁是不必要的，我们可以借用GCD提供的信号量来优化这种操作。在我们创建一个信号量时，如果将信号的个数设置为1，则可以实现类似于锁的功能。\n\n```objc\nNSMutableSet *items = [NSMutableSet set];\n    \ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\ndispatch_semaphore_t itemLock = dispatch_semaphore_create(1);\n    \nuint64_t start = mach_absolute_time();\n    \ndispatch_apply(50, queue, ^(size_t index) {\n   for (NSInteger i = 0; i<10000; i++) {\n       dispatch_semaphore_wait(itemLock, DISPATCH_TIME_FOREVER);\n       [items addObject:@\"hello\"];\n       dispatch_semaphore_signal(itemLock);\n   }\n});\n    \nuint64_t stop = mach_absolute_time();\n    \nNSLog(@\"%f\", subtractTimes(stop, start));\n```\n优化后的代码在我的机器上输出是0.1+s的时间，执行时间上，两者相差10+倍。\n\n### 简单介绍GCD semaphore\n* `dispatch_semaphore_create` 创建一个信号量，参数就是信号个数\n* `dispatch_semaphore_signal` 发送一个信号，会让信号总量+1\n* `dispatch_semaphore_wait` 等待信号，当信号总量≤0的时候就会一直等待，当信号总量>0的时候，正常执行，并且信号总量-1。\n\n通过这样的方式，我们就可以快速创建一个线程锁控制资源访问和并发。\n\n## 参考链接\n[南峰子_老驴#iOS知识小集](http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501)\n\n","slug":"GCD-signal-lock","published":1,"updated":"2016-09-11T07:25:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7kp000f8jpbrb8zonfd","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在多线程环境下，需要处理的一个很大的问题就是<code>资源竞争</code>。在项目中我也遇到了多线程操作同一个数据源的问题，经常会遇到意想不到的Crash，在iOS中有同步锁，互斥锁的方式解决这个问题。</p>\n<p>一般情况下的锁有：<code>NSLock</code>, <code>@synchronized</code>, <code>pthread_mutex_t</code>等等，来保证线程的安全。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>使用锁有很大的问题：加锁和解锁的操作非常昂贵，对性能会有影响。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSMutableSet</span> *items = [<span class=\"built_in\">NSMutableSet</span> set];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLock</span> *lock = [[<span class=\"built_in\">NSLock</span> alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">uint64_t start = mach_absolute_time();</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_apply(<span class=\"number\">50</span>, queue, ^(size_t index) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">       [lock lock];</span><br><span class=\"line\">       [items addObject:<span class=\"string\">@\"hello\"</span>];</span><br><span class=\"line\">       [lock unlock];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">uint64_t stop = mach_absolute_time();</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%f\"</span>, subtractTimes(stop, start));</span><br></pre></td></tr></table></figure>\n<p>上面这段代码在我的机器上输出是1.7+s的时间。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>实际上频繁的加解锁是不必要的，我们可以借用GCD提供的信号量来优化这种操作。在我们创建一个信号量时，如果将信号的个数设置为1，则可以实现类似于锁的功能。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableSet</span> *items = [<span class=\"built_in\">NSMutableSet</span> set];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_semaphore_t itemLock = dispatch_semaphore_create(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">uint64_t start = mach_absolute_time();</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_apply(<span class=\"number\">50</span>, queue, ^(size_t index) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">       dispatch_semaphore_wait(itemLock, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">       [items addObject:<span class=\"string\">@\"hello\"</span>];</span><br><span class=\"line\">       dispatch_semaphore_signal(itemLock);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">uint64_t stop = mach_absolute_time();</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%f\"</span>, subtractTimes(stop, start));</span><br></pre></td></tr></table></figure>\n<p>优化后的代码在我的机器上输出是0.1+s的时间，执行时间上，两者相差10+倍。</p>\n<h3 id=\"简单介绍GCD-semaphore\"><a href=\"#简单介绍GCD-semaphore\" class=\"headerlink\" title=\"简单介绍GCD semaphore\"></a>简单介绍GCD semaphore</h3><ul>\n<li><code>dispatch_semaphore_create</code> 创建一个信号量，参数就是信号个数</li>\n<li><code>dispatch_semaphore_signal</code> 发送一个信号，会让信号总量+1</li>\n<li><code>dispatch_semaphore_wait</code> 等待信号，当信号总量≤0的时候就会一直等待，当信号总量&gt;0的时候，正常执行，并且信号总量-1。</li>\n</ul>\n<p>通过这样的方式，我们就可以快速创建一个线程锁控制资源访问和并发。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501\" target=\"_blank\" rel=\"noopener\">南峰子_老驴#iOS知识小集</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在多线程环境下，需要处理的一个很大的问题就是<code>资源竞争</code>。在项目中我也遇到了多线程操作同一个数据源的问题，经常会遇到意想不到的Crash，在iOS中有同步锁，互斥锁的方式解决这个问题。</p>\n<p>一般情况下的锁有：<code>NSLock</code>, <code>@synchronized</code>, <code>pthread_mutex_t</code>等等，来保证线程的安全。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>使用锁有很大的问题：加锁和解锁的操作非常昂贵，对性能会有影响。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSMutableSet</span> *items = [<span class=\"built_in\">NSMutableSet</span> set];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLock</span> *lock = [[<span class=\"built_in\">NSLock</span> alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">uint64_t start = mach_absolute_time();</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_apply(<span class=\"number\">50</span>, queue, ^(size_t index) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">       [lock lock];</span><br><span class=\"line\">       [items addObject:<span class=\"string\">@\"hello\"</span>];</span><br><span class=\"line\">       [lock unlock];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">uint64_t stop = mach_absolute_time();</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%f\"</span>, subtractTimes(stop, start));</span><br></pre></td></tr></table></figure>\n<p>上面这段代码在我的机器上输出是1.7+s的时间。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>实际上频繁的加解锁是不必要的，我们可以借用GCD提供的信号量来优化这种操作。在我们创建一个信号量时，如果将信号的个数设置为1，则可以实现类似于锁的功能。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableSet</span> *items = [<span class=\"built_in\">NSMutableSet</span> set];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_semaphore_t itemLock = dispatch_semaphore_create(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">uint64_t start = mach_absolute_time();</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_apply(<span class=\"number\">50</span>, queue, ^(size_t index) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">       dispatch_semaphore_wait(itemLock, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">       [items addObject:<span class=\"string\">@\"hello\"</span>];</span><br><span class=\"line\">       dispatch_semaphore_signal(itemLock);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">uint64_t stop = mach_absolute_time();</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%f\"</span>, subtractTimes(stop, start));</span><br></pre></td></tr></table></figure>\n<p>优化后的代码在我的机器上输出是0.1+s的时间，执行时间上，两者相差10+倍。</p>\n<h3 id=\"简单介绍GCD-semaphore\"><a href=\"#简单介绍GCD-semaphore\" class=\"headerlink\" title=\"简单介绍GCD semaphore\"></a>简单介绍GCD semaphore</h3><ul>\n<li><code>dispatch_semaphore_create</code> 创建一个信号量，参数就是信号个数</li>\n<li><code>dispatch_semaphore_signal</code> 发送一个信号，会让信号总量+1</li>\n<li><code>dispatch_semaphore_wait</code> 等待信号，当信号总量≤0的时候就会一直等待，当信号总量&gt;0的时候，正常执行，并且信号总量-1。</li>\n</ul>\n<p>通过这样的方式，我们就可以快速创建一个线程锁控制资源访问和并发。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501\" target=\"_blank\" rel=\"noopener\">南峰子_老驴#iOS知识小集</a></p>\n"},{"title":"学习ReactNative基础（一）","date":"2017-03-05T08:08:05.000Z","_content":"\n## 前言\n\n[React](https://github.com/facebook/react) 应该算是目前最火的前端框架，通过它衍生出来的 [ReactNative](https://github.com/facebook/react-native) 几乎颠覆了人们对 Web APP 的认识。其实2013年5月 **React** 就开源了，而 **ReactNative** 也在 2015年开源了，我在业余时间学习了下 **ReactNative** 基本语法, 希望能在未来的工作使用上。\n\n## React简介\nReact 起源于 Facebook 公司，初期用于 instagram 网站开发，React 是一个用于构建用户界面的JavaScript库，不是一个MVC框架，提出了一种新的开发模式和理念，它强调的是“用户界面”。\n\n### 作为UI\nReact 可以作为MVC中的view层进行使用，并且在已有项目中很容易使用React开发新功能。\n\n### 虚拟DOM\n虚拟DOM是React最重要的特性，实现了优化视图的渲染和刷新，以前没有ajax技术时，web页面从服务器整体渲染出html输出到浏览器进行渲染，用户的一个操作也会刷新整个页面。直到ajax的出现，实现页面局部刷新，带来的高效和分离让web开发们惊叹不已，但是又有新的问题出现，赋值的用户交互和展现需要通过大量的DOM操作来完成，这让页面的性能以及开发的效率又出现了新的瓶颈，如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标。\n\n时至今日，谈到前端性能优化，减少DOM元素，减少reflow和repaint，编码过程中尽可能减少DOM查询等等而页面的任何UI的变化都是通过整体的刷新来完成的，而React之所以快，是因为它不是直接操作DOM，而是引进虚拟的DOM实现来解决这个问题。\n\n基于React进行开发时所有的DOM构建都是通过虚拟的DOM进行，每当数据发生变化，React都会重新构建一个完整的虚拟DOM，虚拟DOM是内存数据，React通过自己实现的 DOM Diff算法将当前的虚拟DOM树和上一次的DOM进行对比，得到两个DOM结构的差异，然后仅仅将需要变化的部分进行实际的浏览器DOM更新，达到最小化重绘，避免不必要的DOM操作，解决了这两个公认的前端性能瓶颈，实现高效DOM渲染。\n\n### 组件化\n虚拟的DOM不仅带来简单的UI开发逻辑，同时也带来了组件化开发的思想，所谓组件，即封装起来的具有独立功能的UI部件，React推荐以组件的方式去思考UI构成，将UI上每个功能都相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体UI构建。\n\n如果说MVC的思想让你做到了视图-数据-控制器分离，那么组件化的思考方向则是带来了UI功能模块之间的分离。\n对于React而言，开发者从功能的角度出发，将UI分成不同的组件，每个组件都独立封装。在React中，你按照界面模块自然划分的方式来组织和编写你的代码，，对于评论界面而言，整个UI是一个通过小组件构成的大组件，每个组件只关心自己部分的逻辑，彼此独立，React组件应该具有以下特征：可组合，可重用，可维护。\n\n### 数据流\nReact 实现了单向的数据流，相对于传统的数据绑定，React更加灵活，便捷。\n\n\n## React和ReactNative的关系\n\nReact用于web应用开发，ReactNative采用React方式进行移动应用开发，既有原生Native的加护体验，又能保留React自由的开发效率，使用灵活的HTML和CSS布局，使用React语法构建组件，然后同时运行在iOS和Android上，“learn once ，write anywhere”。\n\n\n## 零、安装\n\n安装 ReactNative 环境可以参考[搭建开发环境](http://reactnative.cn/docs/0.41/getting-started.html) 这篇文章，一步步来。\n\n安装完成后，测试安装初始化了一个 **AwesomeProject** 工程，工程的结构如图：\n{% asset_img Snip20170305_2.png RN-Structure %}\n\n\n可以直接使用 命令行cd到该目录 或者 Xcode运行起来（由于我是使用Mac环境，所以文章都是以iOS作为实例）。\n\n从图中可以看出，Android 和 iOS 是分开文件夹的，index.android.js 和index.ios.js 分别对应各自的系统，我们代码的入口就是这两个js文件。\n\n## 一、index.ios.js\n\n打开 **index.ios.js** 文件，可以看到分成四部分存在：\n\n### 第一部分\n\n```JavaScript\nimport React, { Component } from 'react';\nimport {\n  AppRegistry,\n  StyleSheet,\n  Text,\n  View\n} from 'react-native';\n```\n\n导入ReactNative包，导入ReactNative组件：\n* AppRegistry: JS运行所有ReactNative应用的入口\n* StyleSheet: ReactNative中使用的样式表，类似CSS样式表\n* 各种开发需要使用的组件\n\n模板中使用的是ES6语法，ES5语法如下：\n\n```JavaScript\nlet React = require('react-native');\nlet {\nAppRegistry,\nStyleSheet,\nText,\nView\n} = React;\n```\n\n当我们需要引入别的文件，使用 `require` 函数：\n\n```JavaScript\nvar BookList = require('./iOS_views/book/book_list');\n```\n\n### 第二部分\n\n```JavaScript\nexport default class HelloWorld extends Component {\n  render() {\n    return (\n      <View style={styles.container}>\n        <Text style={styles.welcome}>\n          Welcome to 淘宝!\n        </Text>\n        <Text style={styles.instructions}>\n          To get started, edit index.ios.js\n        </Text>\n        <Text style={styles.instructions}>\n          Press Cmd+R to reload,{'\\n'}\n          Cmd+D or shake for dev menu\n        </Text>\n      </View>\n    );\n  }\n}\n```\n\n创建ReactNative组件，模板中使用的是ES6的语法，render() {} 是ES6中的函数简写\n\nES5语法如下：\n\n```JavaScript\nvar HelloWorld = React.createClass({\n render: function{\n   return ();\n }\n});\n```\n\n### 第三部分\n\n```JavaScript\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF',\n  },\n  welcome: {\n    fontSize: 20,\n    textAlign: 'center',\n    margin: 10,\n  },\n  instructions: {\n    textAlign: 'center',\n    color: '#333333',\n    marginBottom: 5,\n  },\n});\n```\nStyleSheet.create创建样式实例，在应用中只会被创建一次，不用每次在渲染周期中重新创建\n  \n\n### 第四部分\n\n```JavaScript\nAppRegistry.registerComponent('HelloWorld', () => HelloWorld);\n```\n\n注册入口组件。\n\n* **AppRegistry**：负责注册运行ReactNative应用程序的JavaScript入口\n* **registerComponent**：注册应用程序的入口组件，告知ReactNative哪一个组件被注册为应用的根容器\n\n第二个参数使用了ES6的语法，箭头函数：\n\n```JavaScript\n// 返回的必须是定义的组件类的名字\n// 等价于 function() {return HelloWorld}\n() => HelloWorld \n```\n\n## 总结\n\n本章介绍了 ReactNative 背景以及优缺点，分析了测试安装工程的工程结构，以及index.ios.js 的代码结构，还有很多未涉及的方面，比如IDE的安装等等，想要了解的可以点下方的参考链接。\n\n## 参考链接\n* [React 入门实例教程](http://www.ruanyifeng.com/blog/2015/03/react.html)\n* [也许，DOM 不是答案](http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html)\n* [ReactNavite官网](https://facebook.github.io/react-native/docs/getting-started.html)\n* [ReactNavite中文网](http://reactnative.cn/docs/0.41/getting-started.html)\n* [ React Native开发之IDE（Atom+Nuclide）安装，运行，调试](http://blog.csdn.net/hello_hwc/article/details/51612139)\n* [3分钟带你玩转React Native研发所有调试技巧](http://www.52learn.wang/archives/1071?utm_source=tuicool&utm_medium=referral)\n* [学习 React Native for Android：环境搭建](http://hahack.com/codes/learn-react-native-for-android-01/)\n* [React-Native入门指南](https://github.com/vczero/react-native-lesson)\n\n\n\n\n\n\n\n","source":"_posts/Learn-ReactNative-1.md","raw":"---\ntitle: 学习ReactNative基础（一）\ndate: 2017-03-05 16:08:05\ntags: RN\ncategory: ReactNative\n---\n\n## 前言\n\n[React](https://github.com/facebook/react) 应该算是目前最火的前端框架，通过它衍生出来的 [ReactNative](https://github.com/facebook/react-native) 几乎颠覆了人们对 Web APP 的认识。其实2013年5月 **React** 就开源了，而 **ReactNative** 也在 2015年开源了，我在业余时间学习了下 **ReactNative** 基本语法, 希望能在未来的工作使用上。\n\n## React简介\nReact 起源于 Facebook 公司，初期用于 instagram 网站开发，React 是一个用于构建用户界面的JavaScript库，不是一个MVC框架，提出了一种新的开发模式和理念，它强调的是“用户界面”。\n\n### 作为UI\nReact 可以作为MVC中的view层进行使用，并且在已有项目中很容易使用React开发新功能。\n\n### 虚拟DOM\n虚拟DOM是React最重要的特性，实现了优化视图的渲染和刷新，以前没有ajax技术时，web页面从服务器整体渲染出html输出到浏览器进行渲染，用户的一个操作也会刷新整个页面。直到ajax的出现，实现页面局部刷新，带来的高效和分离让web开发们惊叹不已，但是又有新的问题出现，赋值的用户交互和展现需要通过大量的DOM操作来完成，这让页面的性能以及开发的效率又出现了新的瓶颈，如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标。\n\n时至今日，谈到前端性能优化，减少DOM元素，减少reflow和repaint，编码过程中尽可能减少DOM查询等等而页面的任何UI的变化都是通过整体的刷新来完成的，而React之所以快，是因为它不是直接操作DOM，而是引进虚拟的DOM实现来解决这个问题。\n\n基于React进行开发时所有的DOM构建都是通过虚拟的DOM进行，每当数据发生变化，React都会重新构建一个完整的虚拟DOM，虚拟DOM是内存数据，React通过自己实现的 DOM Diff算法将当前的虚拟DOM树和上一次的DOM进行对比，得到两个DOM结构的差异，然后仅仅将需要变化的部分进行实际的浏览器DOM更新，达到最小化重绘，避免不必要的DOM操作，解决了这两个公认的前端性能瓶颈，实现高效DOM渲染。\n\n### 组件化\n虚拟的DOM不仅带来简单的UI开发逻辑，同时也带来了组件化开发的思想，所谓组件，即封装起来的具有独立功能的UI部件，React推荐以组件的方式去思考UI构成，将UI上每个功能都相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体UI构建。\n\n如果说MVC的思想让你做到了视图-数据-控制器分离，那么组件化的思考方向则是带来了UI功能模块之间的分离。\n对于React而言，开发者从功能的角度出发，将UI分成不同的组件，每个组件都独立封装。在React中，你按照界面模块自然划分的方式来组织和编写你的代码，，对于评论界面而言，整个UI是一个通过小组件构成的大组件，每个组件只关心自己部分的逻辑，彼此独立，React组件应该具有以下特征：可组合，可重用，可维护。\n\n### 数据流\nReact 实现了单向的数据流，相对于传统的数据绑定，React更加灵活，便捷。\n\n\n## React和ReactNative的关系\n\nReact用于web应用开发，ReactNative采用React方式进行移动应用开发，既有原生Native的加护体验，又能保留React自由的开发效率，使用灵活的HTML和CSS布局，使用React语法构建组件，然后同时运行在iOS和Android上，“learn once ，write anywhere”。\n\n\n## 零、安装\n\n安装 ReactNative 环境可以参考[搭建开发环境](http://reactnative.cn/docs/0.41/getting-started.html) 这篇文章，一步步来。\n\n安装完成后，测试安装初始化了一个 **AwesomeProject** 工程，工程的结构如图：\n{% asset_img Snip20170305_2.png RN-Structure %}\n\n\n可以直接使用 命令行cd到该目录 或者 Xcode运行起来（由于我是使用Mac环境，所以文章都是以iOS作为实例）。\n\n从图中可以看出，Android 和 iOS 是分开文件夹的，index.android.js 和index.ios.js 分别对应各自的系统，我们代码的入口就是这两个js文件。\n\n## 一、index.ios.js\n\n打开 **index.ios.js** 文件，可以看到分成四部分存在：\n\n### 第一部分\n\n```JavaScript\nimport React, { Component } from 'react';\nimport {\n  AppRegistry,\n  StyleSheet,\n  Text,\n  View\n} from 'react-native';\n```\n\n导入ReactNative包，导入ReactNative组件：\n* AppRegistry: JS运行所有ReactNative应用的入口\n* StyleSheet: ReactNative中使用的样式表，类似CSS样式表\n* 各种开发需要使用的组件\n\n模板中使用的是ES6语法，ES5语法如下：\n\n```JavaScript\nlet React = require('react-native');\nlet {\nAppRegistry,\nStyleSheet,\nText,\nView\n} = React;\n```\n\n当我们需要引入别的文件，使用 `require` 函数：\n\n```JavaScript\nvar BookList = require('./iOS_views/book/book_list');\n```\n\n### 第二部分\n\n```JavaScript\nexport default class HelloWorld extends Component {\n  render() {\n    return (\n      <View style={styles.container}>\n        <Text style={styles.welcome}>\n          Welcome to 淘宝!\n        </Text>\n        <Text style={styles.instructions}>\n          To get started, edit index.ios.js\n        </Text>\n        <Text style={styles.instructions}>\n          Press Cmd+R to reload,{'\\n'}\n          Cmd+D or shake for dev menu\n        </Text>\n      </View>\n    );\n  }\n}\n```\n\n创建ReactNative组件，模板中使用的是ES6的语法，render() {} 是ES6中的函数简写\n\nES5语法如下：\n\n```JavaScript\nvar HelloWorld = React.createClass({\n render: function{\n   return ();\n }\n});\n```\n\n### 第三部分\n\n```JavaScript\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF',\n  },\n  welcome: {\n    fontSize: 20,\n    textAlign: 'center',\n    margin: 10,\n  },\n  instructions: {\n    textAlign: 'center',\n    color: '#333333',\n    marginBottom: 5,\n  },\n});\n```\nStyleSheet.create创建样式实例，在应用中只会被创建一次，不用每次在渲染周期中重新创建\n  \n\n### 第四部分\n\n```JavaScript\nAppRegistry.registerComponent('HelloWorld', () => HelloWorld);\n```\n\n注册入口组件。\n\n* **AppRegistry**：负责注册运行ReactNative应用程序的JavaScript入口\n* **registerComponent**：注册应用程序的入口组件，告知ReactNative哪一个组件被注册为应用的根容器\n\n第二个参数使用了ES6的语法，箭头函数：\n\n```JavaScript\n// 返回的必须是定义的组件类的名字\n// 等价于 function() {return HelloWorld}\n() => HelloWorld \n```\n\n## 总结\n\n本章介绍了 ReactNative 背景以及优缺点，分析了测试安装工程的工程结构，以及index.ios.js 的代码结构，还有很多未涉及的方面，比如IDE的安装等等，想要了解的可以点下方的参考链接。\n\n## 参考链接\n* [React 入门实例教程](http://www.ruanyifeng.com/blog/2015/03/react.html)\n* [也许，DOM 不是答案](http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html)\n* [ReactNavite官网](https://facebook.github.io/react-native/docs/getting-started.html)\n* [ReactNavite中文网](http://reactnative.cn/docs/0.41/getting-started.html)\n* [ React Native开发之IDE（Atom+Nuclide）安装，运行，调试](http://blog.csdn.net/hello_hwc/article/details/51612139)\n* [3分钟带你玩转React Native研发所有调试技巧](http://www.52learn.wang/archives/1071?utm_source=tuicool&utm_medium=referral)\n* [学习 React Native for Android：环境搭建](http://hahack.com/codes/learn-react-native-for-android-01/)\n* [React-Native入门指南](https://github.com/vczero/react-native-lesson)\n\n\n\n\n\n\n\n","slug":"Learn-ReactNative-1","published":1,"updated":"2017-04-30T10:05:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7ks000h8jpb1b0x70t5","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://github.com/facebook/react\" target=\"_blank\" rel=\"noopener\">React</a> 应该算是目前最火的前端框架，通过它衍生出来的 <a href=\"https://github.com/facebook/react-native\" target=\"_blank\" rel=\"noopener\">ReactNative</a> 几乎颠覆了人们对 Web APP 的认识。其实2013年5月 <strong>React</strong> 就开源了，而 <strong>ReactNative</strong> 也在 2015年开源了，我在业余时间学习了下 <strong>ReactNative</strong> 基本语法, 希望能在未来的工作使用上。</p>\n<h2 id=\"React简介\"><a href=\"#React简介\" class=\"headerlink\" title=\"React简介\"></a>React简介</h2><p>React 起源于 Facebook 公司，初期用于 instagram 网站开发，React 是一个用于构建用户界面的JavaScript库，不是一个MVC框架，提出了一种新的开发模式和理念，它强调的是“用户界面”。</p>\n<h3 id=\"作为UI\"><a href=\"#作为UI\" class=\"headerlink\" title=\"作为UI\"></a>作为UI</h3><p>React 可以作为MVC中的view层进行使用，并且在已有项目中很容易使用React开发新功能。</p>\n<h3 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h3><p>虚拟DOM是React最重要的特性，实现了优化视图的渲染和刷新，以前没有ajax技术时，web页面从服务器整体渲染出html输出到浏览器进行渲染，用户的一个操作也会刷新整个页面。直到ajax的出现，实现页面局部刷新，带来的高效和分离让web开发们惊叹不已，但是又有新的问题出现，赋值的用户交互和展现需要通过大量的DOM操作来完成，这让页面的性能以及开发的效率又出现了新的瓶颈，如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标。</p>\n<p>时至今日，谈到前端性能优化，减少DOM元素，减少reflow和repaint，编码过程中尽可能减少DOM查询等等而页面的任何UI的变化都是通过整体的刷新来完成的，而React之所以快，是因为它不是直接操作DOM，而是引进虚拟的DOM实现来解决这个问题。</p>\n<p>基于React进行开发时所有的DOM构建都是通过虚拟的DOM进行，每当数据发生变化，React都会重新构建一个完整的虚拟DOM，虚拟DOM是内存数据，React通过自己实现的 DOM Diff算法将当前的虚拟DOM树和上一次的DOM进行对比，得到两个DOM结构的差异，然后仅仅将需要变化的部分进行实际的浏览器DOM更新，达到最小化重绘，避免不必要的DOM操作，解决了这两个公认的前端性能瓶颈，实现高效DOM渲染。</p>\n<h3 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h3><p>虚拟的DOM不仅带来简单的UI开发逻辑，同时也带来了组件化开发的思想，所谓组件，即封装起来的具有独立功能的UI部件，React推荐以组件的方式去思考UI构成，将UI上每个功能都相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体UI构建。</p>\n<p>如果说MVC的思想让你做到了视图-数据-控制器分离，那么组件化的思考方向则是带来了UI功能模块之间的分离。<br>对于React而言，开发者从功能的角度出发，将UI分成不同的组件，每个组件都独立封装。在React中，你按照界面模块自然划分的方式来组织和编写你的代码，，对于评论界面而言，整个UI是一个通过小组件构成的大组件，每个组件只关心自己部分的逻辑，彼此独立，React组件应该具有以下特征：可组合，可重用，可维护。</p>\n<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><p>React 实现了单向的数据流，相对于传统的数据绑定，React更加灵活，便捷。</p>\n<h2 id=\"React和ReactNative的关系\"><a href=\"#React和ReactNative的关系\" class=\"headerlink\" title=\"React和ReactNative的关系\"></a>React和ReactNative的关系</h2><p>React用于web应用开发，ReactNative采用React方式进行移动应用开发，既有原生Native的加护体验，又能保留React自由的开发效率，使用灵活的HTML和CSS布局，使用React语法构建组件，然后同时运行在iOS和Android上，“learn once ，write anywhere”。</p>\n<h2 id=\"零、安装\"><a href=\"#零、安装\" class=\"headerlink\" title=\"零、安装\"></a>零、安装</h2><p>安装 ReactNative 环境可以参考<a href=\"http://reactnative.cn/docs/0.41/getting-started.html\" target=\"_blank\" rel=\"noopener\">搭建开发环境</a> 这篇文章，一步步来。</p>\n<p>安装完成后，测试安装初始化了一个 <strong>AwesomeProject</strong> 工程，工程的结构如图：<br><img src=\"/2017/03/05/Learn-ReactNative-1/Snip20170305_2.png\" title=\"RN-Structure\"></p>\n<p>可以直接使用 命令行cd到该目录 或者 Xcode运行起来（由于我是使用Mac环境，所以文章都是以iOS作为实例）。</p>\n<p>从图中可以看出，Android 和 iOS 是分开文件夹的，index.android.js 和index.ios.js 分别对应各自的系统，我们代码的入口就是这两个js文件。</p>\n<h2 id=\"一、index-ios-js\"><a href=\"#一、index-ios-js\" class=\"headerlink\" title=\"一、index.ios.js\"></a>一、index.ios.js</h2><p>打开 <strong>index.ios.js</strong> 文件，可以看到分成四部分存在：</p>\n<h3 id=\"第一部分\"><a href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"></a>第一部分</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  AppRegistry,</span><br><span class=\"line\">  StyleSheet,</span><br><span class=\"line\">  Text,</span><br><span class=\"line\">  View</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</span><br></pre></td></tr></table></figure>\n<p>导入ReactNative包，导入ReactNative组件：</p>\n<ul>\n<li>AppRegistry: JS运行所有ReactNative应用的入口</li>\n<li>StyleSheet: ReactNative中使用的样式表，类似CSS样式表</li>\n<li>各种开发需要使用的组件</li>\n</ul>\n<p>模板中使用的是ES6语法，ES5语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">'react-native'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;</span><br><span class=\"line\">AppRegistry,</span><br><span class=\"line\">StyleSheet,</span><br><span class=\"line\">Text,</span><br><span class=\"line\">View</span><br><span class=\"line\">&#125; = React;</span><br></pre></td></tr></table></figure>\n<p>当我们需要引入别的文件，使用 <code>require</code> 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> BookList = <span class=\"built_in\">require</span>(<span class=\"string\">'./iOS_views/book/book_list'</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二部分\"><a href=\"#第二部分\" class=\"headerlink\" title=\"第二部分\"></a>第二部分</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class=\"line\">          Welcome to 淘宝!</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Text style=&#123;styles.instructions&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          To get started, edit index.ios.js</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.instructions&#125;&gt;</span><br><span class=\"line\">          Press Cmd+R to reload,&#123;<span class=\"string\">'\\n'</span>&#125;</span><br><span class=\"line\">          Cmd+D or shake <span class=\"keyword\">for</span> dev menu</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建ReactNative组件，模板中使用的是ES6的语法，render() {} 是ES6中的函数简写</p>\n<p>ES5语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloWorld = React.createClass(&#123;</span><br><span class=\"line\"> render: <span class=\"function\"><span class=\"keyword\">function</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> ();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三部分\"><a href=\"#第三部分\" class=\"headerlink\" title=\"第三部分\"></a>第三部分</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  welcome: &#123;</span><br><span class=\"line\">    fontSize: <span class=\"number\">20</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    margin: <span class=\"number\">10</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  instructions: &#123;</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    color: <span class=\"string\">'#333333'</span>,</span><br><span class=\"line\">    marginBottom: <span class=\"number\">5</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>StyleSheet.create创建样式实例，在应用中只会被创建一次，不用每次在渲染周期中重新创建</p>\n<h3 id=\"第四部分\"><a href=\"#第四部分\" class=\"headerlink\" title=\"第四部分\"></a>第四部分</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AppRegistry.registerComponent(<span class=\"string\">'HelloWorld'</span>, () =&gt; HelloWorld);</span><br></pre></td></tr></table></figure>\n<p>注册入口组件。</p>\n<ul>\n<li><strong>AppRegistry</strong>：负责注册运行ReactNative应用程序的JavaScript入口</li>\n<li><strong>registerComponent</strong>：注册应用程序的入口组件，告知ReactNative哪一个组件被注册为应用的根容器</li>\n</ul>\n<p>第二个参数使用了ES6的语法，箭头函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回的必须是定义的组件类的名字</span></span><br><span class=\"line\"><span class=\"comment\">// 等价于 function() &#123;return HelloWorld&#125;</span></span><br><span class=\"line\">() =&gt; HelloWorld</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本章介绍了 ReactNative 背景以及优缺点，分析了测试安装工程的工程结构，以及index.ios.js 的代码结构，还有很多未涉及的方面，比如IDE的安装等等，想要了解的可以点下方的参考链接。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"noopener\">React 入门实例教程</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html\" target=\"_blank\" rel=\"noopener\">也许，DOM 不是答案</a></li>\n<li><a href=\"https://facebook.github.io/react-native/docs/getting-started.html\" target=\"_blank\" rel=\"noopener\">ReactNavite官网</a></li>\n<li><a href=\"http://reactnative.cn/docs/0.41/getting-started.html\" target=\"_blank\" rel=\"noopener\">ReactNavite中文网</a></li>\n<li><a href=\"http://blog.csdn.net/hello_hwc/article/details/51612139\" target=\"_blank\" rel=\"noopener\"> React Native开发之IDE（Atom+Nuclide）安装，运行，调试</a></li>\n<li><a href=\"http://www.52learn.wang/archives/1071?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">3分钟带你玩转React Native研发所有调试技巧</a></li>\n<li><a href=\"http://hahack.com/codes/learn-react-native-for-android-01/\" target=\"_blank\" rel=\"noopener\">学习 React Native for Android：环境搭建</a></li>\n<li><a href=\"https://github.com/vczero/react-native-lesson\" target=\"_blank\" rel=\"noopener\">React-Native入门指南</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://github.com/facebook/react\" target=\"_blank\" rel=\"noopener\">React</a> 应该算是目前最火的前端框架，通过它衍生出来的 <a href=\"https://github.com/facebook/react-native\" target=\"_blank\" rel=\"noopener\">ReactNative</a> 几乎颠覆了人们对 Web APP 的认识。其实2013年5月 <strong>React</strong> 就开源了，而 <strong>ReactNative</strong> 也在 2015年开源了，我在业余时间学习了下 <strong>ReactNative</strong> 基本语法, 希望能在未来的工作使用上。</p>\n<h2 id=\"React简介\"><a href=\"#React简介\" class=\"headerlink\" title=\"React简介\"></a>React简介</h2><p>React 起源于 Facebook 公司，初期用于 instagram 网站开发，React 是一个用于构建用户界面的JavaScript库，不是一个MVC框架，提出了一种新的开发模式和理念，它强调的是“用户界面”。</p>\n<h3 id=\"作为UI\"><a href=\"#作为UI\" class=\"headerlink\" title=\"作为UI\"></a>作为UI</h3><p>React 可以作为MVC中的view层进行使用，并且在已有项目中很容易使用React开发新功能。</p>\n<h3 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h3><p>虚拟DOM是React最重要的特性，实现了优化视图的渲染和刷新，以前没有ajax技术时，web页面从服务器整体渲染出html输出到浏览器进行渲染，用户的一个操作也会刷新整个页面。直到ajax的出现，实现页面局部刷新，带来的高效和分离让web开发们惊叹不已，但是又有新的问题出现，赋值的用户交互和展现需要通过大量的DOM操作来完成，这让页面的性能以及开发的效率又出现了新的瓶颈，如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标。</p>\n<p>时至今日，谈到前端性能优化，减少DOM元素，减少reflow和repaint，编码过程中尽可能减少DOM查询等等而页面的任何UI的变化都是通过整体的刷新来完成的，而React之所以快，是因为它不是直接操作DOM，而是引进虚拟的DOM实现来解决这个问题。</p>\n<p>基于React进行开发时所有的DOM构建都是通过虚拟的DOM进行，每当数据发生变化，React都会重新构建一个完整的虚拟DOM，虚拟DOM是内存数据，React通过自己实现的 DOM Diff算法将当前的虚拟DOM树和上一次的DOM进行对比，得到两个DOM结构的差异，然后仅仅将需要变化的部分进行实际的浏览器DOM更新，达到最小化重绘，避免不必要的DOM操作，解决了这两个公认的前端性能瓶颈，实现高效DOM渲染。</p>\n<h3 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h3><p>虚拟的DOM不仅带来简单的UI开发逻辑，同时也带来了组件化开发的思想，所谓组件，即封装起来的具有独立功能的UI部件，React推荐以组件的方式去思考UI构成，将UI上每个功能都相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体UI构建。</p>\n<p>如果说MVC的思想让你做到了视图-数据-控制器分离，那么组件化的思考方向则是带来了UI功能模块之间的分离。<br>对于React而言，开发者从功能的角度出发，将UI分成不同的组件，每个组件都独立封装。在React中，你按照界面模块自然划分的方式来组织和编写你的代码，，对于评论界面而言，整个UI是一个通过小组件构成的大组件，每个组件只关心自己部分的逻辑，彼此独立，React组件应该具有以下特征：可组合，可重用，可维护。</p>\n<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><p>React 实现了单向的数据流，相对于传统的数据绑定，React更加灵活，便捷。</p>\n<h2 id=\"React和ReactNative的关系\"><a href=\"#React和ReactNative的关系\" class=\"headerlink\" title=\"React和ReactNative的关系\"></a>React和ReactNative的关系</h2><p>React用于web应用开发，ReactNative采用React方式进行移动应用开发，既有原生Native的加护体验，又能保留React自由的开发效率，使用灵活的HTML和CSS布局，使用React语法构建组件，然后同时运行在iOS和Android上，“learn once ，write anywhere”。</p>\n<h2 id=\"零、安装\"><a href=\"#零、安装\" class=\"headerlink\" title=\"零、安装\"></a>零、安装</h2><p>安装 ReactNative 环境可以参考<a href=\"http://reactnative.cn/docs/0.41/getting-started.html\" target=\"_blank\" rel=\"noopener\">搭建开发环境</a> 这篇文章，一步步来。</p>\n<p>安装完成后，测试安装初始化了一个 <strong>AwesomeProject</strong> 工程，工程的结构如图：<br><img src=\"/2017/03/05/Learn-ReactNative-1/Snip20170305_2.png\" title=\"RN-Structure\"></p>\n<p>可以直接使用 命令行cd到该目录 或者 Xcode运行起来（由于我是使用Mac环境，所以文章都是以iOS作为实例）。</p>\n<p>从图中可以看出，Android 和 iOS 是分开文件夹的，index.android.js 和index.ios.js 分别对应各自的系统，我们代码的入口就是这两个js文件。</p>\n<h2 id=\"一、index-ios-js\"><a href=\"#一、index-ios-js\" class=\"headerlink\" title=\"一、index.ios.js\"></a>一、index.ios.js</h2><p>打开 <strong>index.ios.js</strong> 文件，可以看到分成四部分存在：</p>\n<h3 id=\"第一部分\"><a href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"></a>第一部分</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  AppRegistry,</span><br><span class=\"line\">  StyleSheet,</span><br><span class=\"line\">  Text,</span><br><span class=\"line\">  View</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</span><br></pre></td></tr></table></figure>\n<p>导入ReactNative包，导入ReactNative组件：</p>\n<ul>\n<li>AppRegistry: JS运行所有ReactNative应用的入口</li>\n<li>StyleSheet: ReactNative中使用的样式表，类似CSS样式表</li>\n<li>各种开发需要使用的组件</li>\n</ul>\n<p>模板中使用的是ES6语法，ES5语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">'react-native'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;</span><br><span class=\"line\">AppRegistry,</span><br><span class=\"line\">StyleSheet,</span><br><span class=\"line\">Text,</span><br><span class=\"line\">View</span><br><span class=\"line\">&#125; = React;</span><br></pre></td></tr></table></figure>\n<p>当我们需要引入别的文件，使用 <code>require</code> 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> BookList = <span class=\"built_in\">require</span>(<span class=\"string\">'./iOS_views/book/book_list'</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二部分\"><a href=\"#第二部分\" class=\"headerlink\" title=\"第二部分\"></a>第二部分</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class=\"line\">          Welcome to 淘宝!</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Text style=&#123;styles.instructions&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          To get started, edit index.ios.js</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.instructions&#125;&gt;</span><br><span class=\"line\">          Press Cmd+R to reload,&#123;<span class=\"string\">'\\n'</span>&#125;</span><br><span class=\"line\">          Cmd+D or shake <span class=\"keyword\">for</span> dev menu</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建ReactNative组件，模板中使用的是ES6的语法，render() {} 是ES6中的函数简写</p>\n<p>ES5语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloWorld = React.createClass(&#123;</span><br><span class=\"line\"> render: <span class=\"function\"><span class=\"keyword\">function</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> ();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三部分\"><a href=\"#第三部分\" class=\"headerlink\" title=\"第三部分\"></a>第三部分</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  welcome: &#123;</span><br><span class=\"line\">    fontSize: <span class=\"number\">20</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    margin: <span class=\"number\">10</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  instructions: &#123;</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    color: <span class=\"string\">'#333333'</span>,</span><br><span class=\"line\">    marginBottom: <span class=\"number\">5</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>StyleSheet.create创建样式实例，在应用中只会被创建一次，不用每次在渲染周期中重新创建</p>\n<h3 id=\"第四部分\"><a href=\"#第四部分\" class=\"headerlink\" title=\"第四部分\"></a>第四部分</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AppRegistry.registerComponent(<span class=\"string\">'HelloWorld'</span>, () =&gt; HelloWorld);</span><br></pre></td></tr></table></figure>\n<p>注册入口组件。</p>\n<ul>\n<li><strong>AppRegistry</strong>：负责注册运行ReactNative应用程序的JavaScript入口</li>\n<li><strong>registerComponent</strong>：注册应用程序的入口组件，告知ReactNative哪一个组件被注册为应用的根容器</li>\n</ul>\n<p>第二个参数使用了ES6的语法，箭头函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回的必须是定义的组件类的名字</span></span><br><span class=\"line\"><span class=\"comment\">// 等价于 function() &#123;return HelloWorld&#125;</span></span><br><span class=\"line\">() =&gt; HelloWorld</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本章介绍了 ReactNative 背景以及优缺点，分析了测试安装工程的工程结构，以及index.ios.js 的代码结构，还有很多未涉及的方面，比如IDE的安装等等，想要了解的可以点下方的参考链接。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"noopener\">React 入门实例教程</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html\" target=\"_blank\" rel=\"noopener\">也许，DOM 不是答案</a></li>\n<li><a href=\"https://facebook.github.io/react-native/docs/getting-started.html\" target=\"_blank\" rel=\"noopener\">ReactNavite官网</a></li>\n<li><a href=\"http://reactnative.cn/docs/0.41/getting-started.html\" target=\"_blank\" rel=\"noopener\">ReactNavite中文网</a></li>\n<li><a href=\"http://blog.csdn.net/hello_hwc/article/details/51612139\" target=\"_blank\" rel=\"noopener\"> React Native开发之IDE（Atom+Nuclide）安装，运行，调试</a></li>\n<li><a href=\"http://www.52learn.wang/archives/1071?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">3分钟带你玩转React Native研发所有调试技巧</a></li>\n<li><a href=\"http://hahack.com/codes/learn-react-native-for-android-01/\" target=\"_blank\" rel=\"noopener\">学习 React Native for Android：环境搭建</a></li>\n<li><a href=\"https://github.com/vczero/react-native-lesson\" target=\"_blank\" rel=\"noopener\">React-Native入门指南</a></li>\n</ul>\n"},{"title":"NSInteger与NSUInteger","date":"2017-02-26T07:33:41.000Z","_content":"\n## 前言\n\n在 iOS 开发中我想最经常使用的基本数据类型非 `NSInteger` 与 `NSUInteger` 莫属，我们经常使用它们来代表有符号与无符号的整数。严格上说，NSInteger 并不能算是“Objective-C 的整数”，**因为 NSInteger 其实是C语言的类型，而不是 Objective-C 对象，用来表示数字的 Objective-C 对象是 `NSNumber` 以及 `NSDecimalNumber`**。\n\n## 定义\n\n在 Objective-C 头文件中看到：\n\n```objc\n#if __LP64__ || (TARGET_OS_EMBEDDED && !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64\ntypedef long NSInteger;\ntypedef unsigned long NSUInteger;\n#else\ntypedef int NSInteger;\ntypedef unsigned int NSUInteger;\n#endif\n```\n在64位系统下，NSInteger 是 long 类型，也就是 64位系统的整数，在32位系统下，是 int。同时，NSUInteger 在64位与32位系统下分别是 unsigned long 与 unsigned int。\n\n总的来说 NSInteger 与 NSUInteger 就是C的整数。\n\n## 使用\n\n我们写代码通常是运行在64位或者32位系统上，比如 iPhone 5和之前机型使用 armv7 ，CPU是32位的系统，iPhone 5s 之后则是在 arm64 上。**因此，当我们使用整数的时候，即使我们也可以直接使用 int 或 long，但我们会尽量使用 NSInteger 与 NSUInteger，让 compiler 帮我们决定使用哪个整数。**\n\n另外，使用浮点数的时候，也尽量使用 CGFloat。CGFloat 一样会在不同环境下，当成32位或者64位的浮点型。\n\n## 参考链接\n* [KKBOX iOS/Mac OS X 基本開發教材](https://www.gitbook.com/book/zonble/kkbox-ios-dev/details)\n\n\n","source":"_posts/NSInteger-NSUInteger.md","raw":"---\ntitle: NSInteger与NSUInteger\ndate: 2017-02-26 15:33:41\ntags: 基础数据类型\ncategory: 拿来主义\n---\n\n## 前言\n\n在 iOS 开发中我想最经常使用的基本数据类型非 `NSInteger` 与 `NSUInteger` 莫属，我们经常使用它们来代表有符号与无符号的整数。严格上说，NSInteger 并不能算是“Objective-C 的整数”，**因为 NSInteger 其实是C语言的类型，而不是 Objective-C 对象，用来表示数字的 Objective-C 对象是 `NSNumber` 以及 `NSDecimalNumber`**。\n\n## 定义\n\n在 Objective-C 头文件中看到：\n\n```objc\n#if __LP64__ || (TARGET_OS_EMBEDDED && !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64\ntypedef long NSInteger;\ntypedef unsigned long NSUInteger;\n#else\ntypedef int NSInteger;\ntypedef unsigned int NSUInteger;\n#endif\n```\n在64位系统下，NSInteger 是 long 类型，也就是 64位系统的整数，在32位系统下，是 int。同时，NSUInteger 在64位与32位系统下分别是 unsigned long 与 unsigned int。\n\n总的来说 NSInteger 与 NSUInteger 就是C的整数。\n\n## 使用\n\n我们写代码通常是运行在64位或者32位系统上，比如 iPhone 5和之前机型使用 armv7 ，CPU是32位的系统，iPhone 5s 之后则是在 arm64 上。**因此，当我们使用整数的时候，即使我们也可以直接使用 int 或 long，但我们会尽量使用 NSInteger 与 NSUInteger，让 compiler 帮我们决定使用哪个整数。**\n\n另外，使用浮点数的时候，也尽量使用 CGFloat。CGFloat 一样会在不同环境下，当成32位或者64位的浮点型。\n\n## 参考链接\n* [KKBOX iOS/Mac OS X 基本開發教材](https://www.gitbook.com/book/zonble/kkbox-ios-dev/details)\n\n\n","slug":"NSInteger-NSUInteger","published":1,"updated":"2017-03-05T07:52:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7ku000l8jpbejaoxhr7","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在 iOS 开发中我想最经常使用的基本数据类型非 <code>NSInteger</code> 与 <code>NSUInteger</code> 莫属，我们经常使用它们来代表有符号与无符号的整数。严格上说，NSInteger 并不能算是“Objective-C 的整数”，<strong>因为 NSInteger 其实是C语言的类型，而不是 Objective-C 对象，用来表示数字的 Objective-C 对象是 <code>NSNumber</code> 以及 <code>NSDecimalNumber</code></strong>。</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>在 Objective-C 头文件中看到：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"built_in\">NSInteger</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"built_in\">NSUInteger</span>;</span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> <span class=\"built_in\">NSInteger</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"built_in\">NSUInteger</span>;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>在64位系统下，NSInteger 是 long 类型，也就是 64位系统的整数，在32位系统下，是 int。同时，NSUInteger 在64位与32位系统下分别是 unsigned long 与 unsigned int。</p>\n<p>总的来说 NSInteger 与 NSUInteger 就是C的整数。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>我们写代码通常是运行在64位或者32位系统上，比如 iPhone 5和之前机型使用 armv7 ，CPU是32位的系统，iPhone 5s 之后则是在 arm64 上。<strong>因此，当我们使用整数的时候，即使我们也可以直接使用 int 或 long，但我们会尽量使用 NSInteger 与 NSUInteger，让 compiler 帮我们决定使用哪个整数。</strong></p>\n<p>另外，使用浮点数的时候，也尽量使用 CGFloat。CGFloat 一样会在不同环境下，当成32位或者64位的浮点型。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://www.gitbook.com/book/zonble/kkbox-ios-dev/details\" target=\"_blank\" rel=\"noopener\">KKBOX iOS/Mac OS X 基本開發教材</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在 iOS 开发中我想最经常使用的基本数据类型非 <code>NSInteger</code> 与 <code>NSUInteger</code> 莫属，我们经常使用它们来代表有符号与无符号的整数。严格上说，NSInteger 并不能算是“Objective-C 的整数”，<strong>因为 NSInteger 其实是C语言的类型，而不是 Objective-C 对象，用来表示数字的 Objective-C 对象是 <code>NSNumber</code> 以及 <code>NSDecimalNumber</code></strong>。</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>在 Objective-C 头文件中看到：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"built_in\">NSInteger</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"built_in\">NSUInteger</span>;</span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> <span class=\"built_in\">NSInteger</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"built_in\">NSUInteger</span>;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>在64位系统下，NSInteger 是 long 类型，也就是 64位系统的整数，在32位系统下，是 int。同时，NSUInteger 在64位与32位系统下分别是 unsigned long 与 unsigned int。</p>\n<p>总的来说 NSInteger 与 NSUInteger 就是C的整数。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>我们写代码通常是运行在64位或者32位系统上，比如 iPhone 5和之前机型使用 armv7 ，CPU是32位的系统，iPhone 5s 之后则是在 arm64 上。<strong>因此，当我们使用整数的时候，即使我们也可以直接使用 int 或 long，但我们会尽量使用 NSInteger 与 NSUInteger，让 compiler 帮我们决定使用哪个整数。</strong></p>\n<p>另外，使用浮点数的时候，也尽量使用 CGFloat。CGFloat 一样会在不同环境下，当成32位或者64位的浮点型。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://www.gitbook.com/book/zonble/kkbox-ios-dev/details\" target=\"_blank\" rel=\"noopener\">KKBOX iOS/Mac OS X 基本開發教材</a></li>\n</ul>\n"},{"title":"NSTimer（二）","date":"2016-11-27T03:42:40.000Z","_content":"\n## 前言\n上一篇博客讨论了 NSTimer 与 它的target 的关系。本篇博客将继续讨论 NSTimer。\n\n## NSTimer并不会准时触发事件\n\n在开发者文档[CFRunLoopTimer](https://developer.apple.com/reference/corefoundation/1666612-cfrunlooptimer)中有说明：\n> A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed. If a timer’s firing time occurs while the run loop is in a mode that is not monitoring the timer or during a long callout, the timer does not fire until the next time the run loop checks the timer. Therefore, the actual time at which the timer fires potentially can be a significant period of time after the scheduled firing time.\n\n翻译过来是：\n\n> NSTimer不是一个实时系统，只有被添加到Runloop，并且到达触发时间才能够被触发。如果在当前Runloop中timer没有被检测到或者Runloop长时间无响应，该timer将不会被触发，直到下一个Runloop周期再次检测。因此，timer的实际触发时间有可能比预定触发时间稍晚。\n\n假设一个 timer 指定3秒后触发某事件，但是当前线程进行很复杂很耗时的运算，timer后等到该运算结束后才会执行，如果延迟超过了一个周期，则会和后面的触发合并，即在一个周期内只会触发一次。即使 timer 延迟的时间超级长，timer后面的触发时间总是倍数于第一次添加timer的间隔。\n\n看下面这个例子：\n\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];\n    [NSTimer scheduledTimerWithTimeInterval:1 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES];\n    \n    [self performSelector:@selector(busyCalculation) withObject:nil afterDelay:3];\n}\n\n// 模拟当前线程正好繁忙的情况\n- (void)busyCalculation {\n    NSLog(@\"start busy!\");\n    NSUInteger caculateCount = 0xFFFFFFFF;\n    CGFloat uselessValue = 0;\n    for (NSUInteger i = 0; i < caculateCount; ++i) {\n        uselessValue = i / 0.3333;\n    }\n    NSLog(@\"finish busy!\");\n}\n```\n\n看看打印结果：\n{% asset_img Snip20161127_2.png print image %}\n\n观察打印结果可以得知，当线程空闲的时候 timer 的触发还是比较准确，当开启大量计算时timer开始停止，等到计算结束后才开始触发消息，这个线程繁忙的过程超过了一个周期，但是timer并没有连着触发两次消息，而只是触发了一次。等线程忙完以后后面的消息触发的时间仍然都是整数倍与开始我们指定的时间，这也从侧面证明，timer并不会因为触发延迟而导致后面的触发时间发生延迟。\n\n### 小结\nNSTimer 并是不实时的机制，会发生延迟，延迟的程度和当前线程的 Runloop 有关。\n\n## NSTimer要添加到RunLoop中才会有作用\n\n也许有人问：前面那没多例子，没有一个添加到 Runloop 的，不照样能够定时触发吗？\n我们没有手动添加，不代表系统 API 没有帮我们添加。\n\n你可以尝试把 NSTimer 创建的 API 改为：\n\n```objc\n    [NSTimer timerWithTimeInterval:1 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES];\n```\n你会发现 timer 并没有触发方法。\n\n👆的代码改为：\n\n```objc\n_timer = [NSTimer timerWithTimeInterval:1 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES];\n[[NSRunLoop mainRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];\n```\n\n会发现 timer 又可以正常的触发了。\n\n总的来说这个和 NSTimer 初始化方式有关：\n\n- **timerWithTimeInterval**  创建出来的 timer 如果手动调用 addTimer: forMode 方法加入主循环池中，将不会循环执行。\n- **scheduledTimerWithTimeInterval**  创建的 timer 会自动将 timer 添加到当前的运行循环，运行循环的模式为默认模式。\n- **init** 创建的 timer 需要手动加入循环池，它会在设定的启动时间启动。\n\n## NSTimer 添加到 Runloop 中但迟迟不触发\n\n原因主要是：`确认 Runloop 是否正常运行。`\n\n每个线程都有它自己的 Runloop ，iOS 的主线程也有自己的 Runloop，前面创建的 timer 都是添加到主线程的 Runloop，所以都能正常的触发，但是如果是添加到自己的新建的线程，它的 Runloop 是不会自己运行起来的，我们需要手动把 Runloop 启动。\n\n举个例子：\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    _thread = [[NSThread alloc]initWithTarget:self selector:@selector(testTimerRunloop) object:nil];\n    //开启线程\n    [_thread start];\n}\n\n- (void)testTimerRunloop {\n    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];\n    NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES];\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n    \n    // 打开下面一行输出runloop的内容就可以看出，timer却是已经被添加进去\n//    NSLog(@\"the thread's runloop: %@\", [NSRunLoop currentRunLoop]);\n    \n    // 打开下面一行, 该线程的runloop就会运行起来，timer才会起作用\n//    [[NSRunLoop currentRunLoop] run];\n}\n```\n\n👆创建了一个子线程，并且启动了线程，然后在新建的线程中创建 timer 并添加到当前 Runloop，但打印结果：\n\n{% asset_img Snip20161127_3.png print image %}\n\ntimer 直到销毁了都没触发，如果把注释打开，timer 就能正常触发了。\n\n## 总结\n\nNSTimer 的触发时机与当前线程有关（与线程 Runloop 有关）。\n\n\n## 参考链接\n\n* [NSTimer](http://justsee.iteye.com/blog/1774722)\n* [iOS 中的 NSTimer](http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/)\n\n\n\n\n\n","source":"_posts/NSTimer-2.md","raw":"---\ntitle: NSTimer（二）\ndate: 2016-11-27 11:42:40\ntags: NSTimer\ncategory: 能工巧匠\n---\n\n## 前言\n上一篇博客讨论了 NSTimer 与 它的target 的关系。本篇博客将继续讨论 NSTimer。\n\n## NSTimer并不会准时触发事件\n\n在开发者文档[CFRunLoopTimer](https://developer.apple.com/reference/corefoundation/1666612-cfrunlooptimer)中有说明：\n> A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed. If a timer’s firing time occurs while the run loop is in a mode that is not monitoring the timer or during a long callout, the timer does not fire until the next time the run loop checks the timer. Therefore, the actual time at which the timer fires potentially can be a significant period of time after the scheduled firing time.\n\n翻译过来是：\n\n> NSTimer不是一个实时系统，只有被添加到Runloop，并且到达触发时间才能够被触发。如果在当前Runloop中timer没有被检测到或者Runloop长时间无响应，该timer将不会被触发，直到下一个Runloop周期再次检测。因此，timer的实际触发时间有可能比预定触发时间稍晚。\n\n假设一个 timer 指定3秒后触发某事件，但是当前线程进行很复杂很耗时的运算，timer后等到该运算结束后才会执行，如果延迟超过了一个周期，则会和后面的触发合并，即在一个周期内只会触发一次。即使 timer 延迟的时间超级长，timer后面的触发时间总是倍数于第一次添加timer的间隔。\n\n看下面这个例子：\n\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];\n    [NSTimer scheduledTimerWithTimeInterval:1 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES];\n    \n    [self performSelector:@selector(busyCalculation) withObject:nil afterDelay:3];\n}\n\n// 模拟当前线程正好繁忙的情况\n- (void)busyCalculation {\n    NSLog(@\"start busy!\");\n    NSUInteger caculateCount = 0xFFFFFFFF;\n    CGFloat uselessValue = 0;\n    for (NSUInteger i = 0; i < caculateCount; ++i) {\n        uselessValue = i / 0.3333;\n    }\n    NSLog(@\"finish busy!\");\n}\n```\n\n看看打印结果：\n{% asset_img Snip20161127_2.png print image %}\n\n观察打印结果可以得知，当线程空闲的时候 timer 的触发还是比较准确，当开启大量计算时timer开始停止，等到计算结束后才开始触发消息，这个线程繁忙的过程超过了一个周期，但是timer并没有连着触发两次消息，而只是触发了一次。等线程忙完以后后面的消息触发的时间仍然都是整数倍与开始我们指定的时间，这也从侧面证明，timer并不会因为触发延迟而导致后面的触发时间发生延迟。\n\n### 小结\nNSTimer 并是不实时的机制，会发生延迟，延迟的程度和当前线程的 Runloop 有关。\n\n## NSTimer要添加到RunLoop中才会有作用\n\n也许有人问：前面那没多例子，没有一个添加到 Runloop 的，不照样能够定时触发吗？\n我们没有手动添加，不代表系统 API 没有帮我们添加。\n\n你可以尝试把 NSTimer 创建的 API 改为：\n\n```objc\n    [NSTimer timerWithTimeInterval:1 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES];\n```\n你会发现 timer 并没有触发方法。\n\n👆的代码改为：\n\n```objc\n_timer = [NSTimer timerWithTimeInterval:1 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES];\n[[NSRunLoop mainRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];\n```\n\n会发现 timer 又可以正常的触发了。\n\n总的来说这个和 NSTimer 初始化方式有关：\n\n- **timerWithTimeInterval**  创建出来的 timer 如果手动调用 addTimer: forMode 方法加入主循环池中，将不会循环执行。\n- **scheduledTimerWithTimeInterval**  创建的 timer 会自动将 timer 添加到当前的运行循环，运行循环的模式为默认模式。\n- **init** 创建的 timer 需要手动加入循环池，它会在设定的启动时间启动。\n\n## NSTimer 添加到 Runloop 中但迟迟不触发\n\n原因主要是：`确认 Runloop 是否正常运行。`\n\n每个线程都有它自己的 Runloop ，iOS 的主线程也有自己的 Runloop，前面创建的 timer 都是添加到主线程的 Runloop，所以都能正常的触发，但是如果是添加到自己的新建的线程，它的 Runloop 是不会自己运行起来的，我们需要手动把 Runloop 启动。\n\n举个例子：\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    _thread = [[NSThread alloc]initWithTarget:self selector:@selector(testTimerRunloop) object:nil];\n    //开启线程\n    [_thread start];\n}\n\n- (void)testTimerRunloop {\n    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];\n    NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES];\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n    \n    // 打开下面一行输出runloop的内容就可以看出，timer却是已经被添加进去\n//    NSLog(@\"the thread's runloop: %@\", [NSRunLoop currentRunLoop]);\n    \n    // 打开下面一行, 该线程的runloop就会运行起来，timer才会起作用\n//    [[NSRunLoop currentRunLoop] run];\n}\n```\n\n👆创建了一个子线程，并且启动了线程，然后在新建的线程中创建 timer 并添加到当前 Runloop，但打印结果：\n\n{% asset_img Snip20161127_3.png print image %}\n\ntimer 直到销毁了都没触发，如果把注释打开，timer 就能正常触发了。\n\n## 总结\n\nNSTimer 的触发时机与当前线程有关（与线程 Runloop 有关）。\n\n\n## 参考链接\n\n* [NSTimer](http://justsee.iteye.com/blog/1774722)\n* [iOS 中的 NSTimer](http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/)\n\n\n\n\n\n","slug":"NSTimer-2","published":1,"updated":"2016-11-27T06:55:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7kx000o8jpbefnpmfl0","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇博客讨论了 NSTimer 与 它的target 的关系。本篇博客将继续讨论 NSTimer。</p>\n<h2 id=\"NSTimer并不会准时触发事件\"><a href=\"#NSTimer并不会准时触发事件\" class=\"headerlink\" title=\"NSTimer并不会准时触发事件\"></a>NSTimer并不会准时触发事件</h2><p>在开发者文档<a href=\"https://developer.apple.com/reference/corefoundation/1666612-cfrunlooptimer\" target=\"_blank\" rel=\"noopener\">CFRunLoopTimer</a>中有说明：</p>\n<blockquote>\n<p>A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed. If a timer’s firing time occurs while the run loop is in a mode that is not monitoring the timer or during a long callout, the timer does not fire until the next time the run loop checks the timer. Therefore, the actual time at which the timer fires potentially can be a significant period of time after the scheduled firing time.</p>\n</blockquote>\n<p>翻译过来是：</p>\n<blockquote>\n<p>NSTimer不是一个实时系统，只有被添加到Runloop，并且到达触发时间才能够被触发。如果在当前Runloop中timer没有被检测到或者Runloop长时间无响应，该timer将不会被触发，直到下一个Runloop周期再次检测。因此，timer的实际触发时间有可能比预定触发时间稍晚。</p>\n</blockquote>\n<p>假设一个 timer 指定3秒后触发某事件，但是当前线程进行很复杂很耗时的运算，timer后等到该运算结束后才会执行，如果延迟超过了一个周期，则会和后面的触发合并，即在一个周期内只会触发一次。即使 timer 延迟的时间超级长，timer后面的触发时间总是倍数于第一次添加timer的间隔。</p>\n<p>看下面这个例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];</span><br><span class=\"line\">    [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:testObject2 selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(busyCalculation) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟当前线程正好繁忙的情况</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)busyCalculation &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"start busy!\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> caculateCount = <span class=\"number\">0xFFFFFFFF</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> uselessValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSUInteger</span> i = <span class=\"number\">0</span>; i &lt; caculateCount; ++i) &#123;</span><br><span class=\"line\">        uselessValue = i / <span class=\"number\">0.3333</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"finish busy!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看看打印结果：<br><img src=\"/2016/11/27/NSTimer-2/Snip20161127_2.png\" title=\"print image\"></p>\n<p>观察打印结果可以得知，当线程空闲的时候 timer 的触发还是比较准确，当开启大量计算时timer开始停止，等到计算结束后才开始触发消息，这个线程繁忙的过程超过了一个周期，但是timer并没有连着触发两次消息，而只是触发了一次。等线程忙完以后后面的消息触发的时间仍然都是整数倍与开始我们指定的时间，这也从侧面证明，timer并不会因为触发延迟而导致后面的触发时间发生延迟。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>NSTimer 并是不实时的机制，会发生延迟，延迟的程度和当前线程的 Runloop 有关。</p>\n<h2 id=\"NSTimer要添加到RunLoop中才会有作用\"><a href=\"#NSTimer要添加到RunLoop中才会有作用\" class=\"headerlink\" title=\"NSTimer要添加到RunLoop中才会有作用\"></a>NSTimer要添加到RunLoop中才会有作用</h2><p>也许有人问：前面那没多例子，没有一个添加到 Runloop 的，不照样能够定时触发吗？<br>我们没有手动添加，不代表系统 API 没有帮我们添加。</p>\n<p>你可以尝试把 NSTimer 创建的 API 改为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> target:testObject2 selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p>你会发现 timer 并没有触发方法。</p>\n<p>👆的代码改为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> target:testObject2 selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] addTimer:_timer forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br></pre></td></tr></table></figure>\n<p>会发现 timer 又可以正常的触发了。</p>\n<p>总的来说这个和 NSTimer 初始化方式有关：</p>\n<ul>\n<li><strong>timerWithTimeInterval</strong>  创建出来的 timer 如果手动调用 addTimer: forMode 方法加入主循环池中，将不会循环执行。</li>\n<li><strong>scheduledTimerWithTimeInterval</strong>  创建的 timer 会自动将 timer 添加到当前的运行循环，运行循环的模式为默认模式。</li>\n<li><strong>init</strong> 创建的 timer 需要手动加入循环池，它会在设定的启动时间启动。</li>\n</ul>\n<h2 id=\"NSTimer-添加到-Runloop-中但迟迟不触发\"><a href=\"#NSTimer-添加到-Runloop-中但迟迟不触发\" class=\"headerlink\" title=\"NSTimer 添加到 Runloop 中但迟迟不触发\"></a>NSTimer 添加到 Runloop 中但迟迟不触发</h2><p>原因主要是：<code>确认 Runloop 是否正常运行。</code></p>\n<p>每个线程都有它自己的 Runloop ，iOS 的主线程也有自己的 Runloop，前面创建的 timer 都是添加到主线程的 Runloop，所以都能正常的触发，但是如果是添加到自己的新建的线程，它的 Runloop 是不会自己运行起来的，我们需要手动把 Runloop 启动。</p>\n<p>举个例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    _thread = [[<span class=\"built_in\">NSThread</span> alloc]initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(testTimerRunloop) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"comment\">//开启线程</span></span><br><span class=\"line\">    [_thread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)testTimerRunloop &#123;</span><br><span class=\"line\">    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> target:testObject2 selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打开下面一行输出runloop的内容就可以看出，timer却是已经被添加进去</span></span><br><span class=\"line\"><span class=\"comment\">//    NSLog(@\"the thread's runloop: %@\", [NSRunLoop currentRunLoop]);</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打开下面一行, 该线程的runloop就会运行起来，timer才会起作用</span></span><br><span class=\"line\"><span class=\"comment\">//    [[NSRunLoop currentRunLoop] run];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆创建了一个子线程，并且启动了线程，然后在新建的线程中创建 timer 并添加到当前 Runloop，但打印结果：</p>\n<img src=\"/2016/11/27/NSTimer-2/Snip20161127_3.png\" title=\"print image\">\n<p>timer 直到销毁了都没触发，如果把注释打开，timer 就能正常触发了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>NSTimer 的触发时机与当前线程有关（与线程 Runloop 有关）。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://justsee.iteye.com/blog/1774722\" target=\"_blank\" rel=\"noopener\">NSTimer</a></li>\n<li><a href=\"http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/\" target=\"_blank\" rel=\"noopener\">iOS 中的 NSTimer</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇博客讨论了 NSTimer 与 它的target 的关系。本篇博客将继续讨论 NSTimer。</p>\n<h2 id=\"NSTimer并不会准时触发事件\"><a href=\"#NSTimer并不会准时触发事件\" class=\"headerlink\" title=\"NSTimer并不会准时触发事件\"></a>NSTimer并不会准时触发事件</h2><p>在开发者文档<a href=\"https://developer.apple.com/reference/corefoundation/1666612-cfrunlooptimer\" target=\"_blank\" rel=\"noopener\">CFRunLoopTimer</a>中有说明：</p>\n<blockquote>\n<p>A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed. If a timer’s firing time occurs while the run loop is in a mode that is not monitoring the timer or during a long callout, the timer does not fire until the next time the run loop checks the timer. Therefore, the actual time at which the timer fires potentially can be a significant period of time after the scheduled firing time.</p>\n</blockquote>\n<p>翻译过来是：</p>\n<blockquote>\n<p>NSTimer不是一个实时系统，只有被添加到Runloop，并且到达触发时间才能够被触发。如果在当前Runloop中timer没有被检测到或者Runloop长时间无响应，该timer将不会被触发，直到下一个Runloop周期再次检测。因此，timer的实际触发时间有可能比预定触发时间稍晚。</p>\n</blockquote>\n<p>假设一个 timer 指定3秒后触发某事件，但是当前线程进行很复杂很耗时的运算，timer后等到该运算结束后才会执行，如果延迟超过了一个周期，则会和后面的触发合并，即在一个周期内只会触发一次。即使 timer 延迟的时间超级长，timer后面的触发时间总是倍数于第一次添加timer的间隔。</p>\n<p>看下面这个例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];</span><br><span class=\"line\">    [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:testObject2 selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(busyCalculation) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟当前线程正好繁忙的情况</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)busyCalculation &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"start busy!\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> caculateCount = <span class=\"number\">0xFFFFFFFF</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> uselessValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSUInteger</span> i = <span class=\"number\">0</span>; i &lt; caculateCount; ++i) &#123;</span><br><span class=\"line\">        uselessValue = i / <span class=\"number\">0.3333</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"finish busy!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看看打印结果：<br><img src=\"/2016/11/27/NSTimer-2/Snip20161127_2.png\" title=\"print image\"></p>\n<p>观察打印结果可以得知，当线程空闲的时候 timer 的触发还是比较准确，当开启大量计算时timer开始停止，等到计算结束后才开始触发消息，这个线程繁忙的过程超过了一个周期，但是timer并没有连着触发两次消息，而只是触发了一次。等线程忙完以后后面的消息触发的时间仍然都是整数倍与开始我们指定的时间，这也从侧面证明，timer并不会因为触发延迟而导致后面的触发时间发生延迟。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>NSTimer 并是不实时的机制，会发生延迟，延迟的程度和当前线程的 Runloop 有关。</p>\n<h2 id=\"NSTimer要添加到RunLoop中才会有作用\"><a href=\"#NSTimer要添加到RunLoop中才会有作用\" class=\"headerlink\" title=\"NSTimer要添加到RunLoop中才会有作用\"></a>NSTimer要添加到RunLoop中才会有作用</h2><p>也许有人问：前面那没多例子，没有一个添加到 Runloop 的，不照样能够定时触发吗？<br>我们没有手动添加，不代表系统 API 没有帮我们添加。</p>\n<p>你可以尝试把 NSTimer 创建的 API 改为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> target:testObject2 selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p>你会发现 timer 并没有触发方法。</p>\n<p>👆的代码改为：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> target:testObject2 selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] addTimer:_timer forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br></pre></td></tr></table></figure>\n<p>会发现 timer 又可以正常的触发了。</p>\n<p>总的来说这个和 NSTimer 初始化方式有关：</p>\n<ul>\n<li><strong>timerWithTimeInterval</strong>  创建出来的 timer 如果手动调用 addTimer: forMode 方法加入主循环池中，将不会循环执行。</li>\n<li><strong>scheduledTimerWithTimeInterval</strong>  创建的 timer 会自动将 timer 添加到当前的运行循环，运行循环的模式为默认模式。</li>\n<li><strong>init</strong> 创建的 timer 需要手动加入循环池，它会在设定的启动时间启动。</li>\n</ul>\n<h2 id=\"NSTimer-添加到-Runloop-中但迟迟不触发\"><a href=\"#NSTimer-添加到-Runloop-中但迟迟不触发\" class=\"headerlink\" title=\"NSTimer 添加到 Runloop 中但迟迟不触发\"></a>NSTimer 添加到 Runloop 中但迟迟不触发</h2><p>原因主要是：<code>确认 Runloop 是否正常运行。</code></p>\n<p>每个线程都有它自己的 Runloop ，iOS 的主线程也有自己的 Runloop，前面创建的 timer 都是添加到主线程的 Runloop，所以都能正常的触发，但是如果是添加到自己的新建的线程，它的 Runloop 是不会自己运行起来的，我们需要手动把 Runloop 启动。</p>\n<p>举个例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    _thread = [[<span class=\"built_in\">NSThread</span> alloc]initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(testTimerRunloop) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"comment\">//开启线程</span></span><br><span class=\"line\">    [_thread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)testTimerRunloop &#123;</span><br><span class=\"line\">    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> target:testObject2 selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打开下面一行输出runloop的内容就可以看出，timer却是已经被添加进去</span></span><br><span class=\"line\"><span class=\"comment\">//    NSLog(@\"the thread's runloop: %@\", [NSRunLoop currentRunLoop]);</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打开下面一行, 该线程的runloop就会运行起来，timer才会起作用</span></span><br><span class=\"line\"><span class=\"comment\">//    [[NSRunLoop currentRunLoop] run];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆创建了一个子线程，并且启动了线程，然后在新建的线程中创建 timer 并添加到当前 Runloop，但打印结果：</p>\n<img src=\"/2016/11/27/NSTimer-2/Snip20161127_3.png\" title=\"print image\">\n<p>timer 直到销毁了都没触发，如果把注释打开，timer 就能正常触发了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>NSTimer 的触发时机与当前线程有关（与线程 Runloop 有关）。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://justsee.iteye.com/blog/1774722\" target=\"_blank\" rel=\"noopener\">NSTimer</a></li>\n<li><a href=\"http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/\" target=\"_blank\" rel=\"noopener\">iOS 中的 NSTimer</a></li>\n</ul>\n"},{"title":"Objective-C中几种锁的实现(一)","date":"2016-09-15T01:57:18.000Z","_content":"\n## 前言\n\n本篇博客转载自[Objective-C中不同方式实现锁(一)](http://www.tanhao.me/pieces/616.html/)\n\n任何的语言的高级部分都有会有多线程，使用多线程都会涉及“锁”。那么在Objective-C中到底有多少种锁？有几种锁的实现方法？\n\n我们先构建一个测试类TestObj，假设它是我们的一个共享资源，有两个互斥的方法 **method1** 和 **method2**，代码如下：\n\n```objc\n@implementation TestObj\n\n- (void)method1\n{\n    NSLog(@\"%@\",NSStringFromSelector(_cmd));\n}\n\n- (void)method2\n{\n    NSLog(@\"%@\",NSStringFromSelector(_cmd));\n}\n\n@end\n```\n\n## 使用NSLock实现的锁\n\n```objc\nTestObj *obj = [TestObj new];\nNSLock *objLock = [NSLock new];\n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   [objLock lock];\n   [obj method1];\n   sleep(10);\n   [objLock unlock];\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);//以保证让线程2的代码后执行\n   [objLock lock];\n   [obj method2];\n   [objLock unlock];\n});\n```\n\n运行的打印结果：\n\n```bash\n2016-09-15 09:50:39.718 test[1388:39695] method1\n2016-09-15 09:50:49.722 test[1388:39688] method2\n```\n从打印结果你可以看到线程1锁住后，线程2会一直等待线程1把锁unlock后，才会执行method2方法。\n\n`NSLock`是Cocoa提供给我们最基本的锁对象，这也是我们经常使用的，除了lock和unlock方法外，NSLock还提供了**tryLock**和**lockBeforeDate:**两个方法。\n* `tryLock`方法会尝试加锁，如果锁不可用（已经被锁住），并不会阻塞线程，并返回NO，如果锁可以用，则自动调用lock方法锁住对象，阻塞线程，并返回YES。\n* `lockBeforeDate:`方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。\n\n\n## 使用synchronized关键字构建的锁\n\nObjective-C中还提供了`@synchronized`指令快速实现锁：\n\n```objc\nTestObj *obj = [TestObj new];\n    \n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   @synchronized (obj) {\n       [obj method1];\n       sleep(5);\n   }\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);//以保证让线程2的代码后执行\n   @synchronized (obj) {\n       [obj method2];\n   }\n});\n```\n代码中**@synchronized**指令使用`obj`为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中把`@synchronized (obj)`改为`@synchronized (other)`则线程2就不会被阻塞。\n\n**@synchronized**实现锁的优点就是我们不需要再代码中现实的创建NSLock对象，便可以实现锁的机制，但作为一种预防措施，**@synchronized**块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用NSLock对象。\n\n## 使用C语言的pthread_mutex_t实现的锁\n\n```objc\nTestObj *obj = [TestObj new];\n__block pthread_mutex_t mutex;\npthread_mutex_init(&mutex, NULL);\n    \n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   pthread_mutex_lock(&mutex);\n   [obj method1];\n   sleep(5);\n   pthread_mutex_unlock(&mutex);\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);//以保证让线程2的代码后执行\n   pthread_mutex_lock(&mutex);\n   [obj method2];\n   pthread_mutex_unlock(&mutex);\n});\n```\n\n使用pthread_mutex_t要记得`#import \"pthread.h\"`\n\n## 使用GCD来实现的”锁”\n以上代码构建多线程我们就已经用到了GCD的dispatch_async方法，其实在GCD中也已经提供了一种**信号机制**，使用它我们也可以来构建一把”锁”(从本质意义上讲，信号量与锁是有区别，可以Google[信号量与互斥锁的区别](https://www.google.com/search?q=%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB&oq=%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB&gs_l=serp.3...7725.7875.0.8139.2.2.0.0.0.0.233.233.2-1.1.0....0...1c.1.64.serp..1.0.0.bAEpnXn44rg)):\n\n```objc\nTestObj *obj = [TestObj new];\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(1);\n    \n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n   [obj method1];\n   sleep(5);\n   dispatch_semaphore_signal(semaphore);\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);//以保证让线程2的代码后执行\n   dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n   [obj method2];\n   dispatch_semaphore_signal(semaphore);\n});\n```\n代码的效果和前面的例子是一模一样的。但是信号锁的效率比NSLock高得多，YYKit也是采用这种方式加锁的，之前我也写过一篇[《GCD信号锁》](http://piglikeyoung.com/2016/09/11/GCD-signal-lock/)比较GCD信号锁和NSLock的效率。\n\n\n\n","source":"_posts/Objc-lock-1.md","raw":"---\ntitle: Objective-C中几种锁的实现(一)\ndate: 2016-09-15 09:57:18\ntags: Objective-C 锁\ncategory: 能工巧匠\n---\n\n## 前言\n\n本篇博客转载自[Objective-C中不同方式实现锁(一)](http://www.tanhao.me/pieces/616.html/)\n\n任何的语言的高级部分都有会有多线程，使用多线程都会涉及“锁”。那么在Objective-C中到底有多少种锁？有几种锁的实现方法？\n\n我们先构建一个测试类TestObj，假设它是我们的一个共享资源，有两个互斥的方法 **method1** 和 **method2**，代码如下：\n\n```objc\n@implementation TestObj\n\n- (void)method1\n{\n    NSLog(@\"%@\",NSStringFromSelector(_cmd));\n}\n\n- (void)method2\n{\n    NSLog(@\"%@\",NSStringFromSelector(_cmd));\n}\n\n@end\n```\n\n## 使用NSLock实现的锁\n\n```objc\nTestObj *obj = [TestObj new];\nNSLock *objLock = [NSLock new];\n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   [objLock lock];\n   [obj method1];\n   sleep(10);\n   [objLock unlock];\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);//以保证让线程2的代码后执行\n   [objLock lock];\n   [obj method2];\n   [objLock unlock];\n});\n```\n\n运行的打印结果：\n\n```bash\n2016-09-15 09:50:39.718 test[1388:39695] method1\n2016-09-15 09:50:49.722 test[1388:39688] method2\n```\n从打印结果你可以看到线程1锁住后，线程2会一直等待线程1把锁unlock后，才会执行method2方法。\n\n`NSLock`是Cocoa提供给我们最基本的锁对象，这也是我们经常使用的，除了lock和unlock方法外，NSLock还提供了**tryLock**和**lockBeforeDate:**两个方法。\n* `tryLock`方法会尝试加锁，如果锁不可用（已经被锁住），并不会阻塞线程，并返回NO，如果锁可以用，则自动调用lock方法锁住对象，阻塞线程，并返回YES。\n* `lockBeforeDate:`方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。\n\n\n## 使用synchronized关键字构建的锁\n\nObjective-C中还提供了`@synchronized`指令快速实现锁：\n\n```objc\nTestObj *obj = [TestObj new];\n    \n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   @synchronized (obj) {\n       [obj method1];\n       sleep(5);\n   }\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);//以保证让线程2的代码后执行\n   @synchronized (obj) {\n       [obj method2];\n   }\n});\n```\n代码中**@synchronized**指令使用`obj`为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中把`@synchronized (obj)`改为`@synchronized (other)`则线程2就不会被阻塞。\n\n**@synchronized**实现锁的优点就是我们不需要再代码中现实的创建NSLock对象，便可以实现锁的机制，但作为一种预防措施，**@synchronized**块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用NSLock对象。\n\n## 使用C语言的pthread_mutex_t实现的锁\n\n```objc\nTestObj *obj = [TestObj new];\n__block pthread_mutex_t mutex;\npthread_mutex_init(&mutex, NULL);\n    \n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   pthread_mutex_lock(&mutex);\n   [obj method1];\n   sleep(5);\n   pthread_mutex_unlock(&mutex);\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);//以保证让线程2的代码后执行\n   pthread_mutex_lock(&mutex);\n   [obj method2];\n   pthread_mutex_unlock(&mutex);\n});\n```\n\n使用pthread_mutex_t要记得`#import \"pthread.h\"`\n\n## 使用GCD来实现的”锁”\n以上代码构建多线程我们就已经用到了GCD的dispatch_async方法，其实在GCD中也已经提供了一种**信号机制**，使用它我们也可以来构建一把”锁”(从本质意义上讲，信号量与锁是有区别，可以Google[信号量与互斥锁的区别](https://www.google.com/search?q=%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB&oq=%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB&gs_l=serp.3...7725.7875.0.8139.2.2.0.0.0.0.233.233.2-1.1.0....0...1c.1.64.serp..1.0.0.bAEpnXn44rg)):\n\n```objc\nTestObj *obj = [TestObj new];\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(1);\n    \n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n   [obj method1];\n   sleep(5);\n   dispatch_semaphore_signal(semaphore);\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);//以保证让线程2的代码后执行\n   dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n   [obj method2];\n   dispatch_semaphore_signal(semaphore);\n});\n```\n代码的效果和前面的例子是一模一样的。但是信号锁的效率比NSLock高得多，YYKit也是采用这种方式加锁的，之前我也写过一篇[《GCD信号锁》](http://piglikeyoung.com/2016/09/11/GCD-signal-lock/)比较GCD信号锁和NSLock的效率。\n\n\n\n","slug":"Objc-lock-1","published":1,"updated":"2016-09-15T05:08:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7kz000s8jpbgcgogziy","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇博客转载自<a href=\"http://www.tanhao.me/pieces/616.html/\" target=\"_blank\" rel=\"noopener\">Objective-C中不同方式实现锁(一)</a></p>\n<p>任何的语言的高级部分都有会有多线程，使用多线程都会涉及“锁”。那么在Objective-C中到底有多少种锁？有几种锁的实现方法？</p>\n<p>我们先构建一个测试类TestObj，假设它是我们的一个共享资源，有两个互斥的方法 <strong>method1</strong> 和 <strong>method2</strong>，代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TestObj</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)method1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,<span class=\"built_in\">NSStringFromSelector</span>(_cmd));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)method2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,<span class=\"built_in\">NSStringFromSelector</span>(_cmd));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用NSLock实现的锁\"><a href=\"#使用NSLock实现的锁\" class=\"headerlink\" title=\"使用NSLock实现的锁\"></a>使用NSLock实现的锁</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestObj *obj = [TestObj new];</span><br><span class=\"line\"><span class=\"built_in\">NSLock</span> *objLock = [<span class=\"built_in\">NSLock</span> new];</span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   [objLock lock];</span><br><span class=\"line\">   [obj method1];</span><br><span class=\"line\">   sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">   [objLock unlock];</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   sleep(<span class=\"number\">1</span>);<span class=\"comment\">//以保证让线程2的代码后执行</span></span><br><span class=\"line\">   [objLock lock];</span><br><span class=\"line\">   [obj method2];</span><br><span class=\"line\">   [objLock unlock];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>运行的打印结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-15 09:50:39.718 <span class=\"built_in\">test</span>[1388:39695] method1</span><br><span class=\"line\">2016-09-15 09:50:49.722 <span class=\"built_in\">test</span>[1388:39688] method2</span><br></pre></td></tr></table></figure>\n<p>从打印结果你可以看到线程1锁住后，线程2会一直等待线程1把锁unlock后，才会执行method2方法。</p>\n<p><code>NSLock</code>是Cocoa提供给我们最基本的锁对象，这也是我们经常使用的，除了lock和unlock方法外，NSLock还提供了<strong>tryLock</strong>和<strong>lockBeforeDate:</strong>两个方法。</p>\n<ul>\n<li><code>tryLock</code>方法会尝试加锁，如果锁不可用（已经被锁住），并不会阻塞线程，并返回NO，如果锁可以用，则自动调用lock方法锁住对象，阻塞线程，并返回YES。</li>\n<li><code>lockBeforeDate:</code>方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</li>\n</ul>\n<h2 id=\"使用synchronized关键字构建的锁\"><a href=\"#使用synchronized关键字构建的锁\" class=\"headerlink\" title=\"使用synchronized关键字构建的锁\"></a>使用synchronized关键字构建的锁</h2><p>Objective-C中还提供了<code>@synchronized</code>指令快速实现锁：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestObj *obj = [TestObj new];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   <span class=\"keyword\">@synchronized</span> (obj) &#123;</span><br><span class=\"line\">       [obj method1];</span><br><span class=\"line\">       sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   sleep(<span class=\"number\">1</span>);<span class=\"comment\">//以保证让线程2的代码后执行</span></span><br><span class=\"line\">   <span class=\"keyword\">@synchronized</span> (obj) &#123;</span><br><span class=\"line\">       [obj method2];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>代码中<strong>@synchronized</strong>指令使用<code>obj</code>为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中把<code>@synchronized (obj)</code>改为<code>@synchronized (other)</code>则线程2就不会被阻塞。</p>\n<p><strong>@synchronized</strong>实现锁的优点就是我们不需要再代码中现实的创建NSLock对象，便可以实现锁的机制，但作为一种预防措施，<strong>@synchronized</strong>块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用NSLock对象。</p>\n<h2 id=\"使用C语言的pthread-mutex-t实现的锁\"><a href=\"#使用C语言的pthread-mutex-t实现的锁\" class=\"headerlink\" title=\"使用C语言的pthread_mutex_t实现的锁\"></a>使用C语言的pthread_mutex_t实现的锁</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestObj *obj = [TestObj new];</span><br><span class=\"line\">__block pthread_mutex_t mutex;</span><br><span class=\"line\">pthread_mutex_init(&amp;mutex, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">   [obj method1];</span><br><span class=\"line\">   sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">   pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   sleep(<span class=\"number\">1</span>);<span class=\"comment\">//以保证让线程2的代码后执行</span></span><br><span class=\"line\">   pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">   [obj method2];</span><br><span class=\"line\">   pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用pthread_mutex_t要记得<code>#import &quot;pthread.h&quot;</code></p>\n<h2 id=\"使用GCD来实现的”锁”\"><a href=\"#使用GCD来实现的”锁”\" class=\"headerlink\" title=\"使用GCD来实现的”锁”\"></a>使用GCD来实现的”锁”</h2><p>以上代码构建多线程我们就已经用到了GCD的dispatch_async方法，其实在GCD中也已经提供了一种<strong>信号机制</strong>，使用它我们也可以来构建一把”锁”(从本质意义上讲，信号量与锁是有区别，可以Google<a href=\"https://www.google.com/search?q=%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB&amp;oq=%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB&amp;gs_l=serp.3...7725.7875.0.8139.2.2.0.0.0.0.233.233.2-1.1.0....0...1c.1.64.serp..1.0.0.bAEpnXn44rg\" target=\"_blank\" rel=\"noopener\">信号量与互斥锁的区别</a>):</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestObj *obj = [TestObj new];</span><br><span class=\"line\">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">   [obj method1];</span><br><span class=\"line\">   sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">   dispatch_semaphore_signal(semaphore);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   sleep(<span class=\"number\">1</span>);<span class=\"comment\">//以保证让线程2的代码后执行</span></span><br><span class=\"line\">   dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">   [obj method2];</span><br><span class=\"line\">   dispatch_semaphore_signal(semaphore);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>代码的效果和前面的例子是一模一样的。但是信号锁的效率比NSLock高得多，YYKit也是采用这种方式加锁的，之前我也写过一篇<a href=\"http://piglikeyoung.com/2016/09/11/GCD-signal-lock/\">《GCD信号锁》</a>比较GCD信号锁和NSLock的效率。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇博客转载自<a href=\"http://www.tanhao.me/pieces/616.html/\" target=\"_blank\" rel=\"noopener\">Objective-C中不同方式实现锁(一)</a></p>\n<p>任何的语言的高级部分都有会有多线程，使用多线程都会涉及“锁”。那么在Objective-C中到底有多少种锁？有几种锁的实现方法？</p>\n<p>我们先构建一个测试类TestObj，假设它是我们的一个共享资源，有两个互斥的方法 <strong>method1</strong> 和 <strong>method2</strong>，代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TestObj</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)method1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,<span class=\"built_in\">NSStringFromSelector</span>(_cmd));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)method2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,<span class=\"built_in\">NSStringFromSelector</span>(_cmd));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用NSLock实现的锁\"><a href=\"#使用NSLock实现的锁\" class=\"headerlink\" title=\"使用NSLock实现的锁\"></a>使用NSLock实现的锁</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestObj *obj = [TestObj new];</span><br><span class=\"line\"><span class=\"built_in\">NSLock</span> *objLock = [<span class=\"built_in\">NSLock</span> new];</span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   [objLock lock];</span><br><span class=\"line\">   [obj method1];</span><br><span class=\"line\">   sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">   [objLock unlock];</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   sleep(<span class=\"number\">1</span>);<span class=\"comment\">//以保证让线程2的代码后执行</span></span><br><span class=\"line\">   [objLock lock];</span><br><span class=\"line\">   [obj method2];</span><br><span class=\"line\">   [objLock unlock];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>运行的打印结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-15 09:50:39.718 <span class=\"built_in\">test</span>[1388:39695] method1</span><br><span class=\"line\">2016-09-15 09:50:49.722 <span class=\"built_in\">test</span>[1388:39688] method2</span><br></pre></td></tr></table></figure>\n<p>从打印结果你可以看到线程1锁住后，线程2会一直等待线程1把锁unlock后，才会执行method2方法。</p>\n<p><code>NSLock</code>是Cocoa提供给我们最基本的锁对象，这也是我们经常使用的，除了lock和unlock方法外，NSLock还提供了<strong>tryLock</strong>和<strong>lockBeforeDate:</strong>两个方法。</p>\n<ul>\n<li><code>tryLock</code>方法会尝试加锁，如果锁不可用（已经被锁住），并不会阻塞线程，并返回NO，如果锁可以用，则自动调用lock方法锁住对象，阻塞线程，并返回YES。</li>\n<li><code>lockBeforeDate:</code>方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</li>\n</ul>\n<h2 id=\"使用synchronized关键字构建的锁\"><a href=\"#使用synchronized关键字构建的锁\" class=\"headerlink\" title=\"使用synchronized关键字构建的锁\"></a>使用synchronized关键字构建的锁</h2><p>Objective-C中还提供了<code>@synchronized</code>指令快速实现锁：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestObj *obj = [TestObj new];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   <span class=\"keyword\">@synchronized</span> (obj) &#123;</span><br><span class=\"line\">       [obj method1];</span><br><span class=\"line\">       sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   sleep(<span class=\"number\">1</span>);<span class=\"comment\">//以保证让线程2的代码后执行</span></span><br><span class=\"line\">   <span class=\"keyword\">@synchronized</span> (obj) &#123;</span><br><span class=\"line\">       [obj method2];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>代码中<strong>@synchronized</strong>指令使用<code>obj</code>为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中把<code>@synchronized (obj)</code>改为<code>@synchronized (other)</code>则线程2就不会被阻塞。</p>\n<p><strong>@synchronized</strong>实现锁的优点就是我们不需要再代码中现实的创建NSLock对象，便可以实现锁的机制，但作为一种预防措施，<strong>@synchronized</strong>块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用NSLock对象。</p>\n<h2 id=\"使用C语言的pthread-mutex-t实现的锁\"><a href=\"#使用C语言的pthread-mutex-t实现的锁\" class=\"headerlink\" title=\"使用C语言的pthread_mutex_t实现的锁\"></a>使用C语言的pthread_mutex_t实现的锁</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestObj *obj = [TestObj new];</span><br><span class=\"line\">__block pthread_mutex_t mutex;</span><br><span class=\"line\">pthread_mutex_init(&amp;mutex, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">   [obj method1];</span><br><span class=\"line\">   sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">   pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   sleep(<span class=\"number\">1</span>);<span class=\"comment\">//以保证让线程2的代码后执行</span></span><br><span class=\"line\">   pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">   [obj method2];</span><br><span class=\"line\">   pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用pthread_mutex_t要记得<code>#import &quot;pthread.h&quot;</code></p>\n<h2 id=\"使用GCD来实现的”锁”\"><a href=\"#使用GCD来实现的”锁”\" class=\"headerlink\" title=\"使用GCD来实现的”锁”\"></a>使用GCD来实现的”锁”</h2><p>以上代码构建多线程我们就已经用到了GCD的dispatch_async方法，其实在GCD中也已经提供了一种<strong>信号机制</strong>，使用它我们也可以来构建一把”锁”(从本质意义上讲，信号量与锁是有区别，可以Google<a href=\"https://www.google.com/search?q=%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB&amp;oq=%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB&amp;gs_l=serp.3...7725.7875.0.8139.2.2.0.0.0.0.233.233.2-1.1.0....0...1c.1.64.serp..1.0.0.bAEpnXn44rg\" target=\"_blank\" rel=\"noopener\">信号量与互斥锁的区别</a>):</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestObj *obj = [TestObj new];</span><br><span class=\"line\">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">   [obj method1];</span><br><span class=\"line\">   sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">   dispatch_semaphore_signal(semaphore);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   sleep(<span class=\"number\">1</span>);<span class=\"comment\">//以保证让线程2的代码后执行</span></span><br><span class=\"line\">   dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">   [obj method2];</span><br><span class=\"line\">   dispatch_semaphore_signal(semaphore);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>代码的效果和前面的例子是一模一样的。但是信号锁的效率比NSLock高得多，YYKit也是采用这种方式加锁的，之前我也写过一篇<a href=\"http://piglikeyoung.com/2016/09/11/GCD-signal-lock/\">《GCD信号锁》</a>比较GCD信号锁和NSLock的效率。</p>\n"},{"title":"Objective-C中几种锁的实现(二)","date":"2016-09-15T03:35:21.000Z","_content":"\n## 前言\n\n本篇博客转载自[Objective-C中不同方式实现锁(二)](http://www.tanhao.me/pieces/643.html/)\n\n在上一篇转载中介绍Objective-C锁的几种实现，也用代码实际的演示了如何通过构建一个互斥锁来实现多线程的资源共享及线程安全，今天我们继续讨论锁的一些高级用法。\n\n## NSRecursiveLock递归锁\n平时我们在代码中使用锁的时候，最容易犯的一个错误就是造成死锁，而容易造成死锁的一种情形就是在递归或循环中，如下代码:\n\n```objc\n//主线程中\nNSLock *theLock = [NSLock new];\nTestObj *obj = [TestObj new];\n    \n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   static void(^TestMethod)(int);\n   TestMethod = ^(int value) {\n       [theLock lock];\n       if (value > 0) {\n           [obj method1];\n           sleep(5);\n           TestMethod(value - 1);\n       }\n       [theLock unlock];\n   };\n   TestMethod(5);\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);//以保证让线程2的代码后执行\n   [theLock lock];\n   [obj method2];\n   [theLock unlock];\n});\n```\n上述代码中，就是一种典型的死锁，因为在线程1的递归block中，锁会被多次lock，所以自己也被阻塞，由于以上的代码非常的简短，所以很容易能识别死锁，但在较为复杂的代码中，就不那么容易发现了，那么如何在递归或循环中正确的使用锁呢？\n\nObjective-C中提供了`NSRecursiveLock`类来解决这个问题，将**NSLock**换成**NSRecursiveLock**就可以了。**NSRecursiveLock**类定义的锁可以在同一线程多次lock，并且不会造成死锁。这个递归锁会跟踪它被lock多少次。每次成功的lock都必须对称调用unlock。只有所有的锁住和解锁都平衡的时候，锁才真正被释放给其他线程获得。\n\n\n## NSConditionLock条件锁\n当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：\n\n```objc\n//主线程中\nNSConditionLock *theLock = [NSConditionLock new];\n    \n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   for (NSInteger i = 0; i<=3; i++) {\n       [theLock lock];\n       NSLog(@\"thread1:%zd\",i);\n       sleep(2);\n       [theLock unlockWithCondition:i];\n   }\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   [theLock lockWhenCondition:3];\n   NSLog(@\"thread2\");\n   [theLock unlock];\n});\n```\n\n在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在**unlockWithCondition:**使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界值（如果只是使用**unlock**，线程2会因为没有等待到开启线程的条件而一直阻塞），而线程2则需要一把被标识为3的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，**NSConditionLock**也跟其它的锁一样，是需要lock与unlock对应的，只是`lock`，`lockWhenCondition:`与`unlock`，`unlockWithCondition:`是可以随意组合的，当然这是与你的需求相关的。\n\n## NSDistributedLock分布式锁（用于Mac的多进程开发）\n以上所有的锁都是在解决多线程之间的冲突，但是如果遇上多个进程或者多个程序之间需要构建互斥的情景该怎么办呢？这个时候我们就需要使用到`NSDistributedLock`了，从它的类名就知道这是一个分布式的Lock，**NSDistributedLock的实现是通过文件系统的，所以使用它才可以有效的实现不同进程之间的互斥**，但NSDistributedLock并非继承于NSLock，它没有lock方法，它只实现了**tryLock**，**unlock**，**breakLock**，所以如果需要lock的话，你就必须自己实现一个tryLock的轮询，下面通过代码简单的演示一下吧：\n\n程序A：\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   lock = [[NSDistributedLock alloc] initWithPath:@\"/Users/mac/Desktop/earning__\"];\n   [lock breakLock];\n   [lock tryLock];\n   sleep(10);\n   [lock unlock];\n   NSLog(@\"appA: OK\");\n});\n```\n\n程序B：\n\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   lock = [[NSDistributedLock alloc] initWithPath:@\"/Users/mac/Desktop/earning__\"];\n\n   while (![lock tryLock]) {\n       NSLog(@\"appB: waiting\");\n       sleep(1);\n   }\n   [lock unlock];\n   NSLog(@\"appB: OK\");\n});\n```\n\n先运行程序A，然后立即运行程序B，根据打印你可以清楚的发现，当程序A刚运行的时候，程序B一直处于等待中，当大概10秒过后，程序B便打印出了appB:OK的输出，以上便实现了两个不同程序之间的互斥。**/Users/mac/Desktop/earning__**是一个文件或文件夹的地址，如果该文件或文件夹不存在，那么在tryLock返回YES时，会自动创建该文件/文件夹。在结束的时候该文件/文件夹会被清除，所以在选择的该路径的时候，应该选择一个不存在的路径，以防止误删了文件。\n\n\n","source":"_posts/Objc-lock-2.md","raw":"---\ntitle: Objective-C中几种锁的实现(二)\ndate: 2016-09-15 11:35:21\ntags: Objective-C 锁\ncategory: 能工巧匠\n---\n\n## 前言\n\n本篇博客转载自[Objective-C中不同方式实现锁(二)](http://www.tanhao.me/pieces/643.html/)\n\n在上一篇转载中介绍Objective-C锁的几种实现，也用代码实际的演示了如何通过构建一个互斥锁来实现多线程的资源共享及线程安全，今天我们继续讨论锁的一些高级用法。\n\n## NSRecursiveLock递归锁\n平时我们在代码中使用锁的时候，最容易犯的一个错误就是造成死锁，而容易造成死锁的一种情形就是在递归或循环中，如下代码:\n\n```objc\n//主线程中\nNSLock *theLock = [NSLock new];\nTestObj *obj = [TestObj new];\n    \n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   static void(^TestMethod)(int);\n   TestMethod = ^(int value) {\n       [theLock lock];\n       if (value > 0) {\n           [obj method1];\n           sleep(5);\n           TestMethod(value - 1);\n       }\n       [theLock unlock];\n   };\n   TestMethod(5);\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);//以保证让线程2的代码后执行\n   [theLock lock];\n   [obj method2];\n   [theLock unlock];\n});\n```\n上述代码中，就是一种典型的死锁，因为在线程1的递归block中，锁会被多次lock，所以自己也被阻塞，由于以上的代码非常的简短，所以很容易能识别死锁，但在较为复杂的代码中，就不那么容易发现了，那么如何在递归或循环中正确的使用锁呢？\n\nObjective-C中提供了`NSRecursiveLock`类来解决这个问题，将**NSLock**换成**NSRecursiveLock**就可以了。**NSRecursiveLock**类定义的锁可以在同一线程多次lock，并且不会造成死锁。这个递归锁会跟踪它被lock多少次。每次成功的lock都必须对称调用unlock。只有所有的锁住和解锁都平衡的时候，锁才真正被释放给其他线程获得。\n\n\n## NSConditionLock条件锁\n当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：\n\n```objc\n//主线程中\nNSConditionLock *theLock = [NSConditionLock new];\n    \n// 线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   for (NSInteger i = 0; i<=3; i++) {\n       [theLock lock];\n       NSLog(@\"thread1:%zd\",i);\n       sleep(2);\n       [theLock unlockWithCondition:i];\n   }\n});\n    \n// 线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   [theLock lockWhenCondition:3];\n   NSLog(@\"thread2\");\n   [theLock unlock];\n});\n```\n\n在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在**unlockWithCondition:**使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界值（如果只是使用**unlock**，线程2会因为没有等待到开启线程的条件而一直阻塞），而线程2则需要一把被标识为3的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，**NSConditionLock**也跟其它的锁一样，是需要lock与unlock对应的，只是`lock`，`lockWhenCondition:`与`unlock`，`unlockWithCondition:`是可以随意组合的，当然这是与你的需求相关的。\n\n## NSDistributedLock分布式锁（用于Mac的多进程开发）\n以上所有的锁都是在解决多线程之间的冲突，但是如果遇上多个进程或者多个程序之间需要构建互斥的情景该怎么办呢？这个时候我们就需要使用到`NSDistributedLock`了，从它的类名就知道这是一个分布式的Lock，**NSDistributedLock的实现是通过文件系统的，所以使用它才可以有效的实现不同进程之间的互斥**，但NSDistributedLock并非继承于NSLock，它没有lock方法，它只实现了**tryLock**，**unlock**，**breakLock**，所以如果需要lock的话，你就必须自己实现一个tryLock的轮询，下面通过代码简单的演示一下吧：\n\n程序A：\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   lock = [[NSDistributedLock alloc] initWithPath:@\"/Users/mac/Desktop/earning__\"];\n   [lock breakLock];\n   [lock tryLock];\n   sleep(10);\n   [lock unlock];\n   NSLog(@\"appA: OK\");\n});\n```\n\n程序B：\n\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   lock = [[NSDistributedLock alloc] initWithPath:@\"/Users/mac/Desktop/earning__\"];\n\n   while (![lock tryLock]) {\n       NSLog(@\"appB: waiting\");\n       sleep(1);\n   }\n   [lock unlock];\n   NSLog(@\"appB: OK\");\n});\n```\n\n先运行程序A，然后立即运行程序B，根据打印你可以清楚的发现，当程序A刚运行的时候，程序B一直处于等待中，当大概10秒过后，程序B便打印出了appB:OK的输出，以上便实现了两个不同程序之间的互斥。**/Users/mac/Desktop/earning__**是一个文件或文件夹的地址，如果该文件或文件夹不存在，那么在tryLock返回YES时，会自动创建该文件/文件夹。在结束的时候该文件/文件夹会被清除，所以在选择的该路径的时候，应该选择一个不存在的路径，以防止误删了文件。\n\n\n","slug":"Objc-lock-2","published":1,"updated":"2016-09-15T05:07:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7l0000v8jpbrv1ltdhh","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇博客转载自<a href=\"http://www.tanhao.me/pieces/643.html/\" target=\"_blank\" rel=\"noopener\">Objective-C中不同方式实现锁(二)</a></p>\n<p>在上一篇转载中介绍Objective-C锁的几种实现，也用代码实际的演示了如何通过构建一个互斥锁来实现多线程的资源共享及线程安全，今天我们继续讨论锁的一些高级用法。</p>\n<h2 id=\"NSRecursiveLock递归锁\"><a href=\"#NSRecursiveLock递归锁\" class=\"headerlink\" title=\"NSRecursiveLock递归锁\"></a>NSRecursiveLock递归锁</h2><p>平时我们在代码中使用锁的时候，最容易犯的一个错误就是造成死锁，而容易造成死锁的一种情形就是在递归或循环中，如下代码:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//主线程中</span></span><br><span class=\"line\"><span class=\"built_in\">NSLock</span> *theLock = [<span class=\"built_in\">NSLock</span> new];</span><br><span class=\"line\">TestObj *obj = [TestObj new];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">void</span>(^TestMethod)(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">   TestMethod = ^(<span class=\"keyword\">int</span> value) &#123;</span><br><span class=\"line\">       [theLock lock];</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (value &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           [obj method1];</span><br><span class=\"line\">           sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">           TestMethod(value - <span class=\"number\">1</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       [theLock unlock];</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   TestMethod(<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   sleep(<span class=\"number\">1</span>);<span class=\"comment\">//以保证让线程2的代码后执行</span></span><br><span class=\"line\">   [theLock lock];</span><br><span class=\"line\">   [obj method2];</span><br><span class=\"line\">   [theLock unlock];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码中，就是一种典型的死锁，因为在线程1的递归block中，锁会被多次lock，所以自己也被阻塞，由于以上的代码非常的简短，所以很容易能识别死锁，但在较为复杂的代码中，就不那么容易发现了，那么如何在递归或循环中正确的使用锁呢？</p>\n<p>Objective-C中提供了<code>NSRecursiveLock</code>类来解决这个问题，将<strong>NSLock</strong>换成<strong>NSRecursiveLock</strong>就可以了。<strong>NSRecursiveLock</strong>类定义的锁可以在同一线程多次lock，并且不会造成死锁。这个递归锁会跟踪它被lock多少次。每次成功的lock都必须对称调用unlock。只有所有的锁住和解锁都平衡的时候，锁才真正被释放给其他线程获得。</p>\n<h2 id=\"NSConditionLock条件锁\"><a href=\"#NSConditionLock条件锁\" class=\"headerlink\" title=\"NSConditionLock条件锁\"></a>NSConditionLock条件锁</h2><p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//主线程中</span></span><br><span class=\"line\"><span class=\"built_in\">NSConditionLock</span> *theLock = [<span class=\"built_in\">NSConditionLock</span> new];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">       [theLock lock];</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread1:%zd\"</span>,i);</span><br><span class=\"line\">       sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">       [theLock unlockWithCondition:i];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   [theLock lockWhenCondition:<span class=\"number\">3</span>];</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread2\"</span>);</span><br><span class=\"line\">   [theLock unlock];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在<strong>unlockWithCondition:</strong>使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界值（如果只是使用<strong>unlock</strong>，线程2会因为没有等待到开启线程的条件而一直阻塞），而线程2则需要一把被标识为3的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，<strong>NSConditionLock</strong>也跟其它的锁一样，是需要lock与unlock对应的，只是<code>lock</code>，<code>lockWhenCondition:</code>与<code>unlock</code>，<code>unlockWithCondition:</code>是可以随意组合的，当然这是与你的需求相关的。</p>\n<h2 id=\"NSDistributedLock分布式锁（用于Mac的多进程开发）\"><a href=\"#NSDistributedLock分布式锁（用于Mac的多进程开发）\" class=\"headerlink\" title=\"NSDistributedLock分布式锁（用于Mac的多进程开发）\"></a>NSDistributedLock分布式锁（用于Mac的多进程开发）</h2><p>以上所有的锁都是在解决多线程之间的冲突，但是如果遇上多个进程或者多个程序之间需要构建互斥的情景该怎么办呢？这个时候我们就需要使用到<code>NSDistributedLock</code>了，从它的类名就知道这是一个分布式的Lock，<strong>NSDistributedLock的实现是通过文件系统的，所以使用它才可以有效的实现不同进程之间的互斥</strong>，但NSDistributedLock并非继承于NSLock，它没有lock方法，它只实现了<strong>tryLock</strong>，<strong>unlock</strong>，<strong>breakLock</strong>，所以如果需要lock的话，你就必须自己实现一个tryLock的轮询，下面通过代码简单的演示一下吧：</p>\n<p>程序A：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   lock = [[<span class=\"built_in\">NSDistributedLock</span> alloc] initWithPath:<span class=\"string\">@\"/Users/mac/Desktop/earning__\"</span>];</span><br><span class=\"line\">   [lock breakLock];</span><br><span class=\"line\">   [lock tryLock];</span><br><span class=\"line\">   sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">   [lock unlock];</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"appA: OK\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>程序B：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   lock = [[<span class=\"built_in\">NSDistributedLock</span> alloc] initWithPath:<span class=\"string\">@\"/Users/mac/Desktop/earning__\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">while</span> (![lock tryLock]) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"appB: waiting\"</span>);</span><br><span class=\"line\">       sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   [lock unlock];</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"appB: OK\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>先运行程序A，然后立即运行程序B，根据打印你可以清楚的发现，当程序A刚运行的时候，程序B一直处于等待中，当大概10秒过后，程序B便打印出了appB:OK的输出，以上便实现了两个不同程序之间的互斥。<strong>/Users/mac/Desktop/earning__</strong>是一个文件或文件夹的地址，如果该文件或文件夹不存在，那么在tryLock返回YES时，会自动创建该文件/文件夹。在结束的时候该文件/文件夹会被清除，所以在选择的该路径的时候，应该选择一个不存在的路径，以防止误删了文件。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇博客转载自<a href=\"http://www.tanhao.me/pieces/643.html/\" target=\"_blank\" rel=\"noopener\">Objective-C中不同方式实现锁(二)</a></p>\n<p>在上一篇转载中介绍Objective-C锁的几种实现，也用代码实际的演示了如何通过构建一个互斥锁来实现多线程的资源共享及线程安全，今天我们继续讨论锁的一些高级用法。</p>\n<h2 id=\"NSRecursiveLock递归锁\"><a href=\"#NSRecursiveLock递归锁\" class=\"headerlink\" title=\"NSRecursiveLock递归锁\"></a>NSRecursiveLock递归锁</h2><p>平时我们在代码中使用锁的时候，最容易犯的一个错误就是造成死锁，而容易造成死锁的一种情形就是在递归或循环中，如下代码:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//主线程中</span></span><br><span class=\"line\"><span class=\"built_in\">NSLock</span> *theLock = [<span class=\"built_in\">NSLock</span> new];</span><br><span class=\"line\">TestObj *obj = [TestObj new];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">void</span>(^TestMethod)(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">   TestMethod = ^(<span class=\"keyword\">int</span> value) &#123;</span><br><span class=\"line\">       [theLock lock];</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (value &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           [obj method1];</span><br><span class=\"line\">           sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">           TestMethod(value - <span class=\"number\">1</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       [theLock unlock];</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   TestMethod(<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   sleep(<span class=\"number\">1</span>);<span class=\"comment\">//以保证让线程2的代码后执行</span></span><br><span class=\"line\">   [theLock lock];</span><br><span class=\"line\">   [obj method2];</span><br><span class=\"line\">   [theLock unlock];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码中，就是一种典型的死锁，因为在线程1的递归block中，锁会被多次lock，所以自己也被阻塞，由于以上的代码非常的简短，所以很容易能识别死锁，但在较为复杂的代码中，就不那么容易发现了，那么如何在递归或循环中正确的使用锁呢？</p>\n<p>Objective-C中提供了<code>NSRecursiveLock</code>类来解决这个问题，将<strong>NSLock</strong>换成<strong>NSRecursiveLock</strong>就可以了。<strong>NSRecursiveLock</strong>类定义的锁可以在同一线程多次lock，并且不会造成死锁。这个递归锁会跟踪它被lock多少次。每次成功的lock都必须对称调用unlock。只有所有的锁住和解锁都平衡的时候，锁才真正被释放给其他线程获得。</p>\n<h2 id=\"NSConditionLock条件锁\"><a href=\"#NSConditionLock条件锁\" class=\"headerlink\" title=\"NSConditionLock条件锁\"></a>NSConditionLock条件锁</h2><p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//主线程中</span></span><br><span class=\"line\"><span class=\"built_in\">NSConditionLock</span> *theLock = [<span class=\"built_in\">NSConditionLock</span> new];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">       [theLock lock];</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread1:%zd\"</span>,i);</span><br><span class=\"line\">       sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">       [theLock unlockWithCondition:i];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   [theLock lockWhenCondition:<span class=\"number\">3</span>];</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"thread2\"</span>);</span><br><span class=\"line\">   [theLock unlock];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在<strong>unlockWithCondition:</strong>使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界值（如果只是使用<strong>unlock</strong>，线程2会因为没有等待到开启线程的条件而一直阻塞），而线程2则需要一把被标识为3的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，<strong>NSConditionLock</strong>也跟其它的锁一样，是需要lock与unlock对应的，只是<code>lock</code>，<code>lockWhenCondition:</code>与<code>unlock</code>，<code>unlockWithCondition:</code>是可以随意组合的，当然这是与你的需求相关的。</p>\n<h2 id=\"NSDistributedLock分布式锁（用于Mac的多进程开发）\"><a href=\"#NSDistributedLock分布式锁（用于Mac的多进程开发）\" class=\"headerlink\" title=\"NSDistributedLock分布式锁（用于Mac的多进程开发）\"></a>NSDistributedLock分布式锁（用于Mac的多进程开发）</h2><p>以上所有的锁都是在解决多线程之间的冲突，但是如果遇上多个进程或者多个程序之间需要构建互斥的情景该怎么办呢？这个时候我们就需要使用到<code>NSDistributedLock</code>了，从它的类名就知道这是一个分布式的Lock，<strong>NSDistributedLock的实现是通过文件系统的，所以使用它才可以有效的实现不同进程之间的互斥</strong>，但NSDistributedLock并非继承于NSLock，它没有lock方法，它只实现了<strong>tryLock</strong>，<strong>unlock</strong>，<strong>breakLock</strong>，所以如果需要lock的话，你就必须自己实现一个tryLock的轮询，下面通过代码简单的演示一下吧：</p>\n<p>程序A：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   lock = [[<span class=\"built_in\">NSDistributedLock</span> alloc] initWithPath:<span class=\"string\">@\"/Users/mac/Desktop/earning__\"</span>];</span><br><span class=\"line\">   [lock breakLock];</span><br><span class=\"line\">   [lock tryLock];</span><br><span class=\"line\">   sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">   [lock unlock];</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"appA: OK\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>程序B：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   lock = [[<span class=\"built_in\">NSDistributedLock</span> alloc] initWithPath:<span class=\"string\">@\"/Users/mac/Desktop/earning__\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">while</span> (![lock tryLock]) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"appB: waiting\"</span>);</span><br><span class=\"line\">       sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   [lock unlock];</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"appB: OK\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>先运行程序A，然后立即运行程序B，根据打印你可以清楚的发现，当程序A刚运行的时候，程序B一直处于等待中，当大概10秒过后，程序B便打印出了appB:OK的输出，以上便实现了两个不同程序之间的互斥。<strong>/Users/mac/Desktop/earning__</strong>是一个文件或文件夹的地址，如果该文件或文件夹不存在，那么在tryLock返回YES时，会自动创建该文件/文件夹。在结束的时候该文件/文件夹会被清除，所以在选择的该路径的时候，应该选择一个不存在的路径，以防止误删了文件。</p>\n"},{"title":"UIDebuggingInformationOverlay","date":"2017-05-27T12:51:37.000Z","_content":"\n## 前言\n\n今天网上突然爆出了一篇文章[《UIDebuggingInformationOverlay》](http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/)，介绍了 iOS 界面调试工具。\n\n以下是我对文章的理解+实践！\n\n之前我们经常通过 [Reveal](https://revealapp.com/) 或者 [FLEX](https://github.com/Flipboard/FLEX) 来调试界面，现在爆出了苹果的私有方法 `UIDebuggingInformationOverlay` 可以用来打开调试界面：\n\n{% asset_img uidebugginginformationoverlay_0.png uidebugginginformationoverlay_0 %}\n\n> 注意：\n> 添加的方法是私有方法，苹果未对外公开，有可能会被拒绝上架 App Store。\n\n## 怎么使用\n\n在某个 ViewController 中加入以下代码：\n\n```swift\nlet overlayClass = NSClassFromString(\"UIDebuggingInformationOverlay\") as? UIWindow.Type\n_ = overlayClass?.perform(NSSelectorFromString(\"prepareDebuggingOverlay\"))\nlet overlay = overlayClass?.perform(NSSelectorFromString(\"overlay\")).takeUnretainedValue() as? UIWindow\n_ = overlay?.perform(NSSelectorFromString(\"toggleVisibility\"))\n```\n\nAPP启动后，加载代码完毕就会调用调试框。\n\nObjective-C代码：\n\n```objc\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t#ifdef DEBUG\n\t#pragma clang diagnostic push\n\t#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n\t        id debugClass = NSClassFromString(@\"UIDebuggingInformationOverlay\");\n\t        [debugClass performSelector:NSSelectorFromString(@\"prepareDebuggingOverlay\")];\n\t        \n\t        id debugOverlayInstance = [debugClass performSelector:NSSelectorFromString(@\"overlay\")];\n\t        [debugOverlayInstance performSelector:NSSelectorFromString(@\"toggleVisibility\")];\n\t#pragma clang diagnostic pop\n\t#endif\n});\n```\n\n### 更简单的方式\n\n只需要加入：\n\n```swift\nlet overlayClass = NSClassFromString(\"UIDebuggingInformationOverlay\") as? UIWindow.Type\n_ = overlayClass?.perform(NSSelectorFromString(\"prepareDebuggingOverlay\"))\n```\n\n运行程序后，`两根手指`同时点击状态栏可以调起之前那个调试界面。\n\n## 能做什么\n\n### View Hierarchy \n\n查看APP的层级关系\n\n这个选项可以查看界面的层级树，点击后面的感叹号就可以进入详情（点击Cell无反应），进入详情可以看到 View 的 Class、Frame、Opacity、Bounds 等属性\n\n{% asset_img uidebugginginformationoverlay_viewhierarchy.png viewhierarchy %}\n{% asset_img uidebugginginformationoverlay_viewhierarchyinfo.png viewhierarchyinfo %}\n\n### VC Hierarchy \n\n查看当前 Controller 的属性或者它的子类的属性，你还可以看看 Controller 是通过 modal 的方式弹出来或者是 presented 出来。\n\n{% asset_img uidebugginginformationoverlay_VCHierarchy.jpeg VCHierarchy %}\n\n### Ivar Explorer\n\n查看 UIApplication 的内部属性\n\n{% asset_img uidebugginginformationoverlay_ivarexplorer.jpeg ivarexplorer %}\n\n### Measure\n\n点击进入后，发现有三个选项：None、Vertical 和 Horizontal 。\n\n你可以通过选择选项，在屏幕上拖拽，显示某个控件的高度或者宽度。\n\n{% asset_img uidebugginginformationoverlay_measure2.jpeg measure2 %}\n\n### Spec Compare\n\n前后界面对比，从相册里读取图片和当前界面对比。（需要获取相册访问权限NSPhotoLibraryUsageDescription）\n\n1. 点击 Add \n2. 从相册选择一个界面截图 ，点击刚添加的截图\n3. 手指在屏幕（调试窗口外部）上下滑动，可动态改变截图的透明度来对比截图和当前界面的差异 \n4. 双击退出\n\n{% asset_img uidebugginginformationoverlay_speccompareoverlay.png speccompareoverlay %}\n\n{% asset_img uidebugginginformationoverlay_speccomparepicker.png speccomparepicker %}\n\n## IPAPatch\n\n上面说的都只是你有源码可以添加代码的情况下打开调试器，假如是别的APP呢？\n\n这里我推荐一个开源的工具 [IPAPatch](https://github.com/Naituw/IPAPatch) 可以免越狱调试、修改第三方App，它的使用可以参考[链接](http://weibo.com/ttarticle/p/show?id=2309404086977153611942)\n\n通过 **IPAPatch** + **UIDebuggingInformationOverlay** 就可以查看第三方APP的层级结构了，使用 **IPAPatch** 有个要求就是必须是解密过的的 IPA，可以在 [iphonecake](https://www.iphonecake.com) 下载（注意有好多假链接）也可以通过越狱的手机导出 IPA，按照参考链接的教程，就可以查看第三方APP的层级结构了（其实前面有些截图就是查看Snapchat的）。\n\n## 参考链接\n\n* [UIDebuggingInformationOverlay](http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/)\n* [IPAPatch: 免越狱调试、修改第三方App](http://weibo.com/ttarticle/p/show?id=2309404086977153611942)\n\n\n\n\n\n\n\n\n","source":"_posts/UIDebuggingInformationOverlay.md","raw":"---\ntitle: UIDebuggingInformationOverlay\ndate: 2017-05-27 20:51:37\ntags: Debug\ncategory: 能工巧匠\n---\n\n## 前言\n\n今天网上突然爆出了一篇文章[《UIDebuggingInformationOverlay》](http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/)，介绍了 iOS 界面调试工具。\n\n以下是我对文章的理解+实践！\n\n之前我们经常通过 [Reveal](https://revealapp.com/) 或者 [FLEX](https://github.com/Flipboard/FLEX) 来调试界面，现在爆出了苹果的私有方法 `UIDebuggingInformationOverlay` 可以用来打开调试界面：\n\n{% asset_img uidebugginginformationoverlay_0.png uidebugginginformationoverlay_0 %}\n\n> 注意：\n> 添加的方法是私有方法，苹果未对外公开，有可能会被拒绝上架 App Store。\n\n## 怎么使用\n\n在某个 ViewController 中加入以下代码：\n\n```swift\nlet overlayClass = NSClassFromString(\"UIDebuggingInformationOverlay\") as? UIWindow.Type\n_ = overlayClass?.perform(NSSelectorFromString(\"prepareDebuggingOverlay\"))\nlet overlay = overlayClass?.perform(NSSelectorFromString(\"overlay\")).takeUnretainedValue() as? UIWindow\n_ = overlay?.perform(NSSelectorFromString(\"toggleVisibility\"))\n```\n\nAPP启动后，加载代码完毕就会调用调试框。\n\nObjective-C代码：\n\n```objc\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t#ifdef DEBUG\n\t#pragma clang diagnostic push\n\t#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n\t        id debugClass = NSClassFromString(@\"UIDebuggingInformationOverlay\");\n\t        [debugClass performSelector:NSSelectorFromString(@\"prepareDebuggingOverlay\")];\n\t        \n\t        id debugOverlayInstance = [debugClass performSelector:NSSelectorFromString(@\"overlay\")];\n\t        [debugOverlayInstance performSelector:NSSelectorFromString(@\"toggleVisibility\")];\n\t#pragma clang diagnostic pop\n\t#endif\n});\n```\n\n### 更简单的方式\n\n只需要加入：\n\n```swift\nlet overlayClass = NSClassFromString(\"UIDebuggingInformationOverlay\") as? UIWindow.Type\n_ = overlayClass?.perform(NSSelectorFromString(\"prepareDebuggingOverlay\"))\n```\n\n运行程序后，`两根手指`同时点击状态栏可以调起之前那个调试界面。\n\n## 能做什么\n\n### View Hierarchy \n\n查看APP的层级关系\n\n这个选项可以查看界面的层级树，点击后面的感叹号就可以进入详情（点击Cell无反应），进入详情可以看到 View 的 Class、Frame、Opacity、Bounds 等属性\n\n{% asset_img uidebugginginformationoverlay_viewhierarchy.png viewhierarchy %}\n{% asset_img uidebugginginformationoverlay_viewhierarchyinfo.png viewhierarchyinfo %}\n\n### VC Hierarchy \n\n查看当前 Controller 的属性或者它的子类的属性，你还可以看看 Controller 是通过 modal 的方式弹出来或者是 presented 出来。\n\n{% asset_img uidebugginginformationoverlay_VCHierarchy.jpeg VCHierarchy %}\n\n### Ivar Explorer\n\n查看 UIApplication 的内部属性\n\n{% asset_img uidebugginginformationoverlay_ivarexplorer.jpeg ivarexplorer %}\n\n### Measure\n\n点击进入后，发现有三个选项：None、Vertical 和 Horizontal 。\n\n你可以通过选择选项，在屏幕上拖拽，显示某个控件的高度或者宽度。\n\n{% asset_img uidebugginginformationoverlay_measure2.jpeg measure2 %}\n\n### Spec Compare\n\n前后界面对比，从相册里读取图片和当前界面对比。（需要获取相册访问权限NSPhotoLibraryUsageDescription）\n\n1. 点击 Add \n2. 从相册选择一个界面截图 ，点击刚添加的截图\n3. 手指在屏幕（调试窗口外部）上下滑动，可动态改变截图的透明度来对比截图和当前界面的差异 \n4. 双击退出\n\n{% asset_img uidebugginginformationoverlay_speccompareoverlay.png speccompareoverlay %}\n\n{% asset_img uidebugginginformationoverlay_speccomparepicker.png speccomparepicker %}\n\n## IPAPatch\n\n上面说的都只是你有源码可以添加代码的情况下打开调试器，假如是别的APP呢？\n\n这里我推荐一个开源的工具 [IPAPatch](https://github.com/Naituw/IPAPatch) 可以免越狱调试、修改第三方App，它的使用可以参考[链接](http://weibo.com/ttarticle/p/show?id=2309404086977153611942)\n\n通过 **IPAPatch** + **UIDebuggingInformationOverlay** 就可以查看第三方APP的层级结构了，使用 **IPAPatch** 有个要求就是必须是解密过的的 IPA，可以在 [iphonecake](https://www.iphonecake.com) 下载（注意有好多假链接）也可以通过越狱的手机导出 IPA，按照参考链接的教程，就可以查看第三方APP的层级结构了（其实前面有些截图就是查看Snapchat的）。\n\n## 参考链接\n\n* [UIDebuggingInformationOverlay](http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/)\n* [IPAPatch: 免越狱调试、修改第三方App](http://weibo.com/ttarticle/p/show?id=2309404086977153611942)\n\n\n\n\n\n\n\n\n","slug":"UIDebuggingInformationOverlay","published":1,"updated":"2017-05-27T14:36:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7l1000y8jpbi871cc0n","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天网上突然爆出了一篇文章<a href=\"http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/\" target=\"_blank\" rel=\"noopener\">《UIDebuggingInformationOverlay》</a>，介绍了 iOS 界面调试工具。</p>\n<p>以下是我对文章的理解+实践！</p>\n<p>之前我们经常通过 <a href=\"https://revealapp.com/\" target=\"_blank\" rel=\"noopener\">Reveal</a> 或者 <a href=\"https://github.com/Flipboard/FLEX\" target=\"_blank\" rel=\"noopener\">FLEX</a> 来调试界面，现在爆出了苹果的私有方法 <code>UIDebuggingInformationOverlay</code> 可以用来打开调试界面：</p>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_0.png\" title=\"uidebugginginformationoverlay_0\">\n<blockquote>\n<p>注意：<br>添加的方法是私有方法，苹果未对外公开，有可能会被拒绝上架 App Store。</p>\n</blockquote>\n<h2 id=\"怎么使用\"><a href=\"#怎么使用\" class=\"headerlink\" title=\"怎么使用\"></a>怎么使用</h2><p>在某个 ViewController 中加入以下代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> overlayClass = <span class=\"type\">NSClassFromString</span>(<span class=\"string\">\"UIDebuggingInformationOverlay\"</span>) <span class=\"keyword\">as</span>? <span class=\"type\">UIWindow</span>.<span class=\"type\">Type</span></span><br><span class=\"line\"><span class=\"number\">_</span> = overlayClass?.perform(<span class=\"type\">NSSelectorFromString</span>(<span class=\"string\">\"prepareDebuggingOverlay\"</span>))</span><br><span class=\"line\"><span class=\"keyword\">let</span> overlay = overlayClass?.perform(<span class=\"type\">NSSelectorFromString</span>(<span class=\"string\">\"overlay\"</span>)).takeUnretainedValue() <span class=\"keyword\">as</span>? <span class=\"type\">UIWindow</span></span><br><span class=\"line\"><span class=\"number\">_</span> = overlay?.perform(<span class=\"type\">NSSelectorFromString</span>(<span class=\"string\">\"toggleVisibility\"</span>))</span><br></pre></td></tr></table></figure>\n<p>APP启动后，加载代码完毕就会调用调试框。</p>\n<p>Objective-C代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">3</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#ifdef DEBUG</span></span><br><span class=\"line\">\t<span class=\"meta\">#pragma clang diagnostic push</span></span><br><span class=\"line\">\t<span class=\"meta\">#pragma clang diagnostic ignored <span class=\"meta-string\">\"-Warc-performSelector-leaks\"</span></span></span><br><span class=\"line\">\t        <span class=\"keyword\">id</span> debugClass = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"UIDebuggingInformationOverlay\"</span>);</span><br><span class=\"line\">\t        [debugClass performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"prepareDebuggingOverlay\"</span>)];</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t        <span class=\"keyword\">id</span> debugOverlayInstance = [debugClass performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"overlay\"</span>)];</span><br><span class=\"line\">\t        [debugOverlayInstance performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"toggleVisibility\"</span>)];</span><br><span class=\"line\">\t<span class=\"meta\">#pragma clang diagnostic pop</span></span><br><span class=\"line\">\t<span class=\"meta\">#endif</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"更简单的方式\"><a href=\"#更简单的方式\" class=\"headerlink\" title=\"更简单的方式\"></a>更简单的方式</h3><p>只需要加入：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> overlayClass = <span class=\"type\">NSClassFromString</span>(<span class=\"string\">\"UIDebuggingInformationOverlay\"</span>) <span class=\"keyword\">as</span>? <span class=\"type\">UIWindow</span>.<span class=\"type\">Type</span></span><br><span class=\"line\"><span class=\"number\">_</span> = overlayClass?.perform(<span class=\"type\">NSSelectorFromString</span>(<span class=\"string\">\"prepareDebuggingOverlay\"</span>))</span><br></pre></td></tr></table></figure>\n<p>运行程序后，<code>两根手指</code>同时点击状态栏可以调起之前那个调试界面。</p>\n<h2 id=\"能做什么\"><a href=\"#能做什么\" class=\"headerlink\" title=\"能做什么\"></a>能做什么</h2><h3 id=\"View-Hierarchy\"><a href=\"#View-Hierarchy\" class=\"headerlink\" title=\"View Hierarchy\"></a>View Hierarchy</h3><p>查看APP的层级关系</p>\n<p>这个选项可以查看界面的层级树，点击后面的感叹号就可以进入详情（点击Cell无反应），进入详情可以看到 View 的 Class、Frame、Opacity、Bounds 等属性</p>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_viewhierarchy.png\" title=\"viewhierarchy\">\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_viewhierarchyinfo.png\" title=\"viewhierarchyinfo\">\n<h3 id=\"VC-Hierarchy\"><a href=\"#VC-Hierarchy\" class=\"headerlink\" title=\"VC Hierarchy\"></a>VC Hierarchy</h3><p>查看当前 Controller 的属性或者它的子类的属性，你还可以看看 Controller 是通过 modal 的方式弹出来或者是 presented 出来。</p>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_VCHierarchy.jpeg\" title=\"VCHierarchy\">\n<h3 id=\"Ivar-Explorer\"><a href=\"#Ivar-Explorer\" class=\"headerlink\" title=\"Ivar Explorer\"></a>Ivar Explorer</h3><p>查看 UIApplication 的内部属性</p>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_ivarexplorer.jpeg\" title=\"ivarexplorer\">\n<h3 id=\"Measure\"><a href=\"#Measure\" class=\"headerlink\" title=\"Measure\"></a>Measure</h3><p>点击进入后，发现有三个选项：None、Vertical 和 Horizontal 。</p>\n<p>你可以通过选择选项，在屏幕上拖拽，显示某个控件的高度或者宽度。</p>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_measure2.jpeg\" title=\"measure2\">\n<h3 id=\"Spec-Compare\"><a href=\"#Spec-Compare\" class=\"headerlink\" title=\"Spec Compare\"></a>Spec Compare</h3><p>前后界面对比，从相册里读取图片和当前界面对比。（需要获取相册访问权限NSPhotoLibraryUsageDescription）</p>\n<ol>\n<li>点击 Add </li>\n<li>从相册选择一个界面截图 ，点击刚添加的截图</li>\n<li>手指在屏幕（调试窗口外部）上下滑动，可动态改变截图的透明度来对比截图和当前界面的差异 </li>\n<li>双击退出</li>\n</ol>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_speccompareoverlay.png\" title=\"speccompareoverlay\">\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_speccomparepicker.png\" title=\"speccomparepicker\">\n<h2 id=\"IPAPatch\"><a href=\"#IPAPatch\" class=\"headerlink\" title=\"IPAPatch\"></a>IPAPatch</h2><p>上面说的都只是你有源码可以添加代码的情况下打开调试器，假如是别的APP呢？</p>\n<p>这里我推荐一个开源的工具 <a href=\"https://github.com/Naituw/IPAPatch\" target=\"_blank\" rel=\"noopener\">IPAPatch</a> 可以免越狱调试、修改第三方App，它的使用可以参考<a href=\"http://weibo.com/ttarticle/p/show?id=2309404086977153611942\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>通过 <strong>IPAPatch</strong> + <strong>UIDebuggingInformationOverlay</strong> 就可以查看第三方APP的层级结构了，使用 <strong>IPAPatch</strong> 有个要求就是必须是解密过的的 IPA，可以在 <a href=\"https://www.iphonecake.com\" target=\"_blank\" rel=\"noopener\">iphonecake</a> 下载（注意有好多假链接）也可以通过越狱的手机导出 IPA，按照参考链接的教程，就可以查看第三方APP的层级结构了（其实前面有些截图就是查看Snapchat的）。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/\" target=\"_blank\" rel=\"noopener\">UIDebuggingInformationOverlay</a></li>\n<li><a href=\"http://weibo.com/ttarticle/p/show?id=2309404086977153611942\" target=\"_blank\" rel=\"noopener\">IPAPatch: 免越狱调试、修改第三方App</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天网上突然爆出了一篇文章<a href=\"http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/\" target=\"_blank\" rel=\"noopener\">《UIDebuggingInformationOverlay》</a>，介绍了 iOS 界面调试工具。</p>\n<p>以下是我对文章的理解+实践！</p>\n<p>之前我们经常通过 <a href=\"https://revealapp.com/\" target=\"_blank\" rel=\"noopener\">Reveal</a> 或者 <a href=\"https://github.com/Flipboard/FLEX\" target=\"_blank\" rel=\"noopener\">FLEX</a> 来调试界面，现在爆出了苹果的私有方法 <code>UIDebuggingInformationOverlay</code> 可以用来打开调试界面：</p>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_0.png\" title=\"uidebugginginformationoverlay_0\">\n<blockquote>\n<p>注意：<br>添加的方法是私有方法，苹果未对外公开，有可能会被拒绝上架 App Store。</p>\n</blockquote>\n<h2 id=\"怎么使用\"><a href=\"#怎么使用\" class=\"headerlink\" title=\"怎么使用\"></a>怎么使用</h2><p>在某个 ViewController 中加入以下代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> overlayClass = <span class=\"type\">NSClassFromString</span>(<span class=\"string\">\"UIDebuggingInformationOverlay\"</span>) <span class=\"keyword\">as</span>? <span class=\"type\">UIWindow</span>.<span class=\"type\">Type</span></span><br><span class=\"line\"><span class=\"number\">_</span> = overlayClass?.perform(<span class=\"type\">NSSelectorFromString</span>(<span class=\"string\">\"prepareDebuggingOverlay\"</span>))</span><br><span class=\"line\"><span class=\"keyword\">let</span> overlay = overlayClass?.perform(<span class=\"type\">NSSelectorFromString</span>(<span class=\"string\">\"overlay\"</span>)).takeUnretainedValue() <span class=\"keyword\">as</span>? <span class=\"type\">UIWindow</span></span><br><span class=\"line\"><span class=\"number\">_</span> = overlay?.perform(<span class=\"type\">NSSelectorFromString</span>(<span class=\"string\">\"toggleVisibility\"</span>))</span><br></pre></td></tr></table></figure>\n<p>APP启动后，加载代码完毕就会调用调试框。</p>\n<p>Objective-C代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">3</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#ifdef DEBUG</span></span><br><span class=\"line\">\t<span class=\"meta\">#pragma clang diagnostic push</span></span><br><span class=\"line\">\t<span class=\"meta\">#pragma clang diagnostic ignored <span class=\"meta-string\">\"-Warc-performSelector-leaks\"</span></span></span><br><span class=\"line\">\t        <span class=\"keyword\">id</span> debugClass = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"UIDebuggingInformationOverlay\"</span>);</span><br><span class=\"line\">\t        [debugClass performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"prepareDebuggingOverlay\"</span>)];</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t        <span class=\"keyword\">id</span> debugOverlayInstance = [debugClass performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"overlay\"</span>)];</span><br><span class=\"line\">\t        [debugOverlayInstance performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"toggleVisibility\"</span>)];</span><br><span class=\"line\">\t<span class=\"meta\">#pragma clang diagnostic pop</span></span><br><span class=\"line\">\t<span class=\"meta\">#endif</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"更简单的方式\"><a href=\"#更简单的方式\" class=\"headerlink\" title=\"更简单的方式\"></a>更简单的方式</h3><p>只需要加入：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> overlayClass = <span class=\"type\">NSClassFromString</span>(<span class=\"string\">\"UIDebuggingInformationOverlay\"</span>) <span class=\"keyword\">as</span>? <span class=\"type\">UIWindow</span>.<span class=\"type\">Type</span></span><br><span class=\"line\"><span class=\"number\">_</span> = overlayClass?.perform(<span class=\"type\">NSSelectorFromString</span>(<span class=\"string\">\"prepareDebuggingOverlay\"</span>))</span><br></pre></td></tr></table></figure>\n<p>运行程序后，<code>两根手指</code>同时点击状态栏可以调起之前那个调试界面。</p>\n<h2 id=\"能做什么\"><a href=\"#能做什么\" class=\"headerlink\" title=\"能做什么\"></a>能做什么</h2><h3 id=\"View-Hierarchy\"><a href=\"#View-Hierarchy\" class=\"headerlink\" title=\"View Hierarchy\"></a>View Hierarchy</h3><p>查看APP的层级关系</p>\n<p>这个选项可以查看界面的层级树，点击后面的感叹号就可以进入详情（点击Cell无反应），进入详情可以看到 View 的 Class、Frame、Opacity、Bounds 等属性</p>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_viewhierarchy.png\" title=\"viewhierarchy\">\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_viewhierarchyinfo.png\" title=\"viewhierarchyinfo\">\n<h3 id=\"VC-Hierarchy\"><a href=\"#VC-Hierarchy\" class=\"headerlink\" title=\"VC Hierarchy\"></a>VC Hierarchy</h3><p>查看当前 Controller 的属性或者它的子类的属性，你还可以看看 Controller 是通过 modal 的方式弹出来或者是 presented 出来。</p>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_VCHierarchy.jpeg\" title=\"VCHierarchy\">\n<h3 id=\"Ivar-Explorer\"><a href=\"#Ivar-Explorer\" class=\"headerlink\" title=\"Ivar Explorer\"></a>Ivar Explorer</h3><p>查看 UIApplication 的内部属性</p>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_ivarexplorer.jpeg\" title=\"ivarexplorer\">\n<h3 id=\"Measure\"><a href=\"#Measure\" class=\"headerlink\" title=\"Measure\"></a>Measure</h3><p>点击进入后，发现有三个选项：None、Vertical 和 Horizontal 。</p>\n<p>你可以通过选择选项，在屏幕上拖拽，显示某个控件的高度或者宽度。</p>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_measure2.jpeg\" title=\"measure2\">\n<h3 id=\"Spec-Compare\"><a href=\"#Spec-Compare\" class=\"headerlink\" title=\"Spec Compare\"></a>Spec Compare</h3><p>前后界面对比，从相册里读取图片和当前界面对比。（需要获取相册访问权限NSPhotoLibraryUsageDescription）</p>\n<ol>\n<li>点击 Add </li>\n<li>从相册选择一个界面截图 ，点击刚添加的截图</li>\n<li>手指在屏幕（调试窗口外部）上下滑动，可动态改变截图的透明度来对比截图和当前界面的差异 </li>\n<li>双击退出</li>\n</ol>\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_speccompareoverlay.png\" title=\"speccompareoverlay\">\n<img src=\"/2017/05/27/UIDebuggingInformationOverlay/uidebugginginformationoverlay_speccomparepicker.png\" title=\"speccomparepicker\">\n<h2 id=\"IPAPatch\"><a href=\"#IPAPatch\" class=\"headerlink\" title=\"IPAPatch\"></a>IPAPatch</h2><p>上面说的都只是你有源码可以添加代码的情况下打开调试器，假如是别的APP呢？</p>\n<p>这里我推荐一个开源的工具 <a href=\"https://github.com/Naituw/IPAPatch\" target=\"_blank\" rel=\"noopener\">IPAPatch</a> 可以免越狱调试、修改第三方App，它的使用可以参考<a href=\"http://weibo.com/ttarticle/p/show?id=2309404086977153611942\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>通过 <strong>IPAPatch</strong> + <strong>UIDebuggingInformationOverlay</strong> 就可以查看第三方APP的层级结构了，使用 <strong>IPAPatch</strong> 有个要求就是必须是解密过的的 IPA，可以在 <a href=\"https://www.iphonecake.com\" target=\"_blank\" rel=\"noopener\">iphonecake</a> 下载（注意有好多假链接）也可以通过越狱的手机导出 IPA，按照参考链接的教程，就可以查看第三方APP的层级结构了（其实前面有些截图就是查看Snapchat的）。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/\" target=\"_blank\" rel=\"noopener\">UIDebuggingInformationOverlay</a></li>\n<li><a href=\"http://weibo.com/ttarticle/p/show?id=2309404086977153611942\" target=\"_blank\" rel=\"noopener\">IPAPatch: 免越狱调试、修改第三方App</a></li>\n</ul>\n"},{"title":"使用GCD（三）","date":"2016-10-07T08:12:44.000Z","_content":"\n## 前言\nGCD 的使用第三篇。前两篇链接：\n* [使用GCD（一）](http://piglikeyoung.com/2016/09/25/Using-Grand-Central-Dispatch-1/)\n* [使用GCD（二）](http://piglikeyoung.com/2016/10/01/Using-Grand-Central-Dispatch-2/)\n\n## dispatch_suspend / dispatch_resume\n\ndispatch_suspend 函数挂起指定的 Dispatch Queue。\n\n```objc\ndispatch_suspend(queue);\n```\n\ndispatch_resume 函数恢复指定的 Dispatch Queue。\n\n```objc\ndispatch_resume(queue);\n```\n这两个函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但没有执行的处理停止执行。恢复后，这些处理继续执行。\n\n## Dispatch Semaphore\n上一篇文章说到，并发执行更新数据处理时，会产生数据不一致的情况，有时APP会异常崩溃。虽然使用 Serial Dispatch Queue 和 dispatch_barrier_async 函数可避免这类问题，但是有必要进行更细粒度的排它处理。\n\n比如这种情况：\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\nNSMutableArray *array = [NSMutableArray array];\nfor (NSInteger i = 0; i < 100000; i++) {\n   dispatch_async(queue, ^{\n       [array addObject:@(i)];\n   });\n}\n```\n例子中的代码，并发大量的操作可变数组，执行后出现内存错误导致APP异常结束的概率非常高（大量的线程同时操作同一片内存）。这时候 Dispatch Semaphore 就派上用场了。\n\n**Dispatch Semaphore** 是持有计数的信号，该计数是多线程编程中的计数类型信号。所谓信号，类似于过马路时常用的手旗。可以通过时举起手旗，不可通过时方式手旗。在 Dispatch Semaphore 中，使用计数类实现该功能。**计数为0时等待，计数为1或者大于1时，减去1而不等待**。\n\n生成 Dispatch Semaphore：\n\n```objc\ndispatch_semaphore_t semphore = dispatch_semaphore_create(1);\n```\n参数表示计数的初始值。例子中计数值初始化为“1”。\n\n**dispatch_semaphore_wait** 函数等待 Dispatch Semaphore 的计数值达到大于或者等于1 。\n\n```objc\ndispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);\n```\n当计数值大于等于1，或者在待机中计数值大于等于1时，对该计数进行减法并从 dispatch_semaphore_wait 函数返回。第二个参数与 dispatch_group_wait 函数等相同，是 dispatch_time_t 类型值。另外，dispatch_semaphore_wait 函数的返回值也和 dispatch_group_wait 相同，返回值参考[《使用GCD（二）》](http://piglikeyoung.com/2016/10/01/Using-Grand-Central-Dispatch-2/)的内容。\n\ndispatch_semaphore_wait 函数做减法操作，而 **dispatch_semaphore_signal** 函数做加法操作，将 Dispatch Semaphore 的计数值加1 。\n\n把前面的例子使用 Dispatch Semaphore 来处理：\n\n```objc\n/*\n* 生成 Dispatch Semaphore\n* Dispatch Semaphore 计数初始值设置为 “1”\n* 保证可访问 NSMutableArray 类对象的线程，同时只有1个\n*/\ndispatch_semaphore_t semphore = dispatch_semaphore_create(1);\n    \ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\nNSMutableArray *array = [NSMutableArray array];\nfor (NSInteger i = 0; i < 100000; i++) {\n   dispatch_async(queue, ^{\n       \n       /*\n        * 等待 Dispatch Semaphore\n        * 一直等待，直到 Dispatch Semaphore 的计数值达到≥1\n        */\n       dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);\n       \n       /*\n        * 由于 Dispatch Semaphore 的计数值达到≥1\n        * 所以将 Dispatch Semaphore 的计数值减去1，\n        * dispatch_semaphore_wait 函数执行返回。\n        * \n        * 即执行到这，Dispatch Semaphore 计数值恒为 “0”\n        * 保证可访问 NSMutableArray 类对象的线程，同时只有1个\n        * 可以安全更新\n        */\n       [array addObject:@(i)];\n       \n       /*\n        * 排它处理结束\n        * 所以通过 dispatch_semaphore_signal 将 Dispatch Semaphore 计数值加1\n        * dispatch_semaphore_wait 函数执行返回。\n        *\n        * 如果有正在等待 Dispatch Semaphore 计数值增加的线程，加1操作结束后\n        * 最先等待的线程先执行\n        *\n        */\n       dispatch_semaphore_signal(semphore);\n   });\n}\n```\n\n> 这种变相给数据源上锁的方式相对比较节省性能，和传统的 NSLock 上锁的性能比较可以参考这篇文章[《GCD信号锁》](http://piglikeyoung.com/2016/09/11/GCD-signal-lock/)。\n\n\n## Dispatch I/O\n读取大文件时，将文件分割成合适大小，使用 Global Dispatch Queue 并发读取，速度会快上很多。这一功能 GCD 也提供了，使用到了 Dispatch I/O 和 Dispatch Data。\n\n具体代码可以看 Apple System Log API 使用的源码（[Libc-763.11 gen/asl.c](https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c)）\n\n## 参考资料\n* [官方文档](https://developer.apple.com/reference/dispatch)\n* Objective-C 高级编程 iOS与OS X多线程和内存管理\n\n\n","source":"_posts/Using-Grand-Central-Dispatch-3.md","raw":"---\ntitle: 使用GCD（三）\ndate: 2016-10-07 16:12:44\ntags: GCD\ncategory: 能工巧匠\n---\n\n## 前言\nGCD 的使用第三篇。前两篇链接：\n* [使用GCD（一）](http://piglikeyoung.com/2016/09/25/Using-Grand-Central-Dispatch-1/)\n* [使用GCD（二）](http://piglikeyoung.com/2016/10/01/Using-Grand-Central-Dispatch-2/)\n\n## dispatch_suspend / dispatch_resume\n\ndispatch_suspend 函数挂起指定的 Dispatch Queue。\n\n```objc\ndispatch_suspend(queue);\n```\n\ndispatch_resume 函数恢复指定的 Dispatch Queue。\n\n```objc\ndispatch_resume(queue);\n```\n这两个函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但没有执行的处理停止执行。恢复后，这些处理继续执行。\n\n## Dispatch Semaphore\n上一篇文章说到，并发执行更新数据处理时，会产生数据不一致的情况，有时APP会异常崩溃。虽然使用 Serial Dispatch Queue 和 dispatch_barrier_async 函数可避免这类问题，但是有必要进行更细粒度的排它处理。\n\n比如这种情况：\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\nNSMutableArray *array = [NSMutableArray array];\nfor (NSInteger i = 0; i < 100000; i++) {\n   dispatch_async(queue, ^{\n       [array addObject:@(i)];\n   });\n}\n```\n例子中的代码，并发大量的操作可变数组，执行后出现内存错误导致APP异常结束的概率非常高（大量的线程同时操作同一片内存）。这时候 Dispatch Semaphore 就派上用场了。\n\n**Dispatch Semaphore** 是持有计数的信号，该计数是多线程编程中的计数类型信号。所谓信号，类似于过马路时常用的手旗。可以通过时举起手旗，不可通过时方式手旗。在 Dispatch Semaphore 中，使用计数类实现该功能。**计数为0时等待，计数为1或者大于1时，减去1而不等待**。\n\n生成 Dispatch Semaphore：\n\n```objc\ndispatch_semaphore_t semphore = dispatch_semaphore_create(1);\n```\n参数表示计数的初始值。例子中计数值初始化为“1”。\n\n**dispatch_semaphore_wait** 函数等待 Dispatch Semaphore 的计数值达到大于或者等于1 。\n\n```objc\ndispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);\n```\n当计数值大于等于1，或者在待机中计数值大于等于1时，对该计数进行减法并从 dispatch_semaphore_wait 函数返回。第二个参数与 dispatch_group_wait 函数等相同，是 dispatch_time_t 类型值。另外，dispatch_semaphore_wait 函数的返回值也和 dispatch_group_wait 相同，返回值参考[《使用GCD（二）》](http://piglikeyoung.com/2016/10/01/Using-Grand-Central-Dispatch-2/)的内容。\n\ndispatch_semaphore_wait 函数做减法操作，而 **dispatch_semaphore_signal** 函数做加法操作，将 Dispatch Semaphore 的计数值加1 。\n\n把前面的例子使用 Dispatch Semaphore 来处理：\n\n```objc\n/*\n* 生成 Dispatch Semaphore\n* Dispatch Semaphore 计数初始值设置为 “1”\n* 保证可访问 NSMutableArray 类对象的线程，同时只有1个\n*/\ndispatch_semaphore_t semphore = dispatch_semaphore_create(1);\n    \ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\nNSMutableArray *array = [NSMutableArray array];\nfor (NSInteger i = 0; i < 100000; i++) {\n   dispatch_async(queue, ^{\n       \n       /*\n        * 等待 Dispatch Semaphore\n        * 一直等待，直到 Dispatch Semaphore 的计数值达到≥1\n        */\n       dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);\n       \n       /*\n        * 由于 Dispatch Semaphore 的计数值达到≥1\n        * 所以将 Dispatch Semaphore 的计数值减去1，\n        * dispatch_semaphore_wait 函数执行返回。\n        * \n        * 即执行到这，Dispatch Semaphore 计数值恒为 “0”\n        * 保证可访问 NSMutableArray 类对象的线程，同时只有1个\n        * 可以安全更新\n        */\n       [array addObject:@(i)];\n       \n       /*\n        * 排它处理结束\n        * 所以通过 dispatch_semaphore_signal 将 Dispatch Semaphore 计数值加1\n        * dispatch_semaphore_wait 函数执行返回。\n        *\n        * 如果有正在等待 Dispatch Semaphore 计数值增加的线程，加1操作结束后\n        * 最先等待的线程先执行\n        *\n        */\n       dispatch_semaphore_signal(semphore);\n   });\n}\n```\n\n> 这种变相给数据源上锁的方式相对比较节省性能，和传统的 NSLock 上锁的性能比较可以参考这篇文章[《GCD信号锁》](http://piglikeyoung.com/2016/09/11/GCD-signal-lock/)。\n\n\n## Dispatch I/O\n读取大文件时，将文件分割成合适大小，使用 Global Dispatch Queue 并发读取，速度会快上很多。这一功能 GCD 也提供了，使用到了 Dispatch I/O 和 Dispatch Data。\n\n具体代码可以看 Apple System Log API 使用的源码（[Libc-763.11 gen/asl.c](https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c)）\n\n## 参考资料\n* [官方文档](https://developer.apple.com/reference/dispatch)\n* Objective-C 高级编程 iOS与OS X多线程和内存管理\n\n\n","slug":"Using-Grand-Central-Dispatch-3","published":1,"updated":"2016-10-05T09:47:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7l300128jpbsb6jqxar","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>GCD 的使用第三篇。前两篇链接：</p>\n<ul>\n<li><a href=\"http://piglikeyoung.com/2016/09/25/Using-Grand-Central-Dispatch-1/\">使用GCD（一）</a></li>\n<li><a href=\"http://piglikeyoung.com/2016/10/01/Using-Grand-Central-Dispatch-2/\">使用GCD（二）</a></li>\n</ul>\n<h2 id=\"dispatch-suspend-dispatch-resume\"><a href=\"#dispatch-suspend-dispatch-resume\" class=\"headerlink\" title=\"dispatch_suspend / dispatch_resume\"></a>dispatch_suspend / dispatch_resume</h2><p>dispatch_suspend 函数挂起指定的 Dispatch Queue。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_suspend(queue);</span><br></pre></td></tr></table></figure>\n<p>dispatch_resume 函数恢复指定的 Dispatch Queue。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_resume(queue);</span><br></pre></td></tr></table></figure>\n<p>这两个函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但没有执行的处理停止执行。恢复后，这些处理继续执行。</p>\n<h2 id=\"Dispatch-Semaphore\"><a href=\"#Dispatch-Semaphore\" class=\"headerlink\" title=\"Dispatch Semaphore\"></a>Dispatch Semaphore</h2><p>上一篇文章说到，并发执行更新数据处理时，会产生数据不一致的情况，有时APP会异常崩溃。虽然使用 Serial Dispatch Queue 和 dispatch_barrier_async 函数可避免这类问题，但是有必要进行更细粒度的排它处理。</p>\n<p>比如这种情况：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">       [array addObject:@(i)];</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例子中的代码，并发大量的操作可变数组，执行后出现内存错误导致APP异常结束的概率非常高（大量的线程同时操作同一片内存）。这时候 Dispatch Semaphore 就派上用场了。</p>\n<p><strong>Dispatch Semaphore</strong> 是持有计数的信号，该计数是多线程编程中的计数类型信号。所谓信号，类似于过马路时常用的手旗。可以通过时举起手旗，不可通过时方式手旗。在 Dispatch Semaphore 中，使用计数类实现该功能。<strong>计数为0时等待，计数为1或者大于1时，减去1而不等待</strong>。</p>\n<p>生成 Dispatch Semaphore：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_semaphore_t semphore = dispatch_semaphore_create(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>参数表示计数的初始值。例子中计数值初始化为“1”。</p>\n<p><strong>dispatch_semaphore_wait</strong> 函数等待 Dispatch Semaphore 的计数值达到大于或者等于1 。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>\n<p>当计数值大于等于1，或者在待机中计数值大于等于1时，对该计数进行减法并从 dispatch_semaphore_wait 函数返回。第二个参数与 dispatch_group_wait 函数等相同，是 dispatch_time_t 类型值。另外，dispatch_semaphore_wait 函数的返回值也和 dispatch_group_wait 相同，返回值参考<a href=\"http://piglikeyoung.com/2016/10/01/Using-Grand-Central-Dispatch-2/\">《使用GCD（二）》</a>的内容。</p>\n<p>dispatch_semaphore_wait 函数做减法操作，而 <strong>dispatch_semaphore_signal</strong> 函数做加法操作，将 Dispatch Semaphore 的计数值加1 。</p>\n<p>把前面的例子使用 Dispatch Semaphore 来处理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 生成 Dispatch Semaphore</span></span><br><span class=\"line\"><span class=\"comment\">* Dispatch Semaphore 计数初始值设置为 “1”</span></span><br><span class=\"line\"><span class=\"comment\">* 保证可访问 NSMutableArray 类对象的线程，同时只有1个</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">dispatch_semaphore_t semphore = dispatch_semaphore_create(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 等待 Dispatch Semaphore</span></span><br><span class=\"line\"><span class=\"comment\">        * 一直等待，直到 Dispatch Semaphore 的计数值达到≥1</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 由于 Dispatch Semaphore 的计数值达到≥1</span></span><br><span class=\"line\"><span class=\"comment\">        * 所以将 Dispatch Semaphore 的计数值减去1，</span></span><br><span class=\"line\"><span class=\"comment\">        * dispatch_semaphore_wait 函数执行返回。</span></span><br><span class=\"line\"><span class=\"comment\">        * </span></span><br><span class=\"line\"><span class=\"comment\">        * 即执行到这，Dispatch Semaphore 计数值恒为 “0”</span></span><br><span class=\"line\"><span class=\"comment\">        * 保证可访问 NSMutableArray 类对象的线程，同时只有1个</span></span><br><span class=\"line\"><span class=\"comment\">        * 可以安全更新</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       [array addObject:@(i)];</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 排它处理结束</span></span><br><span class=\"line\"><span class=\"comment\">        * 所以通过 dispatch_semaphore_signal 将 Dispatch Semaphore 计数值加1</span></span><br><span class=\"line\"><span class=\"comment\">        * dispatch_semaphore_wait 函数执行返回。</span></span><br><span class=\"line\"><span class=\"comment\">        *</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果有正在等待 Dispatch Semaphore 计数值增加的线程，加1操作结束后</span></span><br><span class=\"line\"><span class=\"comment\">        * 最先等待的线程先执行</span></span><br><span class=\"line\"><span class=\"comment\">        *</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       dispatch_semaphore_signal(semphore);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这种变相给数据源上锁的方式相对比较节省性能，和传统的 NSLock 上锁的性能比较可以参考这篇文章<a href=\"http://piglikeyoung.com/2016/09/11/GCD-signal-lock/\">《GCD信号锁》</a>。</p>\n</blockquote>\n<h2 id=\"Dispatch-I-O\"><a href=\"#Dispatch-I-O\" class=\"headerlink\" title=\"Dispatch I/O\"></a>Dispatch I/O</h2><p>读取大文件时，将文件分割成合适大小，使用 Global Dispatch Queue 并发读取，速度会快上很多。这一功能 GCD 也提供了，使用到了 Dispatch I/O 和 Dispatch Data。</p>\n<p>具体代码可以看 Apple System Log API 使用的源码（<a href=\"https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c\" target=\"_blank\" rel=\"noopener\">Libc-763.11 gen/asl.c</a>）</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://developer.apple.com/reference/dispatch\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>Objective-C 高级编程 iOS与OS X多线程和内存管理</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>GCD 的使用第三篇。前两篇链接：</p>\n<ul>\n<li><a href=\"http://piglikeyoung.com/2016/09/25/Using-Grand-Central-Dispatch-1/\">使用GCD（一）</a></li>\n<li><a href=\"http://piglikeyoung.com/2016/10/01/Using-Grand-Central-Dispatch-2/\">使用GCD（二）</a></li>\n</ul>\n<h2 id=\"dispatch-suspend-dispatch-resume\"><a href=\"#dispatch-suspend-dispatch-resume\" class=\"headerlink\" title=\"dispatch_suspend / dispatch_resume\"></a>dispatch_suspend / dispatch_resume</h2><p>dispatch_suspend 函数挂起指定的 Dispatch Queue。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_suspend(queue);</span><br></pre></td></tr></table></figure>\n<p>dispatch_resume 函数恢复指定的 Dispatch Queue。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_resume(queue);</span><br></pre></td></tr></table></figure>\n<p>这两个函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但没有执行的处理停止执行。恢复后，这些处理继续执行。</p>\n<h2 id=\"Dispatch-Semaphore\"><a href=\"#Dispatch-Semaphore\" class=\"headerlink\" title=\"Dispatch Semaphore\"></a>Dispatch Semaphore</h2><p>上一篇文章说到，并发执行更新数据处理时，会产生数据不一致的情况，有时APP会异常崩溃。虽然使用 Serial Dispatch Queue 和 dispatch_barrier_async 函数可避免这类问题，但是有必要进行更细粒度的排它处理。</p>\n<p>比如这种情况：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">       [array addObject:@(i)];</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例子中的代码，并发大量的操作可变数组，执行后出现内存错误导致APP异常结束的概率非常高（大量的线程同时操作同一片内存）。这时候 Dispatch Semaphore 就派上用场了。</p>\n<p><strong>Dispatch Semaphore</strong> 是持有计数的信号，该计数是多线程编程中的计数类型信号。所谓信号，类似于过马路时常用的手旗。可以通过时举起手旗，不可通过时方式手旗。在 Dispatch Semaphore 中，使用计数类实现该功能。<strong>计数为0时等待，计数为1或者大于1时，减去1而不等待</strong>。</p>\n<p>生成 Dispatch Semaphore：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_semaphore_t semphore = dispatch_semaphore_create(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>参数表示计数的初始值。例子中计数值初始化为“1”。</p>\n<p><strong>dispatch_semaphore_wait</strong> 函数等待 Dispatch Semaphore 的计数值达到大于或者等于1 。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>\n<p>当计数值大于等于1，或者在待机中计数值大于等于1时，对该计数进行减法并从 dispatch_semaphore_wait 函数返回。第二个参数与 dispatch_group_wait 函数等相同，是 dispatch_time_t 类型值。另外，dispatch_semaphore_wait 函数的返回值也和 dispatch_group_wait 相同，返回值参考<a href=\"http://piglikeyoung.com/2016/10/01/Using-Grand-Central-Dispatch-2/\">《使用GCD（二）》</a>的内容。</p>\n<p>dispatch_semaphore_wait 函数做减法操作，而 <strong>dispatch_semaphore_signal</strong> 函数做加法操作，将 Dispatch Semaphore 的计数值加1 。</p>\n<p>把前面的例子使用 Dispatch Semaphore 来处理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 生成 Dispatch Semaphore</span></span><br><span class=\"line\"><span class=\"comment\">* Dispatch Semaphore 计数初始值设置为 “1”</span></span><br><span class=\"line\"><span class=\"comment\">* 保证可访问 NSMutableArray 类对象的线程，同时只有1个</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">dispatch_semaphore_t semphore = dispatch_semaphore_create(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 等待 Dispatch Semaphore</span></span><br><span class=\"line\"><span class=\"comment\">        * 一直等待，直到 Dispatch Semaphore 的计数值达到≥1</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 由于 Dispatch Semaphore 的计数值达到≥1</span></span><br><span class=\"line\"><span class=\"comment\">        * 所以将 Dispatch Semaphore 的计数值减去1，</span></span><br><span class=\"line\"><span class=\"comment\">        * dispatch_semaphore_wait 函数执行返回。</span></span><br><span class=\"line\"><span class=\"comment\">        * </span></span><br><span class=\"line\"><span class=\"comment\">        * 即执行到这，Dispatch Semaphore 计数值恒为 “0”</span></span><br><span class=\"line\"><span class=\"comment\">        * 保证可访问 NSMutableArray 类对象的线程，同时只有1个</span></span><br><span class=\"line\"><span class=\"comment\">        * 可以安全更新</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       [array addObject:@(i)];</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 排它处理结束</span></span><br><span class=\"line\"><span class=\"comment\">        * 所以通过 dispatch_semaphore_signal 将 Dispatch Semaphore 计数值加1</span></span><br><span class=\"line\"><span class=\"comment\">        * dispatch_semaphore_wait 函数执行返回。</span></span><br><span class=\"line\"><span class=\"comment\">        *</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果有正在等待 Dispatch Semaphore 计数值增加的线程，加1操作结束后</span></span><br><span class=\"line\"><span class=\"comment\">        * 最先等待的线程先执行</span></span><br><span class=\"line\"><span class=\"comment\">        *</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       dispatch_semaphore_signal(semphore);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这种变相给数据源上锁的方式相对比较节省性能，和传统的 NSLock 上锁的性能比较可以参考这篇文章<a href=\"http://piglikeyoung.com/2016/09/11/GCD-signal-lock/\">《GCD信号锁》</a>。</p>\n</blockquote>\n<h2 id=\"Dispatch-I-O\"><a href=\"#Dispatch-I-O\" class=\"headerlink\" title=\"Dispatch I/O\"></a>Dispatch I/O</h2><p>读取大文件时，将文件分割成合适大小，使用 Global Dispatch Queue 并发读取，速度会快上很多。这一功能 GCD 也提供了，使用到了 Dispatch I/O 和 Dispatch Data。</p>\n<p>具体代码可以看 Apple System Log API 使用的源码（<a href=\"https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c\" target=\"_blank\" rel=\"noopener\">Libc-763.11 gen/asl.c</a>）</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://developer.apple.com/reference/dispatch\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>Objective-C 高级编程 iOS与OS X多线程和内存管理</li>\n</ul>\n"},{"title":"iOS中使用正则表达式","date":"2016-10-04T04:33:39.000Z","_content":"\n## 前言\n在表单验证中，任何语言都会经常使用到正则表达式，来判断用户输入是不是合法，如果不合法提示用户输入错误，不提交到服务器，过滤输入的重点就在于**正则表达式**。这篇文章我们了解下iOS中正则表达式的使用。\n\n## NSString实例方法\nNSString实例里面提供了`rangeOfString:options:`方法来匹配正则表达式：\n\n```objc\nNSString *phoneNum = @\"18123456789\";\nNSRange range = [phoneNum rangeOfString:@\"^1[8]\\\\d{9}$\" options:NSRegularExpressionSearch];\nif (range.location != NSNotFound) {\n   NSLog(@\"%@\", [phoneNum substringWithRange:range]);\n}\n```\n`rangeOfString:options:`会返回第一个匹配结果的位置，如果匹配不到返回**NSNotFound**，也就是**NSIntegerMax**最大值。options中设定**NSRegularExpressionSearch**就是表示利用正则表达式匹配。\n\n这种判断方法适合需要捕获用户输入内容的特定内容时使用，通过**NSRange**可以捕获内容，甚至可以替换内容。\n\n## 谓词（NSPredicate）创建正则表达式\n谓词是iOS里面一个很牛逼的功能，通过它可以过滤很多东西，比如数据库SQL，输入内容匹配，还有我们要使用的正则表达式。\n\n```objc\n// 正则判断是不是正整数\nNSPredicate *predicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", @\"^\\\\d+$\"];\nBOOL isValid = [predicate evaluateWithObject:@\"123\"];\nif (isValid) {\n\t// do Something\n}\n```\n\n例子中创建了谓词对象，设置匹配条件，如果匹配格式，在if判断中可以做处理。\n\n这种判断方法很简洁，如果只是要判断输入内容是否合法，用这种方式就可以了。\n\n## NSRegularExpression类创建正则表达式\n在iOS中`NSRegularExpression`类就是一个专门来处理正则表达式的类，相比前面的方法，这个类更专业。\n\n初始化**NSRegularExpression**的方法有两种，一个init方法和一个类方法。其作用基本是一样的：\n\n```objc\n+ (NSRegularExpression *)regularExpressionWithPattern:(NSString *)pattern options:(NSRegularExpressionOptions)options error:(NSError **)error;\n\n- (instancetype)initWithPattern:(NSString *)pattern options:(NSRegularExpressionOptions)options error:(NSError **)error \n```\n\n**pattern**是正则表达式，**options**参数是一个枚举，表示正则模式的设置，如下：\n\n```objc\ntypedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) {\n   NSRegularExpressionCaseInsensitive             = 1 << 0, //不区分字母大小写的模式\n   NSRegularExpressionAllowCommentsAndWhitespace  = 1 << 1, //忽略掉正则表达式中的空格和#号之后的字符\n   NSRegularExpressionIgnoreMetacharacters        = 1 << 2, //将正则表达式整体作为字符串处理\n   NSRegularExpressionDotMatchesLineSeparators    = 1 << 3, //允许.匹配任何字符，包括换行符  \n   NSRegularExpressionAnchorsMatchLines           = 1 << 4, //允许^和$符号匹配行的开头和结尾\n   NSRegularExpressionUseUnixLineSeparators       = 1 << 5, //设置\\n为唯一的行分隔符，否则所有的都有效。\n   NSRegularExpressionUseUnicodeWordBoundaries    = 1 << 6  //使用Unicode TR#29标准作为词的边界，否则所有传统正则表达式的词边界都有效\n};\n```\n\n可以通过 | 来设置多项参数。\n\n> 注意：\n1.NSRegularExpressionCaseInsensitive模式下正则表达式 aBc 会匹配到abc.\n2.NSRegularExpressionAllowCommentsAndWhitespace模式下正则表达式a b c 会匹配到abc，正则表达式ab#c会匹配到ab。\n3.NSRegularExpressionIgnoreMetacharacters模式下正则表达式[a-z]，会匹配到[a-z]。\n\n\n\niOS提供了两个API来匹配表达式：\n\n### block方法\n\n```objc\n// 匹配是不是a到z\nNSRegularExpression * regex = [[NSRegularExpression alloc]initWithPattern:@\"[a-z]\" options:NSRegularExpressionCaseInsensitive error:nil];\n[regex enumerateMatchesInString:@\"124a\" options:NSMatchingReportProgress range:NSMakeRange(0, 4) usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {\n   NSLog(@\"%@\",result);\n} ];\n```\n\n函数的第一个参数options是个枚举：\n\n```objc\ntypedef NS_OPTIONS(NSUInteger, NSMatchingOptions) {\n   NSMatchingReportProgress         = 1 << 0, //每次都调用block回调，无论是否匹配\n   NSMatchingReportCompletion       = 1 << 1, //找到任何一个匹配串后都回调一次block\n   NSMatchingAnchored               = 1 << 2, //从匹配范围的开始出进行匹配\n   NSMatchingWithTransparentBounds  = 1 << 3, //允许匹配的范围超出设置的范围\n   NSMatchingWithoutAnchoringBounds = 1 << 4  //禁止^和$自动匹配行开始和结束\n};\n```\n\nblock回调的flags枚举：\n\n```objc\ntypedef NS_OPTIONS(NSUInteger, NSMatchingFlags) {\n   NSMatchingProgress               = 1 << 0, //匹配到最长串时被设置     \n   NSMatchingCompleted              = 1 << 1, //全部分配完成后被设置    \n   NSMatchingHitEnd                 = 1 << 2, //匹配到设置范围的末尾时被设置   \n   NSMatchingRequiredEnd            = 1 << 3, //当前匹配到的字符串在匹配范围的末尾时被设置     \n   NSMatchingInternalError          = 1 << 4  //由于错误导致的匹配失败时被设置   \n};\n```\n\nblock中还有个BOOL指针`stop`，设置它为**YES**就会停止匹配。\n\n\n### 非block方法\n\n* 这个方法返回一个结果数组，将所有的匹配结果返回。\n\n```objc\n- (NSArray *)matchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;\n```\n\n\n* 这个方法会返回匹配到的字符串个数\n\n```objc\n- (NSUInteger)numberOfMatchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;\n```\n\n* 这个方法会返回第一个查询到的结果，这个**NSTextCheckingResult**对象中有一个range属性，可以得到匹配到的字符串的范围。\n\n```objc\n- (NSTextCheckingResult *)firstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;\n```\n\n* 这个方法直接返回匹配到得范围，NSRange。\n\n```objc\n- (NSRange)rangeOfFirstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;\n```\n\n\n### 一个辅助方法\nNSRegularExpression类中还提供了一个辅助方法：\n\n```objc\n+ (NSString *)escapedPatternForString:(NSString *)string;\n```\n它可以帮助我们将正则表达式加上\"\\\"进行保护，将元字符转化成字面值。\n\n\n## 总结\n如果你只是简单的匹配用户输入内容是否匹配，**NSString实例方法**和**谓词**方法会方便简洁的给你答案，如果你是想要更加强大的匹配支持**NSRegularExpression**完全能够满足你的需要。\n\n## 参考链接\n[iOS中正则表达式的使用](https://my.oschina.net/u/2340880/blog/403638)\n\n\n\n\n\n","source":"_posts/Using-regex-in-iOS.md","raw":"---\ntitle: iOS中使用正则表达式\ndate: 2016-10-04 12:33:39\ntags: 正则表达式\ncategory: 能工巧匠\n---\n\n## 前言\n在表单验证中，任何语言都会经常使用到正则表达式，来判断用户输入是不是合法，如果不合法提示用户输入错误，不提交到服务器，过滤输入的重点就在于**正则表达式**。这篇文章我们了解下iOS中正则表达式的使用。\n\n## NSString实例方法\nNSString实例里面提供了`rangeOfString:options:`方法来匹配正则表达式：\n\n```objc\nNSString *phoneNum = @\"18123456789\";\nNSRange range = [phoneNum rangeOfString:@\"^1[8]\\\\d{9}$\" options:NSRegularExpressionSearch];\nif (range.location != NSNotFound) {\n   NSLog(@\"%@\", [phoneNum substringWithRange:range]);\n}\n```\n`rangeOfString:options:`会返回第一个匹配结果的位置，如果匹配不到返回**NSNotFound**，也就是**NSIntegerMax**最大值。options中设定**NSRegularExpressionSearch**就是表示利用正则表达式匹配。\n\n这种判断方法适合需要捕获用户输入内容的特定内容时使用，通过**NSRange**可以捕获内容，甚至可以替换内容。\n\n## 谓词（NSPredicate）创建正则表达式\n谓词是iOS里面一个很牛逼的功能，通过它可以过滤很多东西，比如数据库SQL，输入内容匹配，还有我们要使用的正则表达式。\n\n```objc\n// 正则判断是不是正整数\nNSPredicate *predicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", @\"^\\\\d+$\"];\nBOOL isValid = [predicate evaluateWithObject:@\"123\"];\nif (isValid) {\n\t// do Something\n}\n```\n\n例子中创建了谓词对象，设置匹配条件，如果匹配格式，在if判断中可以做处理。\n\n这种判断方法很简洁，如果只是要判断输入内容是否合法，用这种方式就可以了。\n\n## NSRegularExpression类创建正则表达式\n在iOS中`NSRegularExpression`类就是一个专门来处理正则表达式的类，相比前面的方法，这个类更专业。\n\n初始化**NSRegularExpression**的方法有两种，一个init方法和一个类方法。其作用基本是一样的：\n\n```objc\n+ (NSRegularExpression *)regularExpressionWithPattern:(NSString *)pattern options:(NSRegularExpressionOptions)options error:(NSError **)error;\n\n- (instancetype)initWithPattern:(NSString *)pattern options:(NSRegularExpressionOptions)options error:(NSError **)error \n```\n\n**pattern**是正则表达式，**options**参数是一个枚举，表示正则模式的设置，如下：\n\n```objc\ntypedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) {\n   NSRegularExpressionCaseInsensitive             = 1 << 0, //不区分字母大小写的模式\n   NSRegularExpressionAllowCommentsAndWhitespace  = 1 << 1, //忽略掉正则表达式中的空格和#号之后的字符\n   NSRegularExpressionIgnoreMetacharacters        = 1 << 2, //将正则表达式整体作为字符串处理\n   NSRegularExpressionDotMatchesLineSeparators    = 1 << 3, //允许.匹配任何字符，包括换行符  \n   NSRegularExpressionAnchorsMatchLines           = 1 << 4, //允许^和$符号匹配行的开头和结尾\n   NSRegularExpressionUseUnixLineSeparators       = 1 << 5, //设置\\n为唯一的行分隔符，否则所有的都有效。\n   NSRegularExpressionUseUnicodeWordBoundaries    = 1 << 6  //使用Unicode TR#29标准作为词的边界，否则所有传统正则表达式的词边界都有效\n};\n```\n\n可以通过 | 来设置多项参数。\n\n> 注意：\n1.NSRegularExpressionCaseInsensitive模式下正则表达式 aBc 会匹配到abc.\n2.NSRegularExpressionAllowCommentsAndWhitespace模式下正则表达式a b c 会匹配到abc，正则表达式ab#c会匹配到ab。\n3.NSRegularExpressionIgnoreMetacharacters模式下正则表达式[a-z]，会匹配到[a-z]。\n\n\n\niOS提供了两个API来匹配表达式：\n\n### block方法\n\n```objc\n// 匹配是不是a到z\nNSRegularExpression * regex = [[NSRegularExpression alloc]initWithPattern:@\"[a-z]\" options:NSRegularExpressionCaseInsensitive error:nil];\n[regex enumerateMatchesInString:@\"124a\" options:NSMatchingReportProgress range:NSMakeRange(0, 4) usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {\n   NSLog(@\"%@\",result);\n} ];\n```\n\n函数的第一个参数options是个枚举：\n\n```objc\ntypedef NS_OPTIONS(NSUInteger, NSMatchingOptions) {\n   NSMatchingReportProgress         = 1 << 0, //每次都调用block回调，无论是否匹配\n   NSMatchingReportCompletion       = 1 << 1, //找到任何一个匹配串后都回调一次block\n   NSMatchingAnchored               = 1 << 2, //从匹配范围的开始出进行匹配\n   NSMatchingWithTransparentBounds  = 1 << 3, //允许匹配的范围超出设置的范围\n   NSMatchingWithoutAnchoringBounds = 1 << 4  //禁止^和$自动匹配行开始和结束\n};\n```\n\nblock回调的flags枚举：\n\n```objc\ntypedef NS_OPTIONS(NSUInteger, NSMatchingFlags) {\n   NSMatchingProgress               = 1 << 0, //匹配到最长串时被设置     \n   NSMatchingCompleted              = 1 << 1, //全部分配完成后被设置    \n   NSMatchingHitEnd                 = 1 << 2, //匹配到设置范围的末尾时被设置   \n   NSMatchingRequiredEnd            = 1 << 3, //当前匹配到的字符串在匹配范围的末尾时被设置     \n   NSMatchingInternalError          = 1 << 4  //由于错误导致的匹配失败时被设置   \n};\n```\n\nblock中还有个BOOL指针`stop`，设置它为**YES**就会停止匹配。\n\n\n### 非block方法\n\n* 这个方法返回一个结果数组，将所有的匹配结果返回。\n\n```objc\n- (NSArray *)matchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;\n```\n\n\n* 这个方法会返回匹配到的字符串个数\n\n```objc\n- (NSUInteger)numberOfMatchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;\n```\n\n* 这个方法会返回第一个查询到的结果，这个**NSTextCheckingResult**对象中有一个range属性，可以得到匹配到的字符串的范围。\n\n```objc\n- (NSTextCheckingResult *)firstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;\n```\n\n* 这个方法直接返回匹配到得范围，NSRange。\n\n```objc\n- (NSRange)rangeOfFirstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;\n```\n\n\n### 一个辅助方法\nNSRegularExpression类中还提供了一个辅助方法：\n\n```objc\n+ (NSString *)escapedPatternForString:(NSString *)string;\n```\n它可以帮助我们将正则表达式加上\"\\\"进行保护，将元字符转化成字面值。\n\n\n## 总结\n如果你只是简单的匹配用户输入内容是否匹配，**NSString实例方法**和**谓词**方法会方便简洁的给你答案，如果你是想要更加强大的匹配支持**NSRegularExpression**完全能够满足你的需要。\n\n## 参考链接\n[iOS中正则表达式的使用](https://my.oschina.net/u/2340880/blog/403638)\n\n\n\n\n\n","slug":"Using-regex-in-iOS","published":1,"updated":"2016-10-04T07:03:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7l400158jpbrgmwhlgu","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在表单验证中，任何语言都会经常使用到正则表达式，来判断用户输入是不是合法，如果不合法提示用户输入错误，不提交到服务器，过滤输入的重点就在于<strong>正则表达式</strong>。这篇文章我们了解下iOS中正则表达式的使用。</p>\n<h2 id=\"NSString实例方法\"><a href=\"#NSString实例方法\" class=\"headerlink\" title=\"NSString实例方法\"></a>NSString实例方法</h2><p>NSString实例里面提供了<code>rangeOfString:options:</code>方法来匹配正则表达式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *phoneNum = <span class=\"string\">@\"18123456789\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSRange</span> range = [phoneNum rangeOfString:<span class=\"string\">@\"^1[8]\\\\d&#123;9&#125;$\"</span> options:<span class=\"built_in\">NSRegularExpressionSearch</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (range.location != <span class=\"built_in\">NSNotFound</span>) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [phoneNum substringWithRange:range]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>rangeOfString:options:</code>会返回第一个匹配结果的位置，如果匹配不到返回<strong>NSNotFound</strong>，也就是<strong>NSIntegerMax</strong>最大值。options中设定<strong>NSRegularExpressionSearch</strong>就是表示利用正则表达式匹配。</p>\n<p>这种判断方法适合需要捕获用户输入内容的特定内容时使用，通过<strong>NSRange</strong>可以捕获内容，甚至可以替换内容。</p>\n<h2 id=\"谓词（NSPredicate）创建正则表达式\"><a href=\"#谓词（NSPredicate）创建正则表达式\" class=\"headerlink\" title=\"谓词（NSPredicate）创建正则表达式\"></a>谓词（NSPredicate）创建正则表达式</h2><p>谓词是iOS里面一个很牛逼的功能，通过它可以过滤很多东西，比如数据库SQL，输入内容匹配，还有我们要使用的正则表达式。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正则判断是不是正整数</span></span><br><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *predicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"SELF MATCHES %@\"</span>, <span class=\"string\">@\"^\\\\d+$\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> isValid = [predicate evaluateWithObject:<span class=\"string\">@\"123\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (isValid) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do Something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例子中创建了谓词对象，设置匹配条件，如果匹配格式，在if判断中可以做处理。</p>\n<p>这种判断方法很简洁，如果只是要判断输入内容是否合法，用这种方式就可以了。</p>\n<h2 id=\"NSRegularExpression类创建正则表达式\"><a href=\"#NSRegularExpression类创建正则表达式\" class=\"headerlink\" title=\"NSRegularExpression类创建正则表达式\"></a>NSRegularExpression类创建正则表达式</h2><p>在iOS中<code>NSRegularExpression</code>类就是一个专门来处理正则表达式的类，相比前面的方法，这个类更专业。</p>\n<p>初始化<strong>NSRegularExpression</strong>的方法有两种，一个init方法和一个类方法。其作用基本是一样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSRegularExpression</span> *)regularExpressionWithPattern:(<span class=\"built_in\">NSString</span> *)pattern options:(<span class=\"built_in\">NSRegularExpressionOptions</span>)options error:(<span class=\"built_in\">NSError</span> **)error;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithPattern:(<span class=\"built_in\">NSString</span> *)pattern options:(<span class=\"built_in\">NSRegularExpressionOptions</span>)options error:(<span class=\"built_in\">NSError</span> **)error</span><br></pre></td></tr></table></figure>\n<p><strong>pattern</strong>是正则表达式，<strong>options</strong>参数是一个枚举，表示正则模式的设置，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">NSRegularExpressionOptions</span>) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionCaseInsensitive</span>             = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>, <span class=\"comment\">//不区分字母大小写的模式</span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionAllowCommentsAndWhitespace</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>, <span class=\"comment\">//忽略掉正则表达式中的空格和#号之后的字符</span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionIgnoreMetacharacters</span>        = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>, <span class=\"comment\">//将正则表达式整体作为字符串处理</span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionDotMatchesLineSeparators</span>    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>, <span class=\"comment\">//允许.匹配任何字符，包括换行符  </span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionAnchorsMatchLines</span>           = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>, <span class=\"comment\">//允许^和$符号匹配行的开头和结尾</span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionUseUnixLineSeparators</span>       = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">5</span>, <span class=\"comment\">//设置\\n为唯一的行分隔符，否则所有的都有效。</span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionUseUnicodeWordBoundaries</span>    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">6</span>  <span class=\"comment\">//使用Unicode TR#29标准作为词的边界，否则所有传统正则表达式的词边界都有效</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以通过 | 来设置多项参数。</p>\n<blockquote>\n<p>注意：<br>1.NSRegularExpressionCaseInsensitive模式下正则表达式 aBc 会匹配到abc.<br>2.NSRegularExpressionAllowCommentsAndWhitespace模式下正则表达式a b c 会匹配到abc，正则表达式ab#c会匹配到ab。<br>3.NSRegularExpressionIgnoreMetacharacters模式下正则表达式[a-z]，会匹配到[a-z]。</p>\n</blockquote>\n<p>iOS提供了两个API来匹配表达式：</p>\n<h3 id=\"block方法\"><a href=\"#block方法\" class=\"headerlink\" title=\"block方法\"></a>block方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 匹配是不是a到z</span></span><br><span class=\"line\"><span class=\"built_in\">NSRegularExpression</span> * regex = [[<span class=\"built_in\">NSRegularExpression</span> alloc]initWithPattern:<span class=\"string\">@\"[a-z]\"</span> options:<span class=\"built_in\">NSRegularExpressionCaseInsensitive</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">[regex enumerateMatchesInString:<span class=\"string\">@\"124a\"</span> options:<span class=\"built_in\">NSMatchingReportProgress</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">4</span>) usingBlock:^(<span class=\"built_in\">NSTextCheckingResult</span> *result, <span class=\"built_in\">NSMatchingFlags</span> flags, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,result);</span><br><span class=\"line\">&#125; ];</span><br></pre></td></tr></table></figure>\n<p>函数的第一个参数options是个枚举：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">NSMatchingOptions</span>) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingReportProgress</span>         = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>, <span class=\"comment\">//每次都调用block回调，无论是否匹配</span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingReportCompletion</span>       = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>, <span class=\"comment\">//找到任何一个匹配串后都回调一次block</span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingAnchored</span>               = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>, <span class=\"comment\">//从匹配范围的开始出进行匹配</span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingWithTransparentBounds</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>, <span class=\"comment\">//允许匹配的范围超出设置的范围</span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingWithoutAnchoringBounds</span> = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>  <span class=\"comment\">//禁止^和$自动匹配行开始和结束</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>block回调的flags枚举：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">NSMatchingFlags</span>) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingProgress</span>               = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>, <span class=\"comment\">//匹配到最长串时被设置     </span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingCompleted</span>              = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>, <span class=\"comment\">//全部分配完成后被设置    </span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingHitEnd</span>                 = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>, <span class=\"comment\">//匹配到设置范围的末尾时被设置   </span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingRequiredEnd</span>            = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>, <span class=\"comment\">//当前匹配到的字符串在匹配范围的末尾时被设置     </span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingInternalError</span>          = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>  <span class=\"comment\">//由于错误导致的匹配失败时被设置   </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>block中还有个BOOL指针<code>stop</code>，设置它为<strong>YES</strong>就会停止匹配。</p>\n<h3 id=\"非block方法\"><a href=\"#非block方法\" class=\"headerlink\" title=\"非block方法\"></a>非block方法</h3><ul>\n<li>这个方法返回一个结果数组，将所有的匹配结果返回。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)matchesInString:(<span class=\"built_in\">NSString</span> *)string options:(<span class=\"built_in\">NSMatchingOptions</span>)options range:(<span class=\"built_in\">NSRange</span>)range;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这个方法会返回匹配到的字符串个数</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)numberOfMatchesInString:(<span class=\"built_in\">NSString</span> *)string options:(<span class=\"built_in\">NSMatchingOptions</span>)options range:(<span class=\"built_in\">NSRange</span>)range;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这个方法会返回第一个查询到的结果，这个<strong>NSTextCheckingResult</strong>对象中有一个range属性，可以得到匹配到的字符串的范围。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSTextCheckingResult</span> *)firstMatchInString:(<span class=\"built_in\">NSString</span> *)string options:(<span class=\"built_in\">NSMatchingOptions</span>)options range:(<span class=\"built_in\">NSRange</span>)range;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这个方法直接返回匹配到得范围，NSRange。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSRange</span>)rangeOfFirstMatchInString:(<span class=\"built_in\">NSString</span> *)string options:(<span class=\"built_in\">NSMatchingOptions</span>)options range:(<span class=\"built_in\">NSRange</span>)range;</span><br></pre></td></tr></table></figure>\n<h3 id=\"一个辅助方法\"><a href=\"#一个辅助方法\" class=\"headerlink\" title=\"一个辅助方法\"></a>一个辅助方法</h3><p>NSRegularExpression类中还提供了一个辅助方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSString</span> *)escapedPatternForString:(<span class=\"built_in\">NSString</span> *)string;</span><br></pre></td></tr></table></figure>\n<p>它可以帮助我们将正则表达式加上”\\”进行保护，将元字符转化成字面值。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果你只是简单的匹配用户输入内容是否匹配，<strong>NSString实例方法</strong>和<strong>谓词</strong>方法会方便简洁的给你答案，如果你是想要更加强大的匹配支持<strong>NSRegularExpression</strong>完全能够满足你的需要。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://my.oschina.net/u/2340880/blog/403638\" target=\"_blank\" rel=\"noopener\">iOS中正则表达式的使用</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在表单验证中，任何语言都会经常使用到正则表达式，来判断用户输入是不是合法，如果不合法提示用户输入错误，不提交到服务器，过滤输入的重点就在于<strong>正则表达式</strong>。这篇文章我们了解下iOS中正则表达式的使用。</p>\n<h2 id=\"NSString实例方法\"><a href=\"#NSString实例方法\" class=\"headerlink\" title=\"NSString实例方法\"></a>NSString实例方法</h2><p>NSString实例里面提供了<code>rangeOfString:options:</code>方法来匹配正则表达式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *phoneNum = <span class=\"string\">@\"18123456789\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSRange</span> range = [phoneNum rangeOfString:<span class=\"string\">@\"^1[8]\\\\d&#123;9&#125;$\"</span> options:<span class=\"built_in\">NSRegularExpressionSearch</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (range.location != <span class=\"built_in\">NSNotFound</span>) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [phoneNum substringWithRange:range]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>rangeOfString:options:</code>会返回第一个匹配结果的位置，如果匹配不到返回<strong>NSNotFound</strong>，也就是<strong>NSIntegerMax</strong>最大值。options中设定<strong>NSRegularExpressionSearch</strong>就是表示利用正则表达式匹配。</p>\n<p>这种判断方法适合需要捕获用户输入内容的特定内容时使用，通过<strong>NSRange</strong>可以捕获内容，甚至可以替换内容。</p>\n<h2 id=\"谓词（NSPredicate）创建正则表达式\"><a href=\"#谓词（NSPredicate）创建正则表达式\" class=\"headerlink\" title=\"谓词（NSPredicate）创建正则表达式\"></a>谓词（NSPredicate）创建正则表达式</h2><p>谓词是iOS里面一个很牛逼的功能，通过它可以过滤很多东西，比如数据库SQL，输入内容匹配，还有我们要使用的正则表达式。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正则判断是不是正整数</span></span><br><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *predicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"SELF MATCHES %@\"</span>, <span class=\"string\">@\"^\\\\d+$\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> isValid = [predicate evaluateWithObject:<span class=\"string\">@\"123\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (isValid) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do Something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例子中创建了谓词对象，设置匹配条件，如果匹配格式，在if判断中可以做处理。</p>\n<p>这种判断方法很简洁，如果只是要判断输入内容是否合法，用这种方式就可以了。</p>\n<h2 id=\"NSRegularExpression类创建正则表达式\"><a href=\"#NSRegularExpression类创建正则表达式\" class=\"headerlink\" title=\"NSRegularExpression类创建正则表达式\"></a>NSRegularExpression类创建正则表达式</h2><p>在iOS中<code>NSRegularExpression</code>类就是一个专门来处理正则表达式的类，相比前面的方法，这个类更专业。</p>\n<p>初始化<strong>NSRegularExpression</strong>的方法有两种，一个init方法和一个类方法。其作用基本是一样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSRegularExpression</span> *)regularExpressionWithPattern:(<span class=\"built_in\">NSString</span> *)pattern options:(<span class=\"built_in\">NSRegularExpressionOptions</span>)options error:(<span class=\"built_in\">NSError</span> **)error;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithPattern:(<span class=\"built_in\">NSString</span> *)pattern options:(<span class=\"built_in\">NSRegularExpressionOptions</span>)options error:(<span class=\"built_in\">NSError</span> **)error</span><br></pre></td></tr></table></figure>\n<p><strong>pattern</strong>是正则表达式，<strong>options</strong>参数是一个枚举，表示正则模式的设置，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">NSRegularExpressionOptions</span>) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionCaseInsensitive</span>             = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>, <span class=\"comment\">//不区分字母大小写的模式</span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionAllowCommentsAndWhitespace</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>, <span class=\"comment\">//忽略掉正则表达式中的空格和#号之后的字符</span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionIgnoreMetacharacters</span>        = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>, <span class=\"comment\">//将正则表达式整体作为字符串处理</span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionDotMatchesLineSeparators</span>    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>, <span class=\"comment\">//允许.匹配任何字符，包括换行符  </span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionAnchorsMatchLines</span>           = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>, <span class=\"comment\">//允许^和$符号匹配行的开头和结尾</span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionUseUnixLineSeparators</span>       = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">5</span>, <span class=\"comment\">//设置\\n为唯一的行分隔符，否则所有的都有效。</span></span><br><span class=\"line\">   <span class=\"built_in\">NSRegularExpressionUseUnicodeWordBoundaries</span>    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">6</span>  <span class=\"comment\">//使用Unicode TR#29标准作为词的边界，否则所有传统正则表达式的词边界都有效</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以通过 | 来设置多项参数。</p>\n<blockquote>\n<p>注意：<br>1.NSRegularExpressionCaseInsensitive模式下正则表达式 aBc 会匹配到abc.<br>2.NSRegularExpressionAllowCommentsAndWhitespace模式下正则表达式a b c 会匹配到abc，正则表达式ab#c会匹配到ab。<br>3.NSRegularExpressionIgnoreMetacharacters模式下正则表达式[a-z]，会匹配到[a-z]。</p>\n</blockquote>\n<p>iOS提供了两个API来匹配表达式：</p>\n<h3 id=\"block方法\"><a href=\"#block方法\" class=\"headerlink\" title=\"block方法\"></a>block方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 匹配是不是a到z</span></span><br><span class=\"line\"><span class=\"built_in\">NSRegularExpression</span> * regex = [[<span class=\"built_in\">NSRegularExpression</span> alloc]initWithPattern:<span class=\"string\">@\"[a-z]\"</span> options:<span class=\"built_in\">NSRegularExpressionCaseInsensitive</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">[regex enumerateMatchesInString:<span class=\"string\">@\"124a\"</span> options:<span class=\"built_in\">NSMatchingReportProgress</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">4</span>) usingBlock:^(<span class=\"built_in\">NSTextCheckingResult</span> *result, <span class=\"built_in\">NSMatchingFlags</span> flags, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,result);</span><br><span class=\"line\">&#125; ];</span><br></pre></td></tr></table></figure>\n<p>函数的第一个参数options是个枚举：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">NSMatchingOptions</span>) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingReportProgress</span>         = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>, <span class=\"comment\">//每次都调用block回调，无论是否匹配</span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingReportCompletion</span>       = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>, <span class=\"comment\">//找到任何一个匹配串后都回调一次block</span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingAnchored</span>               = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>, <span class=\"comment\">//从匹配范围的开始出进行匹配</span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingWithTransparentBounds</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>, <span class=\"comment\">//允许匹配的范围超出设置的范围</span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingWithoutAnchoringBounds</span> = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>  <span class=\"comment\">//禁止^和$自动匹配行开始和结束</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>block回调的flags枚举：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">NSMatchingFlags</span>) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingProgress</span>               = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>, <span class=\"comment\">//匹配到最长串时被设置     </span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingCompleted</span>              = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>, <span class=\"comment\">//全部分配完成后被设置    </span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingHitEnd</span>                 = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>, <span class=\"comment\">//匹配到设置范围的末尾时被设置   </span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingRequiredEnd</span>            = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>, <span class=\"comment\">//当前匹配到的字符串在匹配范围的末尾时被设置     </span></span><br><span class=\"line\">   <span class=\"built_in\">NSMatchingInternalError</span>          = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>  <span class=\"comment\">//由于错误导致的匹配失败时被设置   </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>block中还有个BOOL指针<code>stop</code>，设置它为<strong>YES</strong>就会停止匹配。</p>\n<h3 id=\"非block方法\"><a href=\"#非block方法\" class=\"headerlink\" title=\"非block方法\"></a>非block方法</h3><ul>\n<li>这个方法返回一个结果数组，将所有的匹配结果返回。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)matchesInString:(<span class=\"built_in\">NSString</span> *)string options:(<span class=\"built_in\">NSMatchingOptions</span>)options range:(<span class=\"built_in\">NSRange</span>)range;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这个方法会返回匹配到的字符串个数</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)numberOfMatchesInString:(<span class=\"built_in\">NSString</span> *)string options:(<span class=\"built_in\">NSMatchingOptions</span>)options range:(<span class=\"built_in\">NSRange</span>)range;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这个方法会返回第一个查询到的结果，这个<strong>NSTextCheckingResult</strong>对象中有一个range属性，可以得到匹配到的字符串的范围。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSTextCheckingResult</span> *)firstMatchInString:(<span class=\"built_in\">NSString</span> *)string options:(<span class=\"built_in\">NSMatchingOptions</span>)options range:(<span class=\"built_in\">NSRange</span>)range;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这个方法直接返回匹配到得范围，NSRange。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSRange</span>)rangeOfFirstMatchInString:(<span class=\"built_in\">NSString</span> *)string options:(<span class=\"built_in\">NSMatchingOptions</span>)options range:(<span class=\"built_in\">NSRange</span>)range;</span><br></pre></td></tr></table></figure>\n<h3 id=\"一个辅助方法\"><a href=\"#一个辅助方法\" class=\"headerlink\" title=\"一个辅助方法\"></a>一个辅助方法</h3><p>NSRegularExpression类中还提供了一个辅助方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSString</span> *)escapedPatternForString:(<span class=\"built_in\">NSString</span> *)string;</span><br></pre></td></tr></table></figure>\n<p>它可以帮助我们将正则表达式加上”\\”进行保护，将元字符转化成字面值。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果你只是简单的匹配用户输入内容是否匹配，<strong>NSString实例方法</strong>和<strong>谓词</strong>方法会方便简洁的给你答案，如果你是想要更加强大的匹配支持<strong>NSRegularExpression</strong>完全能够满足你的需要。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://my.oschina.net/u/2340880/blog/403638\" target=\"_blank\" rel=\"noopener\">iOS中正则表达式的使用</a></p>\n"},{"title":"block使用小建议","date":"2016-09-04T06:29:07.000Z","_content":"\n## 原文链接\n* [南峰子_老驴#iOS知识小集](http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501)\n* [Why do nil / NULL blocks cause bus errors when run?](http://stackoverflow.com/questions/4145164/why-do-nil-null-blocks-cause-bus-errors-when-run)\n\niOS开发中使用到`block`的机会非常多，经常会遇到block为nil或者NULL时程序会崩溃，\n例如\n{% asset_img Snip20160904_1.png block crash %}\n{% asset_img Snip20160904_2.png block crash %}\n\n但是别的Objective-C对象为空就不会出现崩溃的情况\n```Objc\nNSArray *foo = nil;\nNSLog(@\"%zd\", [foo count]); // 正常运行\n```\n所以，每次调用block之前我们都需要判断block是否存在\n```Objc\nif (mBlock) {\n\tmBlock();\n}\n```\n## 分析异常\n调用nil的block会崩溃，抛出的异常是`EXC_BAD_ACCESS(code=1, address=0xc)`（32位系统是0xc，64位是0x10）。这个异常表示程序在试图读取内存地址为0xc的信息时出错。\n\n在定一个block时，编译器在栈上创建了个结构体，结构体类似\n```c\nstruct Block_layout {\n    void *isa;\n    int flags;\n    int reserved;\n    void (*invoke)(void *, ...);\n    struct Block_descriptor *descriptor;\n    /* Imported variables. */\n};\n```\nblock就是指向这个结构体指针。其中的`invoke`就是指向具体实现的函数指针。当block被调用时，程序最终会跳转到这个函数指针(`invoke`)指向的代码区。而当block为nil时，程序就会试图去读取0xc地址的信息，而这个地址什么都不会有(duff address)，于是抛出一个segmentation fault。在32位系统下，之所以是0xc，是因为invoke前面的三个成员变量的大小正好是12。\n\n所以我们在使用block时，应该首先去判断block是否为空。一种比较优雅的写法是：\n\n```Objc\n!block ?: block()\n```\n\n\n\n","source":"_posts/block-tips.md","raw":"---\ntitle: block使用小建议\ndate: 2016-09-04 14:29:07\ntags: Block\ncategory: Tips\n---\n\n## 原文链接\n* [南峰子_老驴#iOS知识小集](http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501)\n* [Why do nil / NULL blocks cause bus errors when run?](http://stackoverflow.com/questions/4145164/why-do-nil-null-blocks-cause-bus-errors-when-run)\n\niOS开发中使用到`block`的机会非常多，经常会遇到block为nil或者NULL时程序会崩溃，\n例如\n{% asset_img Snip20160904_1.png block crash %}\n{% asset_img Snip20160904_2.png block crash %}\n\n但是别的Objective-C对象为空就不会出现崩溃的情况\n```Objc\nNSArray *foo = nil;\nNSLog(@\"%zd\", [foo count]); // 正常运行\n```\n所以，每次调用block之前我们都需要判断block是否存在\n```Objc\nif (mBlock) {\n\tmBlock();\n}\n```\n## 分析异常\n调用nil的block会崩溃，抛出的异常是`EXC_BAD_ACCESS(code=1, address=0xc)`（32位系统是0xc，64位是0x10）。这个异常表示程序在试图读取内存地址为0xc的信息时出错。\n\n在定一个block时，编译器在栈上创建了个结构体，结构体类似\n```c\nstruct Block_layout {\n    void *isa;\n    int flags;\n    int reserved;\n    void (*invoke)(void *, ...);\n    struct Block_descriptor *descriptor;\n    /* Imported variables. */\n};\n```\nblock就是指向这个结构体指针。其中的`invoke`就是指向具体实现的函数指针。当block被调用时，程序最终会跳转到这个函数指针(`invoke`)指向的代码区。而当block为nil时，程序就会试图去读取0xc地址的信息，而这个地址什么都不会有(duff address)，于是抛出一个segmentation fault。在32位系统下，之所以是0xc，是因为invoke前面的三个成员变量的大小正好是12。\n\n所以我们在使用block时，应该首先去判断block是否为空。一种比较优雅的写法是：\n\n```Objc\n!block ?: block()\n```\n\n\n\n","slug":"block-tips","published":1,"updated":"2016-09-11T05:40:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7l700188jpbb6jynqb5","content":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><ul>\n<li><a href=\"http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501\" target=\"_blank\" rel=\"noopener\">南峰子_老驴#iOS知识小集</a></li>\n<li><a href=\"http://stackoverflow.com/questions/4145164/why-do-nil-null-blocks-cause-bus-errors-when-run\" target=\"_blank\" rel=\"noopener\">Why do nil / NULL blocks cause bus errors when run?</a></li>\n</ul>\n<p>iOS开发中使用到<code>block</code>的机会非常多，经常会遇到block为nil或者NULL时程序会崩溃，<br>例如<br><img src=\"/2016/09/04/block-tips/Snip20160904_1.png\" title=\"block crash\"><br><img src=\"/2016/09/04/block-tips/Snip20160904_2.png\" title=\"block crash\"></p>\n<p>但是别的Objective-C对象为空就不会出现崩溃的情况<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *foo = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%zd\"</span>, [foo count]); <span class=\"comment\">// 正常运行</span></span><br></pre></td></tr></table></figure></p>\n<p>所以，每次调用block之前我们都需要判断block是否存在<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mBlock) &#123;</span><br><span class=\"line\">\tmBlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"分析异常\"><a href=\"#分析异常\" class=\"headerlink\" title=\"分析异常\"></a>分析异常</h2><p>调用nil的block会崩溃，抛出的异常是<code>EXC_BAD_ACCESS(code=1, address=0xc)</code>（32位系统是0xc，64位是0x10）。这个异常表示程序在试图读取内存地址为0xc的信息时出错。</p>\n<p>在定一个block时，编译器在栈上创建了个结构体，结构体类似<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Block_layout</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *isa;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> reserved;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Block_descriptor</span> *<span class=\"title\">descriptor</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Imported variables. */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>block就是指向这个结构体指针。其中的<code>invoke</code>就是指向具体实现的函数指针。当block被调用时，程序最终会跳转到这个函数指针(<code>invoke</code>)指向的代码区。而当block为nil时，程序就会试图去读取0xc地址的信息，而这个地址什么都不会有(duff address)，于是抛出一个segmentation fault。在32位系统下，之所以是0xc，是因为invoke前面的三个成员变量的大小正好是12。</p>\n<p>所以我们在使用block时，应该首先去判断block是否为空。一种比较优雅的写法是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!block ?: block()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><ul>\n<li><a href=\"http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501\" target=\"_blank\" rel=\"noopener\">南峰子_老驴#iOS知识小集</a></li>\n<li><a href=\"http://stackoverflow.com/questions/4145164/why-do-nil-null-blocks-cause-bus-errors-when-run\" target=\"_blank\" rel=\"noopener\">Why do nil / NULL blocks cause bus errors when run?</a></li>\n</ul>\n<p>iOS开发中使用到<code>block</code>的机会非常多，经常会遇到block为nil或者NULL时程序会崩溃，<br>例如<br><img src=\"/2016/09/04/block-tips/Snip20160904_1.png\" title=\"block crash\"><br><img src=\"/2016/09/04/block-tips/Snip20160904_2.png\" title=\"block crash\"></p>\n<p>但是别的Objective-C对象为空就不会出现崩溃的情况<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *foo = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%zd\"</span>, [foo count]); <span class=\"comment\">// 正常运行</span></span><br></pre></td></tr></table></figure></p>\n<p>所以，每次调用block之前我们都需要判断block是否存在<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mBlock) &#123;</span><br><span class=\"line\">\tmBlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"分析异常\"><a href=\"#分析异常\" class=\"headerlink\" title=\"分析异常\"></a>分析异常</h2><p>调用nil的block会崩溃，抛出的异常是<code>EXC_BAD_ACCESS(code=1, address=0xc)</code>（32位系统是0xc，64位是0x10）。这个异常表示程序在试图读取内存地址为0xc的信息时出错。</p>\n<p>在定一个block时，编译器在栈上创建了个结构体，结构体类似<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Block_layout</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *isa;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> reserved;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Block_descriptor</span> *<span class=\"title\">descriptor</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Imported variables. */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>block就是指向这个结构体指针。其中的<code>invoke</code>就是指向具体实现的函数指针。当block被调用时，程序最终会跳转到这个函数指针(<code>invoke</code>)指向的代码区。而当block为nil时，程序就会试图去读取0xc地址的信息，而这个地址什么都不会有(duff address)，于是抛出一个segmentation fault。在32位系统下，之所以是0xc，是因为invoke前面的三个成员变量的大小正好是12。</p>\n<p>所以我们在使用block时，应该首先去判断block是否为空。一种比较优雅的写法是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!block ?: block()</span><br></pre></td></tr></table></figure>\n"},{"title":"bool与BOOL","date":"2017-02-12T06:50:13.000Z","_content":"\n## 前言\n\n过完年后，总有有些懒惰，加上公司工作任务繁重，所以好久没更新自己的学习了。今天就来了解下Objective-C中的bool和BOOL。\n\n## 历史\n\nObjective-C 是在 C语言的基础上，增加了面向对象与动态语言的特性的语言，很多基本数据类型都是直接来自C语言。\n\nC语言在刚开始时，并没有布尔类型，所以Objective-C语言在发展的过程中，定义了自己的`BOOL`，但是在C99标准中，C语言又有了自己的布尔类型`bool`，并且**Objective-C又可以和C++混编成Objective-C++，C++里头也有bool**。\n\n## 差别\n\n那么，Objective-C 的 BOOL，和 C99 以及 C++ 的bool的差别在哪里？\n先看看 Objective-C 中 iOS 10 SDK的头文件定义：\n\n\n```objc\n#include <stdbool.h>\n\n....\n\n#define OBJC_BOOL_DEFINED\n\n/// Type to represent a boolean value.\n#if (TARGET_OS_IPHONE && __LP64__)  ||  TARGET_OS_WATCH\n#define OBJC_BOOL_IS_BOOL 1\ntypedef bool BOOL;\n#else\n#define OBJC_BOOL_IS_CHAR 1\ntypedef signed char BOOL; \n// BOOL is explicitly signed so @encode(BOOL) == \"c\" rather than \"C\" \n// even if -funsigned-char is used.\n#endif\n\n#if __has_feature(objc_bool)\n#define YES __objc_yes\n#define NO  __objc_no\n#else\n#define YES ((BOOL)1)\n#define NO  ((BOOL)0)\n#endif\n```\n\n\n所以说，在 iOS 的64位系统或者在Apple Watch 上，Objective-C 的 BOOL 直接等于定义在  stdbool.h 里头的 bool，其实是 int，假如使用了C++，那么stdbool.h里面的定义就变成了C++的 bool。但是，如果是在 MacOS 或者 32位系统的 iOS ，BOOL会被定义成一个 char，而 BOOL 与 bool，就分别是一个 byte 或者是 四个 bytes 的差别。\n\n```objc\nNSLog(@\"YES: %zd\", sizeof(YES));\nNSLog(@\"true: %zd\", sizeof(true));\n```\n\n{% asset_img Snip20170305_1.png YES-true %}\n\n总的来说，在64位系统或者 Apple Watch上，BOOL 与 bool 并没有差别，但我们通常不能假设我们的代码只会在这个环境下运行，虽然其他环境下，使用 BOOL 或者是 bool 通常也没什么影响，但是既然某个 API 明确要求传入 BOOL，那么就传入 YES 或 NO，好像也没有非要传入 true 或 false 的理由。\n\n在 Xcode4.4 之后，增加了 literals 的写法，很简单的把 BOOL 转成 NSNumber，写成 `@(YES)` 或 `@(NO)`  ，另外在 Core Foundation 里面也定义了 `kCFBooleanTrue` 與 `kCFBooleanFalse` 也具有同样的功能。\n\n## 参考链接\n* [KKBOX iOS/Mac OS X 基本開發教材](https://www.gitbook.com/book/zonble/kkbox-ios-dev/details)\n\n\n","source":"_posts/bool-BOOL.md","raw":"---\ntitle: bool与BOOL\ndate: 2017-02-12 14:50:13\ntags: 基础数据类型\ncategory: 拿来主义\n---\n\n## 前言\n\n过完年后，总有有些懒惰，加上公司工作任务繁重，所以好久没更新自己的学习了。今天就来了解下Objective-C中的bool和BOOL。\n\n## 历史\n\nObjective-C 是在 C语言的基础上，增加了面向对象与动态语言的特性的语言，很多基本数据类型都是直接来自C语言。\n\nC语言在刚开始时，并没有布尔类型，所以Objective-C语言在发展的过程中，定义了自己的`BOOL`，但是在C99标准中，C语言又有了自己的布尔类型`bool`，并且**Objective-C又可以和C++混编成Objective-C++，C++里头也有bool**。\n\n## 差别\n\n那么，Objective-C 的 BOOL，和 C99 以及 C++ 的bool的差别在哪里？\n先看看 Objective-C 中 iOS 10 SDK的头文件定义：\n\n\n```objc\n#include <stdbool.h>\n\n....\n\n#define OBJC_BOOL_DEFINED\n\n/// Type to represent a boolean value.\n#if (TARGET_OS_IPHONE && __LP64__)  ||  TARGET_OS_WATCH\n#define OBJC_BOOL_IS_BOOL 1\ntypedef bool BOOL;\n#else\n#define OBJC_BOOL_IS_CHAR 1\ntypedef signed char BOOL; \n// BOOL is explicitly signed so @encode(BOOL) == \"c\" rather than \"C\" \n// even if -funsigned-char is used.\n#endif\n\n#if __has_feature(objc_bool)\n#define YES __objc_yes\n#define NO  __objc_no\n#else\n#define YES ((BOOL)1)\n#define NO  ((BOOL)0)\n#endif\n```\n\n\n所以说，在 iOS 的64位系统或者在Apple Watch 上，Objective-C 的 BOOL 直接等于定义在  stdbool.h 里头的 bool，其实是 int，假如使用了C++，那么stdbool.h里面的定义就变成了C++的 bool。但是，如果是在 MacOS 或者 32位系统的 iOS ，BOOL会被定义成一个 char，而 BOOL 与 bool，就分别是一个 byte 或者是 四个 bytes 的差别。\n\n```objc\nNSLog(@\"YES: %zd\", sizeof(YES));\nNSLog(@\"true: %zd\", sizeof(true));\n```\n\n{% asset_img Snip20170305_1.png YES-true %}\n\n总的来说，在64位系统或者 Apple Watch上，BOOL 与 bool 并没有差别，但我们通常不能假设我们的代码只会在这个环境下运行，虽然其他环境下，使用 BOOL 或者是 bool 通常也没什么影响，但是既然某个 API 明确要求传入 BOOL，那么就传入 YES 或 NO，好像也没有非要传入 true 或 false 的理由。\n\n在 Xcode4.4 之后，增加了 literals 的写法，很简单的把 BOOL 转成 NSNumber，写成 `@(YES)` 或 `@(NO)`  ，另外在 Core Foundation 里面也定义了 `kCFBooleanTrue` 與 `kCFBooleanFalse` 也具有同样的功能。\n\n## 参考链接\n* [KKBOX iOS/Mac OS X 基本開發教材](https://www.gitbook.com/book/zonble/kkbox-ios-dev/details)\n\n\n","slug":"bool-BOOL","published":1,"updated":"2017-03-05T07:32:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7l8001b8jpbff2s4ojs","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>过完年后，总有有些懒惰，加上公司工作任务繁重，所以好久没更新自己的学习了。今天就来了解下Objective-C中的bool和BOOL。</p>\n<h2 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h2><p>Objective-C 是在 C语言的基础上，增加了面向对象与动态语言的特性的语言，很多基本数据类型都是直接来自C语言。</p>\n<p>C语言在刚开始时，并没有布尔类型，所以Objective-C语言在发展的过程中，定义了自己的<code>BOOL</code>，但是在C99标准中，C语言又有了自己的布尔类型<code>bool</code>，并且<strong>Objective-C又可以和C++混编成Objective-C++，C++里头也有bool</strong>。</p>\n<h2 id=\"差别\"><a href=\"#差别\" class=\"headerlink\" title=\"差别\"></a>差别</h2><p>那么，Objective-C 的 BOOL，和 C99 以及 C++ 的bool的差别在哪里？<br>先看看 Objective-C 中 iOS 10 SDK的头文件定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#include <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#define OBJC_BOOL_DEFINED</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Type to represent a boolean value.</span></span><br><span class=\"line\"><span class=\"meta\">#if (TARGET_OS_IPHONE &amp;&amp; __LP64__)  ||  TARGET_OS_WATCH</span></span><br><span class=\"line\"><span class=\"meta\">#define OBJC_BOOL_IS_BOOL 1</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">bool</span> <span class=\"built_in\">BOOL</span>;</span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"meta\">#define OBJC_BOOL_IS_CHAR 1</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> <span class=\"built_in\">BOOL</span>; </span><br><span class=\"line\"><span class=\"comment\">// BOOL is explicitly signed so @encode(BOOL) == \"c\" rather than \"C\" </span></span><br><span class=\"line\"><span class=\"comment\">// even if -funsigned-char is used.</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#if __has_feature(objc_bool)</span></span><br><span class=\"line\"><span class=\"meta\">#define YES __objc_yes</span></span><br><span class=\"line\"><span class=\"meta\">#define NO  __objc_no</span></span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"meta\">#define YES ((BOOL)1)</span></span><br><span class=\"line\"><span class=\"meta\">#define NO  ((BOOL)0)</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>所以说，在 iOS 的64位系统或者在Apple Watch 上，Objective-C 的 BOOL 直接等于定义在  stdbool.h 里头的 bool，其实是 int，假如使用了C++，那么stdbool.h里面的定义就变成了C++的 bool。但是，如果是在 MacOS 或者 32位系统的 iOS ，BOOL会被定义成一个 char，而 BOOL 与 bool，就分别是一个 byte 或者是 四个 bytes 的差别。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"YES: %zd\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"literal\">YES</span>));</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"true: %zd\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"literal\">true</span>));</span><br></pre></td></tr></table></figure>\n<img src=\"/2017/02/12/bool-BOOL/Snip20170305_1.png\" title=\"YES-true\">\n<p>总的来说，在64位系统或者 Apple Watch上，BOOL 与 bool 并没有差别，但我们通常不能假设我们的代码只会在这个环境下运行，虽然其他环境下，使用 BOOL 或者是 bool 通常也没什么影响，但是既然某个 API 明确要求传入 BOOL，那么就传入 YES 或 NO，好像也没有非要传入 true 或 false 的理由。</p>\n<p>在 Xcode4.4 之后，增加了 literals 的写法，很简单的把 BOOL 转成 NSNumber，写成 <code>@(YES)</code> 或 <code>@(NO)</code>  ，另外在 Core Foundation 里面也定义了 <code>kCFBooleanTrue</code> 與 <code>kCFBooleanFalse</code> 也具有同样的功能。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://www.gitbook.com/book/zonble/kkbox-ios-dev/details\" target=\"_blank\" rel=\"noopener\">KKBOX iOS/Mac OS X 基本開發教材</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>过完年后，总有有些懒惰，加上公司工作任务繁重，所以好久没更新自己的学习了。今天就来了解下Objective-C中的bool和BOOL。</p>\n<h2 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h2><p>Objective-C 是在 C语言的基础上，增加了面向对象与动态语言的特性的语言，很多基本数据类型都是直接来自C语言。</p>\n<p>C语言在刚开始时，并没有布尔类型，所以Objective-C语言在发展的过程中，定义了自己的<code>BOOL</code>，但是在C99标准中，C语言又有了自己的布尔类型<code>bool</code>，并且<strong>Objective-C又可以和C++混编成Objective-C++，C++里头也有bool</strong>。</p>\n<h2 id=\"差别\"><a href=\"#差别\" class=\"headerlink\" title=\"差别\"></a>差别</h2><p>那么，Objective-C 的 BOOL，和 C99 以及 C++ 的bool的差别在哪里？<br>先看看 Objective-C 中 iOS 10 SDK的头文件定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#include <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#define OBJC_BOOL_DEFINED</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Type to represent a boolean value.</span></span><br><span class=\"line\"><span class=\"meta\">#if (TARGET_OS_IPHONE &amp;&amp; __LP64__)  ||  TARGET_OS_WATCH</span></span><br><span class=\"line\"><span class=\"meta\">#define OBJC_BOOL_IS_BOOL 1</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">bool</span> <span class=\"built_in\">BOOL</span>;</span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"meta\">#define OBJC_BOOL_IS_CHAR 1</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> <span class=\"built_in\">BOOL</span>; </span><br><span class=\"line\"><span class=\"comment\">// BOOL is explicitly signed so @encode(BOOL) == \"c\" rather than \"C\" </span></span><br><span class=\"line\"><span class=\"comment\">// even if -funsigned-char is used.</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#if __has_feature(objc_bool)</span></span><br><span class=\"line\"><span class=\"meta\">#define YES __objc_yes</span></span><br><span class=\"line\"><span class=\"meta\">#define NO  __objc_no</span></span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"meta\">#define YES ((BOOL)1)</span></span><br><span class=\"line\"><span class=\"meta\">#define NO  ((BOOL)0)</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>所以说，在 iOS 的64位系统或者在Apple Watch 上，Objective-C 的 BOOL 直接等于定义在  stdbool.h 里头的 bool，其实是 int，假如使用了C++，那么stdbool.h里面的定义就变成了C++的 bool。但是，如果是在 MacOS 或者 32位系统的 iOS ，BOOL会被定义成一个 char，而 BOOL 与 bool，就分别是一个 byte 或者是 四个 bytes 的差别。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"YES: %zd\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"literal\">YES</span>));</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"true: %zd\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"literal\">true</span>));</span><br></pre></td></tr></table></figure>\n<img src=\"/2017/02/12/bool-BOOL/Snip20170305_1.png\" title=\"YES-true\">\n<p>总的来说，在64位系统或者 Apple Watch上，BOOL 与 bool 并没有差别，但我们通常不能假设我们的代码只会在这个环境下运行，虽然其他环境下，使用 BOOL 或者是 bool 通常也没什么影响，但是既然某个 API 明确要求传入 BOOL，那么就传入 YES 或 NO，好像也没有非要传入 true 或 false 的理由。</p>\n<p>在 Xcode4.4 之后，增加了 literals 的写法，很简单的把 BOOL 转成 NSNumber，写成 <code>@(YES)</code> 或 <code>@(NO)</code>  ，另外在 Core Foundation 里面也定义了 <code>kCFBooleanTrue</code> 與 <code>kCFBooleanFalse</code> 也具有同样的功能。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://www.gitbook.com/book/zonble/kkbox-ios-dev/details\" target=\"_blank\" rel=\"noopener\">KKBOX iOS/Mac OS X 基本開發教材</a></li>\n</ul>\n"},{"title":"检测一段iOS代码的执行效率函数","date":"2016-09-11T07:31:35.000Z","_content":"\n## 前言\n开发中我们经常需要检测**某个方法**或者**某段代码**具体的执行时间，有人使用NSDate来计算，但是这个类的精确度太差，你可以抛弃它了。\n\n其实在iOS中有个`mach_absolute_time()`函数可以获取到CPU的tickcount的计数值（貌似Android也有个获取精确时间的函数），获取到纳秒级的精确度。\n\n## 使用\n先导入头文件\n\n```objc\n#import <mach/mach_time.h>\n```\n\n简单使用\n```objc\nuint64_t start = mach_absolute_time();\nNSLog(@\"%f\", machTimeToSecs(start));\n    \nfor (NSInteger i = 0; i<10000; i++) {\n   [items addObject:@\"hello\"];\n}\n    \nuint64_t stop = mach_absolute_time();\nNSLog(@\"%f\", machTimeToSecs(stop));\n    \nNSLog(@\"%f\", subtractTimes(stop, start));\n```\n\n由于`mach_absolute_time()`返回的是纳米级别的时间，我们需要将转换成秒，可以使用下面的函数完成转换。\n\n```c\n// mach_absolute_times going in, seconds out\ndouble machTimeToSecs(uint64_t time)\n{\n    mach_timebase_info_data_t timebase;\n    mach_timebase_info(&timebase);\n    return (double)time * (double)timebase.numer /\n    (double)timebase.denom / 1e9;\n}\n```\n\n或者直接点，将开始和结束的时间都传入，返回计算并转换好的秒数。\n\n```c\n//Raw mach_absolute_times going in,difference in seconds out\ndouble subtractTimes( uint64_t endTime, uint64_t startTime )\n{\n    uint64_t difference = endTime - startTime;\n    static double conversion = 0.0;\n    if( conversion == 0.0 )\n    {\n        mach_timebase_info_data_t info;\n        kern_return_t err =mach_timebase_info( &info );\n        //Convert the timebase into seconds\n        if( err == 0  )\n            conversion= 1e-9 * (double) info.numer / (double) info.denom;\n    } \n    return conversion * (double)difference; \n}\n```\n\n## 参考链接\n* [性能和时间](http://www.cocoachina.com/industry/20130608/6362.html)\n* [Quick Performance Measurements](http://iosdeveloperzone.com/2011/05/03/quick-performance-measurements/)\n\n\n","source":"_posts/code-execution-efficiency-function.md","raw":"---\ntitle: 检测一段iOS代码的执行效率函数\ndate: 2016-09-11 15:31:35\ntags: 效率\ncategory: Tips\n---\n\n## 前言\n开发中我们经常需要检测**某个方法**或者**某段代码**具体的执行时间，有人使用NSDate来计算，但是这个类的精确度太差，你可以抛弃它了。\n\n其实在iOS中有个`mach_absolute_time()`函数可以获取到CPU的tickcount的计数值（貌似Android也有个获取精确时间的函数），获取到纳秒级的精确度。\n\n## 使用\n先导入头文件\n\n```objc\n#import <mach/mach_time.h>\n```\n\n简单使用\n```objc\nuint64_t start = mach_absolute_time();\nNSLog(@\"%f\", machTimeToSecs(start));\n    \nfor (NSInteger i = 0; i<10000; i++) {\n   [items addObject:@\"hello\"];\n}\n    \nuint64_t stop = mach_absolute_time();\nNSLog(@\"%f\", machTimeToSecs(stop));\n    \nNSLog(@\"%f\", subtractTimes(stop, start));\n```\n\n由于`mach_absolute_time()`返回的是纳米级别的时间，我们需要将转换成秒，可以使用下面的函数完成转换。\n\n```c\n// mach_absolute_times going in, seconds out\ndouble machTimeToSecs(uint64_t time)\n{\n    mach_timebase_info_data_t timebase;\n    mach_timebase_info(&timebase);\n    return (double)time * (double)timebase.numer /\n    (double)timebase.denom / 1e9;\n}\n```\n\n或者直接点，将开始和结束的时间都传入，返回计算并转换好的秒数。\n\n```c\n//Raw mach_absolute_times going in,difference in seconds out\ndouble subtractTimes( uint64_t endTime, uint64_t startTime )\n{\n    uint64_t difference = endTime - startTime;\n    static double conversion = 0.0;\n    if( conversion == 0.0 )\n    {\n        mach_timebase_info_data_t info;\n        kern_return_t err =mach_timebase_info( &info );\n        //Convert the timebase into seconds\n        if( err == 0  )\n            conversion= 1e-9 * (double) info.numer / (double) info.denom;\n    } \n    return conversion * (double)difference; \n}\n```\n\n## 参考链接\n* [性能和时间](http://www.cocoachina.com/industry/20130608/6362.html)\n* [Quick Performance Measurements](http://iosdeveloperzone.com/2011/05/03/quick-performance-measurements/)\n\n\n","slug":"code-execution-efficiency-function","published":1,"updated":"2016-09-11T08:13:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7la001g8jpboeklfkqx","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>开发中我们经常需要检测<strong>某个方法</strong>或者<strong>某段代码</strong>具体的执行时间，有人使用NSDate来计算，但是这个类的精确度太差，你可以抛弃它了。</p>\n<p>其实在iOS中有个<code>mach_absolute_time()</code>函数可以获取到CPU的tickcount的计数值（貌似Android也有个获取精确时间的函数），获取到纳秒级的精确度。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>先导入头文件</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;mach/mach_time.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>简单使用<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint64_t start = mach_absolute_time();</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%f\"</span>, machTimeToSecs(start));</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">   [items addObject:<span class=\"string\">@\"hello\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">uint64_t stop = mach_absolute_time();</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%f\"</span>, machTimeToSecs(stop));</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%f\"</span>, subtractTimes(stop, start));</span><br></pre></td></tr></table></figure></p>\n<p>由于<code>mach_absolute_time()</code>返回的是纳米级别的时间，我们需要将转换成秒，可以使用下面的函数完成转换。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mach_absolute_times going in, seconds out</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">machTimeToSecs</span><span class=\"params\">(<span class=\"keyword\">uint64_t</span> time)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">mach_timebase_info_data_t</span> timebase;</span><br><span class=\"line\">    mach_timebase_info(&amp;timebase);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">double</span>)time * (<span class=\"keyword\">double</span>)timebase.numer /</span><br><span class=\"line\">    (<span class=\"keyword\">double</span>)timebase.denom / <span class=\"number\">1e9</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者直接点，将开始和结束的时间都传入，返回计算并转换好的秒数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Raw mach_absolute_times going in,difference in seconds out</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">subtractTimes</span><span class=\"params\">( <span class=\"keyword\">uint64_t</span> endTime, <span class=\"keyword\">uint64_t</span> startTime )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> difference = endTime - startTime;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> conversion = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( conversion == <span class=\"number\">0.0</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">mach_timebase_info_data_t</span> info;</span><br><span class=\"line\">        <span class=\"keyword\">kern_return_t</span> err =mach_timebase_info( &amp;info );</span><br><span class=\"line\">        <span class=\"comment\">//Convert the timebase into seconds</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( err == <span class=\"number\">0</span>  )</span><br><span class=\"line\">            conversion= <span class=\"number\">1e-9</span> * (<span class=\"keyword\">double</span>) info.numer / (<span class=\"keyword\">double</span>) info.denom;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> conversion * (<span class=\"keyword\">double</span>)difference; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://www.cocoachina.com/industry/20130608/6362.html\" target=\"_blank\" rel=\"noopener\">性能和时间</a></li>\n<li><a href=\"http://iosdeveloperzone.com/2011/05/03/quick-performance-measurements/\" target=\"_blank\" rel=\"noopener\">Quick Performance Measurements</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>开发中我们经常需要检测<strong>某个方法</strong>或者<strong>某段代码</strong>具体的执行时间，有人使用NSDate来计算，但是这个类的精确度太差，你可以抛弃它了。</p>\n<p>其实在iOS中有个<code>mach_absolute_time()</code>函数可以获取到CPU的tickcount的计数值（貌似Android也有个获取精确时间的函数），获取到纳秒级的精确度。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>先导入头文件</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;mach/mach_time.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>简单使用<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint64_t start = mach_absolute_time();</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%f\"</span>, machTimeToSecs(start));</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">   [items addObject:<span class=\"string\">@\"hello\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">uint64_t stop = mach_absolute_time();</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%f\"</span>, machTimeToSecs(stop));</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%f\"</span>, subtractTimes(stop, start));</span><br></pre></td></tr></table></figure></p>\n<p>由于<code>mach_absolute_time()</code>返回的是纳米级别的时间，我们需要将转换成秒，可以使用下面的函数完成转换。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mach_absolute_times going in, seconds out</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">machTimeToSecs</span><span class=\"params\">(<span class=\"keyword\">uint64_t</span> time)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">mach_timebase_info_data_t</span> timebase;</span><br><span class=\"line\">    mach_timebase_info(&amp;timebase);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">double</span>)time * (<span class=\"keyword\">double</span>)timebase.numer /</span><br><span class=\"line\">    (<span class=\"keyword\">double</span>)timebase.denom / <span class=\"number\">1e9</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者直接点，将开始和结束的时间都传入，返回计算并转换好的秒数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Raw mach_absolute_times going in,difference in seconds out</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">subtractTimes</span><span class=\"params\">( <span class=\"keyword\">uint64_t</span> endTime, <span class=\"keyword\">uint64_t</span> startTime )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> difference = endTime - startTime;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> conversion = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( conversion == <span class=\"number\">0.0</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">mach_timebase_info_data_t</span> info;</span><br><span class=\"line\">        <span class=\"keyword\">kern_return_t</span> err =mach_timebase_info( &amp;info );</span><br><span class=\"line\">        <span class=\"comment\">//Convert the timebase into seconds</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( err == <span class=\"number\">0</span>  )</span><br><span class=\"line\">            conversion= <span class=\"number\">1e-9</span> * (<span class=\"keyword\">double</span>) info.numer / (<span class=\"keyword\">double</span>) info.denom;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> conversion * (<span class=\"keyword\">double</span>)difference; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://www.cocoachina.com/industry/20130608/6362.html\" target=\"_blank\" rel=\"noopener\">性能和时间</a></li>\n<li><a href=\"http://iosdeveloperzone.com/2011/05/03/quick-performance-measurements/\" target=\"_blank\" rel=\"noopener\">Quick Performance Measurements</a></li>\n</ul>\n"},{"title":"iOS 实际开发中使用到的小技巧","date":"2017-07-01T08:17:11.000Z","_content":"\n## 前言\n\n以下是我收集的关于 iOS 开发提高效率的小技巧。\n\n## 一、如何快速的查看一段代码的执行时间\n\n\n```objc\n#define TICK   NSDate *startTime = [NSDate date]\n#define TOCK   NSLog(@\"Time: %f\", -[startTime timeIntervalSinceNow])\n```\n\n在想要查看执行时间的代码的地方进行这么处理\n\n```objc\nTICK\n//do your work here\nTOC\n```\n\n## 二、如何快速查看一个函数的调用次数，且不添加一句代码\n\n在 if 或者 for 打个断点，然后编辑断点。\n\n{% asset_img calculate-the-number-of-calls.jpg calculate-the-number-of-calls %}\n\n这种方法适合于一个if方法，一个for循环，而且不会中断程序，且不需要加一句代码。但是一定要记得选中下面的 **automatically continue after evaluting actions**;\n\n## 三、快速手机截屏\n\n在iOS开发中我们在和产品和设计沟通的时候我们经常需要截取手机的屏幕或者模拟器上的屏幕，我们用手机可能会使用 Home 键 + 开机键，然后再通过 iPhoto 或者在手机用 qq 传过去，但是我教大家一个方法直接使用快捷键截取手机上的图到电脑桌面上。\n\n{% asset_img take-screenshot.jpg take-screenshot %}\n\n在 Xcode的 debug菜单中找到 **viewDebugging**,即使当前程序没有运行，也可以直接截取手机上的图片直接到桌面。（哈哈哈这样再不需要TM的按TM的手机上的按键再用 iPhoto拷贝到桌面了）。年轻人你以为这样就完了吗！？你还是太稚嫩啊，谁TM的想找到这个debug菜单再找到下面的一堆东西，当然要改成快捷键了，如何做看下图。\n\n{% asset_img take-screenshot-fast.jpg take-screenshot-fast %}\n\n看到这个血淋漓的红色的箭头了嘛，你首先找到 debug 的快捷键菜单项，在把它改成 ?+?这个，这时候有冲突了怎么办？你不知道有没有影响到其他快捷键怎么办，小傻瓜，改呗！把以前的这个功能去掉?+?（ps:以前的就是 show complete list 如同点击一个?一个效果，那你还要它做嘛啊?），为什么改成这个份听哥的，你改成这个绝壁会用着特别爽。（好了以后要给产品还是设计发图分分钟的事情了~~）\n\n## 四、iOS调试技巧只显示图片的对齐尺寸和 frame\n\n我记得以前一个说显示对齐尺寸的，他是这么做的：\n\n“在应项目的Edit Scheme中设置一个启动参数 **UIViewShowAlignmentRects** 并将参数值设置为YES，可以让程序在运行时显示视图的对齐矩阵（alignment rectangle）。”\n\n这种方式太麻烦了，有个更简单的方式，上个截图 **viewDebuging** 中有 **showViewFrame** 和 **ShowAlignmentRects**，当然点击这些菜单就会出现我这些效果了。\n\n{% asset_img debug-frame.gif debug-frame %}\n\n## 五、计算UIImageView在视图中位置的函数\n\n`AVMakeRectWithAspectRatioInsideRect` 通过这个函数，我们可以计算一个图片放在另一个 view 按照一定的比例居中显示。比如，将一个 UIImageView 居中显示到一个 View 中，那么UIImageView 居中后，X 和 Y 的值是多少，通过该函数能够非常方便的计算出来。\n\n{% asset_img AVMakeRectWithAspectRatioInsideRect.jpeg AVMakeRectWithAspectRatioInsideRect %}\n\n```objc\n// 将要显示的图片size放到第一个参数，第二个参数是装载UIImageView的View容器frame\n// 函数返回的frame就是图片居中显示的frame\nCGRect imageViewAspectRect = AVMakeRectWithAspectRatioInsideRect(CGSizeMake(image.size.width, image.size.height), _videoPicBackground.frame);\n// 赋值\nmageView.frame = imageViewAspectRect;\n```\n\n函数在AV库中，记得引入头文件\n\n```objc\n#import <AVFoundation/AVFoundation.h>\n```\n\n\n## 参考链接\n[iOS 开发的一些小技巧篇一](http://www.jianshu.com/p/221507eb8590)\n[iOS 开发的一些小技巧篇二](http://www.jianshu.com/p/80ebbb1950ba)\n[iOS 开发的一些小技巧篇三](http://www.jianshu.com/p/827090aa933b)\n\n\n\n\n\n\n","source":"_posts/collect-tips.md","raw":"---\ntitle: iOS 实际开发中使用到的小技巧\ndate: 2017-07-01 16:17:11\ntags: Debug\ncategory: Tips\n---\n\n## 前言\n\n以下是我收集的关于 iOS 开发提高效率的小技巧。\n\n## 一、如何快速的查看一段代码的执行时间\n\n\n```objc\n#define TICK   NSDate *startTime = [NSDate date]\n#define TOCK   NSLog(@\"Time: %f\", -[startTime timeIntervalSinceNow])\n```\n\n在想要查看执行时间的代码的地方进行这么处理\n\n```objc\nTICK\n//do your work here\nTOC\n```\n\n## 二、如何快速查看一个函数的调用次数，且不添加一句代码\n\n在 if 或者 for 打个断点，然后编辑断点。\n\n{% asset_img calculate-the-number-of-calls.jpg calculate-the-number-of-calls %}\n\n这种方法适合于一个if方法，一个for循环，而且不会中断程序，且不需要加一句代码。但是一定要记得选中下面的 **automatically continue after evaluting actions**;\n\n## 三、快速手机截屏\n\n在iOS开发中我们在和产品和设计沟通的时候我们经常需要截取手机的屏幕或者模拟器上的屏幕，我们用手机可能会使用 Home 键 + 开机键，然后再通过 iPhoto 或者在手机用 qq 传过去，但是我教大家一个方法直接使用快捷键截取手机上的图到电脑桌面上。\n\n{% asset_img take-screenshot.jpg take-screenshot %}\n\n在 Xcode的 debug菜单中找到 **viewDebugging**,即使当前程序没有运行，也可以直接截取手机上的图片直接到桌面。（哈哈哈这样再不需要TM的按TM的手机上的按键再用 iPhoto拷贝到桌面了）。年轻人你以为这样就完了吗！？你还是太稚嫩啊，谁TM的想找到这个debug菜单再找到下面的一堆东西，当然要改成快捷键了，如何做看下图。\n\n{% asset_img take-screenshot-fast.jpg take-screenshot-fast %}\n\n看到这个血淋漓的红色的箭头了嘛，你首先找到 debug 的快捷键菜单项，在把它改成 ?+?这个，这时候有冲突了怎么办？你不知道有没有影响到其他快捷键怎么办，小傻瓜，改呗！把以前的这个功能去掉?+?（ps:以前的就是 show complete list 如同点击一个?一个效果，那你还要它做嘛啊?），为什么改成这个份听哥的，你改成这个绝壁会用着特别爽。（好了以后要给产品还是设计发图分分钟的事情了~~）\n\n## 四、iOS调试技巧只显示图片的对齐尺寸和 frame\n\n我记得以前一个说显示对齐尺寸的，他是这么做的：\n\n“在应项目的Edit Scheme中设置一个启动参数 **UIViewShowAlignmentRects** 并将参数值设置为YES，可以让程序在运行时显示视图的对齐矩阵（alignment rectangle）。”\n\n这种方式太麻烦了，有个更简单的方式，上个截图 **viewDebuging** 中有 **showViewFrame** 和 **ShowAlignmentRects**，当然点击这些菜单就会出现我这些效果了。\n\n{% asset_img debug-frame.gif debug-frame %}\n\n## 五、计算UIImageView在视图中位置的函数\n\n`AVMakeRectWithAspectRatioInsideRect` 通过这个函数，我们可以计算一个图片放在另一个 view 按照一定的比例居中显示。比如，将一个 UIImageView 居中显示到一个 View 中，那么UIImageView 居中后，X 和 Y 的值是多少，通过该函数能够非常方便的计算出来。\n\n{% asset_img AVMakeRectWithAspectRatioInsideRect.jpeg AVMakeRectWithAspectRatioInsideRect %}\n\n```objc\n// 将要显示的图片size放到第一个参数，第二个参数是装载UIImageView的View容器frame\n// 函数返回的frame就是图片居中显示的frame\nCGRect imageViewAspectRect = AVMakeRectWithAspectRatioInsideRect(CGSizeMake(image.size.width, image.size.height), _videoPicBackground.frame);\n// 赋值\nmageView.frame = imageViewAspectRect;\n```\n\n函数在AV库中，记得引入头文件\n\n```objc\n#import <AVFoundation/AVFoundation.h>\n```\n\n\n## 参考链接\n[iOS 开发的一些小技巧篇一](http://www.jianshu.com/p/221507eb8590)\n[iOS 开发的一些小技巧篇二](http://www.jianshu.com/p/80ebbb1950ba)\n[iOS 开发的一些小技巧篇三](http://www.jianshu.com/p/827090aa933b)\n\n\n\n\n\n\n","slug":"collect-tips","published":1,"updated":"2017-11-05T10:32:19.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7lb001j8jpbk4d43fd0","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>以下是我收集的关于 iOS 开发提高效率的小技巧。</p>\n<h2 id=\"一、如何快速的查看一段代码的执行时间\"><a href=\"#一、如何快速的查看一段代码的执行时间\" class=\"headerlink\" title=\"一、如何快速的查看一段代码的执行时间\"></a>一、如何快速的查看一段代码的执行时间</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define TICK   NSDate *startTime = [NSDate date]</span></span><br><span class=\"line\"><span class=\"meta\">#define TOCK   NSLog(@<span class=\"meta-string\">\"Time: %f\"</span>, -[startTime timeIntervalSinceNow])</span></span><br></pre></td></tr></table></figure>\n<p>在想要查看执行时间的代码的地方进行这么处理</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TICK</span><br><span class=\"line\"><span class=\"comment\">//do your work here</span></span><br><span class=\"line\">TOC</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、如何快速查看一个函数的调用次数，且不添加一句代码\"><a href=\"#二、如何快速查看一个函数的调用次数，且不添加一句代码\" class=\"headerlink\" title=\"二、如何快速查看一个函数的调用次数，且不添加一句代码\"></a>二、如何快速查看一个函数的调用次数，且不添加一句代码</h2><p>在 if 或者 for 打个断点，然后编辑断点。</p>\n<img src=\"/2017/07/01/collect-tips/calculate-the-number-of-calls.jpg\" title=\"calculate-the-number-of-calls\">\n<p>这种方法适合于一个if方法，一个for循环，而且不会中断程序，且不需要加一句代码。但是一定要记得选中下面的 <strong>automatically continue after evaluting actions</strong>;</p>\n<h2 id=\"三、快速手机截屏\"><a href=\"#三、快速手机截屏\" class=\"headerlink\" title=\"三、快速手机截屏\"></a>三、快速手机截屏</h2><p>在iOS开发中我们在和产品和设计沟通的时候我们经常需要截取手机的屏幕或者模拟器上的屏幕，我们用手机可能会使用 Home 键 + 开机键，然后再通过 iPhoto 或者在手机用 qq 传过去，但是我教大家一个方法直接使用快捷键截取手机上的图到电脑桌面上。</p>\n<img src=\"/2017/07/01/collect-tips/take-screenshot.jpg\" title=\"take-screenshot\">\n<p>在 Xcode的 debug菜单中找到 <strong>viewDebugging</strong>,即使当前程序没有运行，也可以直接截取手机上的图片直接到桌面。（哈哈哈这样再不需要TM的按TM的手机上的按键再用 iPhoto拷贝到桌面了）。年轻人你以为这样就完了吗！？你还是太稚嫩啊，谁TM的想找到这个debug菜单再找到下面的一堆东西，当然要改成快捷键了，如何做看下图。</p>\n<img src=\"/2017/07/01/collect-tips/take-screenshot-fast.jpg\" title=\"take-screenshot-fast\">\n<p>看到这个血淋漓的红色的箭头了嘛，你首先找到 debug 的快捷键菜单项，在把它改成 ?+?这个，这时候有冲突了怎么办？你不知道有没有影响到其他快捷键怎么办，小傻瓜，改呗！把以前的这个功能去掉?+?（ps:以前的就是 show complete list 如同点击一个?一个效果，那你还要它做嘛啊?），为什么改成这个份听哥的，你改成这个绝壁会用着特别爽。（好了以后要给产品还是设计发图分分钟的事情了~~）</p>\n<h2 id=\"四、iOS调试技巧只显示图片的对齐尺寸和-frame\"><a href=\"#四、iOS调试技巧只显示图片的对齐尺寸和-frame\" class=\"headerlink\" title=\"四、iOS调试技巧只显示图片的对齐尺寸和 frame\"></a>四、iOS调试技巧只显示图片的对齐尺寸和 frame</h2><p>我记得以前一个说显示对齐尺寸的，他是这么做的：</p>\n<p>“在应项目的Edit Scheme中设置一个启动参数 <strong>UIViewShowAlignmentRects</strong> 并将参数值设置为YES，可以让程序在运行时显示视图的对齐矩阵（alignment rectangle）。”</p>\n<p>这种方式太麻烦了，有个更简单的方式，上个截图 <strong>viewDebuging</strong> 中有 <strong>showViewFrame</strong> 和 <strong>ShowAlignmentRects</strong>，当然点击这些菜单就会出现我这些效果了。</p>\n<img src=\"/2017/07/01/collect-tips/debug-frame.gif\" title=\"debug-frame\">\n<h2 id=\"五、计算UIImageView在视图中位置的函数\"><a href=\"#五、计算UIImageView在视图中位置的函数\" class=\"headerlink\" title=\"五、计算UIImageView在视图中位置的函数\"></a>五、计算UIImageView在视图中位置的函数</h2><p><code>AVMakeRectWithAspectRatioInsideRect</code> 通过这个函数，我们可以计算一个图片放在另一个 view 按照一定的比例居中显示。比如，将一个 UIImageView 居中显示到一个 View 中，那么UIImageView 居中后，X 和 Y 的值是多少，通过该函数能够非常方便的计算出来。</p>\n<img src=\"/2017/07/01/collect-tips/AVMakeRectWithAspectRatioInsideRect.jpeg\" title=\"AVMakeRectWithAspectRatioInsideRect\">\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将要显示的图片size放到第一个参数，第二个参数是装载UIImageView的View容器frame</span></span><br><span class=\"line\"><span class=\"comment\">// 函数返回的frame就是图片居中显示的frame</span></span><br><span class=\"line\"><span class=\"built_in\">CGRect</span> imageViewAspectRect = <span class=\"built_in\">AVMakeRectWithAspectRatioInsideRect</span>(<span class=\"built_in\">CGSizeMake</span>(image.size.width, image.size.height), _videoPicBackground.frame);</span><br><span class=\"line\"><span class=\"comment\">// 赋值</span></span><br><span class=\"line\">mageView.frame = imageViewAspectRect;</span><br></pre></td></tr></table></figure>\n<p>函数在AV库中，记得引入头文件</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://www.jianshu.com/p/221507eb8590\" target=\"_blank\" rel=\"noopener\">iOS 开发的一些小技巧篇一</a><br><a href=\"http://www.jianshu.com/p/80ebbb1950ba\" target=\"_blank\" rel=\"noopener\">iOS 开发的一些小技巧篇二</a><br><a href=\"http://www.jianshu.com/p/827090aa933b\" target=\"_blank\" rel=\"noopener\">iOS 开发的一些小技巧篇三</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>以下是我收集的关于 iOS 开发提高效率的小技巧。</p>\n<h2 id=\"一、如何快速的查看一段代码的执行时间\"><a href=\"#一、如何快速的查看一段代码的执行时间\" class=\"headerlink\" title=\"一、如何快速的查看一段代码的执行时间\"></a>一、如何快速的查看一段代码的执行时间</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define TICK   NSDate *startTime = [NSDate date]</span></span><br><span class=\"line\"><span class=\"meta\">#define TOCK   NSLog(@<span class=\"meta-string\">\"Time: %f\"</span>, -[startTime timeIntervalSinceNow])</span></span><br></pre></td></tr></table></figure>\n<p>在想要查看执行时间的代码的地方进行这么处理</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TICK</span><br><span class=\"line\"><span class=\"comment\">//do your work here</span></span><br><span class=\"line\">TOC</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、如何快速查看一个函数的调用次数，且不添加一句代码\"><a href=\"#二、如何快速查看一个函数的调用次数，且不添加一句代码\" class=\"headerlink\" title=\"二、如何快速查看一个函数的调用次数，且不添加一句代码\"></a>二、如何快速查看一个函数的调用次数，且不添加一句代码</h2><p>在 if 或者 for 打个断点，然后编辑断点。</p>\n<img src=\"/2017/07/01/collect-tips/calculate-the-number-of-calls.jpg\" title=\"calculate-the-number-of-calls\">\n<p>这种方法适合于一个if方法，一个for循环，而且不会中断程序，且不需要加一句代码。但是一定要记得选中下面的 <strong>automatically continue after evaluting actions</strong>;</p>\n<h2 id=\"三、快速手机截屏\"><a href=\"#三、快速手机截屏\" class=\"headerlink\" title=\"三、快速手机截屏\"></a>三、快速手机截屏</h2><p>在iOS开发中我们在和产品和设计沟通的时候我们经常需要截取手机的屏幕或者模拟器上的屏幕，我们用手机可能会使用 Home 键 + 开机键，然后再通过 iPhoto 或者在手机用 qq 传过去，但是我教大家一个方法直接使用快捷键截取手机上的图到电脑桌面上。</p>\n<img src=\"/2017/07/01/collect-tips/take-screenshot.jpg\" title=\"take-screenshot\">\n<p>在 Xcode的 debug菜单中找到 <strong>viewDebugging</strong>,即使当前程序没有运行，也可以直接截取手机上的图片直接到桌面。（哈哈哈这样再不需要TM的按TM的手机上的按键再用 iPhoto拷贝到桌面了）。年轻人你以为这样就完了吗！？你还是太稚嫩啊，谁TM的想找到这个debug菜单再找到下面的一堆东西，当然要改成快捷键了，如何做看下图。</p>\n<img src=\"/2017/07/01/collect-tips/take-screenshot-fast.jpg\" title=\"take-screenshot-fast\">\n<p>看到这个血淋漓的红色的箭头了嘛，你首先找到 debug 的快捷键菜单项，在把它改成 ?+?这个，这时候有冲突了怎么办？你不知道有没有影响到其他快捷键怎么办，小傻瓜，改呗！把以前的这个功能去掉?+?（ps:以前的就是 show complete list 如同点击一个?一个效果，那你还要它做嘛啊?），为什么改成这个份听哥的，你改成这个绝壁会用着特别爽。（好了以后要给产品还是设计发图分分钟的事情了~~）</p>\n<h2 id=\"四、iOS调试技巧只显示图片的对齐尺寸和-frame\"><a href=\"#四、iOS调试技巧只显示图片的对齐尺寸和-frame\" class=\"headerlink\" title=\"四、iOS调试技巧只显示图片的对齐尺寸和 frame\"></a>四、iOS调试技巧只显示图片的对齐尺寸和 frame</h2><p>我记得以前一个说显示对齐尺寸的，他是这么做的：</p>\n<p>“在应项目的Edit Scheme中设置一个启动参数 <strong>UIViewShowAlignmentRects</strong> 并将参数值设置为YES，可以让程序在运行时显示视图的对齐矩阵（alignment rectangle）。”</p>\n<p>这种方式太麻烦了，有个更简单的方式，上个截图 <strong>viewDebuging</strong> 中有 <strong>showViewFrame</strong> 和 <strong>ShowAlignmentRects</strong>，当然点击这些菜单就会出现我这些效果了。</p>\n<img src=\"/2017/07/01/collect-tips/debug-frame.gif\" title=\"debug-frame\">\n<h2 id=\"五、计算UIImageView在视图中位置的函数\"><a href=\"#五、计算UIImageView在视图中位置的函数\" class=\"headerlink\" title=\"五、计算UIImageView在视图中位置的函数\"></a>五、计算UIImageView在视图中位置的函数</h2><p><code>AVMakeRectWithAspectRatioInsideRect</code> 通过这个函数，我们可以计算一个图片放在另一个 view 按照一定的比例居中显示。比如，将一个 UIImageView 居中显示到一个 View 中，那么UIImageView 居中后，X 和 Y 的值是多少，通过该函数能够非常方便的计算出来。</p>\n<img src=\"/2017/07/01/collect-tips/AVMakeRectWithAspectRatioInsideRect.jpeg\" title=\"AVMakeRectWithAspectRatioInsideRect\">\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将要显示的图片size放到第一个参数，第二个参数是装载UIImageView的View容器frame</span></span><br><span class=\"line\"><span class=\"comment\">// 函数返回的frame就是图片居中显示的frame</span></span><br><span class=\"line\"><span class=\"built_in\">CGRect</span> imageViewAspectRect = <span class=\"built_in\">AVMakeRectWithAspectRatioInsideRect</span>(<span class=\"built_in\">CGSizeMake</span>(image.size.width, image.size.height), _videoPicBackground.frame);</span><br><span class=\"line\"><span class=\"comment\">// 赋值</span></span><br><span class=\"line\">mageView.frame = imageViewAspectRect;</span><br></pre></td></tr></table></figure>\n<p>函数在AV库中，记得引入头文件</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://www.jianshu.com/p/221507eb8590\" target=\"_blank\" rel=\"noopener\">iOS 开发的一些小技巧篇一</a><br><a href=\"http://www.jianshu.com/p/80ebbb1950ba\" target=\"_blank\" rel=\"noopener\">iOS 开发的一些小技巧篇二</a><br><a href=\"http://www.jianshu.com/p/827090aa933b\" target=\"_blank\" rel=\"noopener\">iOS 开发的一些小技巧篇三</a></p>\n"},{"title":"防止点击Cell时ViewController被重复Push","date":"2016-09-12T12:19:24.000Z","_content":"\n## 前言\n相信不少iOS开发者都遇到过点击`tableView(:didSelectRowAtIndexPath:)`push到别的界面，有些用户点击了cell后，可能会触发两次push，弹出两次别的界面。这种情况出现的概率比较小，在***快速双击*** 或者 ***长按cell稍微放开又按下***的情况下比较容易复现。\n\n为此去Google解决方案，找到这篇文章[《防止点击 Cell 时 ViewController 被重复 Push》](https://github.com/nixzhu/dev-blog/blob/master/2016-01-04-duplicate-push.md)，作者[@nixzhu](https://twitter.com/nixzhu)\n\n然后结合我的实际情况作出解决并摘录了一些原文内容。\n\n既然push了两次，那么`tableView(:didSelectRowAtIndexPath:)`一定被调用了两次。但又因为这是一个delegate方法，是由iOS来调用的，怎样才算被“选中”实在难以猜想，何况不同的 iOS 版本还可能有差异。不过我们仍然有办法做处理，毕竟它被调用了两次，就算是用**计数判断**的办法，我们也能防止同一次点击出现重复的 push。真实的问题是这种情况难以调试，因为问题很不容易出现，你怎么知道修改后的代码是工作的呢？\n\n## 解决\n原文章就给出了解决方案：\n\n```swift\nfunc tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {\n    defer {\n        tableView.deselectRowAtIndexPath(indexPath, animated: true)\n    }\n\n    if let navigationController = navigationController {\n        guard navigationController.topViewController == self else {\n            return\n        }\n    }\n\n    // TODO: performSegueWithIdentifier...\n}\n```\n这个代码是利用了 push 后，navigationController 的`ViewControllers stack` 会发生改变，那么其`topViewController`自然会发生改变。**所以在 push 之前，我们先保证此时的 topViewController 是当前 ViewController，这样就可避免重复 push，因为你第二次 push ，topViewController就变成了第一次 push 后的 ViewController 就会 return 掉**。\n\n原作者还用了 defer 关键字，也就是无论如何，我们都可以取消 cell 的选中。当然，我们还应该判断 navigationController 的存在性，因为当前的 ViewController 不一定内嵌在某个 UINavigationController 里，segue 也并非只有 push 一种，还有show。\n\n### 如何重现问题？\n我自己是快速点击两次cell，原作者是长按 cell，然后稍微减少手指的压力再立即增加压力，触发这个bug。（估计是UI业务逻辑有关吧，如果你没有观察到两次 push 间 viewControllers stack 的改变，那说明你遇到的问题更加诡异，此方法也可能不适用。）\n\n我通过打印的办法确认，在出现重复 push 的情况下，iOS 9.2 会调用两次 `tableView(:didSelectRowAtIndexPath:)`，但在此之间，第一次 performSegue 时，UINavigationController 的 viewControllers stack 就已经被改变了，也就是说，第二次就不会再 push 了。\n\n既然只要 performSegue 就能改变 UINavigationController 的 viewControllers stack，那我们也不需要在 tableView(:didSelectRowAtIndexPath:) 里做处理，直接重载 ViewController 的 `performSegueWithIdentifier(:sender:)` 即可：\n\n```objc\noverride func performSegueWithIdentifier(identifier: String, sender: AnyObject?) {\n    if let navigationController = navigationController {\n        guard navigationController.topViewController == self else {\n            return\n        }\n    }\n\n    super.performSegueWithIdentifier(identifier, sender: sender)\n}\n```\n\n这样代码逻辑会更好一点。进一步，若你的 app 里有许多 ViewController，也许它们都有可能出现重复 push。那为了避免重复代码，可以写一个基类让其他 ViewController 继承。\n\n**注意**，你可能会想说，怎么不在 `shouldPerformSegueWithIdentifier(:sender:)` 里做处理呢？不是更合理吗？\n\n这个方法看起来挺像这么回事，但可惜，`它只会作用于直接在 IB 里连线的 segue，如果你手动 performSegue，它并不会被调用`。这样的逻辑也说得通，毕竟你都手动调用了，哪还有shouldPerformSegue（该不该跳转）的问题呢？\n\n## 我的情况\n我的cell点击后的情况比较特殊：点击cell后调用异步网络请求，根据请求返回确定cell是否跳转，这又是个bug，因为请求是异步的，当你第一次请求还没回来没有 push （viewControllers stack未改变），第二次点击请求回来了并且已经 push ，这时第一次请求回来了又 push 一次，这样原作者的办法就无效了。\n\n两种方法解决：\n\n* 点击cell后增加个小菊花loading，让用户在请求回来前不能响应别的事件\n* 增加个Bool变量isClickCell，默认是NO。每次点击cell前判断是否为YES，如果是YES直接return，反之isClickCell赋值为YES，然后异步网络请求，网络请求不论成功或者失败都赋值为NO，让用户下次可以点击cell\n\n**这两种解决方法都不算特别突出，如果你有更好的解决办法，可以给我留言，我们交流交流。**\n\n## 参考链接\n[《防止点击 Cell 时 ViewController 被重复 Push》](https://github.com/nixzhu/dev-blog/blob/master/2016-01-04-duplicate-push.md)\n\n","source":"_posts/duplicate-push.md","raw":"---\ntitle: 防止点击Cell时ViewController被重复Push\ndate: 2016-09-12 20:19:24\ntags: Bug\ncategory: Tips\n---\n\n## 前言\n相信不少iOS开发者都遇到过点击`tableView(:didSelectRowAtIndexPath:)`push到别的界面，有些用户点击了cell后，可能会触发两次push，弹出两次别的界面。这种情况出现的概率比较小，在***快速双击*** 或者 ***长按cell稍微放开又按下***的情况下比较容易复现。\n\n为此去Google解决方案，找到这篇文章[《防止点击 Cell 时 ViewController 被重复 Push》](https://github.com/nixzhu/dev-blog/blob/master/2016-01-04-duplicate-push.md)，作者[@nixzhu](https://twitter.com/nixzhu)\n\n然后结合我的实际情况作出解决并摘录了一些原文内容。\n\n既然push了两次，那么`tableView(:didSelectRowAtIndexPath:)`一定被调用了两次。但又因为这是一个delegate方法，是由iOS来调用的，怎样才算被“选中”实在难以猜想，何况不同的 iOS 版本还可能有差异。不过我们仍然有办法做处理，毕竟它被调用了两次，就算是用**计数判断**的办法，我们也能防止同一次点击出现重复的 push。真实的问题是这种情况难以调试，因为问题很不容易出现，你怎么知道修改后的代码是工作的呢？\n\n## 解决\n原文章就给出了解决方案：\n\n```swift\nfunc tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {\n    defer {\n        tableView.deselectRowAtIndexPath(indexPath, animated: true)\n    }\n\n    if let navigationController = navigationController {\n        guard navigationController.topViewController == self else {\n            return\n        }\n    }\n\n    // TODO: performSegueWithIdentifier...\n}\n```\n这个代码是利用了 push 后，navigationController 的`ViewControllers stack` 会发生改变，那么其`topViewController`自然会发生改变。**所以在 push 之前，我们先保证此时的 topViewController 是当前 ViewController，这样就可避免重复 push，因为你第二次 push ，topViewController就变成了第一次 push 后的 ViewController 就会 return 掉**。\n\n原作者还用了 defer 关键字，也就是无论如何，我们都可以取消 cell 的选中。当然，我们还应该判断 navigationController 的存在性，因为当前的 ViewController 不一定内嵌在某个 UINavigationController 里，segue 也并非只有 push 一种，还有show。\n\n### 如何重现问题？\n我自己是快速点击两次cell，原作者是长按 cell，然后稍微减少手指的压力再立即增加压力，触发这个bug。（估计是UI业务逻辑有关吧，如果你没有观察到两次 push 间 viewControllers stack 的改变，那说明你遇到的问题更加诡异，此方法也可能不适用。）\n\n我通过打印的办法确认，在出现重复 push 的情况下，iOS 9.2 会调用两次 `tableView(:didSelectRowAtIndexPath:)`，但在此之间，第一次 performSegue 时，UINavigationController 的 viewControllers stack 就已经被改变了，也就是说，第二次就不会再 push 了。\n\n既然只要 performSegue 就能改变 UINavigationController 的 viewControllers stack，那我们也不需要在 tableView(:didSelectRowAtIndexPath:) 里做处理，直接重载 ViewController 的 `performSegueWithIdentifier(:sender:)` 即可：\n\n```objc\noverride func performSegueWithIdentifier(identifier: String, sender: AnyObject?) {\n    if let navigationController = navigationController {\n        guard navigationController.topViewController == self else {\n            return\n        }\n    }\n\n    super.performSegueWithIdentifier(identifier, sender: sender)\n}\n```\n\n这样代码逻辑会更好一点。进一步，若你的 app 里有许多 ViewController，也许它们都有可能出现重复 push。那为了避免重复代码，可以写一个基类让其他 ViewController 继承。\n\n**注意**，你可能会想说，怎么不在 `shouldPerformSegueWithIdentifier(:sender:)` 里做处理呢？不是更合理吗？\n\n这个方法看起来挺像这么回事，但可惜，`它只会作用于直接在 IB 里连线的 segue，如果你手动 performSegue，它并不会被调用`。这样的逻辑也说得通，毕竟你都手动调用了，哪还有shouldPerformSegue（该不该跳转）的问题呢？\n\n## 我的情况\n我的cell点击后的情况比较特殊：点击cell后调用异步网络请求，根据请求返回确定cell是否跳转，这又是个bug，因为请求是异步的，当你第一次请求还没回来没有 push （viewControllers stack未改变），第二次点击请求回来了并且已经 push ，这时第一次请求回来了又 push 一次，这样原作者的办法就无效了。\n\n两种方法解决：\n\n* 点击cell后增加个小菊花loading，让用户在请求回来前不能响应别的事件\n* 增加个Bool变量isClickCell，默认是NO。每次点击cell前判断是否为YES，如果是YES直接return，反之isClickCell赋值为YES，然后异步网络请求，网络请求不论成功或者失败都赋值为NO，让用户下次可以点击cell\n\n**这两种解决方法都不算特别突出，如果你有更好的解决办法，可以给我留言，我们交流交流。**\n\n## 参考链接\n[《防止点击 Cell 时 ViewController 被重复 Push》](https://github.com/nixzhu/dev-blog/blob/master/2016-01-04-duplicate-push.md)\n\n","slug":"duplicate-push","published":1,"updated":"2016-09-11T14:08:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7lc001n8jpbmggph3fp","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>相信不少iOS开发者都遇到过点击<code>tableView(:didSelectRowAtIndexPath:)</code>push到别的界面，有些用户点击了cell后，可能会触发两次push，弹出两次别的界面。这种情况出现的概率比较小，在<strong><em>快速双击</em></strong> 或者 <strong><em>长按cell稍微放开又按下</em></strong>的情况下比较容易复现。</p>\n<p>为此去Google解决方案，找到这篇文章<a href=\"https://github.com/nixzhu/dev-blog/blob/master/2016-01-04-duplicate-push.md\" target=\"_blank\" rel=\"noopener\">《防止点击 Cell 时 ViewController 被重复 Push》</a>，作者<a href=\"https://twitter.com/nixzhu\" target=\"_blank\" rel=\"noopener\">@nixzhu</a></p>\n<p>然后结合我的实际情况作出解决并摘录了一些原文内容。</p>\n<p>既然push了两次，那么<code>tableView(:didSelectRowAtIndexPath:)</code>一定被调用了两次。但又因为这是一个delegate方法，是由iOS来调用的，怎样才算被“选中”实在难以猜想，何况不同的 iOS 版本还可能有差异。不过我们仍然有办法做处理，毕竟它被调用了两次，就算是用<strong>计数判断</strong>的办法，我们也能防止同一次点击出现重复的 push。真实的问题是这种情况难以调试，因为问题很不容易出现，你怎么知道修改后的代码是工作的呢？</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>原文章就给出了解决方案：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> &#123;</span><br><span class=\"line\">        tableView.deselectRowAtIndexPath(indexPath, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> navigationController = navigationController &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> navigationController.topViewController == <span class=\"keyword\">self</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> performSegueWithIdentifier...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个代码是利用了 push 后，navigationController 的<code>ViewControllers stack</code> 会发生改变，那么其<code>topViewController</code>自然会发生改变。<strong>所以在 push 之前，我们先保证此时的 topViewController 是当前 ViewController，这样就可避免重复 push，因为你第二次 push ，topViewController就变成了第一次 push 后的 ViewController 就会 return 掉</strong>。</p>\n<p>原作者还用了 defer 关键字，也就是无论如何，我们都可以取消 cell 的选中。当然，我们还应该判断 navigationController 的存在性，因为当前的 ViewController 不一定内嵌在某个 UINavigationController 里，segue 也并非只有 push 一种，还有show。</p>\n<h3 id=\"如何重现问题？\"><a href=\"#如何重现问题？\" class=\"headerlink\" title=\"如何重现问题？\"></a>如何重现问题？</h3><p>我自己是快速点击两次cell，原作者是长按 cell，然后稍微减少手指的压力再立即增加压力，触发这个bug。（估计是UI业务逻辑有关吧，如果你没有观察到两次 push 间 viewControllers stack 的改变，那说明你遇到的问题更加诡异，此方法也可能不适用。）</p>\n<p>我通过打印的办法确认，在出现重复 push 的情况下，iOS 9.2 会调用两次 <code>tableView(:didSelectRowAtIndexPath:)</code>，但在此之间，第一次 performSegue 时，UINavigationController 的 viewControllers stack 就已经被改变了，也就是说，第二次就不会再 push 了。</p>\n<p>既然只要 performSegue 就能改变 UINavigationController 的 viewControllers stack，那我们也不需要在 tableView(:didSelectRowAtIndexPath:) 里做处理，直接重载 ViewController 的 <code>performSegueWithIdentifier(:sender:)</code> 即可：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">override func performSegueWithIdentifier(identifier: String, sender: AnyObject?) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> let navigationController = navigationController &#123;</span><br><span class=\"line\">        guard navigationController.topViewController == <span class=\"keyword\">self</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.performSegueWithIdentifier(identifier, sender: sender)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样代码逻辑会更好一点。进一步，若你的 app 里有许多 ViewController，也许它们都有可能出现重复 push。那为了避免重复代码，可以写一个基类让其他 ViewController 继承。</p>\n<p><strong>注意</strong>，你可能会想说，怎么不在 <code>shouldPerformSegueWithIdentifier(:sender:)</code> 里做处理呢？不是更合理吗？</p>\n<p>这个方法看起来挺像这么回事，但可惜，<code>它只会作用于直接在 IB 里连线的 segue，如果你手动 performSegue，它并不会被调用</code>。这样的逻辑也说得通，毕竟你都手动调用了，哪还有shouldPerformSegue（该不该跳转）的问题呢？</p>\n<h2 id=\"我的情况\"><a href=\"#我的情况\" class=\"headerlink\" title=\"我的情况\"></a>我的情况</h2><p>我的cell点击后的情况比较特殊：点击cell后调用异步网络请求，根据请求返回确定cell是否跳转，这又是个bug，因为请求是异步的，当你第一次请求还没回来没有 push （viewControllers stack未改变），第二次点击请求回来了并且已经 push ，这时第一次请求回来了又 push 一次，这样原作者的办法就无效了。</p>\n<p>两种方法解决：</p>\n<ul>\n<li>点击cell后增加个小菊花loading，让用户在请求回来前不能响应别的事件</li>\n<li>增加个Bool变量isClickCell，默认是NO。每次点击cell前判断是否为YES，如果是YES直接return，反之isClickCell赋值为YES，然后异步网络请求，网络请求不论成功或者失败都赋值为NO，让用户下次可以点击cell</li>\n</ul>\n<p><strong>这两种解决方法都不算特别突出，如果你有更好的解决办法，可以给我留言，我们交流交流。</strong></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://github.com/nixzhu/dev-blog/blob/master/2016-01-04-duplicate-push.md\" target=\"_blank\" rel=\"noopener\">《防止点击 Cell 时 ViewController 被重复 Push》</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>相信不少iOS开发者都遇到过点击<code>tableView(:didSelectRowAtIndexPath:)</code>push到别的界面，有些用户点击了cell后，可能会触发两次push，弹出两次别的界面。这种情况出现的概率比较小，在<strong><em>快速双击</em></strong> 或者 <strong><em>长按cell稍微放开又按下</em></strong>的情况下比较容易复现。</p>\n<p>为此去Google解决方案，找到这篇文章<a href=\"https://github.com/nixzhu/dev-blog/blob/master/2016-01-04-duplicate-push.md\" target=\"_blank\" rel=\"noopener\">《防止点击 Cell 时 ViewController 被重复 Push》</a>，作者<a href=\"https://twitter.com/nixzhu\" target=\"_blank\" rel=\"noopener\">@nixzhu</a></p>\n<p>然后结合我的实际情况作出解决并摘录了一些原文内容。</p>\n<p>既然push了两次，那么<code>tableView(:didSelectRowAtIndexPath:)</code>一定被调用了两次。但又因为这是一个delegate方法，是由iOS来调用的，怎样才算被“选中”实在难以猜想，何况不同的 iOS 版本还可能有差异。不过我们仍然有办法做处理，毕竟它被调用了两次，就算是用<strong>计数判断</strong>的办法，我们也能防止同一次点击出现重复的 push。真实的问题是这种情况难以调试，因为问题很不容易出现，你怎么知道修改后的代码是工作的呢？</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>原文章就给出了解决方案：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> &#123;</span><br><span class=\"line\">        tableView.deselectRowAtIndexPath(indexPath, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> navigationController = navigationController &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> navigationController.topViewController == <span class=\"keyword\">self</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> performSegueWithIdentifier...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个代码是利用了 push 后，navigationController 的<code>ViewControllers stack</code> 会发生改变，那么其<code>topViewController</code>自然会发生改变。<strong>所以在 push 之前，我们先保证此时的 topViewController 是当前 ViewController，这样就可避免重复 push，因为你第二次 push ，topViewController就变成了第一次 push 后的 ViewController 就会 return 掉</strong>。</p>\n<p>原作者还用了 defer 关键字，也就是无论如何，我们都可以取消 cell 的选中。当然，我们还应该判断 navigationController 的存在性，因为当前的 ViewController 不一定内嵌在某个 UINavigationController 里，segue 也并非只有 push 一种，还有show。</p>\n<h3 id=\"如何重现问题？\"><a href=\"#如何重现问题？\" class=\"headerlink\" title=\"如何重现问题？\"></a>如何重现问题？</h3><p>我自己是快速点击两次cell，原作者是长按 cell，然后稍微减少手指的压力再立即增加压力，触发这个bug。（估计是UI业务逻辑有关吧，如果你没有观察到两次 push 间 viewControllers stack 的改变，那说明你遇到的问题更加诡异，此方法也可能不适用。）</p>\n<p>我通过打印的办法确认，在出现重复 push 的情况下，iOS 9.2 会调用两次 <code>tableView(:didSelectRowAtIndexPath:)</code>，但在此之间，第一次 performSegue 时，UINavigationController 的 viewControllers stack 就已经被改变了，也就是说，第二次就不会再 push 了。</p>\n<p>既然只要 performSegue 就能改变 UINavigationController 的 viewControllers stack，那我们也不需要在 tableView(:didSelectRowAtIndexPath:) 里做处理，直接重载 ViewController 的 <code>performSegueWithIdentifier(:sender:)</code> 即可：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">override func performSegueWithIdentifier(identifier: String, sender: AnyObject?) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> let navigationController = navigationController &#123;</span><br><span class=\"line\">        guard navigationController.topViewController == <span class=\"keyword\">self</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.performSegueWithIdentifier(identifier, sender: sender)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样代码逻辑会更好一点。进一步，若你的 app 里有许多 ViewController，也许它们都有可能出现重复 push。那为了避免重复代码，可以写一个基类让其他 ViewController 继承。</p>\n<p><strong>注意</strong>，你可能会想说，怎么不在 <code>shouldPerformSegueWithIdentifier(:sender:)</code> 里做处理呢？不是更合理吗？</p>\n<p>这个方法看起来挺像这么回事，但可惜，<code>它只会作用于直接在 IB 里连线的 segue，如果你手动 performSegue，它并不会被调用</code>。这样的逻辑也说得通，毕竟你都手动调用了，哪还有shouldPerformSegue（该不该跳转）的问题呢？</p>\n<h2 id=\"我的情况\"><a href=\"#我的情况\" class=\"headerlink\" title=\"我的情况\"></a>我的情况</h2><p>我的cell点击后的情况比较特殊：点击cell后调用异步网络请求，根据请求返回确定cell是否跳转，这又是个bug，因为请求是异步的，当你第一次请求还没回来没有 push （viewControllers stack未改变），第二次点击请求回来了并且已经 push ，这时第一次请求回来了又 push 一次，这样原作者的办法就无效了。</p>\n<p>两种方法解决：</p>\n<ul>\n<li>点击cell后增加个小菊花loading，让用户在请求回来前不能响应别的事件</li>\n<li>增加个Bool变量isClickCell，默认是NO。每次点击cell前判断是否为YES，如果是YES直接return，反之isClickCell赋值为YES，然后异步网络请求，网络请求不论成功或者失败都赋值为NO，让用户下次可以点击cell</li>\n</ul>\n<p><strong>这两种解决方法都不算特别突出，如果你有更好的解决办法，可以给我留言，我们交流交流。</strong></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://github.com/nixzhu/dev-blog/blob/master/2016-01-04-duplicate-push.md\" target=\"_blank\" rel=\"noopener\">《防止点击 Cell 时 ViewController 被重复 Push》</a></p>\n"},{"title":"字符串本地化","date":"2016-09-22T13:43:19.000Z","_content":"\n## 前言\n最近忙着做个国外的项目，国外的就需要做字符串本地化了，这里就简单聊聊如何使用国际化。\n\n字符串本地化有两种方法：`修改代码` 或者 `修改xib和storyboard`，这里主要介绍通过代码的方式实现字符串本地化。\n\n## NSLocalizedString\n本地化字符串肯定要用到的`NSLocalizedString`这个宏，它是本地化的核心，它还有三个鲜为人知的变体：\n\n* **NSLocalizedStringFromTable**\n* **NSLocalizedStringFromTableInBundle**\n* **NSLocalizedStringWithDefaultValue**\n\n这些宏最终都调用 **NSBundle** 的 **localizedStringForKey:value:table:** 方法来完成任务。\n\n使用这些宏有两个好处：一方面相比直接调用 **localizedStringForKey:value:table:** 方法，使用宏让代码简单易懂；另一方面，类似 **genstrings** 这样的工具能够监测到这些宏，从而生成供你翻译使用的字符串文件。这些工具会解析 .c 和 .m 后缀的文件，然后为其中每一个需要进行本地化的字符串都生成对应条目，并写入到生成的 .strings 文件中。\n\n## genstrings的使用\n为什么要使用这个工具，直接去选择生成需要的语言就好了啊？\n\n主要是因为当你后面增加一个本地化字符串都得去**Localizable.strings**添加相应的key-value，当数量很多的时候很麻烦，所以苹果提供这个这个工具快捷的生成本地化key-value。\n\n\n**使用方式也很简单：**\n1.先cd到工程所在目录，执行命令创建**en.lproj**文件夹\n\n```bash\nmkdir en.lproj\n```\n\n2.让**genstrings**去检测自己项目中所有的 .m 后缀文件\n\n```bash\nfind . -name *.m | xargs genstrings -o en.lproj\n```\n`-o` 选项指定了生成字符串文件的存放目录，默认情况下文件名是 Localizable.strings。需要注意的是，genstrings 默认会覆盖已存在的同名字符串文件。\n\n`-a` 选项可以让 genstrings 将生成的条目追加到已存在同名文件的末尾，而不会覆盖原文件。\n\n不过一般情况下你也许想将生成文件放到另一个目录中，然后使用你喜欢的合并工具将它们与已有文件合并以保留已翻译好的条目。\n\n字符串文件的格式非常简单，都是键值对的形式：\n\n```objc\n/* 就是关于我们啦 */\n\"About Us\" = \"About Us\";\n```\n\n**需要注意一点：**NSLocalizedString(key,comment) 用这个函数时，`key不能是宏定义或者一些动态字符串`，否则用上面的命令会报错。把那些不支持的key去掉后就可以编译生成了。\n\n## 字符串键值最佳实践\n使用`NSLocalizedString`宏的时候，第一个参数就是为每个特殊字符串指定的键值**（key）**。\n这个**Key**如何定义会比较好，并且能够保证它的唯一性，否则在多语言的时候会出现多种意思。\n\n以英文单词「run」为例，作为名词表示「跑步」，作为动词表示「奔跑」，在翻译的时候要加以区别。而且根据上下文的不同，每种具体的译法在文字上可能还会有细微变化。\n\n一个健身应用在不同的地方用到这个单词的不同意思是很正常的，但是如果你使用下面的方法来进行本地化：\n\n```objc\nNSLocalizedString(@\"Run\", nil)\n```\n\n无论第二个参数指定了注释内容还是留空，你在字符串文件中都只有一个「run」的条目。而在德语中，「run」作名词时应该译为「Lauf」，作动词时则应该译为「laufen」，或者在特定情况下译为完全不同的形式比如「loslaufen」和「Los geht’s」。\n\n好的键值应该满足两个条件：\n\n* `键值必须在每个具体的上下文中保持唯一性`\n* `如果我们没有翻译特定的那个上下文，那么它们不会被其他情况覆盖到而被翻译`\n\n本文推荐使用如下的命名空间方法：\n\n```objc\nNSLocalizedString(@\"activity-profile.title.the-run\", nil)\nNSLocalizedString(@\"home.button.start-run\", nil)\n```\n\n这样的键值可以区分应用中不同地方出现的单词，同时提供具体的上下文，比如是标题中的或者按钮中的。上面的例子里我们为了简便忽略了第二个参数，实际使用中如果键值本身没有提供清晰的上下文说明，你可以将进一步的说明作为第二个参数传入。同时请确保键值中只含有 ASCII 字符。\n\n## 分割字符串文件\n当需要本地化的内容很多的时候，我们通常会把字符串归类，比如分为Home，Me等等模块，这时候就可以使用`NSLocalizedStringFromTable`这个宏来分类，它有三个参数key、table 和 comment，其中 **table** 参数表示该字符串对应的一个表格，genstrings 会为表中的每一个条目生成一个以条目名称（假设为 table-item）命名的独立字符串文件 **table-item.strings**。\n\n比如：\n\n```objc\nNSLocalizedStringFromTable(@\"home.button.start-run\", @\"Home\", @\"some comment..\")\n```\n\n还有个简便的方法来设置Table，让本地化更轻松些：\n\n```objc\nstatic NSString * LocalizedHomeString(NSString *key, NSString *comment) {\n    return [[NSBundle mainBundle] localizedStringForKey:key value:key table:@\"Home\"];\n}\n```\n这样就不用每次设置table，不过为了给所有调用此函数的地方生成字符串文件，你要在执行 genstrings 的时候加上 -s 选项：\n\n```bash\nfind . -name *.m | xargs genstrings -o en.lproj -s LocalizedHomeString\n```\n`-s` 这个选项指定了本地化函数的`共同前缀名称`，如果你还定义了 **LocalizedHomeString**FromTable，**LocalizedHomeString**FromTableInBundle， **LocalizedHomeString**WithDefaultValue 等函数，以上命令也会调用它们。\n\n## 格式化字符串\n我们经常需要在运行时才能最终确定下来字符串的本地化，格式化字符串可以很容易的实现这一点。\n\n以字符串「Run 1 out of 3 completed.」为例，我们可以这样构造格式化字符串:\n\n\n```objc\nNSString *localizedString = NSLocalizedString(@\"activity-profile.label.run %lu out of %lu completed\", nil);\nself.label.text = [NSString localizedStringWithFormat:localizedString, completedRuns, totalRuns];\n```\n\n在翻译的时候经常需要对其中的格式化占位符进行顺序调整以符合语法，幸运的是我们可以在字符串文件中轻松地搞定：\n\n\n```objc\n\"activity-profile.label.run %lu out of %lu completed\" = \"Von %2$lu Läufen hast du %1$lu absolviert\";\n```\n\n## 结论\n字符串本地化还包含了很多功能：单复数与阴阳性，字母大小写，格式化数字，格式化日期，调试本地化字符串等等内容，我在这就使用了常用的部分，更多的内容可以浏览 [《ObjC-字符串本地化》](https://objccn.io/issue-9-3/)\n\n## 参考链接\n* [字符串本地化](https://objccn.io/issue-9-3/)\n* [使用genstrings和NSLocalizedString实现App文本的本地化](http://www.cnblogs.com/every2003/archive/2012/03/20/2407253.html)\n* [iOS国际化和genstrings所有子目录本地化字符串](https://my.oschina.net/u/1049180/blog/215695)\n\n","source":"_posts/localized-string.md","raw":"---\ntitle: 字符串本地化\ndate: 2016-09-22 21:43:19\ntags: 本地化\ncategory: 能工巧匠\n---\n\n## 前言\n最近忙着做个国外的项目，国外的就需要做字符串本地化了，这里就简单聊聊如何使用国际化。\n\n字符串本地化有两种方法：`修改代码` 或者 `修改xib和storyboard`，这里主要介绍通过代码的方式实现字符串本地化。\n\n## NSLocalizedString\n本地化字符串肯定要用到的`NSLocalizedString`这个宏，它是本地化的核心，它还有三个鲜为人知的变体：\n\n* **NSLocalizedStringFromTable**\n* **NSLocalizedStringFromTableInBundle**\n* **NSLocalizedStringWithDefaultValue**\n\n这些宏最终都调用 **NSBundle** 的 **localizedStringForKey:value:table:** 方法来完成任务。\n\n使用这些宏有两个好处：一方面相比直接调用 **localizedStringForKey:value:table:** 方法，使用宏让代码简单易懂；另一方面，类似 **genstrings** 这样的工具能够监测到这些宏，从而生成供你翻译使用的字符串文件。这些工具会解析 .c 和 .m 后缀的文件，然后为其中每一个需要进行本地化的字符串都生成对应条目，并写入到生成的 .strings 文件中。\n\n## genstrings的使用\n为什么要使用这个工具，直接去选择生成需要的语言就好了啊？\n\n主要是因为当你后面增加一个本地化字符串都得去**Localizable.strings**添加相应的key-value，当数量很多的时候很麻烦，所以苹果提供这个这个工具快捷的生成本地化key-value。\n\n\n**使用方式也很简单：**\n1.先cd到工程所在目录，执行命令创建**en.lproj**文件夹\n\n```bash\nmkdir en.lproj\n```\n\n2.让**genstrings**去检测自己项目中所有的 .m 后缀文件\n\n```bash\nfind . -name *.m | xargs genstrings -o en.lproj\n```\n`-o` 选项指定了生成字符串文件的存放目录，默认情况下文件名是 Localizable.strings。需要注意的是，genstrings 默认会覆盖已存在的同名字符串文件。\n\n`-a` 选项可以让 genstrings 将生成的条目追加到已存在同名文件的末尾，而不会覆盖原文件。\n\n不过一般情况下你也许想将生成文件放到另一个目录中，然后使用你喜欢的合并工具将它们与已有文件合并以保留已翻译好的条目。\n\n字符串文件的格式非常简单，都是键值对的形式：\n\n```objc\n/* 就是关于我们啦 */\n\"About Us\" = \"About Us\";\n```\n\n**需要注意一点：**NSLocalizedString(key,comment) 用这个函数时，`key不能是宏定义或者一些动态字符串`，否则用上面的命令会报错。把那些不支持的key去掉后就可以编译生成了。\n\n## 字符串键值最佳实践\n使用`NSLocalizedString`宏的时候，第一个参数就是为每个特殊字符串指定的键值**（key）**。\n这个**Key**如何定义会比较好，并且能够保证它的唯一性，否则在多语言的时候会出现多种意思。\n\n以英文单词「run」为例，作为名词表示「跑步」，作为动词表示「奔跑」，在翻译的时候要加以区别。而且根据上下文的不同，每种具体的译法在文字上可能还会有细微变化。\n\n一个健身应用在不同的地方用到这个单词的不同意思是很正常的，但是如果你使用下面的方法来进行本地化：\n\n```objc\nNSLocalizedString(@\"Run\", nil)\n```\n\n无论第二个参数指定了注释内容还是留空，你在字符串文件中都只有一个「run」的条目。而在德语中，「run」作名词时应该译为「Lauf」，作动词时则应该译为「laufen」，或者在特定情况下译为完全不同的形式比如「loslaufen」和「Los geht’s」。\n\n好的键值应该满足两个条件：\n\n* `键值必须在每个具体的上下文中保持唯一性`\n* `如果我们没有翻译特定的那个上下文，那么它们不会被其他情况覆盖到而被翻译`\n\n本文推荐使用如下的命名空间方法：\n\n```objc\nNSLocalizedString(@\"activity-profile.title.the-run\", nil)\nNSLocalizedString(@\"home.button.start-run\", nil)\n```\n\n这样的键值可以区分应用中不同地方出现的单词，同时提供具体的上下文，比如是标题中的或者按钮中的。上面的例子里我们为了简便忽略了第二个参数，实际使用中如果键值本身没有提供清晰的上下文说明，你可以将进一步的说明作为第二个参数传入。同时请确保键值中只含有 ASCII 字符。\n\n## 分割字符串文件\n当需要本地化的内容很多的时候，我们通常会把字符串归类，比如分为Home，Me等等模块，这时候就可以使用`NSLocalizedStringFromTable`这个宏来分类，它有三个参数key、table 和 comment，其中 **table** 参数表示该字符串对应的一个表格，genstrings 会为表中的每一个条目生成一个以条目名称（假设为 table-item）命名的独立字符串文件 **table-item.strings**。\n\n比如：\n\n```objc\nNSLocalizedStringFromTable(@\"home.button.start-run\", @\"Home\", @\"some comment..\")\n```\n\n还有个简便的方法来设置Table，让本地化更轻松些：\n\n```objc\nstatic NSString * LocalizedHomeString(NSString *key, NSString *comment) {\n    return [[NSBundle mainBundle] localizedStringForKey:key value:key table:@\"Home\"];\n}\n```\n这样就不用每次设置table，不过为了给所有调用此函数的地方生成字符串文件，你要在执行 genstrings 的时候加上 -s 选项：\n\n```bash\nfind . -name *.m | xargs genstrings -o en.lproj -s LocalizedHomeString\n```\n`-s` 这个选项指定了本地化函数的`共同前缀名称`，如果你还定义了 **LocalizedHomeString**FromTable，**LocalizedHomeString**FromTableInBundle， **LocalizedHomeString**WithDefaultValue 等函数，以上命令也会调用它们。\n\n## 格式化字符串\n我们经常需要在运行时才能最终确定下来字符串的本地化，格式化字符串可以很容易的实现这一点。\n\n以字符串「Run 1 out of 3 completed.」为例，我们可以这样构造格式化字符串:\n\n\n```objc\nNSString *localizedString = NSLocalizedString(@\"activity-profile.label.run %lu out of %lu completed\", nil);\nself.label.text = [NSString localizedStringWithFormat:localizedString, completedRuns, totalRuns];\n```\n\n在翻译的时候经常需要对其中的格式化占位符进行顺序调整以符合语法，幸运的是我们可以在字符串文件中轻松地搞定：\n\n\n```objc\n\"activity-profile.label.run %lu out of %lu completed\" = \"Von %2$lu Läufen hast du %1$lu absolviert\";\n```\n\n## 结论\n字符串本地化还包含了很多功能：单复数与阴阳性，字母大小写，格式化数字，格式化日期，调试本地化字符串等等内容，我在这就使用了常用的部分，更多的内容可以浏览 [《ObjC-字符串本地化》](https://objccn.io/issue-9-3/)\n\n## 参考链接\n* [字符串本地化](https://objccn.io/issue-9-3/)\n* [使用genstrings和NSLocalizedString实现App文本的本地化](http://www.cnblogs.com/every2003/archive/2012/03/20/2407253.html)\n* [iOS国际化和genstrings所有子目录本地化字符串](https://my.oschina.net/u/1049180/blog/215695)\n\n","slug":"localized-string","published":1,"updated":"2016-09-22T15:43:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7ld001q8jpbg27hm8yo","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近忙着做个国外的项目，国外的就需要做字符串本地化了，这里就简单聊聊如何使用国际化。</p>\n<p>字符串本地化有两种方法：<code>修改代码</code> 或者 <code>修改xib和storyboard</code>，这里主要介绍通过代码的方式实现字符串本地化。</p>\n<h2 id=\"NSLocalizedString\"><a href=\"#NSLocalizedString\" class=\"headerlink\" title=\"NSLocalizedString\"></a>NSLocalizedString</h2><p>本地化字符串肯定要用到的<code>NSLocalizedString</code>这个宏，它是本地化的核心，它还有三个鲜为人知的变体：</p>\n<ul>\n<li><strong>NSLocalizedStringFromTable</strong></li>\n<li><strong>NSLocalizedStringFromTableInBundle</strong></li>\n<li><strong>NSLocalizedStringWithDefaultValue</strong></li>\n</ul>\n<p>这些宏最终都调用 <strong>NSBundle</strong> 的 <strong>localizedStringForKey:value:table:</strong> 方法来完成任务。</p>\n<p>使用这些宏有两个好处：一方面相比直接调用 <strong>localizedStringForKey:value:table:</strong> 方法，使用宏让代码简单易懂；另一方面，类似 <strong>genstrings</strong> 这样的工具能够监测到这些宏，从而生成供你翻译使用的字符串文件。这些工具会解析 .c 和 .m 后缀的文件，然后为其中每一个需要进行本地化的字符串都生成对应条目，并写入到生成的 .strings 文件中。</p>\n<h2 id=\"genstrings的使用\"><a href=\"#genstrings的使用\" class=\"headerlink\" title=\"genstrings的使用\"></a>genstrings的使用</h2><p>为什么要使用这个工具，直接去选择生成需要的语言就好了啊？</p>\n<p>主要是因为当你后面增加一个本地化字符串都得去<strong>Localizable.strings</strong>添加相应的key-value，当数量很多的时候很麻烦，所以苹果提供这个这个工具快捷的生成本地化key-value。</p>\n<p><strong>使用方式也很简单：</strong><br>1.先cd到工程所在目录，执行命令创建<strong>en.lproj</strong>文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir en.lproj</span><br></pre></td></tr></table></figure>\n<p>2.让<strong>genstrings</strong>去检测自己项目中所有的 .m 后缀文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name *.m | xargs genstrings -o en.lproj</span><br></pre></td></tr></table></figure>\n<p><code>-o</code> 选项指定了生成字符串文件的存放目录，默认情况下文件名是 Localizable.strings。需要注意的是，genstrings 默认会覆盖已存在的同名字符串文件。</p>\n<p><code>-a</code> 选项可以让 genstrings 将生成的条目追加到已存在同名文件的末尾，而不会覆盖原文件。</p>\n<p>不过一般情况下你也许想将生成文件放到另一个目录中，然后使用你喜欢的合并工具将它们与已有文件合并以保留已翻译好的条目。</p>\n<p>字符串文件的格式非常简单，都是键值对的形式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 就是关于我们啦 */</span></span><br><span class=\"line\"><span class=\"string\">\"About Us\"</span> = <span class=\"string\">\"About Us\"</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>需要注意一点：</strong>NSLocalizedString(key,comment) 用这个函数时，<code>key不能是宏定义或者一些动态字符串</code>，否则用上面的命令会报错。把那些不支持的key去掉后就可以编译生成了。</p>\n<h2 id=\"字符串键值最佳实践\"><a href=\"#字符串键值最佳实践\" class=\"headerlink\" title=\"字符串键值最佳实践\"></a>字符串键值最佳实践</h2><p>使用<code>NSLocalizedString</code>宏的时候，第一个参数就是为每个特殊字符串指定的键值<strong>（key）</strong>。<br>这个<strong>Key</strong>如何定义会比较好，并且能够保证它的唯一性，否则在多语言的时候会出现多种意思。</p>\n<p>以英文单词「run」为例，作为名词表示「跑步」，作为动词表示「奔跑」，在翻译的时候要加以区别。而且根据上下文的不同，每种具体的译法在文字上可能还会有细微变化。</p>\n<p>一个健身应用在不同的地方用到这个单词的不同意思是很正常的，但是如果你使用下面的方法来进行本地化：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLocalizedString</span>(<span class=\"string\">@\"Run\"</span>, <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>无论第二个参数指定了注释内容还是留空，你在字符串文件中都只有一个「run」的条目。而在德语中，「run」作名词时应该译为「Lauf」，作动词时则应该译为「laufen」，或者在特定情况下译为完全不同的形式比如「loslaufen」和「Los geht’s」。</p>\n<p>好的键值应该满足两个条件：</p>\n<ul>\n<li><code>键值必须在每个具体的上下文中保持唯一性</code></li>\n<li><code>如果我们没有翻译特定的那个上下文，那么它们不会被其他情况覆盖到而被翻译</code></li>\n</ul>\n<p>本文推荐使用如下的命名空间方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLocalizedString</span>(<span class=\"string\">@\"activity-profile.title.the-run\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"built_in\">NSLocalizedString</span>(<span class=\"string\">@\"home.button.start-run\"</span>, <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>这样的键值可以区分应用中不同地方出现的单词，同时提供具体的上下文，比如是标题中的或者按钮中的。上面的例子里我们为了简便忽略了第二个参数，实际使用中如果键值本身没有提供清晰的上下文说明，你可以将进一步的说明作为第二个参数传入。同时请确保键值中只含有 ASCII 字符。</p>\n<h2 id=\"分割字符串文件\"><a href=\"#分割字符串文件\" class=\"headerlink\" title=\"分割字符串文件\"></a>分割字符串文件</h2><p>当需要本地化的内容很多的时候，我们通常会把字符串归类，比如分为Home，Me等等模块，这时候就可以使用<code>NSLocalizedStringFromTable</code>这个宏来分类，它有三个参数key、table 和 comment，其中 <strong>table</strong> 参数表示该字符串对应的一个表格，genstrings 会为表中的每一个条目生成一个以条目名称（假设为 table-item）命名的独立字符串文件 <strong>table-item.strings</strong>。</p>\n<p>比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLocalizedStringFromTable</span>(<span class=\"string\">@\"home.button.start-run\"</span>, <span class=\"string\">@\"Home\"</span>, <span class=\"string\">@\"some comment..\"</span>)</span><br></pre></td></tr></table></figure>\n<p>还有个简便的方法来设置Table，让本地化更轻松些：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> * LocalizedHomeString(<span class=\"built_in\">NSString</span> *key, <span class=\"built_in\">NSString</span> *comment) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[<span class=\"built_in\">NSBundle</span> mainBundle] localizedStringForKey:key value:key table:<span class=\"string\">@\"Home\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就不用每次设置table，不过为了给所有调用此函数的地方生成字符串文件，你要在执行 genstrings 的时候加上 -s 选项：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name *.m | xargs genstrings -o en.lproj -s LocalizedHomeString</span><br></pre></td></tr></table></figure>\n<p><code>-s</code> 这个选项指定了本地化函数的<code>共同前缀名称</code>，如果你还定义了 <strong>LocalizedHomeString</strong>FromTable，<strong>LocalizedHomeString</strong>FromTableInBundle， <strong>LocalizedHomeString</strong>WithDefaultValue 等函数，以上命令也会调用它们。</p>\n<h2 id=\"格式化字符串\"><a href=\"#格式化字符串\" class=\"headerlink\" title=\"格式化字符串\"></a>格式化字符串</h2><p>我们经常需要在运行时才能最终确定下来字符串的本地化，格式化字符串可以很容易的实现这一点。</p>\n<p>以字符串「Run 1 out of 3 completed.」为例，我们可以这样构造格式化字符串:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *localizedString = <span class=\"built_in\">NSLocalizedString</span>(<span class=\"string\">@\"activity-profile.label.run %lu out of %lu completed\"</span>, <span class=\"literal\">nil</span>);</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label.text = [<span class=\"built_in\">NSString</span> localizedStringWithFormat:localizedString, completedRuns, totalRuns];</span><br></pre></td></tr></table></figure>\n<p>在翻译的时候经常需要对其中的格式化占位符进行顺序调整以符合语法，幸运的是我们可以在字符串文件中轻松地搞定：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"activity-profile.label.run %lu out of %lu completed\"</span> = <span class=\"string\">\"Von %2$lu Läufen hast du %1$lu absolviert\"</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>字符串本地化还包含了很多功能：单复数与阴阳性，字母大小写，格式化数字，格式化日期，调试本地化字符串等等内容，我在这就使用了常用的部分，更多的内容可以浏览 <a href=\"https://objccn.io/issue-9-3/\" target=\"_blank\" rel=\"noopener\">《ObjC-字符串本地化》</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://objccn.io/issue-9-3/\" target=\"_blank\" rel=\"noopener\">字符串本地化</a></li>\n<li><a href=\"http://www.cnblogs.com/every2003/archive/2012/03/20/2407253.html\" target=\"_blank\" rel=\"noopener\">使用genstrings和NSLocalizedString实现App文本的本地化</a></li>\n<li><a href=\"https://my.oschina.net/u/1049180/blog/215695\" target=\"_blank\" rel=\"noopener\">iOS国际化和genstrings所有子目录本地化字符串</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近忙着做个国外的项目，国外的就需要做字符串本地化了，这里就简单聊聊如何使用国际化。</p>\n<p>字符串本地化有两种方法：<code>修改代码</code> 或者 <code>修改xib和storyboard</code>，这里主要介绍通过代码的方式实现字符串本地化。</p>\n<h2 id=\"NSLocalizedString\"><a href=\"#NSLocalizedString\" class=\"headerlink\" title=\"NSLocalizedString\"></a>NSLocalizedString</h2><p>本地化字符串肯定要用到的<code>NSLocalizedString</code>这个宏，它是本地化的核心，它还有三个鲜为人知的变体：</p>\n<ul>\n<li><strong>NSLocalizedStringFromTable</strong></li>\n<li><strong>NSLocalizedStringFromTableInBundle</strong></li>\n<li><strong>NSLocalizedStringWithDefaultValue</strong></li>\n</ul>\n<p>这些宏最终都调用 <strong>NSBundle</strong> 的 <strong>localizedStringForKey:value:table:</strong> 方法来完成任务。</p>\n<p>使用这些宏有两个好处：一方面相比直接调用 <strong>localizedStringForKey:value:table:</strong> 方法，使用宏让代码简单易懂；另一方面，类似 <strong>genstrings</strong> 这样的工具能够监测到这些宏，从而生成供你翻译使用的字符串文件。这些工具会解析 .c 和 .m 后缀的文件，然后为其中每一个需要进行本地化的字符串都生成对应条目，并写入到生成的 .strings 文件中。</p>\n<h2 id=\"genstrings的使用\"><a href=\"#genstrings的使用\" class=\"headerlink\" title=\"genstrings的使用\"></a>genstrings的使用</h2><p>为什么要使用这个工具，直接去选择生成需要的语言就好了啊？</p>\n<p>主要是因为当你后面增加一个本地化字符串都得去<strong>Localizable.strings</strong>添加相应的key-value，当数量很多的时候很麻烦，所以苹果提供这个这个工具快捷的生成本地化key-value。</p>\n<p><strong>使用方式也很简单：</strong><br>1.先cd到工程所在目录，执行命令创建<strong>en.lproj</strong>文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir en.lproj</span><br></pre></td></tr></table></figure>\n<p>2.让<strong>genstrings</strong>去检测自己项目中所有的 .m 后缀文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name *.m | xargs genstrings -o en.lproj</span><br></pre></td></tr></table></figure>\n<p><code>-o</code> 选项指定了生成字符串文件的存放目录，默认情况下文件名是 Localizable.strings。需要注意的是，genstrings 默认会覆盖已存在的同名字符串文件。</p>\n<p><code>-a</code> 选项可以让 genstrings 将生成的条目追加到已存在同名文件的末尾，而不会覆盖原文件。</p>\n<p>不过一般情况下你也许想将生成文件放到另一个目录中，然后使用你喜欢的合并工具将它们与已有文件合并以保留已翻译好的条目。</p>\n<p>字符串文件的格式非常简单，都是键值对的形式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 就是关于我们啦 */</span></span><br><span class=\"line\"><span class=\"string\">\"About Us\"</span> = <span class=\"string\">\"About Us\"</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>需要注意一点：</strong>NSLocalizedString(key,comment) 用这个函数时，<code>key不能是宏定义或者一些动态字符串</code>，否则用上面的命令会报错。把那些不支持的key去掉后就可以编译生成了。</p>\n<h2 id=\"字符串键值最佳实践\"><a href=\"#字符串键值最佳实践\" class=\"headerlink\" title=\"字符串键值最佳实践\"></a>字符串键值最佳实践</h2><p>使用<code>NSLocalizedString</code>宏的时候，第一个参数就是为每个特殊字符串指定的键值<strong>（key）</strong>。<br>这个<strong>Key</strong>如何定义会比较好，并且能够保证它的唯一性，否则在多语言的时候会出现多种意思。</p>\n<p>以英文单词「run」为例，作为名词表示「跑步」，作为动词表示「奔跑」，在翻译的时候要加以区别。而且根据上下文的不同，每种具体的译法在文字上可能还会有细微变化。</p>\n<p>一个健身应用在不同的地方用到这个单词的不同意思是很正常的，但是如果你使用下面的方法来进行本地化：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLocalizedString</span>(<span class=\"string\">@\"Run\"</span>, <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>无论第二个参数指定了注释内容还是留空，你在字符串文件中都只有一个「run」的条目。而在德语中，「run」作名词时应该译为「Lauf」，作动词时则应该译为「laufen」，或者在特定情况下译为完全不同的形式比如「loslaufen」和「Los geht’s」。</p>\n<p>好的键值应该满足两个条件：</p>\n<ul>\n<li><code>键值必须在每个具体的上下文中保持唯一性</code></li>\n<li><code>如果我们没有翻译特定的那个上下文，那么它们不会被其他情况覆盖到而被翻译</code></li>\n</ul>\n<p>本文推荐使用如下的命名空间方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLocalizedString</span>(<span class=\"string\">@\"activity-profile.title.the-run\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"built_in\">NSLocalizedString</span>(<span class=\"string\">@\"home.button.start-run\"</span>, <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>这样的键值可以区分应用中不同地方出现的单词，同时提供具体的上下文，比如是标题中的或者按钮中的。上面的例子里我们为了简便忽略了第二个参数，实际使用中如果键值本身没有提供清晰的上下文说明，你可以将进一步的说明作为第二个参数传入。同时请确保键值中只含有 ASCII 字符。</p>\n<h2 id=\"分割字符串文件\"><a href=\"#分割字符串文件\" class=\"headerlink\" title=\"分割字符串文件\"></a>分割字符串文件</h2><p>当需要本地化的内容很多的时候，我们通常会把字符串归类，比如分为Home，Me等等模块，这时候就可以使用<code>NSLocalizedStringFromTable</code>这个宏来分类，它有三个参数key、table 和 comment，其中 <strong>table</strong> 参数表示该字符串对应的一个表格，genstrings 会为表中的每一个条目生成一个以条目名称（假设为 table-item）命名的独立字符串文件 <strong>table-item.strings</strong>。</p>\n<p>比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLocalizedStringFromTable</span>(<span class=\"string\">@\"home.button.start-run\"</span>, <span class=\"string\">@\"Home\"</span>, <span class=\"string\">@\"some comment..\"</span>)</span><br></pre></td></tr></table></figure>\n<p>还有个简便的方法来设置Table，让本地化更轻松些：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> * LocalizedHomeString(<span class=\"built_in\">NSString</span> *key, <span class=\"built_in\">NSString</span> *comment) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[<span class=\"built_in\">NSBundle</span> mainBundle] localizedStringForKey:key value:key table:<span class=\"string\">@\"Home\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就不用每次设置table，不过为了给所有调用此函数的地方生成字符串文件，你要在执行 genstrings 的时候加上 -s 选项：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name *.m | xargs genstrings -o en.lproj -s LocalizedHomeString</span><br></pre></td></tr></table></figure>\n<p><code>-s</code> 这个选项指定了本地化函数的<code>共同前缀名称</code>，如果你还定义了 <strong>LocalizedHomeString</strong>FromTable，<strong>LocalizedHomeString</strong>FromTableInBundle， <strong>LocalizedHomeString</strong>WithDefaultValue 等函数，以上命令也会调用它们。</p>\n<h2 id=\"格式化字符串\"><a href=\"#格式化字符串\" class=\"headerlink\" title=\"格式化字符串\"></a>格式化字符串</h2><p>我们经常需要在运行时才能最终确定下来字符串的本地化，格式化字符串可以很容易的实现这一点。</p>\n<p>以字符串「Run 1 out of 3 completed.」为例，我们可以这样构造格式化字符串:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *localizedString = <span class=\"built_in\">NSLocalizedString</span>(<span class=\"string\">@\"activity-profile.label.run %lu out of %lu completed\"</span>, <span class=\"literal\">nil</span>);</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label.text = [<span class=\"built_in\">NSString</span> localizedStringWithFormat:localizedString, completedRuns, totalRuns];</span><br></pre></td></tr></table></figure>\n<p>在翻译的时候经常需要对其中的格式化占位符进行顺序调整以符合语法，幸运的是我们可以在字符串文件中轻松地搞定：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"activity-profile.label.run %lu out of %lu completed\"</span> = <span class=\"string\">\"Von %2$lu Läufen hast du %1$lu absolviert\"</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>字符串本地化还包含了很多功能：单复数与阴阳性，字母大小写，格式化数字，格式化日期，调试本地化字符串等等内容，我在这就使用了常用的部分，更多的内容可以浏览 <a href=\"https://objccn.io/issue-9-3/\" target=\"_blank\" rel=\"noopener\">《ObjC-字符串本地化》</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://objccn.io/issue-9-3/\" target=\"_blank\" rel=\"noopener\">字符串本地化</a></li>\n<li><a href=\"http://www.cnblogs.com/every2003/archive/2012/03/20/2407253.html\" target=\"_blank\" rel=\"noopener\">使用genstrings和NSLocalizedString实现App文本的本地化</a></li>\n<li><a href=\"https://my.oschina.net/u/1049180/blog/215695\" target=\"_blank\" rel=\"noopener\">iOS国际化和genstrings所有子目录本地化字符串</a></li>\n</ul>\n"},{"title":"遍历中修改可变数组","date":"2016-09-04T08:25:26.000Z","_content":"\n## 前言\n浏览微博时，看到一篇关于`遍历中修改可变数组`Tips，觉得很实用，在此记录下来。\n\n原出处：[南峰子_老驴#iOS知识小集](http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501)\n\n## 问题\n相信每个开发都会遇到在遍历中修改可变数组的情况，稍不小心就会数组越界，**我们不建议在遍历可变数组时修改数组**，包括添加，删除，替换元素。\n\n不过，如果真的要在遍历的同时删除元素，可以采用`倒序遍历`，不会引起崩溃。\n\n```objc\nNSMutableArray *array = [NSMutableArray arrayWithObjects:@\"a\", @\"b\", @\"c\", @\"d\", @\"e\", nil];\n[array enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n   if ([obj isEqualToString:@\"c\"] || [obj isEqualToString:@\"e\"]) {\n       [array removeObject:obj];\n   }\n}];\n    \nNSLog(@\"%@\", array);// a, b, d\n```\n\n\n```objc\nNSMutableArray *array = [NSMutableArray arrayWithObjects:@\"a\", @\"b\", @\"c\", @\"d\", @\"e\", nil];\nfor (NSString *obj in array.reverseObjectEnumerator) {\nif ([obj isEqualToString:@\"a\"] || [obj isEqualToString:@\"e\"] || [obj isEqualToString:@\"c\"]) {\n       [array removeObject:obj];\n   }\n}\nNSLog(@\"%@\", array);// b, d\n```\n\n## 分析原因\n无论是`for...in...` 还是 `enumerateObjectsWithOptions`    都可以认为是先获取了数组的大小 **int count = array.count**，然后**for(int i=0;i<count;i++)**\n\n假设count是10，这时候你在循环时删除了一个元素，数组剩余9个，你能获取到的index最多到8，但是你的循环还是执行到i到9为止，之后就越界了。\n\n如果是倒序 **for(int i=count-1;i>=0;i--)**，这么遍历就算把数组元素全部删除也不会有问题。\n你调用枚举器遍历数组时count只会获取一次，且中途不能修改。\n\n**如果非要顺序删除也有方法，你删完立刻break。**\n\n## Update 2016-9-11\n之前的文章说到遍历中修改可变数组可能会造成Crash，但是亲身尝试了发现在一些情况下并不会有什么问题。\n\n我们常用的遍历数组的方式大概有三种：`for`，`for in`，`enumerateObjectsUsingBlock`。\n\n### for 和 enumerateObjectsUsingBlock\n在这三种方法中，使用`for`和`enumerateObjectsUsingBlock`遍历时，可以修改数组，不会有Crash等问题。\n\n```objc\nNSMutableArray *array = [NSMutableArray arrayWithCapacity:8];\n[array addObject:@\"1\"];\n[array addObject:@\"2\"];\n[array addObject:@\"3\"];\n[array addObject:@\"4\"];\n[array addObject:@\"5\"];\n    \n[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n   if ([obj isEqualToString:@\"3\"]) {\n       [array removeObject:obj];\n   }\n}];\n    \nNSLog(@\"%@\", array);// 1,2,4,5\n    \nfor (NSInteger i = 0; i<array.count; i++) {\n   NSString *temp = array[i];\n   if ([temp isEqualToString:@\"2\"]) {\n       [array removeObject:temp];\n       [array addObject:@\"8\"];\n   }\n}\n    \nNSLog(@\"%@\", array);// 1,4,5,8\n```\n\n**上述代码虽然没有造成Crash，但是有个潜在的问题，如果遍历时删除元素，可能导致后面的元素不会被遍历到**。\n\n```objc\nNSMutableArray *array = [NSMutableArray arrayWithCapacity:8];\n[array addObject:@\"1\"];\n[array addObject:@\"2\"];\n[array addObject:@\"3\"];\n[array addObject:@\"4\"];\n[array addObject:@\"5\"];\n    \n[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n   if ([obj isEqualToString:@\"3\"]) {\n       [array removeObject:obj];\n   }\n   \n   if ([obj isEqualToString:@\"4\"]) { // 无效\n       [array removeObject:obj];\n   }\n}];\n    \nNSLog(@\"%@\", array);// 1,2,4,5\n    \nfor (NSInteger i = 0; i<array.count; i++) {\n   NSString *temp = array[i];\n   if ([temp isEqualToString:@\"2\"]) {\n       [array removeObject:temp];\n   }\n   \n   if ([temp isEqualToString:@\"4\"]) { // 无效\n       [array addObject:@\"8\"];\n   }\n}\n    \nNSLog(@\"%@\", array);// 1,4,5\n```\n\n虽然遍历时修改数组不会造成Crash，但是**我们还是不建议在遍历可变数组时修改数组**。\n\n### for in\n当使用`for in`来遍历时，修改元素会抛出NSGenericException异常。\n\n```objc\nfor (NSString *str in array) { // Crash \n   if ([str isEqualToString:@\"2\"]) {\n       [array addObject:@\"8\"];\n   }\n}\n```\n{% asset_img Snip20160911_1.png for in crash %}\n\n一个通用的做法是：`从原数组copy一个数组出来，然后遍历copy数组，过滤出自己需要的元素，最后再对原数组进行操作`。\n\n```objc\nNSArray *temp = [array copy]; // 拷贝一份\nfor (NSString *str in temp) { // 遍历拷贝\n   if ([str isEqualToString:@\"2\"]) {\n       [array addObject:@\"8\"]; // 操作原数组\n       [array removeObject:str];\n   }\n}\n    \nNSLog(@\"%@\", array); // 1,3,4,5,8\n```\n\n## 参考链接\n[iOS : Modifying NSFastEnumerationState to hide mutation while enumerating](http://stackoverflow.com/questions/20069825/ios-modifying-nsfastenumerationstate-to-hide-mutation-while-enumerating)\n\n\n","source":"_posts/modify-mutable-array.md","raw":"---\ntitle: 遍历中修改可变数组\ndate: 2016-09-04 16:25:26\ntags: 数组\ncategory: Tips\n---\n\n## 前言\n浏览微博时，看到一篇关于`遍历中修改可变数组`Tips，觉得很实用，在此记录下来。\n\n原出处：[南峰子_老驴#iOS知识小集](http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501)\n\n## 问题\n相信每个开发都会遇到在遍历中修改可变数组的情况，稍不小心就会数组越界，**我们不建议在遍历可变数组时修改数组**，包括添加，删除，替换元素。\n\n不过，如果真的要在遍历的同时删除元素，可以采用`倒序遍历`，不会引起崩溃。\n\n```objc\nNSMutableArray *array = [NSMutableArray arrayWithObjects:@\"a\", @\"b\", @\"c\", @\"d\", @\"e\", nil];\n[array enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n   if ([obj isEqualToString:@\"c\"] || [obj isEqualToString:@\"e\"]) {\n       [array removeObject:obj];\n   }\n}];\n    \nNSLog(@\"%@\", array);// a, b, d\n```\n\n\n```objc\nNSMutableArray *array = [NSMutableArray arrayWithObjects:@\"a\", @\"b\", @\"c\", @\"d\", @\"e\", nil];\nfor (NSString *obj in array.reverseObjectEnumerator) {\nif ([obj isEqualToString:@\"a\"] || [obj isEqualToString:@\"e\"] || [obj isEqualToString:@\"c\"]) {\n       [array removeObject:obj];\n   }\n}\nNSLog(@\"%@\", array);// b, d\n```\n\n## 分析原因\n无论是`for...in...` 还是 `enumerateObjectsWithOptions`    都可以认为是先获取了数组的大小 **int count = array.count**，然后**for(int i=0;i<count;i++)**\n\n假设count是10，这时候你在循环时删除了一个元素，数组剩余9个，你能获取到的index最多到8，但是你的循环还是执行到i到9为止，之后就越界了。\n\n如果是倒序 **for(int i=count-1;i>=0;i--)**，这么遍历就算把数组元素全部删除也不会有问题。\n你调用枚举器遍历数组时count只会获取一次，且中途不能修改。\n\n**如果非要顺序删除也有方法，你删完立刻break。**\n\n## Update 2016-9-11\n之前的文章说到遍历中修改可变数组可能会造成Crash，但是亲身尝试了发现在一些情况下并不会有什么问题。\n\n我们常用的遍历数组的方式大概有三种：`for`，`for in`，`enumerateObjectsUsingBlock`。\n\n### for 和 enumerateObjectsUsingBlock\n在这三种方法中，使用`for`和`enumerateObjectsUsingBlock`遍历时，可以修改数组，不会有Crash等问题。\n\n```objc\nNSMutableArray *array = [NSMutableArray arrayWithCapacity:8];\n[array addObject:@\"1\"];\n[array addObject:@\"2\"];\n[array addObject:@\"3\"];\n[array addObject:@\"4\"];\n[array addObject:@\"5\"];\n    \n[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n   if ([obj isEqualToString:@\"3\"]) {\n       [array removeObject:obj];\n   }\n}];\n    \nNSLog(@\"%@\", array);// 1,2,4,5\n    \nfor (NSInteger i = 0; i<array.count; i++) {\n   NSString *temp = array[i];\n   if ([temp isEqualToString:@\"2\"]) {\n       [array removeObject:temp];\n       [array addObject:@\"8\"];\n   }\n}\n    \nNSLog(@\"%@\", array);// 1,4,5,8\n```\n\n**上述代码虽然没有造成Crash，但是有个潜在的问题，如果遍历时删除元素，可能导致后面的元素不会被遍历到**。\n\n```objc\nNSMutableArray *array = [NSMutableArray arrayWithCapacity:8];\n[array addObject:@\"1\"];\n[array addObject:@\"2\"];\n[array addObject:@\"3\"];\n[array addObject:@\"4\"];\n[array addObject:@\"5\"];\n    \n[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n   if ([obj isEqualToString:@\"3\"]) {\n       [array removeObject:obj];\n   }\n   \n   if ([obj isEqualToString:@\"4\"]) { // 无效\n       [array removeObject:obj];\n   }\n}];\n    \nNSLog(@\"%@\", array);// 1,2,4,5\n    \nfor (NSInteger i = 0; i<array.count; i++) {\n   NSString *temp = array[i];\n   if ([temp isEqualToString:@\"2\"]) {\n       [array removeObject:temp];\n   }\n   \n   if ([temp isEqualToString:@\"4\"]) { // 无效\n       [array addObject:@\"8\"];\n   }\n}\n    \nNSLog(@\"%@\", array);// 1,4,5\n```\n\n虽然遍历时修改数组不会造成Crash，但是**我们还是不建议在遍历可变数组时修改数组**。\n\n### for in\n当使用`for in`来遍历时，修改元素会抛出NSGenericException异常。\n\n```objc\nfor (NSString *str in array) { // Crash \n   if ([str isEqualToString:@\"2\"]) {\n       [array addObject:@\"8\"];\n   }\n}\n```\n{% asset_img Snip20160911_1.png for in crash %}\n\n一个通用的做法是：`从原数组copy一个数组出来，然后遍历copy数组，过滤出自己需要的元素，最后再对原数组进行操作`。\n\n```objc\nNSArray *temp = [array copy]; // 拷贝一份\nfor (NSString *str in temp) { // 遍历拷贝\n   if ([str isEqualToString:@\"2\"]) {\n       [array addObject:@\"8\"]; // 操作原数组\n       [array removeObject:str];\n   }\n}\n    \nNSLog(@\"%@\", array); // 1,3,4,5,8\n```\n\n## 参考链接\n[iOS : Modifying NSFastEnumerationState to hide mutation while enumerating](http://stackoverflow.com/questions/20069825/ios-modifying-nsfastenumerationstate-to-hide-mutation-while-enumerating)\n\n\n","slug":"modify-mutable-array","published":1,"updated":"2016-09-11T05:41:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7lf001t8jpbpuiqyv0k","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>浏览微博时，看到一篇关于<code>遍历中修改可变数组</code>Tips，觉得很实用，在此记录下来。</p>\n<p>原出处：<a href=\"http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501\" target=\"_blank\" rel=\"noopener\">南峰子_老驴#iOS知识小集</a></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>相信每个开发都会遇到在遍历中修改可变数组的情况，稍不小心就会数组越界，<strong>我们不建议在遍历可变数组时修改数组</strong>，包括添加，删除，替换元素。</p>\n<p>不过，如果真的要在遍历的同时删除元素，可以采用<code>倒序遍历</code>，不会引起崩溃。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> arrayWithObjects:<span class=\"string\">@\"a\"</span>, <span class=\"string\">@\"b\"</span>, <span class=\"string\">@\"c\"</span>, <span class=\"string\">@\"d\"</span>, <span class=\"string\">@\"e\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">[array enumerateObjectsWithOptions:<span class=\"built_in\">NSEnumerationReverse</span> usingBlock:^(<span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"c\"</span>] || [obj isEqualToString:<span class=\"string\">@\"e\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:obj];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// a, b, d</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> arrayWithObjects:<span class=\"string\">@\"a\"</span>, <span class=\"string\">@\"b\"</span>, <span class=\"string\">@\"c\"</span>, <span class=\"string\">@\"d\"</span>, <span class=\"string\">@\"e\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *obj <span class=\"keyword\">in</span> array.reverseObjectEnumerator) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"a\"</span>] || [obj isEqualToString:<span class=\"string\">@\"e\"</span>] || [obj isEqualToString:<span class=\"string\">@\"c\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:obj];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// b, d</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"分析原因\"><a href=\"#分析原因\" class=\"headerlink\" title=\"分析原因\"></a>分析原因</h2><p>无论是<code>for...in...</code> 还是 <code>enumerateObjectsWithOptions</code>    都可以认为是先获取了数组的大小 <strong>int count = array.count</strong>，然后<strong>for(int i=0;i&lt;count;i++)</strong></p>\n<p>假设count是10，这时候你在循环时删除了一个元素，数组剩余9个，你能获取到的index最多到8，但是你的循环还是执行到i到9为止，之后就越界了。</p>\n<p>如果是倒序 <strong>for(int i=count-1;i&gt;=0;i–)</strong>，这么遍历就算把数组元素全部删除也不会有问题。<br>你调用枚举器遍历数组时count只会获取一次，且中途不能修改。</p>\n<p><strong>如果非要顺序删除也有方法，你删完立刻break。</strong></p>\n<h2 id=\"Update-2016-9-11\"><a href=\"#Update-2016-9-11\" class=\"headerlink\" title=\"Update 2016-9-11\"></a>Update 2016-9-11</h2><p>之前的文章说到遍历中修改可变数组可能会造成Crash，但是亲身尝试了发现在一些情况下并不会有什么问题。</p>\n<p>我们常用的遍历数组的方式大概有三种：<code>for</code>，<code>for in</code>，<code>enumerateObjectsUsingBlock</code>。</p>\n<h3 id=\"for-和-enumerateObjectsUsingBlock\"><a href=\"#for-和-enumerateObjectsUsingBlock\" class=\"headerlink\" title=\"for 和 enumerateObjectsUsingBlock\"></a>for 和 enumerateObjectsUsingBlock</h3><p>在这三种方法中，使用<code>for</code>和<code>enumerateObjectsUsingBlock</code>遍历时，可以修改数组，不会有Crash等问题。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> arrayWithCapacity:<span class=\"number\">8</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"1\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"3\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"4\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"5\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">[array enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"3\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:obj];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// 1,2,4,5</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;array.count; i++) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> *temp = array[i];</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([temp isEqualToString:<span class=\"string\">@\"2\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:temp];</span><br><span class=\"line\">       [array addObject:<span class=\"string\">@\"8\"</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// 1,4,5,8</span></span><br></pre></td></tr></table></figure>\n<p><strong>上述代码虽然没有造成Crash，但是有个潜在的问题，如果遍历时删除元素，可能导致后面的元素不会被遍历到</strong>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> arrayWithCapacity:<span class=\"number\">8</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"1\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"3\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"4\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"5\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">[array enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"3\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:obj];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"4\"</span>]) &#123; <span class=\"comment\">// 无效</span></span><br><span class=\"line\">       [array removeObject:obj];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// 1,2,4,5</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;array.count; i++) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> *temp = array[i];</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([temp isEqualToString:<span class=\"string\">@\"2\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:temp];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([temp isEqualToString:<span class=\"string\">@\"4\"</span>]) &#123; <span class=\"comment\">// 无效</span></span><br><span class=\"line\">       [array addObject:<span class=\"string\">@\"8\"</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// 1,4,5</span></span><br></pre></td></tr></table></figure>\n<p>虽然遍历时修改数组不会造成Crash，但是<strong>我们还是不建议在遍历可变数组时修改数组</strong>。</p>\n<h3 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for in\"></a>for in</h3><p>当使用<code>for in</code>来遍历时，修改元素会抛出NSGenericException异常。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *str <span class=\"keyword\">in</span> array) &#123; <span class=\"comment\">// Crash </span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([str isEqualToString:<span class=\"string\">@\"2\"</span>]) &#123;</span><br><span class=\"line\">       [array addObject:<span class=\"string\">@\"8\"</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2016/09/04/modify-mutable-array/Snip20160911_1.png\" title=\"for in crash\">\n<p>一个通用的做法是：<code>从原数组copy一个数组出来，然后遍历copy数组，过滤出自己需要的元素，最后再对原数组进行操作</code>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *temp = [array <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 拷贝一份</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *str <span class=\"keyword\">in</span> temp) &#123; <span class=\"comment\">// 遍历拷贝</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([str isEqualToString:<span class=\"string\">@\"2\"</span>]) &#123;</span><br><span class=\"line\">       [array addObject:<span class=\"string\">@\"8\"</span>]; <span class=\"comment\">// 操作原数组</span></span><br><span class=\"line\">       [array removeObject:str];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array); <span class=\"comment\">// 1,3,4,5,8</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://stackoverflow.com/questions/20069825/ios-modifying-nsfastenumerationstate-to-hide-mutation-while-enumerating\" target=\"_blank\" rel=\"noopener\">iOS : Modifying NSFastEnumerationState to hide mutation while enumerating</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>浏览微博时，看到一篇关于<code>遍历中修改可变数组</code>Tips，觉得很实用，在此记录下来。</p>\n<p>原出处：<a href=\"http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501\" target=\"_blank\" rel=\"noopener\">南峰子_老驴#iOS知识小集</a></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>相信每个开发都会遇到在遍历中修改可变数组的情况，稍不小心就会数组越界，<strong>我们不建议在遍历可变数组时修改数组</strong>，包括添加，删除，替换元素。</p>\n<p>不过，如果真的要在遍历的同时删除元素，可以采用<code>倒序遍历</code>，不会引起崩溃。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> arrayWithObjects:<span class=\"string\">@\"a\"</span>, <span class=\"string\">@\"b\"</span>, <span class=\"string\">@\"c\"</span>, <span class=\"string\">@\"d\"</span>, <span class=\"string\">@\"e\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">[array enumerateObjectsWithOptions:<span class=\"built_in\">NSEnumerationReverse</span> usingBlock:^(<span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"c\"</span>] || [obj isEqualToString:<span class=\"string\">@\"e\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:obj];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// a, b, d</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> arrayWithObjects:<span class=\"string\">@\"a\"</span>, <span class=\"string\">@\"b\"</span>, <span class=\"string\">@\"c\"</span>, <span class=\"string\">@\"d\"</span>, <span class=\"string\">@\"e\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *obj <span class=\"keyword\">in</span> array.reverseObjectEnumerator) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"a\"</span>] || [obj isEqualToString:<span class=\"string\">@\"e\"</span>] || [obj isEqualToString:<span class=\"string\">@\"c\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:obj];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// b, d</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"分析原因\"><a href=\"#分析原因\" class=\"headerlink\" title=\"分析原因\"></a>分析原因</h2><p>无论是<code>for...in...</code> 还是 <code>enumerateObjectsWithOptions</code>    都可以认为是先获取了数组的大小 <strong>int count = array.count</strong>，然后<strong>for(int i=0;i&lt;count;i++)</strong></p>\n<p>假设count是10，这时候你在循环时删除了一个元素，数组剩余9个，你能获取到的index最多到8，但是你的循环还是执行到i到9为止，之后就越界了。</p>\n<p>如果是倒序 <strong>for(int i=count-1;i&gt;=0;i–)</strong>，这么遍历就算把数组元素全部删除也不会有问题。<br>你调用枚举器遍历数组时count只会获取一次，且中途不能修改。</p>\n<p><strong>如果非要顺序删除也有方法，你删完立刻break。</strong></p>\n<h2 id=\"Update-2016-9-11\"><a href=\"#Update-2016-9-11\" class=\"headerlink\" title=\"Update 2016-9-11\"></a>Update 2016-9-11</h2><p>之前的文章说到遍历中修改可变数组可能会造成Crash，但是亲身尝试了发现在一些情况下并不会有什么问题。</p>\n<p>我们常用的遍历数组的方式大概有三种：<code>for</code>，<code>for in</code>，<code>enumerateObjectsUsingBlock</code>。</p>\n<h3 id=\"for-和-enumerateObjectsUsingBlock\"><a href=\"#for-和-enumerateObjectsUsingBlock\" class=\"headerlink\" title=\"for 和 enumerateObjectsUsingBlock\"></a>for 和 enumerateObjectsUsingBlock</h3><p>在这三种方法中，使用<code>for</code>和<code>enumerateObjectsUsingBlock</code>遍历时，可以修改数组，不会有Crash等问题。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> arrayWithCapacity:<span class=\"number\">8</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"1\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"3\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"4\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"5\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">[array enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"3\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:obj];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// 1,2,4,5</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;array.count; i++) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> *temp = array[i];</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([temp isEqualToString:<span class=\"string\">@\"2\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:temp];</span><br><span class=\"line\">       [array addObject:<span class=\"string\">@\"8\"</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// 1,4,5,8</span></span><br></pre></td></tr></table></figure>\n<p><strong>上述代码虽然没有造成Crash，但是有个潜在的问题，如果遍历时删除元素，可能导致后面的元素不会被遍历到</strong>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> arrayWithCapacity:<span class=\"number\">8</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"1\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"3\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"4\"</span>];</span><br><span class=\"line\">[array addObject:<span class=\"string\">@\"5\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">[array enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"3\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:obj];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"4\"</span>]) &#123; <span class=\"comment\">// 无效</span></span><br><span class=\"line\">       [array removeObject:obj];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// 1,2,4,5</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i&lt;array.count; i++) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> *temp = array[i];</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([temp isEqualToString:<span class=\"string\">@\"2\"</span>]) &#123;</span><br><span class=\"line\">       [array removeObject:temp];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([temp isEqualToString:<span class=\"string\">@\"4\"</span>]) &#123; <span class=\"comment\">// 无效</span></span><br><span class=\"line\">       [array addObject:<span class=\"string\">@\"8\"</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array);<span class=\"comment\">// 1,4,5</span></span><br></pre></td></tr></table></figure>\n<p>虽然遍历时修改数组不会造成Crash，但是<strong>我们还是不建议在遍历可变数组时修改数组</strong>。</p>\n<h3 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for in\"></a>for in</h3><p>当使用<code>for in</code>来遍历时，修改元素会抛出NSGenericException异常。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *str <span class=\"keyword\">in</span> array) &#123; <span class=\"comment\">// Crash </span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([str isEqualToString:<span class=\"string\">@\"2\"</span>]) &#123;</span><br><span class=\"line\">       [array addObject:<span class=\"string\">@\"8\"</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2016/09/04/modify-mutable-array/Snip20160911_1.png\" title=\"for in crash\">\n<p>一个通用的做法是：<code>从原数组copy一个数组出来，然后遍历copy数组，过滤出自己需要的元素，最后再对原数组进行操作</code>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *temp = [array <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 拷贝一份</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *str <span class=\"keyword\">in</span> temp) &#123; <span class=\"comment\">// 遍历拷贝</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([str isEqualToString:<span class=\"string\">@\"2\"</span>]) &#123;</span><br><span class=\"line\">       [array addObject:<span class=\"string\">@\"8\"</span>]; <span class=\"comment\">// 操作原数组</span></span><br><span class=\"line\">       [array removeObject:str];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, array); <span class=\"comment\">// 1,3,4,5,8</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://stackoverflow.com/questions/20069825/ios-modifying-nsfastenumerationstate-to-hide-mutation-while-enumerating\" target=\"_blank\" rel=\"noopener\">iOS : Modifying NSFastEnumerationState to hide mutation while enumerating</a></p>\n"},{"title":"Moya 源码分析（一）","date":"2017-08-27T09:46:51.000Z","_content":"\n## 前言\n\n由于现在业务需要，新项目将使用 Swift 语言进行开发，需要进行技术预言，APP 的开发最重要的部分就是网络请求了。iOS 中可以使用 **URLSession** 进行网络请求，但是方便起见，我通常会选择使用 [**Alamofire**](https://github.com/Alamofire/Alamofire) 这样的著名第三方库。\n\n而 [**Moya**](https://github.com/Moya/Moya) 又是基于 **Alamofire** 的更高一层的网络请求封装抽象层，我们可以直接操作 **Moya**，然后 **Moya** 去管理请求，而不用直接和 **Alamofire** 进行接触。\n\n> 本文不会详细指导如何使用 Moya ，如果你还没使用过 Moya 建议你去下载Demo看看，或者去查看它的温度。\n\n## 结构\n\n本文是基于 **Moya 10.0.1**  进行分析的。\n\n{% asset_img WechatIMG32.jpeg Moya_struct %}\n\n上图是 Moya 的文件结构，接下来将对其主要部分进行分析。\n\n## Target\n\n发出网络请求之前，一般是先建立一个 **Enum** 的 **Target**，它定义了网络请求相关行为，**Target** 必须实现 **TargetType** 协议。\n\n### TargetType.swift\n```swift\npublic protocol TargetType {\n\n    /// The target's base `URL`.\n    var baseURL: URL { get }\n\n    /// The path to be appended to `baseURL` to form the full `URL`.\n    var path: String { get }\n\n    /// The HTTP method used in the request.\n    var method: Moya.Method { get }\n\n    /// Provides stub data for use in testing.\n    /// 用于单元测试的测试数据，只会在单元测试文件中有作用\n    var sampleData: Data { get }\n\n    /// The type of HTTP task to be performed.\n    /// request、upload、download\n    var task: Task { get }\n\n    /// A Boolean value determining whether the embedded target performs Alamofire validation. Defaults to `false`.\n    /// 是否执行Alamofire校验 ，一般有手机号、邮箱号校验之类的\n    var validate: Bool { get }\n\n    /// The headers to be used in the request.\n    /// 请求头\n    var headers: [String: String]? { get }\n}\n\npublic extension TargetType {\n    /// Defaults to `false`.\n    /// 默认不执行Alamofire校验\n    var validate: Bool {\n        return false\n    }\n}\n```\n\n协议很简单，都是网络请求的基础参数，其中有两个有意思的参数：**SampleData** 和 **validate**\n\n**SampleData**，在我们进行单元测试的时候自动返回设置的测试数据，这样在服务器接口没有完成的情况下也能调用网络请求。\n\n**validate**，以前我们想要验证参数的合法性，可能需要这么做：\n* 在发送请求前先校验，不合法 return 并弹出提示框\n* 写一个 Block：(参数)->(校验结果) 当做一个参数传进 Request 方法中\n\n而在 Moya 中，简单很多：\n\n```swift\npublic var validate: Bool {\n    switch self {\n    case .login(params):\n        let phoneNumber = params.phoneNumber\n        return phoneNumber.count == 11\n    default:\n        return false\n    }\n}\n```\n\n#### 通过Enum来管理APIs\n\n可能你们有疑问，返回的值都是固定的，是不是每个API都要创建一个实例遵守 **TargetType** 协议，然后创建一个基类 baseAPI 让其他API继承减少重复代码？\n\n**肯定是不需要基类的**，可以仿照 **TargetType** 返回默认值的扩展，给每个参数返回默认值，这样之后每个API实现了协议，没有赋值的均使用默认值：\n\n```Swift\npublic extension TargetType {\n    \n    // 服务器地址\n    public var baseURL: URL {\n        return ServerHelper.getServerBasePath()\n    }\n    \n    public var path: String {\n        return \"\"\n    }\n    \n    // 请求类型\n    public var method: Moya.Method {\n        return .post\n    }\n    \n    // 是否执行Alamofire验证\n    public var validate: Bool {\n        return false\n    }\n\n    public var sampleData: Data {\n        return \"{}\".data(using: String.Encoding.utf8)!\n    }\n\n    public var headers: [String: String]? {\n        return nil\n    }\n}\n```\n\nDemo 中提供了一个GithubAPI的模块，通过使用Enum的关联值来表示各个API的具体参数：\n\n```swift\npublic enum GitHub {\n    case zen\n    case userProfile(String)\n    case userRepositories(String)\n}\n```\n\n这么简便的使用方式，都需要归功于 Swift 强大的 Enum，如果不是很清楚可以参考这篇文章[《Swift 中枚举高级用法及实践》](http://swift.gg/2015/11/20/advanced-practical-enum-examples/)\n\n## MultiTarget.swift\n\nMoya 中还有个 **MultiTarget.swift** 的文件，它是个遵守了 **TargetType** 协议的 Enum，也重写了协议的每个属性，但是它只有一个Case：\n\n```swift\n/// The embedded `TargetType`.\ncase target(TargetType)\n\n/// Initializes a `MultiTarget`.\npublic init(_ target: TargetType) {\n    self = MultiTarget.target(target)\n}\n    \n/// The embedded `TargetType`.\npublic var target: TargetType {\n    switch self {\n    case .target(let t): return t\n    }\n}\n```\n它的初始化就是传入一个API枚举参数，比如 **GitHub.userRepositories(username)**。\n\n之前我们都是一个 **target** 对应一个 **Provider**。有时我们程序会根据业务逻辑拆分成多个 **target**，这样 **target** 可能就会有很多个，如果有多少个 **target** 我们就创建多少个 **Provider**，会让应用程序的逻辑复杂化。特别是当它们使用同样的 **plugins** 或 **closures** 时，又要做一些额外的工作去维护。\n\n### Provider 定义\n之前一一对应的Privider：\n\n```Swift\nlet giphyProvider = MoyaProvider<Giphy>()\n\nlet gitHubProvider = MoyaProvider<GitHub>()\n```\n\n现在使用多个 **target** 的 Privider：\n\n```swift\nlet provider = MoyaProvider<MultiTarget>()\n```\n\n### Provider 使用\n之前一一对应的Privider：\n\n```swift\ngiphyProvider.request(.upload) { result in\n    // do something with `result`\n}\n \ngitHubProvider.request(.zen) { result in\n    // do something with `result`\n}\n```\n\n现在使用多个 **target** 的 Privider：\n\n```swift\nprovider.request(MultiTarget(Giphy.upload)) { result in\n\t\n}\n\nprovider.request(MultiTarget(GitHub.zen)) { result in\n            \n}\n```\n\n## 参考文档\n* [Swift 中枚举高级用法及实践](http://swift.gg/2015/11/20/advanced-practical-enum-examples/)\n* [Swift - 网络抽象层库Moya的使用详解7(多个target使用同一个Provider)](http://www.hangge.com/blog/cache/detail_1817.html)\n\n","source":"_posts/moya-analysis-1.md","raw":"---\ntitle: Moya 源码分析（一）\ndate: 2017-08-27 17:46:51\ntags: Moya\ncategory: Source Code Analyze\n---\n\n## 前言\n\n由于现在业务需要，新项目将使用 Swift 语言进行开发，需要进行技术预言，APP 的开发最重要的部分就是网络请求了。iOS 中可以使用 **URLSession** 进行网络请求，但是方便起见，我通常会选择使用 [**Alamofire**](https://github.com/Alamofire/Alamofire) 这样的著名第三方库。\n\n而 [**Moya**](https://github.com/Moya/Moya) 又是基于 **Alamofire** 的更高一层的网络请求封装抽象层，我们可以直接操作 **Moya**，然后 **Moya** 去管理请求，而不用直接和 **Alamofire** 进行接触。\n\n> 本文不会详细指导如何使用 Moya ，如果你还没使用过 Moya 建议你去下载Demo看看，或者去查看它的温度。\n\n## 结构\n\n本文是基于 **Moya 10.0.1**  进行分析的。\n\n{% asset_img WechatIMG32.jpeg Moya_struct %}\n\n上图是 Moya 的文件结构，接下来将对其主要部分进行分析。\n\n## Target\n\n发出网络请求之前，一般是先建立一个 **Enum** 的 **Target**，它定义了网络请求相关行为，**Target** 必须实现 **TargetType** 协议。\n\n### TargetType.swift\n```swift\npublic protocol TargetType {\n\n    /// The target's base `URL`.\n    var baseURL: URL { get }\n\n    /// The path to be appended to `baseURL` to form the full `URL`.\n    var path: String { get }\n\n    /// The HTTP method used in the request.\n    var method: Moya.Method { get }\n\n    /// Provides stub data for use in testing.\n    /// 用于单元测试的测试数据，只会在单元测试文件中有作用\n    var sampleData: Data { get }\n\n    /// The type of HTTP task to be performed.\n    /// request、upload、download\n    var task: Task { get }\n\n    /// A Boolean value determining whether the embedded target performs Alamofire validation. Defaults to `false`.\n    /// 是否执行Alamofire校验 ，一般有手机号、邮箱号校验之类的\n    var validate: Bool { get }\n\n    /// The headers to be used in the request.\n    /// 请求头\n    var headers: [String: String]? { get }\n}\n\npublic extension TargetType {\n    /// Defaults to `false`.\n    /// 默认不执行Alamofire校验\n    var validate: Bool {\n        return false\n    }\n}\n```\n\n协议很简单，都是网络请求的基础参数，其中有两个有意思的参数：**SampleData** 和 **validate**\n\n**SampleData**，在我们进行单元测试的时候自动返回设置的测试数据，这样在服务器接口没有完成的情况下也能调用网络请求。\n\n**validate**，以前我们想要验证参数的合法性，可能需要这么做：\n* 在发送请求前先校验，不合法 return 并弹出提示框\n* 写一个 Block：(参数)->(校验结果) 当做一个参数传进 Request 方法中\n\n而在 Moya 中，简单很多：\n\n```swift\npublic var validate: Bool {\n    switch self {\n    case .login(params):\n        let phoneNumber = params.phoneNumber\n        return phoneNumber.count == 11\n    default:\n        return false\n    }\n}\n```\n\n#### 通过Enum来管理APIs\n\n可能你们有疑问，返回的值都是固定的，是不是每个API都要创建一个实例遵守 **TargetType** 协议，然后创建一个基类 baseAPI 让其他API继承减少重复代码？\n\n**肯定是不需要基类的**，可以仿照 **TargetType** 返回默认值的扩展，给每个参数返回默认值，这样之后每个API实现了协议，没有赋值的均使用默认值：\n\n```Swift\npublic extension TargetType {\n    \n    // 服务器地址\n    public var baseURL: URL {\n        return ServerHelper.getServerBasePath()\n    }\n    \n    public var path: String {\n        return \"\"\n    }\n    \n    // 请求类型\n    public var method: Moya.Method {\n        return .post\n    }\n    \n    // 是否执行Alamofire验证\n    public var validate: Bool {\n        return false\n    }\n\n    public var sampleData: Data {\n        return \"{}\".data(using: String.Encoding.utf8)!\n    }\n\n    public var headers: [String: String]? {\n        return nil\n    }\n}\n```\n\nDemo 中提供了一个GithubAPI的模块，通过使用Enum的关联值来表示各个API的具体参数：\n\n```swift\npublic enum GitHub {\n    case zen\n    case userProfile(String)\n    case userRepositories(String)\n}\n```\n\n这么简便的使用方式，都需要归功于 Swift 强大的 Enum，如果不是很清楚可以参考这篇文章[《Swift 中枚举高级用法及实践》](http://swift.gg/2015/11/20/advanced-practical-enum-examples/)\n\n## MultiTarget.swift\n\nMoya 中还有个 **MultiTarget.swift** 的文件，它是个遵守了 **TargetType** 协议的 Enum，也重写了协议的每个属性，但是它只有一个Case：\n\n```swift\n/// The embedded `TargetType`.\ncase target(TargetType)\n\n/// Initializes a `MultiTarget`.\npublic init(_ target: TargetType) {\n    self = MultiTarget.target(target)\n}\n    \n/// The embedded `TargetType`.\npublic var target: TargetType {\n    switch self {\n    case .target(let t): return t\n    }\n}\n```\n它的初始化就是传入一个API枚举参数，比如 **GitHub.userRepositories(username)**。\n\n之前我们都是一个 **target** 对应一个 **Provider**。有时我们程序会根据业务逻辑拆分成多个 **target**，这样 **target** 可能就会有很多个，如果有多少个 **target** 我们就创建多少个 **Provider**，会让应用程序的逻辑复杂化。特别是当它们使用同样的 **plugins** 或 **closures** 时，又要做一些额外的工作去维护。\n\n### Provider 定义\n之前一一对应的Privider：\n\n```Swift\nlet giphyProvider = MoyaProvider<Giphy>()\n\nlet gitHubProvider = MoyaProvider<GitHub>()\n```\n\n现在使用多个 **target** 的 Privider：\n\n```swift\nlet provider = MoyaProvider<MultiTarget>()\n```\n\n### Provider 使用\n之前一一对应的Privider：\n\n```swift\ngiphyProvider.request(.upload) { result in\n    // do something with `result`\n}\n \ngitHubProvider.request(.zen) { result in\n    // do something with `result`\n}\n```\n\n现在使用多个 **target** 的 Privider：\n\n```swift\nprovider.request(MultiTarget(Giphy.upload)) { result in\n\t\n}\n\nprovider.request(MultiTarget(GitHub.zen)) { result in\n            \n}\n```\n\n## 参考文档\n* [Swift 中枚举高级用法及实践](http://swift.gg/2015/11/20/advanced-practical-enum-examples/)\n* [Swift - 网络抽象层库Moya的使用详解7(多个target使用同一个Provider)](http://www.hangge.com/blog/cache/detail_1817.html)\n\n","slug":"moya-analysis-1","published":1,"updated":"2018-01-20T11:39:15.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7lh001x8jpb30tq6mlh","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于现在业务需要，新项目将使用 Swift 语言进行开发，需要进行技术预言，APP 的开发最重要的部分就是网络请求了。iOS 中可以使用 <strong>URLSession</strong> 进行网络请求，但是方便起见，我通常会选择使用 <a href=\"https://github.com/Alamofire/Alamofire\" target=\"_blank\" rel=\"noopener\"><strong>Alamofire</strong></a> 这样的著名第三方库。</p>\n<p>而 <a href=\"https://github.com/Moya/Moya\" target=\"_blank\" rel=\"noopener\"><strong>Moya</strong></a> 又是基于 <strong>Alamofire</strong> 的更高一层的网络请求封装抽象层，我们可以直接操作 <strong>Moya</strong>，然后 <strong>Moya</strong> 去管理请求，而不用直接和 <strong>Alamofire</strong> 进行接触。</p>\n<blockquote>\n<p>本文不会详细指导如何使用 Moya ，如果你还没使用过 Moya 建议你去下载Demo看看，或者去查看它的温度。</p>\n</blockquote>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><p>本文是基于 <strong>Moya 10.0.1</strong>  进行分析的。</p>\n<img src=\"/2017/08/27/moya-analysis-1/WechatIMG32.jpeg\" title=\"Moya_struct\">\n<p>上图是 Moya 的文件结构，接下来将对其主要部分进行分析。</p>\n<h2 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"Target\"></a>Target</h2><p>发出网络请求之前，一般是先建立一个 <strong>Enum</strong> 的 <strong>Target</strong>，它定义了网络请求相关行为，<strong>Target</strong> 必须实现 <strong>TargetType</strong> 协议。</p>\n<h3 id=\"TargetType-swift\"><a href=\"#TargetType-swift\" class=\"headerlink\" title=\"TargetType.swift\"></a>TargetType.swift</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">TargetType</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The target's base `URL`.</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> baseURL: <span class=\"type\">URL</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The path to be appended to `baseURL` to form the full `URL`.</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> path: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The HTTP method used in the request.</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> method: <span class=\"type\">Moya</span>.<span class=\"type\">Method</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Provides stub data for use in testing.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 用于单元测试的测试数据，只会在单元测试文件中有作用</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> sampleData: <span class=\"type\">Data</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The type of HTTP task to be performed.</span></span><br><span class=\"line\">    <span class=\"comment\">/// request、upload、download</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> task: <span class=\"type\">Task</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// A Boolean value determining whether the embedded target performs Alamofire validation. Defaults to `false`.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 是否执行Alamofire校验 ，一般有手机号、邮箱号校验之类的</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> validate: <span class=\"type\">Bool</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The headers to be used in the request.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 请求头</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> headers: [<span class=\"type\">String</span>: <span class=\"type\">String</span>]? &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">TargetType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Defaults to `false`.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 默认不执行Alamofire校验</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> validate: <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>协议很简单，都是网络请求的基础参数，其中有两个有意思的参数：<strong>SampleData</strong> 和 <strong>validate</strong></p>\n<p><strong>SampleData</strong>，在我们进行单元测试的时候自动返回设置的测试数据，这样在服务器接口没有完成的情况下也能调用网络请求。</p>\n<p><strong>validate</strong>，以前我们想要验证参数的合法性，可能需要这么做：</p>\n<ul>\n<li>在发送请求前先校验，不合法 return 并弹出提示框</li>\n<li>写一个 Block：(参数)-&gt;(校验结果) 当做一个参数传进 Request 方法中</li>\n</ul>\n<p>而在 Moya 中，简单很多：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> validate: <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .login(params):</span><br><span class=\"line\">        <span class=\"keyword\">let</span> phoneNumber = params.phoneNumber</span><br><span class=\"line\">        <span class=\"keyword\">return</span> phoneNumber.<span class=\"built_in\">count</span> == <span class=\"number\">11</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过Enum来管理APIs\"><a href=\"#通过Enum来管理APIs\" class=\"headerlink\" title=\"通过Enum来管理APIs\"></a>通过Enum来管理APIs</h4><p>可能你们有疑问，返回的值都是固定的，是不是每个API都要创建一个实例遵守 <strong>TargetType</strong> 协议，然后创建一个基类 baseAPI 让其他API继承减少重复代码？</p>\n<p><strong>肯定是不需要基类的</strong>，可以仿照 <strong>TargetType</strong> 返回默认值的扩展，给每个参数返回默认值，这样之后每个API实现了协议，没有赋值的均使用默认值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">TargetType</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 服务器地址</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> baseURL: <span class=\"type\">URL</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ServerHelper</span>.getServerBasePath()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> path: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 请求类型</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> method: <span class=\"type\">Moya</span>.<span class=\"type\">Method</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> .post</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 是否执行Alamofire验证</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> validate: <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> sampleData: <span class=\"type\">Data</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"&#123;&#125;\"</span>.data(using: <span class=\"type\">String</span>.<span class=\"type\">Encoding</span>.utf8)!</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> headers: [<span class=\"type\">String</span>: <span class=\"type\">String</span>]? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Demo 中提供了一个GithubAPI的模块，通过使用Enum的关联值来表示各个API的具体参数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">GitHub</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> zen</span><br><span class=\"line\">    <span class=\"keyword\">case</span> userProfile(<span class=\"type\">String</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> userRepositories(<span class=\"type\">String</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这么简便的使用方式，都需要归功于 Swift 强大的 Enum，如果不是很清楚可以参考这篇文章<a href=\"http://swift.gg/2015/11/20/advanced-practical-enum-examples/\" target=\"_blank\" rel=\"noopener\">《Swift 中枚举高级用法及实践》</a></p>\n<h2 id=\"MultiTarget-swift\"><a href=\"#MultiTarget-swift\" class=\"headerlink\" title=\"MultiTarget.swift\"></a>MultiTarget.swift</h2><p>Moya 中还有个 <strong>MultiTarget.swift</strong> 的文件，它是个遵守了 <strong>TargetType</strong> 协议的 Enum，也重写了协议的每个属性，但是它只有一个Case：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// The embedded `TargetType`.</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> target(<span class=\"type\">TargetType</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Initializes a `MultiTarget`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"number\">_</span> target: <span class=\"type\">TargetType</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = <span class=\"type\">MultiTarget</span>.target(target)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/// The embedded `TargetType`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> target: <span class=\"type\">TargetType</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .target(<span class=\"keyword\">let</span> t): <span class=\"keyword\">return</span> t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它的初始化就是传入一个API枚举参数，比如 <strong>GitHub.userRepositories(username)</strong>。</p>\n<p>之前我们都是一个 <strong>target</strong> 对应一个 <strong>Provider</strong>。有时我们程序会根据业务逻辑拆分成多个 <strong>target</strong>，这样 <strong>target</strong> 可能就会有很多个，如果有多少个 <strong>target</strong> 我们就创建多少个 <strong>Provider</strong>，会让应用程序的逻辑复杂化。特别是当它们使用同样的 <strong>plugins</strong> 或 <strong>closures</strong> 时，又要做一些额外的工作去维护。</p>\n<h3 id=\"Provider-定义\"><a href=\"#Provider-定义\" class=\"headerlink\" title=\"Provider 定义\"></a>Provider 定义</h3><p>之前一一对应的Privider：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> giphyProvider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">Giphy</span>&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> gitHubProvider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">GitHub</span>&gt;()</span><br></pre></td></tr></table></figure>\n<p>现在使用多个 <strong>target</strong> 的 Privider：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> provider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">MultiTarget</span>&gt;()</span><br></pre></td></tr></table></figure>\n<h3 id=\"Provider-使用\"><a href=\"#Provider-使用\" class=\"headerlink\" title=\"Provider 使用\"></a>Provider 使用</h3><p>之前一一对应的Privider：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">giphyProvider.request(.upload) &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"comment\">// do something with `result`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">gitHubProvider.request(.zen) &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"comment\">// do something with `result`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在使用多个 <strong>target</strong> 的 Privider：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">provider.request(<span class=\"type\">MultiTarget</span>(<span class=\"type\">Giphy</span>.upload)) &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">provider.request(<span class=\"type\">MultiTarget</span>(<span class=\"type\">GitHub</span>.zen)) &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"http://swift.gg/2015/11/20/advanced-practical-enum-examples/\" target=\"_blank\" rel=\"noopener\">Swift 中枚举高级用法及实践</a></li>\n<li><a href=\"http://www.hangge.com/blog/cache/detail_1817.html\" target=\"_blank\" rel=\"noopener\">Swift - 网络抽象层库Moya的使用详解7(多个target使用同一个Provider)</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于现在业务需要，新项目将使用 Swift 语言进行开发，需要进行技术预言，APP 的开发最重要的部分就是网络请求了。iOS 中可以使用 <strong>URLSession</strong> 进行网络请求，但是方便起见，我通常会选择使用 <a href=\"https://github.com/Alamofire/Alamofire\" target=\"_blank\" rel=\"noopener\"><strong>Alamofire</strong></a> 这样的著名第三方库。</p>\n<p>而 <a href=\"https://github.com/Moya/Moya\" target=\"_blank\" rel=\"noopener\"><strong>Moya</strong></a> 又是基于 <strong>Alamofire</strong> 的更高一层的网络请求封装抽象层，我们可以直接操作 <strong>Moya</strong>，然后 <strong>Moya</strong> 去管理请求，而不用直接和 <strong>Alamofire</strong> 进行接触。</p>\n<blockquote>\n<p>本文不会详细指导如何使用 Moya ，如果你还没使用过 Moya 建议你去下载Demo看看，或者去查看它的温度。</p>\n</blockquote>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><p>本文是基于 <strong>Moya 10.0.1</strong>  进行分析的。</p>\n<img src=\"/2017/08/27/moya-analysis-1/WechatIMG32.jpeg\" title=\"Moya_struct\">\n<p>上图是 Moya 的文件结构，接下来将对其主要部分进行分析。</p>\n<h2 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"Target\"></a>Target</h2><p>发出网络请求之前，一般是先建立一个 <strong>Enum</strong> 的 <strong>Target</strong>，它定义了网络请求相关行为，<strong>Target</strong> 必须实现 <strong>TargetType</strong> 协议。</p>\n<h3 id=\"TargetType-swift\"><a href=\"#TargetType-swift\" class=\"headerlink\" title=\"TargetType.swift\"></a>TargetType.swift</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">TargetType</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The target's base `URL`.</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> baseURL: <span class=\"type\">URL</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The path to be appended to `baseURL` to form the full `URL`.</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> path: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The HTTP method used in the request.</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> method: <span class=\"type\">Moya</span>.<span class=\"type\">Method</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Provides stub data for use in testing.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 用于单元测试的测试数据，只会在单元测试文件中有作用</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> sampleData: <span class=\"type\">Data</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The type of HTTP task to be performed.</span></span><br><span class=\"line\">    <span class=\"comment\">/// request、upload、download</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> task: <span class=\"type\">Task</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// A Boolean value determining whether the embedded target performs Alamofire validation. Defaults to `false`.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 是否执行Alamofire校验 ，一般有手机号、邮箱号校验之类的</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> validate: <span class=\"type\">Bool</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The headers to be used in the request.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 请求头</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> headers: [<span class=\"type\">String</span>: <span class=\"type\">String</span>]? &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">TargetType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Defaults to `false`.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 默认不执行Alamofire校验</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> validate: <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>协议很简单，都是网络请求的基础参数，其中有两个有意思的参数：<strong>SampleData</strong> 和 <strong>validate</strong></p>\n<p><strong>SampleData</strong>，在我们进行单元测试的时候自动返回设置的测试数据，这样在服务器接口没有完成的情况下也能调用网络请求。</p>\n<p><strong>validate</strong>，以前我们想要验证参数的合法性，可能需要这么做：</p>\n<ul>\n<li>在发送请求前先校验，不合法 return 并弹出提示框</li>\n<li>写一个 Block：(参数)-&gt;(校验结果) 当做一个参数传进 Request 方法中</li>\n</ul>\n<p>而在 Moya 中，简单很多：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> validate: <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .login(params):</span><br><span class=\"line\">        <span class=\"keyword\">let</span> phoneNumber = params.phoneNumber</span><br><span class=\"line\">        <span class=\"keyword\">return</span> phoneNumber.<span class=\"built_in\">count</span> == <span class=\"number\">11</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过Enum来管理APIs\"><a href=\"#通过Enum来管理APIs\" class=\"headerlink\" title=\"通过Enum来管理APIs\"></a>通过Enum来管理APIs</h4><p>可能你们有疑问，返回的值都是固定的，是不是每个API都要创建一个实例遵守 <strong>TargetType</strong> 协议，然后创建一个基类 baseAPI 让其他API继承减少重复代码？</p>\n<p><strong>肯定是不需要基类的</strong>，可以仿照 <strong>TargetType</strong> 返回默认值的扩展，给每个参数返回默认值，这样之后每个API实现了协议，没有赋值的均使用默认值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">TargetType</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 服务器地址</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> baseURL: <span class=\"type\">URL</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ServerHelper</span>.getServerBasePath()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> path: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 请求类型</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> method: <span class=\"type\">Moya</span>.<span class=\"type\">Method</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> .post</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 是否执行Alamofire验证</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> validate: <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> sampleData: <span class=\"type\">Data</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"&#123;&#125;\"</span>.data(using: <span class=\"type\">String</span>.<span class=\"type\">Encoding</span>.utf8)!</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> headers: [<span class=\"type\">String</span>: <span class=\"type\">String</span>]? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Demo 中提供了一个GithubAPI的模块，通过使用Enum的关联值来表示各个API的具体参数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">GitHub</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> zen</span><br><span class=\"line\">    <span class=\"keyword\">case</span> userProfile(<span class=\"type\">String</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> userRepositories(<span class=\"type\">String</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这么简便的使用方式，都需要归功于 Swift 强大的 Enum，如果不是很清楚可以参考这篇文章<a href=\"http://swift.gg/2015/11/20/advanced-practical-enum-examples/\" target=\"_blank\" rel=\"noopener\">《Swift 中枚举高级用法及实践》</a></p>\n<h2 id=\"MultiTarget-swift\"><a href=\"#MultiTarget-swift\" class=\"headerlink\" title=\"MultiTarget.swift\"></a>MultiTarget.swift</h2><p>Moya 中还有个 <strong>MultiTarget.swift</strong> 的文件，它是个遵守了 <strong>TargetType</strong> 协议的 Enum，也重写了协议的每个属性，但是它只有一个Case：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// The embedded `TargetType`.</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> target(<span class=\"type\">TargetType</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Initializes a `MultiTarget`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"number\">_</span> target: <span class=\"type\">TargetType</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = <span class=\"type\">MultiTarget</span>.target(target)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/// The embedded `TargetType`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> target: <span class=\"type\">TargetType</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .target(<span class=\"keyword\">let</span> t): <span class=\"keyword\">return</span> t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它的初始化就是传入一个API枚举参数，比如 <strong>GitHub.userRepositories(username)</strong>。</p>\n<p>之前我们都是一个 <strong>target</strong> 对应一个 <strong>Provider</strong>。有时我们程序会根据业务逻辑拆分成多个 <strong>target</strong>，这样 <strong>target</strong> 可能就会有很多个，如果有多少个 <strong>target</strong> 我们就创建多少个 <strong>Provider</strong>，会让应用程序的逻辑复杂化。特别是当它们使用同样的 <strong>plugins</strong> 或 <strong>closures</strong> 时，又要做一些额外的工作去维护。</p>\n<h3 id=\"Provider-定义\"><a href=\"#Provider-定义\" class=\"headerlink\" title=\"Provider 定义\"></a>Provider 定义</h3><p>之前一一对应的Privider：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> giphyProvider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">Giphy</span>&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> gitHubProvider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">GitHub</span>&gt;()</span><br></pre></td></tr></table></figure>\n<p>现在使用多个 <strong>target</strong> 的 Privider：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> provider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">MultiTarget</span>&gt;()</span><br></pre></td></tr></table></figure>\n<h3 id=\"Provider-使用\"><a href=\"#Provider-使用\" class=\"headerlink\" title=\"Provider 使用\"></a>Provider 使用</h3><p>之前一一对应的Privider：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">giphyProvider.request(.upload) &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"comment\">// do something with `result`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">gitHubProvider.request(.zen) &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"comment\">// do something with `result`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在使用多个 <strong>target</strong> 的 Privider：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">provider.request(<span class=\"type\">MultiTarget</span>(<span class=\"type\">Giphy</span>.upload)) &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">provider.request(<span class=\"type\">MultiTarget</span>(<span class=\"type\">GitHub</span>.zen)) &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"http://swift.gg/2015/11/20/advanced-practical-enum-examples/\" target=\"_blank\" rel=\"noopener\">Swift 中枚举高级用法及实践</a></li>\n<li><a href=\"http://www.hangge.com/blog/cache/detail_1817.html\" target=\"_blank\" rel=\"noopener\">Swift - 网络抽象层库Moya的使用详解7(多个target使用同一个Provider)</a></li>\n</ul>\n"},{"title":"截取字符串遇到emoji的处理","date":"2017-06-10T08:17:11.000Z","_content":"\n## 前言\n\n最近开发的时候遇到到聊天文本框的字符长度限制的需求，比如粘贴过来的文本超过最大字符限制，将文本截取。但是使用 **substringToIndex** 截取的时候遇到恰好是emoji表情的时候就会出现 emoji 长度不是 1 的情况，截取后出现**半边A**的编码错误的情况。\n\n{% asset_img emoji-substring-error.jpg emojiError %}\n\n## 解决方法\n\n### 方法一（有bug）\n刚开始我觉得既然 emoji 多了一个字符，那我少截取一个字符吧，写了一个方法：\n\n```objc\n- (NSString *)subStringWith:(NSString *)string ToIndex:(NSInteger)index{\n\n    NSString *result = string;\n\n    const char *res = [result substringToIndex:index].UTF8String;\n    if (res == NULL) {\n        result = [result substringToIndex:index - 1];\n    } else {\n        result = [result substringToIndex:index];\n    }\n\n    return result;\n}\n```\n\n将截取的字符转码成 **UTF8** 编码的字符集，然后判断转码是否成功，假如成功了说明截取成功，没有将 emoji 截取错误；反之截取失败，然后少截取一个字符，保持 emoji 完整。\n\n自测后发现，上面的方法放在以前还行，但是现在出现了很多新的 emoji ，比如国旗emoji，占了4个字符长度，利用上面的方法还是会切除失败。\n\n### 方法二（完美解决）\n\n只好上网查找并看了下NSString的API，找到两个API：\n\n```objc\n- (NSRange)rangeOfComposedCharacterSequenceAtIndex:(NSUInteger)index;\n- (NSRange)rangeOfComposedCharacterSequencesForRange:(NSRange)range API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n```\n\n尝试下后发现它可以根据字符组成的序列判断截取的地方是否一个完整的字符，假设是个 emoji 它会将 emoji 完整截取。\n\n\n```objc\n/**\n *  监听输入文字变化\n */\n- (void)inputTextLimited {\n    NSString *resultString = _inputTextView.text;\n    \n    if ([resultString length] > _maxTextLength){\n        NSRange rangeIndex = [resultString rangeOfComposedCharacterSequenceAtIndex:_maxTextLength];\n        _inputTextView.text = [_inputTextView.text substringToIndex:rangeIndex.location];\n    }\n}\n```\n\n\n\n\n\n\n","source":"_posts/nsstring-cropped.md","raw":"---\ntitle: 截取字符串遇到emoji的处理\ndate: 2017-06-10 16:17:11\ntags: emoji\ncategory: Tips\n---\n\n## 前言\n\n最近开发的时候遇到到聊天文本框的字符长度限制的需求，比如粘贴过来的文本超过最大字符限制，将文本截取。但是使用 **substringToIndex** 截取的时候遇到恰好是emoji表情的时候就会出现 emoji 长度不是 1 的情况，截取后出现**半边A**的编码错误的情况。\n\n{% asset_img emoji-substring-error.jpg emojiError %}\n\n## 解决方法\n\n### 方法一（有bug）\n刚开始我觉得既然 emoji 多了一个字符，那我少截取一个字符吧，写了一个方法：\n\n```objc\n- (NSString *)subStringWith:(NSString *)string ToIndex:(NSInteger)index{\n\n    NSString *result = string;\n\n    const char *res = [result substringToIndex:index].UTF8String;\n    if (res == NULL) {\n        result = [result substringToIndex:index - 1];\n    } else {\n        result = [result substringToIndex:index];\n    }\n\n    return result;\n}\n```\n\n将截取的字符转码成 **UTF8** 编码的字符集，然后判断转码是否成功，假如成功了说明截取成功，没有将 emoji 截取错误；反之截取失败，然后少截取一个字符，保持 emoji 完整。\n\n自测后发现，上面的方法放在以前还行，但是现在出现了很多新的 emoji ，比如国旗emoji，占了4个字符长度，利用上面的方法还是会切除失败。\n\n### 方法二（完美解决）\n\n只好上网查找并看了下NSString的API，找到两个API：\n\n```objc\n- (NSRange)rangeOfComposedCharacterSequenceAtIndex:(NSUInteger)index;\n- (NSRange)rangeOfComposedCharacterSequencesForRange:(NSRange)range API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n```\n\n尝试下后发现它可以根据字符组成的序列判断截取的地方是否一个完整的字符，假设是个 emoji 它会将 emoji 完整截取。\n\n\n```objc\n/**\n *  监听输入文字变化\n */\n- (void)inputTextLimited {\n    NSString *resultString = _inputTextView.text;\n    \n    if ([resultString length] > _maxTextLength){\n        NSRange rangeIndex = [resultString rangeOfComposedCharacterSequenceAtIndex:_maxTextLength];\n        _inputTextView.text = [_inputTextView.text substringToIndex:rangeIndex.location];\n    }\n}\n```\n\n\n\n\n\n\n","slug":"nsstring-cropped","published":1,"updated":"2017-11-05T08:52:56.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7li00208jpb9xe69nlu","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近开发的时候遇到到聊天文本框的字符长度限制的需求，比如粘贴过来的文本超过最大字符限制，将文本截取。但是使用 <strong>substringToIndex</strong> 截取的时候遇到恰好是emoji表情的时候就会出现 emoji 长度不是 1 的情况，截取后出现<strong>半边A</strong>的编码错误的情况。</p>\n<img src=\"/2017/06/10/nsstring-cropped/emoji-substring-error.jpg\" title=\"emojiError\">\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><h3 id=\"方法一（有bug）\"><a href=\"#方法一（有bug）\" class=\"headerlink\" title=\"方法一（有bug）\"></a>方法一（有bug）</h3><p>刚开始我觉得既然 emoji 多了一个字符，那我少截取一个字符吧，写了一个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)subStringWith:(<span class=\"built_in\">NSString</span> *)string ToIndex:(<span class=\"built_in\">NSInteger</span>)index&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *result = string;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *res = [result substringToIndex:index].UTF8String;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        result = [result substringToIndex:index - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        result = [result substringToIndex:index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将截取的字符转码成 <strong>UTF8</strong> 编码的字符集，然后判断转码是否成功，假如成功了说明截取成功，没有将 emoji 截取错误；反之截取失败，然后少截取一个字符，保持 emoji 完整。</p>\n<p>自测后发现，上面的方法放在以前还行，但是现在出现了很多新的 emoji ，比如国旗emoji，占了4个字符长度，利用上面的方法还是会切除失败。</p>\n<h3 id=\"方法二（完美解决）\"><a href=\"#方法二（完美解决）\" class=\"headerlink\" title=\"方法二（完美解决）\"></a>方法二（完美解决）</h3><p>只好上网查找并看了下NSString的API，找到两个API：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSRange</span>)rangeOfComposedCharacterSequenceAtIndex:(<span class=\"built_in\">NSUInteger</span>)index;</span><br><span class=\"line\">- (<span class=\"built_in\">NSRange</span>)rangeOfComposedCharacterSequencesForRange:(<span class=\"built_in\">NSRange</span>)range API_AVAILABLE(macos(<span class=\"number\">10.5</span>), ios(<span class=\"number\">2.0</span>), watchos(<span class=\"number\">2.0</span>), tvos(<span class=\"number\">9.0</span>));</span><br></pre></td></tr></table></figure>\n<p>尝试下后发现它可以根据字符组成的序列判断截取的地方是否一个完整的字符，假设是个 emoji 它会将 emoji 完整截取。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  监听输入文字变化</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)inputTextLimited &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *resultString = _inputTextView.text;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([resultString length] &gt; _maxTextLength)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSRange</span> rangeIndex = [resultString rangeOfComposedCharacterSequenceAtIndex:_maxTextLength];</span><br><span class=\"line\">        _inputTextView.text = [_inputTextView.text substringToIndex:rangeIndex.location];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近开发的时候遇到到聊天文本框的字符长度限制的需求，比如粘贴过来的文本超过最大字符限制，将文本截取。但是使用 <strong>substringToIndex</strong> 截取的时候遇到恰好是emoji表情的时候就会出现 emoji 长度不是 1 的情况，截取后出现<strong>半边A</strong>的编码错误的情况。</p>\n<img src=\"/2017/06/10/nsstring-cropped/emoji-substring-error.jpg\" title=\"emojiError\">\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><h3 id=\"方法一（有bug）\"><a href=\"#方法一（有bug）\" class=\"headerlink\" title=\"方法一（有bug）\"></a>方法一（有bug）</h3><p>刚开始我觉得既然 emoji 多了一个字符，那我少截取一个字符吧，写了一个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)subStringWith:(<span class=\"built_in\">NSString</span> *)string ToIndex:(<span class=\"built_in\">NSInteger</span>)index&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *result = string;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *res = [result substringToIndex:index].UTF8String;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        result = [result substringToIndex:index - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        result = [result substringToIndex:index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将截取的字符转码成 <strong>UTF8</strong> 编码的字符集，然后判断转码是否成功，假如成功了说明截取成功，没有将 emoji 截取错误；反之截取失败，然后少截取一个字符，保持 emoji 完整。</p>\n<p>自测后发现，上面的方法放在以前还行，但是现在出现了很多新的 emoji ，比如国旗emoji，占了4个字符长度，利用上面的方法还是会切除失败。</p>\n<h3 id=\"方法二（完美解决）\"><a href=\"#方法二（完美解决）\" class=\"headerlink\" title=\"方法二（完美解决）\"></a>方法二（完美解决）</h3><p>只好上网查找并看了下NSString的API，找到两个API：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSRange</span>)rangeOfComposedCharacterSequenceAtIndex:(<span class=\"built_in\">NSUInteger</span>)index;</span><br><span class=\"line\">- (<span class=\"built_in\">NSRange</span>)rangeOfComposedCharacterSequencesForRange:(<span class=\"built_in\">NSRange</span>)range API_AVAILABLE(macos(<span class=\"number\">10.5</span>), ios(<span class=\"number\">2.0</span>), watchos(<span class=\"number\">2.0</span>), tvos(<span class=\"number\">9.0</span>));</span><br></pre></td></tr></table></figure>\n<p>尝试下后发现它可以根据字符组成的序列判断截取的地方是否一个完整的字符，假设是个 emoji 它会将 emoji 完整截取。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  监听输入文字变化</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)inputTextLimited &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *resultString = _inputTextView.text;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([resultString length] &gt; _maxTextLength)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSRange</span> rangeIndex = [resultString rangeOfComposedCharacterSequenceAtIndex:_maxTextLength];</span><br><span class=\"line\">        _inputTextView.text = [_inputTextView.text substringToIndex:rangeIndex.location];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Moya 源码分析（三）","date":"2017-10-28T02:50:51.000Z","_content":"\n## 前言\n\n前两篇文章已经将 Moya 的主体思想`Target -> Endpoint -> Request`大致分析了下，本章将说说 Moya 的 **Plugin** 插件机制。\n\n## Plugin\n\nMoya 提供还提供插件机制，你可以自定义各种插件，所有插件必须满足 PluginType 协议：\n\n```swift\npublic protocol PluginType {\n    /// Called to modify a request before sending.\n    func prepare(_ request: URLRequest, target: TargetType) -> URLRequest\n\n    /// Called immediately before a request is sent over the network (or stubbed).\n    func willSend(_ request: RequestType, target: TargetType)\n\n    /// Called after a response has been received, but before the MoyaProvider has invoked its completion handler.\n    func didReceive(_ result: Result<Moya.Response, MoyaError>, target: TargetType)\n\n    /// Called to modify a result before completion.\n    func process(_ result: Result<Moya.Response, MoyaError>, target: TargetType) -> Result<Moya.Response, MoyaError>\n}\n\npublic extension PluginType {\n    func prepare(_ request: URLRequest, target: TargetType) -> URLRequest { return request }\n    func willSend(_ request: RequestType, target: TargetType) { }\n    func didReceive(_ result: Result<Moya.Response, MoyaError>, target: TargetType) { }\n    func process(_ result: Result<Moya.Response, MoyaError>, target: TargetType) -> Result<Moya.Response, MoyaError> { return result }\n}\n```\n\n协议里定义一个网络请求流程里可以处理的事情：\n* prepare 准备发起请求\n* willSend 开始发起请求\n* didReceive 收到请求响应\n* process 处理请求结果\n\nMoya 默认提供了四个插件：\n\nAccessTokenAuthorizable插件 (AccessTokenAuthorizable.swift)，HTTP认证的插件。\nCredentialsPlugin 插件，URL证书插件。\nLogging插件(NetworkLoggerPlugin.swift)，在调试时，输入网络请求的调试信息到控制台\nNetwork Activity Indicator插件（NetworkActivityPlugin.swift）。可以用这个插件来显示网络菊花。\n\n\n如果要创建自定义插件，请参考[《创建自定义插件》](http://www.hangge.com/blog/cache/detail_1818.html)\n\n\n","source":"_posts/moya-analysis-3.md","raw":"---\ntitle: Moya 源码分析（三）\ndate: 2017-10-28 10:50:51\ntags: Moya\ncategory: Source Code Analyze\n---\n\n## 前言\n\n前两篇文章已经将 Moya 的主体思想`Target -> Endpoint -> Request`大致分析了下，本章将说说 Moya 的 **Plugin** 插件机制。\n\n## Plugin\n\nMoya 提供还提供插件机制，你可以自定义各种插件，所有插件必须满足 PluginType 协议：\n\n```swift\npublic protocol PluginType {\n    /// Called to modify a request before sending.\n    func prepare(_ request: URLRequest, target: TargetType) -> URLRequest\n\n    /// Called immediately before a request is sent over the network (or stubbed).\n    func willSend(_ request: RequestType, target: TargetType)\n\n    /// Called after a response has been received, but before the MoyaProvider has invoked its completion handler.\n    func didReceive(_ result: Result<Moya.Response, MoyaError>, target: TargetType)\n\n    /// Called to modify a result before completion.\n    func process(_ result: Result<Moya.Response, MoyaError>, target: TargetType) -> Result<Moya.Response, MoyaError>\n}\n\npublic extension PluginType {\n    func prepare(_ request: URLRequest, target: TargetType) -> URLRequest { return request }\n    func willSend(_ request: RequestType, target: TargetType) { }\n    func didReceive(_ result: Result<Moya.Response, MoyaError>, target: TargetType) { }\n    func process(_ result: Result<Moya.Response, MoyaError>, target: TargetType) -> Result<Moya.Response, MoyaError> { return result }\n}\n```\n\n协议里定义一个网络请求流程里可以处理的事情：\n* prepare 准备发起请求\n* willSend 开始发起请求\n* didReceive 收到请求响应\n* process 处理请求结果\n\nMoya 默认提供了四个插件：\n\nAccessTokenAuthorizable插件 (AccessTokenAuthorizable.swift)，HTTP认证的插件。\nCredentialsPlugin 插件，URL证书插件。\nLogging插件(NetworkLoggerPlugin.swift)，在调试时，输入网络请求的调试信息到控制台\nNetwork Activity Indicator插件（NetworkActivityPlugin.swift）。可以用这个插件来显示网络菊花。\n\n\n如果要创建自定义插件，请参考[《创建自定义插件》](http://www.hangge.com/blog/cache/detail_1818.html)\n\n\n","slug":"moya-analysis-3","published":1,"updated":"2018-01-20T14:35:12.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7lk00238jpbw0w5mhpi","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前两篇文章已经将 Moya 的主体思想<code>Target -&gt; Endpoint -&gt; Request</code>大致分析了下，本章将说说 Moya 的 <strong>Plugin</strong> 插件机制。</p>\n<h2 id=\"Plugin\"><a href=\"#Plugin\" class=\"headerlink\" title=\"Plugin\"></a>Plugin</h2><p>Moya 提供还提供插件机制，你可以自定义各种插件，所有插件必须满足 PluginType 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PluginType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Called to modify a request before sending.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"number\">_</span> request: URLRequest, target: TargetType)</span></span> -&gt; <span class=\"type\">URLRequest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Called immediately before a request is sent over the network (or stubbed).</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">willSend</span><span class=\"params\">(<span class=\"number\">_</span> request: RequestType, target: TargetType)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Called after a response has been received, but before the MoyaProvider has invoked its completion handler.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(<span class=\"number\">_</span> result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Called to modify a result before completion.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"number\">_</span> result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span></span> -&gt; <span class=\"type\">Result</span>&lt;<span class=\"type\">Moya</span>.<span class=\"type\">Response</span>, <span class=\"type\">MoyaError</span>&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">PluginType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"number\">_</span> request: URLRequest, target: TargetType)</span></span> -&gt; <span class=\"type\">URLRequest</span> &#123; <span class=\"keyword\">return</span> request &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">willSend</span><span class=\"params\">(<span class=\"number\">_</span> request: RequestType, target: TargetType)</span></span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(<span class=\"number\">_</span> result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span></span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"number\">_</span> result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span></span> -&gt; <span class=\"type\">Result</span>&lt;<span class=\"type\">Moya</span>.<span class=\"type\">Response</span>, <span class=\"type\">MoyaError</span>&gt; &#123; <span class=\"keyword\">return</span> result &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>协议里定义一个网络请求流程里可以处理的事情：</p>\n<ul>\n<li>prepare 准备发起请求</li>\n<li>willSend 开始发起请求</li>\n<li>didReceive 收到请求响应</li>\n<li>process 处理请求结果</li>\n</ul>\n<p>Moya 默认提供了四个插件：</p>\n<p>AccessTokenAuthorizable插件 (AccessTokenAuthorizable.swift)，HTTP认证的插件。<br>CredentialsPlugin 插件，URL证书插件。<br>Logging插件(NetworkLoggerPlugin.swift)，在调试时，输入网络请求的调试信息到控制台<br>Network Activity Indicator插件（NetworkActivityPlugin.swift）。可以用这个插件来显示网络菊花。</p>\n<p>如果要创建自定义插件，请参考<a href=\"http://www.hangge.com/blog/cache/detail_1818.html\" target=\"_blank\" rel=\"noopener\">《创建自定义插件》</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前两篇文章已经将 Moya 的主体思想<code>Target -&gt; Endpoint -&gt; Request</code>大致分析了下，本章将说说 Moya 的 <strong>Plugin</strong> 插件机制。</p>\n<h2 id=\"Plugin\"><a href=\"#Plugin\" class=\"headerlink\" title=\"Plugin\"></a>Plugin</h2><p>Moya 提供还提供插件机制，你可以自定义各种插件，所有插件必须满足 PluginType 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PluginType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Called to modify a request before sending.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"number\">_</span> request: URLRequest, target: TargetType)</span></span> -&gt; <span class=\"type\">URLRequest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Called immediately before a request is sent over the network (or stubbed).</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">willSend</span><span class=\"params\">(<span class=\"number\">_</span> request: RequestType, target: TargetType)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Called after a response has been received, but before the MoyaProvider has invoked its completion handler.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(<span class=\"number\">_</span> result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Called to modify a result before completion.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"number\">_</span> result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span></span> -&gt; <span class=\"type\">Result</span>&lt;<span class=\"type\">Moya</span>.<span class=\"type\">Response</span>, <span class=\"type\">MoyaError</span>&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">PluginType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"number\">_</span> request: URLRequest, target: TargetType)</span></span> -&gt; <span class=\"type\">URLRequest</span> &#123; <span class=\"keyword\">return</span> request &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">willSend</span><span class=\"params\">(<span class=\"number\">_</span> request: RequestType, target: TargetType)</span></span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(<span class=\"number\">_</span> result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span></span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"number\">_</span> result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span></span> -&gt; <span class=\"type\">Result</span>&lt;<span class=\"type\">Moya</span>.<span class=\"type\">Response</span>, <span class=\"type\">MoyaError</span>&gt; &#123; <span class=\"keyword\">return</span> result &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>协议里定义一个网络请求流程里可以处理的事情：</p>\n<ul>\n<li>prepare 准备发起请求</li>\n<li>willSend 开始发起请求</li>\n<li>didReceive 收到请求响应</li>\n<li>process 处理请求结果</li>\n</ul>\n<p>Moya 默认提供了四个插件：</p>\n<p>AccessTokenAuthorizable插件 (AccessTokenAuthorizable.swift)，HTTP认证的插件。<br>CredentialsPlugin 插件，URL证书插件。<br>Logging插件(NetworkLoggerPlugin.swift)，在调试时，输入网络请求的调试信息到控制台<br>Network Activity Indicator插件（NetworkActivityPlugin.swift）。可以用这个插件来显示网络菊花。</p>\n<p>如果要创建自定义插件，请参考<a href=\"http://www.hangge.com/blog/cache/detail_1818.html\" target=\"_blank\" rel=\"noopener\">《创建自定义插件》</a></p>\n"},{"title":"nil / Nil / NULL / NSNull","date":"2016-11-13T05:30:01.000Z","_content":"\n## 前言\n每种开发语言都有判断对象不存在的时候，最基础的C语言是通过“0”来判断“不存在”，而用 **NULL** 作为指针空值。在 OC 中有`nil` / `Nil` / `NULL` / `NSNull`。下面我们分别来看看这几种空值的区别。\n\n## nil\nObjective-C在C的表达不存在的基础上增加了nil。nil是一个指向不存在的对象指针。\n\n在 objc.h 中的定义：\n\n```objc\n#ifndef nil\n# if __has_feature(cxx_nullptr)\n#   define nil nullptr\n# else\n#   define nil __DARWIN_NULL\n# endif\n#endif\n```\n判断是否有 **cxx_nullptr** 特性，如果有， nil 定义为 **nullptr**，否则定义为 **__DARWIN_NULL**。\n\n在 _types.h 中的定义：\n\n```objc\n#define __DARWIN_NULL ((void *)0)\n```\n\n本质上 nil 是 **(void *)0**。\n\n### 使用场景\nnil 一般用于指向Objective-C对象，表示对象为空，例如：\n\n```objc\nNSObject *obj = nil;\nid onObj = nil;\nif (obj2){...}\n```\n\nnil 最显著的行为是，它虽然为零，仍然可以有消息发送给它。在别的语言里，比如Java，调用空对象的方法会崩溃，但是在Objective-C中，即使nil为“零”，你也可以调用它的方法，这样可以简化非空判断：\n\n```objc\n// 举个例子，这个表达...\nif (name != nil && [name isEqualToString:@\"Steve\"]) { ... }\n\n// ...可以被简化为：\nif ([name isEqualToString:@\"steve\"]) { ... }\n```\n\n## Nil\n在 objc.h 中定义：\n\n```objc\n#ifndef Nil\n# if __has_feature(cxx_nullptr)\n#   define Nil nullptr\n# else\n#   define Nil __DARWIN_NULL\n# endif\n#endif\n```\n与 `nil` 基本一致，本质上也是 **(void *)0**。\n\n### 使用场景\nNil 是 Objective-C 类类型的书面空值，对应 Class 类型对象。\n\n```objc\nClass someClass = Nil;\nClass anotherClass = [NSString class];\n```\n\n## NULL\n在 _null.h 中的定义：\n\n```objc\n#ifndef NULL \n#define NULL  __DARWIN_NULL\n#endif  /* NULL */\n```\n\n那么本质上 NULL 也是 **(void *)0**。\n\n### 使用场景\nNULL 一般用于表示 C 指针空值，例如：\n\n```objc\nint *pointerToInt = NULL;\nchar *pointerToChar = NULL;\nstruct TreeNode *rootNode = NULL;\n```\n\n## NSNull\n看到 **NS** 就可以判断它是  Objective-C 的一个类，代表空值的类。它定义在 NSNull.h 文件里：\n\n```objc\n#import <Foundation/NSObject.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface NSNull : NSObject <NSCopying, NSSecureCoding>\n\n+ (NSNull *)null;\n\n@end\n\nNS_ASSUME_NONNULL_END\n```\n\nNSNull 只有一个单例方法 +[NSnull null]，一般用于在集合对象中保存一个空的占位对象。\n\n### 使用场景\n在 Foundation 集合对象（NSArray、NSDictionary、NSSet 等）中， nil 通常被用于表示集合对象结束的标志，因此无法用 nil 来存储一个空值，所以一般用 [NSNull null] 空对象来存储。另外，在 NSDictionary 的 -objectForKey: 方法中，如果当前字典中 key 对应的值不存在时，该方法会返回 nil，表明当前 key 在字典中未添加，但是如果我们想明确表示某一 key 已经在字典中添加，但是它没有值，这时候就可以用 [NSNull null] 来赋值表示。\n\n```objc\n// 当 NSArray 里遇到 nil 时，就说明这个数组对象的元素截止了，即 NSArray 只关注 nil 之前的对象，nil 之后的对象会被抛弃。\nNSArray *array = [NSArray arrayWithObjects:@\"one\", @\"two\", nil];\n \n// 错误的使用\nNSMutableDictionary *dict = [NSMutableDictionary dictionary];\n[dict setObject:nil forKey:@\"someKey\"];\n \n// 正确的使用\nNSMutableDictionary *dict = [NSMutableDictionary dictionary];\n[dict setObject:[NSNull null] forKey:@\"someKey\"];\n```\n\n## NIL 或 NSNil\n\n**Objective-C 中不存在这两个符号！！！**\n\n## 总结\n从上述分析我们可知，不管是 NULL、nil 还是 Nil，它们本质上是一样的，都是 (void *)0，只是写法不同。这样做的意义是为了区分不同的数据类型，虽然它们值相同，但我们需要理解它们之间的字面意义并用于不同场景，让代码更加明确，增加可读性。\n\n| 标志 | 值 | 含义 |\n| :------------ | :--------------- | :----- |\n| NULL | (void *)0 | C指针的字面零值 |\n| nil | (id)0 | Objective-C对象的字面零值 |\n| Nil | (Class)0 | Objective-C类的字面零值 |\n| NSNull | [NSNull null] | 用来表示零值的单独的对象 |\n\n## 参考链接\n* [nil / Nil / NULL / NSNull](http://nshipster.cn/nil/)\n* [Objective C 中的nil，Nil，NULL和NSNull理解](http://magicalboy.com/null-value-in-objective-c/)\n* [nil/Nil/NULL/NSNull的区别](http://blog.csdn.net/wzzvictory/article/details/18413519)\n* [Objective-C 中 NULL、nil、Nil、NSNull 的定义及不同](https://kangzubin.cn/null-and-nil-in-objective-c/#more)\n\n\n","source":"_posts/null-and-nil.md","raw":"---\ntitle: nil / Nil / NULL / NSNull\ndate: 2016-11-13 13:30:01\ntags: nil\ncategory: 拿来主义\n---\n\n## 前言\n每种开发语言都有判断对象不存在的时候，最基础的C语言是通过“0”来判断“不存在”，而用 **NULL** 作为指针空值。在 OC 中有`nil` / `Nil` / `NULL` / `NSNull`。下面我们分别来看看这几种空值的区别。\n\n## nil\nObjective-C在C的表达不存在的基础上增加了nil。nil是一个指向不存在的对象指针。\n\n在 objc.h 中的定义：\n\n```objc\n#ifndef nil\n# if __has_feature(cxx_nullptr)\n#   define nil nullptr\n# else\n#   define nil __DARWIN_NULL\n# endif\n#endif\n```\n判断是否有 **cxx_nullptr** 特性，如果有， nil 定义为 **nullptr**，否则定义为 **__DARWIN_NULL**。\n\n在 _types.h 中的定义：\n\n```objc\n#define __DARWIN_NULL ((void *)0)\n```\n\n本质上 nil 是 **(void *)0**。\n\n### 使用场景\nnil 一般用于指向Objective-C对象，表示对象为空，例如：\n\n```objc\nNSObject *obj = nil;\nid onObj = nil;\nif (obj2){...}\n```\n\nnil 最显著的行为是，它虽然为零，仍然可以有消息发送给它。在别的语言里，比如Java，调用空对象的方法会崩溃，但是在Objective-C中，即使nil为“零”，你也可以调用它的方法，这样可以简化非空判断：\n\n```objc\n// 举个例子，这个表达...\nif (name != nil && [name isEqualToString:@\"Steve\"]) { ... }\n\n// ...可以被简化为：\nif ([name isEqualToString:@\"steve\"]) { ... }\n```\n\n## Nil\n在 objc.h 中定义：\n\n```objc\n#ifndef Nil\n# if __has_feature(cxx_nullptr)\n#   define Nil nullptr\n# else\n#   define Nil __DARWIN_NULL\n# endif\n#endif\n```\n与 `nil` 基本一致，本质上也是 **(void *)0**。\n\n### 使用场景\nNil 是 Objective-C 类类型的书面空值，对应 Class 类型对象。\n\n```objc\nClass someClass = Nil;\nClass anotherClass = [NSString class];\n```\n\n## NULL\n在 _null.h 中的定义：\n\n```objc\n#ifndef NULL \n#define NULL  __DARWIN_NULL\n#endif  /* NULL */\n```\n\n那么本质上 NULL 也是 **(void *)0**。\n\n### 使用场景\nNULL 一般用于表示 C 指针空值，例如：\n\n```objc\nint *pointerToInt = NULL;\nchar *pointerToChar = NULL;\nstruct TreeNode *rootNode = NULL;\n```\n\n## NSNull\n看到 **NS** 就可以判断它是  Objective-C 的一个类，代表空值的类。它定义在 NSNull.h 文件里：\n\n```objc\n#import <Foundation/NSObject.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface NSNull : NSObject <NSCopying, NSSecureCoding>\n\n+ (NSNull *)null;\n\n@end\n\nNS_ASSUME_NONNULL_END\n```\n\nNSNull 只有一个单例方法 +[NSnull null]，一般用于在集合对象中保存一个空的占位对象。\n\n### 使用场景\n在 Foundation 集合对象（NSArray、NSDictionary、NSSet 等）中， nil 通常被用于表示集合对象结束的标志，因此无法用 nil 来存储一个空值，所以一般用 [NSNull null] 空对象来存储。另外，在 NSDictionary 的 -objectForKey: 方法中，如果当前字典中 key 对应的值不存在时，该方法会返回 nil，表明当前 key 在字典中未添加，但是如果我们想明确表示某一 key 已经在字典中添加，但是它没有值，这时候就可以用 [NSNull null] 来赋值表示。\n\n```objc\n// 当 NSArray 里遇到 nil 时，就说明这个数组对象的元素截止了，即 NSArray 只关注 nil 之前的对象，nil 之后的对象会被抛弃。\nNSArray *array = [NSArray arrayWithObjects:@\"one\", @\"two\", nil];\n \n// 错误的使用\nNSMutableDictionary *dict = [NSMutableDictionary dictionary];\n[dict setObject:nil forKey:@\"someKey\"];\n \n// 正确的使用\nNSMutableDictionary *dict = [NSMutableDictionary dictionary];\n[dict setObject:[NSNull null] forKey:@\"someKey\"];\n```\n\n## NIL 或 NSNil\n\n**Objective-C 中不存在这两个符号！！！**\n\n## 总结\n从上述分析我们可知，不管是 NULL、nil 还是 Nil，它们本质上是一样的，都是 (void *)0，只是写法不同。这样做的意义是为了区分不同的数据类型，虽然它们值相同，但我们需要理解它们之间的字面意义并用于不同场景，让代码更加明确，增加可读性。\n\n| 标志 | 值 | 含义 |\n| :------------ | :--------------- | :----- |\n| NULL | (void *)0 | C指针的字面零值 |\n| nil | (id)0 | Objective-C对象的字面零值 |\n| Nil | (Class)0 | Objective-C类的字面零值 |\n| NSNull | [NSNull null] | 用来表示零值的单独的对象 |\n\n## 参考链接\n* [nil / Nil / NULL / NSNull](http://nshipster.cn/nil/)\n* [Objective C 中的nil，Nil，NULL和NSNull理解](http://magicalboy.com/null-value-in-objective-c/)\n* [nil/Nil/NULL/NSNull的区别](http://blog.csdn.net/wzzvictory/article/details/18413519)\n* [Objective-C 中 NULL、nil、Nil、NSNull 的定义及不同](https://kangzubin.cn/null-and-nil-in-objective-c/#more)\n\n\n","slug":"null-and-nil","published":1,"updated":"2017-03-05T07:32:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7ll00278jpbp4u4fwo3","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>每种开发语言都有判断对象不存在的时候，最基础的C语言是通过“0”来判断“不存在”，而用 <strong>NULL</strong> 作为指针空值。在 OC 中有<code>nil</code> / <code>Nil</code> / <code>NULL</code> / <code>NSNull</code>。下面我们分别来看看这几种空值的区别。</p>\n<h2 id=\"nil\"><a href=\"#nil\" class=\"headerlink\" title=\"nil\"></a>nil</h2><p>Objective-C在C的表达不存在的基础上增加了nil。nil是一个指向不存在的对象指针。</p>\n<p>在 objc.h 中的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifndef nil</span></span><br><span class=\"line\"><span class=\"meta\"># if __has_feature(cxx_nullptr)</span></span><br><span class=\"line\"><span class=\"meta\">#   define nil nullptr</span></span><br><span class=\"line\"><span class=\"meta\"># else</span></span><br><span class=\"line\"><span class=\"meta\">#   define nil __DARWIN_NULL</span></span><br><span class=\"line\"><span class=\"meta\"># endif</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>判断是否有 <strong>cxx_nullptr</strong> 特性，如果有， nil 定义为 <strong>nullptr</strong>，否则定义为 <strong>__DARWIN_NULL</strong>。</p>\n<p>在 _types.h 中的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define __DARWIN_NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>\n<p>本质上 nil 是 <strong>(void *)0</strong>。</p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>nil 一般用于指向Objective-C对象，表示对象为空，例如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSObject</span> *obj = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"><span class=\"keyword\">id</span> onObj = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (obj2)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>nil 最显著的行为是，它虽然为零，仍然可以有消息发送给它。在别的语言里，比如Java，调用空对象的方法会崩溃，但是在Objective-C中，即使nil为“零”，你也可以调用它的方法，这样可以简化非空判断：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 举个例子，这个表达...</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (name != <span class=\"literal\">nil</span> &amp;&amp; [name isEqualToString:<span class=\"string\">@\"Steve\"</span>]) &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...可以被简化为：</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([name isEqualToString:<span class=\"string\">@\"steve\"</span>]) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Nil\"><a href=\"#Nil\" class=\"headerlink\" title=\"Nil\"></a>Nil</h2><p>在 objc.h 中定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifndef Nil</span></span><br><span class=\"line\"><span class=\"meta\"># if __has_feature(cxx_nullptr)</span></span><br><span class=\"line\"><span class=\"meta\">#   define Nil nullptr</span></span><br><span class=\"line\"><span class=\"meta\"># else</span></span><br><span class=\"line\"><span class=\"meta\">#   define Nil __DARWIN_NULL</span></span><br><span class=\"line\"><span class=\"meta\"># endif</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>与 <code>nil</code> 基本一致，本质上也是 <strong>(void *)0</strong>。</p>\n<h3 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>Nil 是 Objective-C 类类型的书面空值，对应 Class 类型对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class someClass = Nil;</span><br><span class=\"line\">Class anotherClass = [<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"NULL\"><a href=\"#NULL\" class=\"headerlink\" title=\"NULL\"></a>NULL</h2><p>在 _null.h 中的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifndef NULL </span></span><br><span class=\"line\"><span class=\"meta\">#define NULL  __DARWIN_NULL</span></span><br><span class=\"line\"><span class=\"meta\">#endif  /* NULL */</span></span><br></pre></td></tr></table></figure>\n<p>那么本质上 NULL 也是 <strong>(void *)0</strong>。</p>\n<h3 id=\"使用场景-2\"><a href=\"#使用场景-2\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>NULL 一般用于表示 C 指针空值，例如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pointerToInt = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *pointerToChar = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> TreeNode *rootNode = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"NSNull\"><a href=\"#NSNull\" class=\"headerlink\" title=\"NSNull\"></a>NSNull</h2><p>看到 <strong>NS</strong> 就可以判断它是  Objective-C 的一个类，代表空值的类。它定义在 NSNull.h 文件里：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/NSObject.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSNull</span> : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">NSCopying</span>, <span class=\"title\">NSSecureCoding</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSNull</span> *)null;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>\n<p>NSNull 只有一个单例方法 +[NSnull null]，一般用于在集合对象中保存一个空的占位对象。</p>\n<h3 id=\"使用场景-3\"><a href=\"#使用场景-3\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>在 Foundation 集合对象（NSArray、NSDictionary、NSSet 等）中， nil 通常被用于表示集合对象结束的标志，因此无法用 nil 来存储一个空值，所以一般用 [NSNull null] 空对象来存储。另外，在 NSDictionary 的 -objectForKey: 方法中，如果当前字典中 key 对应的值不存在时，该方法会返回 nil，表明当前 key 在字典中未添加，但是如果我们想明确表示某一 key 已经在字典中添加，但是它没有值，这时候就可以用 [NSNull null] 来赋值表示。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当 NSArray 里遇到 nil 时，就说明这个数组对象的元素截止了，即 NSArray 只关注 nil 之前的对象，nil 之后的对象会被抛弃。</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = [<span class=\"built_in\">NSArray</span> arrayWithObjects:<span class=\"string\">@\"one\"</span>, <span class=\"string\">@\"two\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 错误的使用</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *dict = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">[dict setObject:<span class=\"literal\">nil</span> forKey:<span class=\"string\">@\"someKey\"</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 正确的使用</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *dict = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">[dict setObject:[<span class=\"built_in\">NSNull</span> null] forKey:<span class=\"string\">@\"someKey\"</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"NIL-或-NSNil\"><a href=\"#NIL-或-NSNil\" class=\"headerlink\" title=\"NIL 或 NSNil\"></a>NIL 或 NSNil</h2><p><strong>Objective-C 中不存在这两个符号！！！</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>从上述分析我们可知，不管是 NULL、nil 还是 Nil，它们本质上是一样的，都是 (void *)0，只是写法不同。这样做的意义是为了区分不同的数据类型，虽然它们值相同，但我们需要理解它们之间的字面意义并用于不同场景，让代码更加明确，增加可读性。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">标志</th>\n<th style=\"text-align:left\">值</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">NULL</td>\n<td style=\"text-align:left\">(void *)0</td>\n<td style=\"text-align:left\">C指针的字面零值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">nil</td>\n<td style=\"text-align:left\">(id)0</td>\n<td style=\"text-align:left\">Objective-C对象的字面零值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Nil</td>\n<td style=\"text-align:left\">(Class)0</td>\n<td style=\"text-align:left\">Objective-C类的字面零值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">NSNull</td>\n<td style=\"text-align:left\">[NSNull null]</td>\n<td style=\"text-align:left\">用来表示零值的单独的对象</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://nshipster.cn/nil/\" target=\"_blank\" rel=\"noopener\">nil / Nil / NULL / NSNull</a></li>\n<li><a href=\"http://magicalboy.com/null-value-in-objective-c/\" target=\"_blank\" rel=\"noopener\">Objective C 中的nil，Nil，NULL和NSNull理解</a></li>\n<li><a href=\"http://blog.csdn.net/wzzvictory/article/details/18413519\" target=\"_blank\" rel=\"noopener\">nil/Nil/NULL/NSNull的区别</a></li>\n<li><a href=\"https://kangzubin.cn/null-and-nil-in-objective-c/#more\" target=\"_blank\" rel=\"noopener\">Objective-C 中 NULL、nil、Nil、NSNull 的定义及不同</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>每种开发语言都有判断对象不存在的时候，最基础的C语言是通过“0”来判断“不存在”，而用 <strong>NULL</strong> 作为指针空值。在 OC 中有<code>nil</code> / <code>Nil</code> / <code>NULL</code> / <code>NSNull</code>。下面我们分别来看看这几种空值的区别。</p>\n<h2 id=\"nil\"><a href=\"#nil\" class=\"headerlink\" title=\"nil\"></a>nil</h2><p>Objective-C在C的表达不存在的基础上增加了nil。nil是一个指向不存在的对象指针。</p>\n<p>在 objc.h 中的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifndef nil</span></span><br><span class=\"line\"><span class=\"meta\"># if __has_feature(cxx_nullptr)</span></span><br><span class=\"line\"><span class=\"meta\">#   define nil nullptr</span></span><br><span class=\"line\"><span class=\"meta\"># else</span></span><br><span class=\"line\"><span class=\"meta\">#   define nil __DARWIN_NULL</span></span><br><span class=\"line\"><span class=\"meta\"># endif</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>判断是否有 <strong>cxx_nullptr</strong> 特性，如果有， nil 定义为 <strong>nullptr</strong>，否则定义为 <strong>__DARWIN_NULL</strong>。</p>\n<p>在 _types.h 中的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define __DARWIN_NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>\n<p>本质上 nil 是 <strong>(void *)0</strong>。</p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>nil 一般用于指向Objective-C对象，表示对象为空，例如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSObject</span> *obj = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"><span class=\"keyword\">id</span> onObj = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (obj2)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>nil 最显著的行为是，它虽然为零，仍然可以有消息发送给它。在别的语言里，比如Java，调用空对象的方法会崩溃，但是在Objective-C中，即使nil为“零”，你也可以调用它的方法，这样可以简化非空判断：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 举个例子，这个表达...</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (name != <span class=\"literal\">nil</span> &amp;&amp; [name isEqualToString:<span class=\"string\">@\"Steve\"</span>]) &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...可以被简化为：</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([name isEqualToString:<span class=\"string\">@\"steve\"</span>]) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Nil\"><a href=\"#Nil\" class=\"headerlink\" title=\"Nil\"></a>Nil</h2><p>在 objc.h 中定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifndef Nil</span></span><br><span class=\"line\"><span class=\"meta\"># if __has_feature(cxx_nullptr)</span></span><br><span class=\"line\"><span class=\"meta\">#   define Nil nullptr</span></span><br><span class=\"line\"><span class=\"meta\"># else</span></span><br><span class=\"line\"><span class=\"meta\">#   define Nil __DARWIN_NULL</span></span><br><span class=\"line\"><span class=\"meta\"># endif</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>与 <code>nil</code> 基本一致，本质上也是 <strong>(void *)0</strong>。</p>\n<h3 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>Nil 是 Objective-C 类类型的书面空值，对应 Class 类型对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class someClass = Nil;</span><br><span class=\"line\">Class anotherClass = [<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"NULL\"><a href=\"#NULL\" class=\"headerlink\" title=\"NULL\"></a>NULL</h2><p>在 _null.h 中的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifndef NULL </span></span><br><span class=\"line\"><span class=\"meta\">#define NULL  __DARWIN_NULL</span></span><br><span class=\"line\"><span class=\"meta\">#endif  /* NULL */</span></span><br></pre></td></tr></table></figure>\n<p>那么本质上 NULL 也是 <strong>(void *)0</strong>。</p>\n<h3 id=\"使用场景-2\"><a href=\"#使用场景-2\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>NULL 一般用于表示 C 指针空值，例如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pointerToInt = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *pointerToChar = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> TreeNode *rootNode = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"NSNull\"><a href=\"#NSNull\" class=\"headerlink\" title=\"NSNull\"></a>NSNull</h2><p>看到 <strong>NS</strong> 就可以判断它是  Objective-C 的一个类，代表空值的类。它定义在 NSNull.h 文件里：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/NSObject.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSNull</span> : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">NSCopying</span>, <span class=\"title\">NSSecureCoding</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSNull</span> *)null;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>\n<p>NSNull 只有一个单例方法 +[NSnull null]，一般用于在集合对象中保存一个空的占位对象。</p>\n<h3 id=\"使用场景-3\"><a href=\"#使用场景-3\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>在 Foundation 集合对象（NSArray、NSDictionary、NSSet 等）中， nil 通常被用于表示集合对象结束的标志，因此无法用 nil 来存储一个空值，所以一般用 [NSNull null] 空对象来存储。另外，在 NSDictionary 的 -objectForKey: 方法中，如果当前字典中 key 对应的值不存在时，该方法会返回 nil，表明当前 key 在字典中未添加，但是如果我们想明确表示某一 key 已经在字典中添加，但是它没有值，这时候就可以用 [NSNull null] 来赋值表示。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当 NSArray 里遇到 nil 时，就说明这个数组对象的元素截止了，即 NSArray 只关注 nil 之前的对象，nil 之后的对象会被抛弃。</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = [<span class=\"built_in\">NSArray</span> arrayWithObjects:<span class=\"string\">@\"one\"</span>, <span class=\"string\">@\"two\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 错误的使用</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *dict = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">[dict setObject:<span class=\"literal\">nil</span> forKey:<span class=\"string\">@\"someKey\"</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 正确的使用</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *dict = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">[dict setObject:[<span class=\"built_in\">NSNull</span> null] forKey:<span class=\"string\">@\"someKey\"</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"NIL-或-NSNil\"><a href=\"#NIL-或-NSNil\" class=\"headerlink\" title=\"NIL 或 NSNil\"></a>NIL 或 NSNil</h2><p><strong>Objective-C 中不存在这两个符号！！！</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>从上述分析我们可知，不管是 NULL、nil 还是 Nil，它们本质上是一样的，都是 (void *)0，只是写法不同。这样做的意义是为了区分不同的数据类型，虽然它们值相同，但我们需要理解它们之间的字面意义并用于不同场景，让代码更加明确，增加可读性。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">标志</th>\n<th style=\"text-align:left\">值</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">NULL</td>\n<td style=\"text-align:left\">(void *)0</td>\n<td style=\"text-align:left\">C指针的字面零值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">nil</td>\n<td style=\"text-align:left\">(id)0</td>\n<td style=\"text-align:left\">Objective-C对象的字面零值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Nil</td>\n<td style=\"text-align:left\">(Class)0</td>\n<td style=\"text-align:left\">Objective-C类的字面零值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">NSNull</td>\n<td style=\"text-align:left\">[NSNull null]</td>\n<td style=\"text-align:left\">用来表示零值的单独的对象</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://nshipster.cn/nil/\" target=\"_blank\" rel=\"noopener\">nil / Nil / NULL / NSNull</a></li>\n<li><a href=\"http://magicalboy.com/null-value-in-objective-c/\" target=\"_blank\" rel=\"noopener\">Objective C 中的nil，Nil，NULL和NSNull理解</a></li>\n<li><a href=\"http://blog.csdn.net/wzzvictory/article/details/18413519\" target=\"_blank\" rel=\"noopener\">nil/Nil/NULL/NSNull的区别</a></li>\n<li><a href=\"https://kangzubin.cn/null-and-nil-in-objective-c/#more\" target=\"_blank\" rel=\"noopener\">Objective-C 中 NULL、nil、Nil、NSNull 的定义及不同</a></li>\n</ul>\n"},{"title":"取消UIKit中某些控件的隐式动画","date":"2016-09-06T14:56:03.000Z","_content":"\n本篇文章是参考[南峰子_老驴#iOS知识小集](http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501)并结合自己实践所做。\n\n## 问题\n在iOS上有很多让人耳目一新的动画，非常吸引眼球，苹果也对许多控件都加上了默认的动画，比如UITableView和UIColletionView增加一个元素时，会有默认的动画，我们创建一个UIButton，然后改变它的文字也会有个渐变动画\n\n```objc\nself.button = ({\n   UIButton *btn = [UIButton buttonWithType:UIButtonTypeSystem];\n   btn.frame = (CGRect){100.0f, 50.0f, 200.0f, 30.0f};\n   [btn setTitle:@\"This is a button\" forState:UIControlStateNormal];\n   [btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];\n   btn.backgroundColor = [UIColor blueColor];\n   btn;\n});\n    \ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t[self.button setTitle:@\"Button is here\" forState:UIControlStateNormal];\n\t[self.button layoutIfNeeded];\n});\n```\n\n## 解决\n但是某些情况下我们不想要这些动画，在iOS7+的系统上，可以使用UIView的`performWithoutAnimation:`方法来达到这一目的。\n\n这个方法的具体解释，可以参考objc.io的[文章](http://t.cn/Rthp9c3)，它的说法是这个方法就是一个使动画失效的简单封装。\n{% asset_img Snip20160906_8.png objc.io %}\n\n`performWithoutAnimation:`只能影响到block参数里的动画，对外面的动画没有影响，我们可以这么做取消掉动画\n\n```objc\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n   [UIView performWithoutAnimation:^{\n       [self.button setTitle:@\"Button is here\" forState:UIControlStateNormal];\n       [self.button layoutIfNeeded];\n   }];\n});\n```\n\n可以把UIView动画放到`performWithoutAnimation:`中，这样动画也不会执行\n\n```objc\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n   [UIView performWithoutAnimation:^{\n       [UIView animateWithDuration:3 animations:^{\n           self.button.frame = CGRectMake(100.0, 100.0, 100.0, 30.0);\n       }];\n   }];\n});\n```\n\n### CALayer动画\n假如你使用到了CALayer的动画，使用上述方法是解决不了的，`performWithoutAnimation:`只能解决UIView的Animation，原文章也给了解决方案\n\n```objc\n- (void)layoutSubviews {\n\t[super layoutSubviews];\n\t    \n\t[CATransaction begin];\n\t[CATransaction setDisableActions:YES];\n\tself.frameLayer.frame = self.frameView.bounds;\n\t[CATransaction commit];\n}\n```\n\n再次感谢**南峰子_老驴**的Tips！\n\n## 参考链接\n[Tips:取消UICollectionView的隐式动画](http://adad184.com/2015/11/10/disable-uicollectionview-implicit-animation/)\n\n## 补充\n```objc\nUIButton *btn = [[UIButton alloc] init];\n```\n如果你是通过这种方式创建UIButton，改变button文字是没有渐变动画的，因为通过这种方式创建没有走苹果类方法中的某些处理，苹果也就不会给你加上动画。\n\n\n\n","source":"_posts/performWithoutAnimation-cancel-implicit-animation.md","raw":"---\ntitle: 取消UIKit中某些控件的隐式动画\ndate: 2016-09-06 22:56:03\ntags: 动画\ncategory: Tips\n---\n\n本篇文章是参考[南峰子_老驴#iOS知识小集](http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501)并结合自己实践所做。\n\n## 问题\n在iOS上有很多让人耳目一新的动画，非常吸引眼球，苹果也对许多控件都加上了默认的动画，比如UITableView和UIColletionView增加一个元素时，会有默认的动画，我们创建一个UIButton，然后改变它的文字也会有个渐变动画\n\n```objc\nself.button = ({\n   UIButton *btn = [UIButton buttonWithType:UIButtonTypeSystem];\n   btn.frame = (CGRect){100.0f, 50.0f, 200.0f, 30.0f};\n   [btn setTitle:@\"This is a button\" forState:UIControlStateNormal];\n   [btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];\n   btn.backgroundColor = [UIColor blueColor];\n   btn;\n});\n    \ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t[self.button setTitle:@\"Button is here\" forState:UIControlStateNormal];\n\t[self.button layoutIfNeeded];\n});\n```\n\n## 解决\n但是某些情况下我们不想要这些动画，在iOS7+的系统上，可以使用UIView的`performWithoutAnimation:`方法来达到这一目的。\n\n这个方法的具体解释，可以参考objc.io的[文章](http://t.cn/Rthp9c3)，它的说法是这个方法就是一个使动画失效的简单封装。\n{% asset_img Snip20160906_8.png objc.io %}\n\n`performWithoutAnimation:`只能影响到block参数里的动画，对外面的动画没有影响，我们可以这么做取消掉动画\n\n```objc\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n   [UIView performWithoutAnimation:^{\n       [self.button setTitle:@\"Button is here\" forState:UIControlStateNormal];\n       [self.button layoutIfNeeded];\n   }];\n});\n```\n\n可以把UIView动画放到`performWithoutAnimation:`中，这样动画也不会执行\n\n```objc\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n   [UIView performWithoutAnimation:^{\n       [UIView animateWithDuration:3 animations:^{\n           self.button.frame = CGRectMake(100.0, 100.0, 100.0, 30.0);\n       }];\n   }];\n});\n```\n\n### CALayer动画\n假如你使用到了CALayer的动画，使用上述方法是解决不了的，`performWithoutAnimation:`只能解决UIView的Animation，原文章也给了解决方案\n\n```objc\n- (void)layoutSubviews {\n\t[super layoutSubviews];\n\t    \n\t[CATransaction begin];\n\t[CATransaction setDisableActions:YES];\n\tself.frameLayer.frame = self.frameView.bounds;\n\t[CATransaction commit];\n}\n```\n\n再次感谢**南峰子_老驴**的Tips！\n\n## 参考链接\n[Tips:取消UICollectionView的隐式动画](http://adad184.com/2015/11/10/disable-uicollectionview-implicit-animation/)\n\n## 补充\n```objc\nUIButton *btn = [[UIButton alloc] init];\n```\n如果你是通过这种方式创建UIButton，改变button文字是没有渐变动画的，因为通过这种方式创建没有走苹果类方法中的某些处理，苹果也就不会给你加上动画。\n\n\n\n","slug":"performWithoutAnimation-cancel-implicit-animation","published":1,"updated":"2016-09-11T05:42:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7ln002a8jpba4scfz13","content":"<p>本篇文章是参考<a href=\"http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501\" target=\"_blank\" rel=\"noopener\">南峰子_老驴#iOS知识小集</a>并结合自己实践所做。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在iOS上有很多让人耳目一新的动画，非常吸引眼球，苹果也对许多控件都加上了默认的动画，比如UITableView和UIColletionView增加一个元素时，会有默认的动画，我们创建一个UIButton，然后改变它的文字也会有个渐变动画</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.button = (&#123;</span><br><span class=\"line\">   <span class=\"built_in\">UIButton</span> *btn = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeSystem</span>];</span><br><span class=\"line\">   btn.frame = (<span class=\"built_in\">CGRect</span>)&#123;<span class=\"number\">100.0</span>f, <span class=\"number\">50.0</span>f, <span class=\"number\">200.0</span>f, <span class=\"number\">30.0</span>f&#125;;</span><br><span class=\"line\">   [btn setTitle:<span class=\"string\">@\"This is a button\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">   [btn setTitleColor:[<span class=\"built_in\">UIColor</span> redColor] forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">   btn.backgroundColor = [<span class=\"built_in\">UIColor</span> blueColor];</span><br><span class=\"line\">   btn;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.button setTitle:<span class=\"string\">@\"Button is here\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.button layoutIfNeeded];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>但是某些情况下我们不想要这些动画，在iOS7+的系统上，可以使用UIView的<code>performWithoutAnimation:</code>方法来达到这一目的。</p>\n<p>这个方法的具体解释，可以参考objc.io的<a href=\"http://t.cn/Rthp9c3\" target=\"_blank\" rel=\"noopener\">文章</a>，它的说法是这个方法就是一个使动画失效的简单封装。<br><img src=\"/2016/09/06/performWithoutAnimation-cancel-implicit-animation/Snip20160906_8.png\" title=\"objc.io\"></p>\n<p><code>performWithoutAnimation:</code>只能影响到block参数里的动画，对外面的动画没有影响，我们可以这么做取消掉动画</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">   [<span class=\"built_in\">UIView</span> performWithoutAnimation:^&#123;</span><br><span class=\"line\">       [<span class=\"keyword\">self</span>.button setTitle:<span class=\"string\">@\"Button is here\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">       [<span class=\"keyword\">self</span>.button layoutIfNeeded];</span><br><span class=\"line\">   &#125;];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>可以把UIView动画放到<code>performWithoutAnimation:</code>中，这样动画也不会执行</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">1.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">   [<span class=\"built_in\">UIView</span> performWithoutAnimation:^&#123;</span><br><span class=\"line\">       [<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">3</span> animations:^&#123;</span><br><span class=\"line\">           <span class=\"keyword\">self</span>.button.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100.0</span>, <span class=\"number\">100.0</span>, <span class=\"number\">100.0</span>, <span class=\"number\">30.0</span>);</span><br><span class=\"line\">       &#125;];</span><br><span class=\"line\">   &#125;];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"CALayer动画\"><a href=\"#CALayer动画\" class=\"headerlink\" title=\"CALayer动画\"></a>CALayer动画</h3><p>假如你使用到了CALayer的动画，使用上述方法是解决不了的，<code>performWithoutAnimation:</code>只能解决UIView的Animation，原文章也给了解决方案</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)layoutSubviews &#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">super</span> layoutSubviews];</span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t[<span class=\"built_in\">CATransaction</span> begin];</span><br><span class=\"line\">\t[<span class=\"built_in\">CATransaction</span> setDisableActions:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.frameLayer.frame = <span class=\"keyword\">self</span>.frameView.bounds;</span><br><span class=\"line\">\t[<span class=\"built_in\">CATransaction</span> commit];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次感谢<strong>南峰子_老驴</strong>的Tips！</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://adad184.com/2015/11/10/disable-uicollectionview-implicit-animation/\" target=\"_blank\" rel=\"noopener\">Tips:取消UICollectionView的隐式动画</a></p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span> *btn = [[<span class=\"built_in\">UIButton</span> alloc] init];</span><br></pre></td></tr></table></figure>\n<p>如果你是通过这种方式创建UIButton，改变button文字是没有渐变动画的，因为通过这种方式创建没有走苹果类方法中的某些处理，苹果也就不会给你加上动画。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本篇文章是参考<a href=\"http://huati.weibo.com/k/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86?from=501\" target=\"_blank\" rel=\"noopener\">南峰子_老驴#iOS知识小集</a>并结合自己实践所做。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在iOS上有很多让人耳目一新的动画，非常吸引眼球，苹果也对许多控件都加上了默认的动画，比如UITableView和UIColletionView增加一个元素时，会有默认的动画，我们创建一个UIButton，然后改变它的文字也会有个渐变动画</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.button = (&#123;</span><br><span class=\"line\">   <span class=\"built_in\">UIButton</span> *btn = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeSystem</span>];</span><br><span class=\"line\">   btn.frame = (<span class=\"built_in\">CGRect</span>)&#123;<span class=\"number\">100.0</span>f, <span class=\"number\">50.0</span>f, <span class=\"number\">200.0</span>f, <span class=\"number\">30.0</span>f&#125;;</span><br><span class=\"line\">   [btn setTitle:<span class=\"string\">@\"This is a button\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">   [btn setTitleColor:[<span class=\"built_in\">UIColor</span> redColor] forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">   btn.backgroundColor = [<span class=\"built_in\">UIColor</span> blueColor];</span><br><span class=\"line\">   btn;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.button setTitle:<span class=\"string\">@\"Button is here\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.button layoutIfNeeded];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>但是某些情况下我们不想要这些动画，在iOS7+的系统上，可以使用UIView的<code>performWithoutAnimation:</code>方法来达到这一目的。</p>\n<p>这个方法的具体解释，可以参考objc.io的<a href=\"http://t.cn/Rthp9c3\" target=\"_blank\" rel=\"noopener\">文章</a>，它的说法是这个方法就是一个使动画失效的简单封装。<br><img src=\"/2016/09/06/performWithoutAnimation-cancel-implicit-animation/Snip20160906_8.png\" title=\"objc.io\"></p>\n<p><code>performWithoutAnimation:</code>只能影响到block参数里的动画，对外面的动画没有影响，我们可以这么做取消掉动画</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">   [<span class=\"built_in\">UIView</span> performWithoutAnimation:^&#123;</span><br><span class=\"line\">       [<span class=\"keyword\">self</span>.button setTitle:<span class=\"string\">@\"Button is here\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">       [<span class=\"keyword\">self</span>.button layoutIfNeeded];</span><br><span class=\"line\">   &#125;];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>可以把UIView动画放到<code>performWithoutAnimation:</code>中，这样动画也不会执行</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">1.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">   [<span class=\"built_in\">UIView</span> performWithoutAnimation:^&#123;</span><br><span class=\"line\">       [<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">3</span> animations:^&#123;</span><br><span class=\"line\">           <span class=\"keyword\">self</span>.button.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100.0</span>, <span class=\"number\">100.0</span>, <span class=\"number\">100.0</span>, <span class=\"number\">30.0</span>);</span><br><span class=\"line\">       &#125;];</span><br><span class=\"line\">   &#125;];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"CALayer动画\"><a href=\"#CALayer动画\" class=\"headerlink\" title=\"CALayer动画\"></a>CALayer动画</h3><p>假如你使用到了CALayer的动画，使用上述方法是解决不了的，<code>performWithoutAnimation:</code>只能解决UIView的Animation，原文章也给了解决方案</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)layoutSubviews &#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">super</span> layoutSubviews];</span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t[<span class=\"built_in\">CATransaction</span> begin];</span><br><span class=\"line\">\t[<span class=\"built_in\">CATransaction</span> setDisableActions:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.frameLayer.frame = <span class=\"keyword\">self</span>.frameView.bounds;</span><br><span class=\"line\">\t[<span class=\"built_in\">CATransaction</span> commit];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次感谢<strong>南峰子_老驴</strong>的Tips！</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://adad184.com/2015/11/10/disable-uicollectionview-implicit-animation/\" target=\"_blank\" rel=\"noopener\">Tips:取消UICollectionView的隐式动画</a></p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span> *btn = [[<span class=\"built_in\">UIButton</span> alloc] init];</span><br></pre></td></tr></table></figure>\n<p>如果你是通过这种方式创建UIButton，改变button文字是没有渐变动画的，因为通过这种方式创建没有走苹果类方法中的某些处理，苹果也就不会给你加上动画。</p>\n"},{"title":"记一次 UIActivityItemSource 使用","date":"2017-05-06T12:32:27.000Z","_content":"\n## 前言\n\n最近产品提了个需求，要求能够针对多个APP定制分享，如果用户没有装某个APP，则不需要显示分享。看到这个需求我第一时间想到使用iOS原生的分享，因为它不需要APP引入各种分享的SDK就能达到分享的目的，虽然UI无法定制，但是内容可以定制，并且用户安装了哪些APP，系统能够自动判定，但是缺点也很明显，假如想要分享的APP没有支持 `Share Extension` 那么就无法使用分享了。\n\n## UIActivityViewController\n\niOS 从3.2就提供了 `UIDocumentInteractionController` 支持同设备上app之间的文档分享外，还可以实现文档的预览、打印、发邮件以及复制，使用起来也非常简单。但是 iOS 6 之后苹果有提供了功能更加强大的 `UIActivityViewController`。它俩的区别可以参考：\n\n* [《Tutorial: Sharing Data Locally Between iOS Apps》](Tutorial: Sharing Data Locally Between iOS Apps)\n* [《UIActivityViewController vs UIDocumentInteractionController in iOS》](http://stackoverflow.com/questions/21234699/uiactivityviewcontroller-vs-uidocumentinteractioncontroller-in-ios)\n\n{% asset_img WX20170513_234019.png extension %}\n\n如图，第一排是 AirDrop 能够近距离分享文件，照片等内容；第二排就是待会要讲的 `Share Extension` ；第三排就是 `Action Extension` ；\n\n显示在 Share Extension 上的APP都是系统自己识别的，并且只有第三方APP支持 Share Extensions 才会显示，在列表的最末端有三个点的按钮，点开它可以看到支持 Share Extensions 的全部APP列表。\n\n使用 `UIActivityViewController` 非常简单，创建它并通过modal的形式弹出来：\n\n```objc\nUIActivityViewController *activityController = [[UIActivityViewController alloc] initWithActivityItems:@[[UIImage imageNamed:@\"share\"]] applicationActivities:nil];\nactivityController.excludedActivityTypes = @[UIActivityTypeAirDrop];\n        \n//        [activityController setCompletionWithItemsHandler:^(NSString * __nullable activityType, BOOL completed, NSArray * __nullable returnedItems, NSError * __nullable activityError){\n//            \n//        }];\n[self presentViewController:activityController animated:YES completion:nil];\n```\n\n第一个数组内的对象代表的是我们想要操作的数据的一些内容，而且这个数组不能为空，比如我们PDF文档的名称、URL、、文本或者图片；第二个数组指定了泛型，数组内的对象必须是UIActivity类型的对象，代表的是iOS系统支持的我们自定义的服务，关于这点跟自定义UIActivity服务的内容有关，目前没用上，现在我们暂时置为nil。\n\n执行代码后，你会看到弹出和上图一样的控制器，这时候你就有疑问了，可分享的平台这么多，我怎么定制根据分享的app不同，内容也不同呢？\n\n## 定制分享内容\n\n### 分享文本\n定制分享内容你需要创建一个对象，实现 `UIActivityItemSource` 协议：\n\n```objc\n@interface LSCustomizedStringItemSource: NSObject <UIActivityItemSource>\n@property (nonatomic, copy) NSString *partnerCode;\n@end\n\n@implementation LSCustomizedStringItemSource\n\n- (id)activityViewControllerPlaceholderItem:(UIActivityViewController *)activityViewController {\n    return @\"\";\n}\n\n- (id)activityViewController:(UIActivityViewController *)activityViewController itemForActivityType:(NSString *)activityType {\n\n    if ([activityType isEqualToString:UIActivityTypePostToFacebook]) {\n        return @\"Facebook\";\n    } else if ([activityType isEqualToString:UIActivityTypePostToTwitter]) {\n        return @\"Twitter\";\n    } else if ([activityType isEqualToString:UIActivityTypeMessage]) {\n        return @\"Message\";\n    } else if ([activityType isEqualToString:UIActivityTypeMail]) {\n        return @\"Mail\";\n    }\n    return @\"Default\";\n}\n\n@end\n```\n\n上面是自定义的文本分享内容，根据平台的不同，分享不同的文本。\n\n### 分享图片\n```objc\n@interface LSCustomizedImageItemSource: NSObject <UIActivityItemSource>\n@end\n\n@implementation LSCustomizedImageItemSource\n\n- (id)activityViewControllerPlaceholderItem:(UIActivityViewController *)activityViewController {\n    return @\"\";\n}\n\n- (id)activityViewController:(UIActivityViewController *)activityViewController itemForActivityType:(NSString *)activityType {\n    if ([activityType isEqualToString:UIActivityTypeMessage]) {\n        return nil;\n    }\n    return [UIImage imageNamed:@\"share\"];\n}\n\n@end\n```\n\n上面是自定义的图片分享，分享到 iMessage 的时候，不需要分享图片\n\n### 分享URL\n\n```objc\n@interface LSCustomizedURLItemSource: NSObject <UIActivityItemSource>\n@end\n\n@implementation LSCustomizedURLItemSource\n\n- (id)activityViewControllerPlaceholderItem:(UIActivityViewController *)activityViewController {\n    return @\"\";\n}\n\n- (id)activityViewController:(UIActivityViewController *)activityViewController itemForActivityType:(NSString *)activityType {\n    \n    return [NSURL URLWithString:@\"https://www.taobao.com\"];\n}\n\n@end\n```\n\n### 重新设置 UIActivityViewController\n\n\n```objc\nLSCustomizedStringItemSource *stringItemSource = [[LSCustomizedStringItemSource alloc] init];\nLSCustomizedURLItemSource *urlItemSource = [[LSCustomizedURLItemSource alloc] init];\nLSCustomizedImageItemSource *imageItemSource = [[LSCustomizedImageItemSource alloc] init];\n\nUIActivityViewController *activityController = [[UIActivityViewController alloc] initWithActivityItems:@[stringItemSource, urlItemSource, imageItemSource] applicationActivities:nil];\n```\n\n创建自定义分享内容，并赋值给 UIActivityViewController，这样就可以根据APP的不同，分享不同的内容。\n\n## 总结\n\n使用 UIActivityViewController 分享，优点和缺点都非常明显，所以需要根据你的业务需求来决定是否使用。\n\n## 参考链接\n\n* [Give thumbnail image with UIActivityViewController](http://stackoverflow.com/questions/37468195/give-thumbnail-image-with-uiactivityviewcontroller/37548529)\n* [通过UIActivityViewController实现更多分享服务](http://www.jianshu.com/p/a1c9621a3f4e)\n* [研究 UIActivityViewController](http://www.cocoachina.com/industry/20140425/8233.html)\n* [iOS8扩展插件开发配置](http://blog.csdn.net/phunxm/article/details/42715145)\n* [实现iOS app之间的内容分享](https://segmentfault.com/a/1190000004237771s)\n\n\n\n","source":"_posts/use-UIActivityItemSource.md","raw":"---\ntitle: 记一次 UIActivityItemSource 使用\ndate: 2017-05-06 20:32:27\ntags: UIActivityItemSource\ncategory: 能工巧匠\n---\n\n## 前言\n\n最近产品提了个需求，要求能够针对多个APP定制分享，如果用户没有装某个APP，则不需要显示分享。看到这个需求我第一时间想到使用iOS原生的分享，因为它不需要APP引入各种分享的SDK就能达到分享的目的，虽然UI无法定制，但是内容可以定制，并且用户安装了哪些APP，系统能够自动判定，但是缺点也很明显，假如想要分享的APP没有支持 `Share Extension` 那么就无法使用分享了。\n\n## UIActivityViewController\n\niOS 从3.2就提供了 `UIDocumentInteractionController` 支持同设备上app之间的文档分享外，还可以实现文档的预览、打印、发邮件以及复制，使用起来也非常简单。但是 iOS 6 之后苹果有提供了功能更加强大的 `UIActivityViewController`。它俩的区别可以参考：\n\n* [《Tutorial: Sharing Data Locally Between iOS Apps》](Tutorial: Sharing Data Locally Between iOS Apps)\n* [《UIActivityViewController vs UIDocumentInteractionController in iOS》](http://stackoverflow.com/questions/21234699/uiactivityviewcontroller-vs-uidocumentinteractioncontroller-in-ios)\n\n{% asset_img WX20170513_234019.png extension %}\n\n如图，第一排是 AirDrop 能够近距离分享文件，照片等内容；第二排就是待会要讲的 `Share Extension` ；第三排就是 `Action Extension` ；\n\n显示在 Share Extension 上的APP都是系统自己识别的，并且只有第三方APP支持 Share Extensions 才会显示，在列表的最末端有三个点的按钮，点开它可以看到支持 Share Extensions 的全部APP列表。\n\n使用 `UIActivityViewController` 非常简单，创建它并通过modal的形式弹出来：\n\n```objc\nUIActivityViewController *activityController = [[UIActivityViewController alloc] initWithActivityItems:@[[UIImage imageNamed:@\"share\"]] applicationActivities:nil];\nactivityController.excludedActivityTypes = @[UIActivityTypeAirDrop];\n        \n//        [activityController setCompletionWithItemsHandler:^(NSString * __nullable activityType, BOOL completed, NSArray * __nullable returnedItems, NSError * __nullable activityError){\n//            \n//        }];\n[self presentViewController:activityController animated:YES completion:nil];\n```\n\n第一个数组内的对象代表的是我们想要操作的数据的一些内容，而且这个数组不能为空，比如我们PDF文档的名称、URL、、文本或者图片；第二个数组指定了泛型，数组内的对象必须是UIActivity类型的对象，代表的是iOS系统支持的我们自定义的服务，关于这点跟自定义UIActivity服务的内容有关，目前没用上，现在我们暂时置为nil。\n\n执行代码后，你会看到弹出和上图一样的控制器，这时候你就有疑问了，可分享的平台这么多，我怎么定制根据分享的app不同，内容也不同呢？\n\n## 定制分享内容\n\n### 分享文本\n定制分享内容你需要创建一个对象，实现 `UIActivityItemSource` 协议：\n\n```objc\n@interface LSCustomizedStringItemSource: NSObject <UIActivityItemSource>\n@property (nonatomic, copy) NSString *partnerCode;\n@end\n\n@implementation LSCustomizedStringItemSource\n\n- (id)activityViewControllerPlaceholderItem:(UIActivityViewController *)activityViewController {\n    return @\"\";\n}\n\n- (id)activityViewController:(UIActivityViewController *)activityViewController itemForActivityType:(NSString *)activityType {\n\n    if ([activityType isEqualToString:UIActivityTypePostToFacebook]) {\n        return @\"Facebook\";\n    } else if ([activityType isEqualToString:UIActivityTypePostToTwitter]) {\n        return @\"Twitter\";\n    } else if ([activityType isEqualToString:UIActivityTypeMessage]) {\n        return @\"Message\";\n    } else if ([activityType isEqualToString:UIActivityTypeMail]) {\n        return @\"Mail\";\n    }\n    return @\"Default\";\n}\n\n@end\n```\n\n上面是自定义的文本分享内容，根据平台的不同，分享不同的文本。\n\n### 分享图片\n```objc\n@interface LSCustomizedImageItemSource: NSObject <UIActivityItemSource>\n@end\n\n@implementation LSCustomizedImageItemSource\n\n- (id)activityViewControllerPlaceholderItem:(UIActivityViewController *)activityViewController {\n    return @\"\";\n}\n\n- (id)activityViewController:(UIActivityViewController *)activityViewController itemForActivityType:(NSString *)activityType {\n    if ([activityType isEqualToString:UIActivityTypeMessage]) {\n        return nil;\n    }\n    return [UIImage imageNamed:@\"share\"];\n}\n\n@end\n```\n\n上面是自定义的图片分享，分享到 iMessage 的时候，不需要分享图片\n\n### 分享URL\n\n```objc\n@interface LSCustomizedURLItemSource: NSObject <UIActivityItemSource>\n@end\n\n@implementation LSCustomizedURLItemSource\n\n- (id)activityViewControllerPlaceholderItem:(UIActivityViewController *)activityViewController {\n    return @\"\";\n}\n\n- (id)activityViewController:(UIActivityViewController *)activityViewController itemForActivityType:(NSString *)activityType {\n    \n    return [NSURL URLWithString:@\"https://www.taobao.com\"];\n}\n\n@end\n```\n\n### 重新设置 UIActivityViewController\n\n\n```objc\nLSCustomizedStringItemSource *stringItemSource = [[LSCustomizedStringItemSource alloc] init];\nLSCustomizedURLItemSource *urlItemSource = [[LSCustomizedURLItemSource alloc] init];\nLSCustomizedImageItemSource *imageItemSource = [[LSCustomizedImageItemSource alloc] init];\n\nUIActivityViewController *activityController = [[UIActivityViewController alloc] initWithActivityItems:@[stringItemSource, urlItemSource, imageItemSource] applicationActivities:nil];\n```\n\n创建自定义分享内容，并赋值给 UIActivityViewController，这样就可以根据APP的不同，分享不同的内容。\n\n## 总结\n\n使用 UIActivityViewController 分享，优点和缺点都非常明显，所以需要根据你的业务需求来决定是否使用。\n\n## 参考链接\n\n* [Give thumbnail image with UIActivityViewController](http://stackoverflow.com/questions/37468195/give-thumbnail-image-with-uiactivityviewcontroller/37548529)\n* [通过UIActivityViewController实现更多分享服务](http://www.jianshu.com/p/a1c9621a3f4e)\n* [研究 UIActivityViewController](http://www.cocoachina.com/industry/20140425/8233.html)\n* [iOS8扩展插件开发配置](http://blog.csdn.net/phunxm/article/details/42715145)\n* [实现iOS app之间的内容分享](https://segmentfault.com/a/1190000004237771s)\n\n\n\n","slug":"use-UIActivityItemSource","published":1,"updated":"2017-05-13T16:32:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7lu002d8jpb4q8hbhft","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近产品提了个需求，要求能够针对多个APP定制分享，如果用户没有装某个APP，则不需要显示分享。看到这个需求我第一时间想到使用iOS原生的分享，因为它不需要APP引入各种分享的SDK就能达到分享的目的，虽然UI无法定制，但是内容可以定制，并且用户安装了哪些APP，系统能够自动判定，但是缺点也很明显，假如想要分享的APP没有支持 <code>Share Extension</code> 那么就无法使用分享了。</p>\n<h2 id=\"UIActivityViewController\"><a href=\"#UIActivityViewController\" class=\"headerlink\" title=\"UIActivityViewController\"></a>UIActivityViewController</h2><p>iOS 从3.2就提供了 <code>UIDocumentInteractionController</code> 支持同设备上app之间的文档分享外，还可以实现文档的预览、打印、发邮件以及复制，使用起来也非常简单。但是 iOS 6 之后苹果有提供了功能更加强大的 <code>UIActivityViewController</code>。它俩的区别可以参考：</p>\n<ul>\n<li><a href=\"Tutorial: Sharing Data Locally Between iOS Apps\" target=\"_blank\" rel=\"noopener\">《Tutorial: Sharing Data Locally Between iOS Apps》</a></li>\n<li><a href=\"http://stackoverflow.com/questions/21234699/uiactivityviewcontroller-vs-uidocumentinteractioncontroller-in-ios\" target=\"_blank\" rel=\"noopener\">《UIActivityViewController vs UIDocumentInteractionController in iOS》</a></li>\n</ul>\n<img src=\"/2017/05/06/use-UIActivityItemSource/WX20170513_234019.png\" title=\"extension\">\n<p>如图，第一排是 AirDrop 能够近距离分享文件，照片等内容；第二排就是待会要讲的 <code>Share Extension</code> ；第三排就是 <code>Action Extension</code> ；</p>\n<p>显示在 Share Extension 上的APP都是系统自己识别的，并且只有第三方APP支持 Share Extensions 才会显示，在列表的最末端有三个点的按钮，点开它可以看到支持 Share Extensions 的全部APP列表。</p>\n<p>使用 <code>UIActivityViewController</code> 非常简单，创建它并通过modal的形式弹出来：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIActivityViewController</span> *activityController = [[<span class=\"built_in\">UIActivityViewController</span> alloc] initWithActivityItems:@[[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"share\"</span>]] applicationActivities:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">activityController.excludedActivityTypes = @[<span class=\"built_in\">UIActivityTypeAirDrop</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">//        [activityController setCompletionWithItemsHandler:^(NSString * __nullable activityType, BOOL completed, NSArray * __nullable returnedItems, NSError * __nullable activityError)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            </span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;];</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> presentViewController:activityController animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<p>第一个数组内的对象代表的是我们想要操作的数据的一些内容，而且这个数组不能为空，比如我们PDF文档的名称、URL、、文本或者图片；第二个数组指定了泛型，数组内的对象必须是UIActivity类型的对象，代表的是iOS系统支持的我们自定义的服务，关于这点跟自定义UIActivity服务的内容有关，目前没用上，现在我们暂时置为nil。</p>\n<p>执行代码后，你会看到弹出和上图一样的控制器，这时候你就有疑问了，可分享的平台这么多，我怎么定制根据分享的app不同，内容也不同呢？</p>\n<h2 id=\"定制分享内容\"><a href=\"#定制分享内容\" class=\"headerlink\" title=\"定制分享内容\"></a>定制分享内容</h2><h3 id=\"分享文本\"><a href=\"#分享文本\" class=\"headerlink\" title=\"分享文本\"></a>分享文本</h3><p>定制分享内容你需要创建一个对象，实现 <code>UIActivityItemSource</code> 协议：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">LSCustomizedStringItemSource</span>: <span class=\"title\">NSObject</span> &lt;<span class=\"title\">UIActivityItemSource</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *partnerCode;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">LSCustomizedStringItemSource</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewControllerPlaceholderItem:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewController:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController itemForActivityType:(<span class=\"built_in\">NSString</span> *)activityType &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([activityType isEqualToString:<span class=\"built_in\">UIActivityTypePostToFacebook</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"Facebook\"</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([activityType isEqualToString:<span class=\"built_in\">UIActivityTypePostToTwitter</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"Twitter\"</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([activityType isEqualToString:<span class=\"built_in\">UIActivityTypeMessage</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"Message\"</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([activityType isEqualToString:<span class=\"built_in\">UIActivityTypeMail</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"Mail\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"Default\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>上面是自定义的文本分享内容，根据平台的不同，分享不同的文本。</p>\n<h3 id=\"分享图片\"><a href=\"#分享图片\" class=\"headerlink\" title=\"分享图片\"></a>分享图片</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">LSCustomizedImageItemSource</span>: <span class=\"title\">NSObject</span> &lt;<span class=\"title\">UIActivityItemSource</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">LSCustomizedImageItemSource</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewControllerPlaceholderItem:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewController:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController itemForActivityType:(<span class=\"built_in\">NSString</span> *)activityType &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([activityType isEqualToString:<span class=\"built_in\">UIActivityTypeMessage</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"share\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>上面是自定义的图片分享，分享到 iMessage 的时候，不需要分享图片</p>\n<h3 id=\"分享URL\"><a href=\"#分享URL\" class=\"headerlink\" title=\"分享URL\"></a>分享URL</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">LSCustomizedURLItemSource</span>: <span class=\"title\">NSObject</span> &lt;<span class=\"title\">UIActivityItemSource</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">LSCustomizedURLItemSource</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewControllerPlaceholderItem:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewController:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController itemForActivityType:(<span class=\"built_in\">NSString</span> *)activityType &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"https://www.taobao.com\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"重新设置-UIActivityViewController\"><a href=\"#重新设置-UIActivityViewController\" class=\"headerlink\" title=\"重新设置 UIActivityViewController\"></a>重新设置 UIActivityViewController</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSCustomizedStringItemSource *stringItemSource = [[LSCustomizedStringItemSource alloc] init];</span><br><span class=\"line\">LSCustomizedURLItemSource *urlItemSource = [[LSCustomizedURLItemSource alloc] init];</span><br><span class=\"line\">LSCustomizedImageItemSource *imageItemSource = [[LSCustomizedImageItemSource alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIActivityViewController</span> *activityController = [[<span class=\"built_in\">UIActivityViewController</span> alloc] initWithActivityItems:@[stringItemSource, urlItemSource, imageItemSource] applicationActivities:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<p>创建自定义分享内容，并赋值给 UIActivityViewController，这样就可以根据APP的不同，分享不同的内容。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用 UIActivityViewController 分享，优点和缺点都非常明显，所以需要根据你的业务需求来决定是否使用。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://stackoverflow.com/questions/37468195/give-thumbnail-image-with-uiactivityviewcontroller/37548529\" target=\"_blank\" rel=\"noopener\">Give thumbnail image with UIActivityViewController</a></li>\n<li><a href=\"http://www.jianshu.com/p/a1c9621a3f4e\" target=\"_blank\" rel=\"noopener\">通过UIActivityViewController实现更多分享服务</a></li>\n<li><a href=\"http://www.cocoachina.com/industry/20140425/8233.html\" target=\"_blank\" rel=\"noopener\">研究 UIActivityViewController</a></li>\n<li><a href=\"http://blog.csdn.net/phunxm/article/details/42715145\" target=\"_blank\" rel=\"noopener\">iOS8扩展插件开发配置</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004237771s\" target=\"_blank\" rel=\"noopener\">实现iOS app之间的内容分享</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近产品提了个需求，要求能够针对多个APP定制分享，如果用户没有装某个APP，则不需要显示分享。看到这个需求我第一时间想到使用iOS原生的分享，因为它不需要APP引入各种分享的SDK就能达到分享的目的，虽然UI无法定制，但是内容可以定制，并且用户安装了哪些APP，系统能够自动判定，但是缺点也很明显，假如想要分享的APP没有支持 <code>Share Extension</code> 那么就无法使用分享了。</p>\n<h2 id=\"UIActivityViewController\"><a href=\"#UIActivityViewController\" class=\"headerlink\" title=\"UIActivityViewController\"></a>UIActivityViewController</h2><p>iOS 从3.2就提供了 <code>UIDocumentInteractionController</code> 支持同设备上app之间的文档分享外，还可以实现文档的预览、打印、发邮件以及复制，使用起来也非常简单。但是 iOS 6 之后苹果有提供了功能更加强大的 <code>UIActivityViewController</code>。它俩的区别可以参考：</p>\n<ul>\n<li><a href=\"Tutorial: Sharing Data Locally Between iOS Apps\" target=\"_blank\" rel=\"noopener\">《Tutorial: Sharing Data Locally Between iOS Apps》</a></li>\n<li><a href=\"http://stackoverflow.com/questions/21234699/uiactivityviewcontroller-vs-uidocumentinteractioncontroller-in-ios\" target=\"_blank\" rel=\"noopener\">《UIActivityViewController vs UIDocumentInteractionController in iOS》</a></li>\n</ul>\n<img src=\"/2017/05/06/use-UIActivityItemSource/WX20170513_234019.png\" title=\"extension\">\n<p>如图，第一排是 AirDrop 能够近距离分享文件，照片等内容；第二排就是待会要讲的 <code>Share Extension</code> ；第三排就是 <code>Action Extension</code> ；</p>\n<p>显示在 Share Extension 上的APP都是系统自己识别的，并且只有第三方APP支持 Share Extensions 才会显示，在列表的最末端有三个点的按钮，点开它可以看到支持 Share Extensions 的全部APP列表。</p>\n<p>使用 <code>UIActivityViewController</code> 非常简单，创建它并通过modal的形式弹出来：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIActivityViewController</span> *activityController = [[<span class=\"built_in\">UIActivityViewController</span> alloc] initWithActivityItems:@[[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"share\"</span>]] applicationActivities:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">activityController.excludedActivityTypes = @[<span class=\"built_in\">UIActivityTypeAirDrop</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">//        [activityController setCompletionWithItemsHandler:^(NSString * __nullable activityType, BOOL completed, NSArray * __nullable returnedItems, NSError * __nullable activityError)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            </span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;];</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> presentViewController:activityController animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<p>第一个数组内的对象代表的是我们想要操作的数据的一些内容，而且这个数组不能为空，比如我们PDF文档的名称、URL、、文本或者图片；第二个数组指定了泛型，数组内的对象必须是UIActivity类型的对象，代表的是iOS系统支持的我们自定义的服务，关于这点跟自定义UIActivity服务的内容有关，目前没用上，现在我们暂时置为nil。</p>\n<p>执行代码后，你会看到弹出和上图一样的控制器，这时候你就有疑问了，可分享的平台这么多，我怎么定制根据分享的app不同，内容也不同呢？</p>\n<h2 id=\"定制分享内容\"><a href=\"#定制分享内容\" class=\"headerlink\" title=\"定制分享内容\"></a>定制分享内容</h2><h3 id=\"分享文本\"><a href=\"#分享文本\" class=\"headerlink\" title=\"分享文本\"></a>分享文本</h3><p>定制分享内容你需要创建一个对象，实现 <code>UIActivityItemSource</code> 协议：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">LSCustomizedStringItemSource</span>: <span class=\"title\">NSObject</span> &lt;<span class=\"title\">UIActivityItemSource</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *partnerCode;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">LSCustomizedStringItemSource</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewControllerPlaceholderItem:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewController:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController itemForActivityType:(<span class=\"built_in\">NSString</span> *)activityType &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([activityType isEqualToString:<span class=\"built_in\">UIActivityTypePostToFacebook</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"Facebook\"</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([activityType isEqualToString:<span class=\"built_in\">UIActivityTypePostToTwitter</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"Twitter\"</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([activityType isEqualToString:<span class=\"built_in\">UIActivityTypeMessage</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"Message\"</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([activityType isEqualToString:<span class=\"built_in\">UIActivityTypeMail</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"Mail\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"Default\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>上面是自定义的文本分享内容，根据平台的不同，分享不同的文本。</p>\n<h3 id=\"分享图片\"><a href=\"#分享图片\" class=\"headerlink\" title=\"分享图片\"></a>分享图片</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">LSCustomizedImageItemSource</span>: <span class=\"title\">NSObject</span> &lt;<span class=\"title\">UIActivityItemSource</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">LSCustomizedImageItemSource</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewControllerPlaceholderItem:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewController:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController itemForActivityType:(<span class=\"built_in\">NSString</span> *)activityType &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([activityType isEqualToString:<span class=\"built_in\">UIActivityTypeMessage</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"share\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>上面是自定义的图片分享，分享到 iMessage 的时候，不需要分享图片</p>\n<h3 id=\"分享URL\"><a href=\"#分享URL\" class=\"headerlink\" title=\"分享URL\"></a>分享URL</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">LSCustomizedURLItemSource</span>: <span class=\"title\">NSObject</span> &lt;<span class=\"title\">UIActivityItemSource</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">LSCustomizedURLItemSource</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewControllerPlaceholderItem:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)activityViewController:(<span class=\"built_in\">UIActivityViewController</span> *)activityViewController itemForActivityType:(<span class=\"built_in\">NSString</span> *)activityType &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"https://www.taobao.com\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"重新设置-UIActivityViewController\"><a href=\"#重新设置-UIActivityViewController\" class=\"headerlink\" title=\"重新设置 UIActivityViewController\"></a>重新设置 UIActivityViewController</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSCustomizedStringItemSource *stringItemSource = [[LSCustomizedStringItemSource alloc] init];</span><br><span class=\"line\">LSCustomizedURLItemSource *urlItemSource = [[LSCustomizedURLItemSource alloc] init];</span><br><span class=\"line\">LSCustomizedImageItemSource *imageItemSource = [[LSCustomizedImageItemSource alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIActivityViewController</span> *activityController = [[<span class=\"built_in\">UIActivityViewController</span> alloc] initWithActivityItems:@[stringItemSource, urlItemSource, imageItemSource] applicationActivities:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<p>创建自定义分享内容，并赋值给 UIActivityViewController，这样就可以根据APP的不同，分享不同的内容。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用 UIActivityViewController 分享，优点和缺点都非常明显，所以需要根据你的业务需求来决定是否使用。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://stackoverflow.com/questions/37468195/give-thumbnail-image-with-uiactivityviewcontroller/37548529\" target=\"_blank\" rel=\"noopener\">Give thumbnail image with UIActivityViewController</a></li>\n<li><a href=\"http://www.jianshu.com/p/a1c9621a3f4e\" target=\"_blank\" rel=\"noopener\">通过UIActivityViewController实现更多分享服务</a></li>\n<li><a href=\"http://www.cocoachina.com/industry/20140425/8233.html\" target=\"_blank\" rel=\"noopener\">研究 UIActivityViewController</a></li>\n<li><a href=\"http://blog.csdn.net/phunxm/article/details/42715145\" target=\"_blank\" rel=\"noopener\">iOS8扩展插件开发配置</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004237771s\" target=\"_blank\" rel=\"noopener\">实现iOS app之间的内容分享</a></li>\n</ul>\n"},{"title":"fastlane 实践","date":"2017-05-14T04:46:12.000Z","_content":"\n## 前言\n\n众所周知，现在APP迭代的速度非常快，对开发和测试都是严重的考验，有很多客观因素可以通过自动化集成来减少人力成本，增加开发效率。`fastlane` 就是一个可以提高打包效率的工具。\n\n## fastlane\n\nfastlane 如何安装，怎么使用，可以Google或者baidu，也可以访问[官网](https://docs.fastlane.tools/getting-started/android/setup/)，总的来说它是一套自动化打包的工具集，用 Ruby 写的，用于 iOS 和 Android 的自动化打包的发布等工作。gym是其中的打包命令。\n\nfastlane 主要有以下指令：\n\n* deliver: 上传屏幕截图、二进制程序数据和应用程序到App Store\n* snapshot: 自动截取你的程序在每个设备上的图片\n* frameit: 快速将截图放入对应的手机设备中\n* pem: 自动生成和更新应用推送通知描述文件\n* sigh: 生成配置文件\n* produce: 通过命令行在iTunes Connect创建一个新的iOS app\n* cert: 自动创建iOS证书\n* gym: 建立新的发布的版本，打包\n\n一个最完整的发布过程使用fastlane可以这样描述：\n\n```\nlane :appstore do\n  increment_build_number\n  cocoapods\n  xctool\n  snapshot\n  sigh\n  deliver\n  frameit\n  sh \"./customScript.sh\"\nslack end\n```\n\n1. 增加 build 的版本号\n2. cocoapods进行pod配置\n3. xctool进行编译\n4. snapshot自动生成截图\n5. sigh处理配置文件\n6. deliver上传截图\n7. frameit将应用截图快速放入对应的设备尺寸中\n8. 执行些自动化脚本\n\n## 实践\n\n现在实践：执行命令-->打包-->上传Bugly\n\n首先，cd到项目的根目录，执行\n\n```shell\nfastlane init\n```\n\n初始化的过程会让你填写一些项目信息，比如Apple ID，项目的Targets（如果你有多个的话），还会生成如下图的项目结构：\n\n{% asset_img WX20170514-140038.png fastlane-project %}\n\n* Appfile：里存放App基本信息包括app_identifier、apple_id、team_id。\n\n* Fastfile：就是编写执行action的文件，所有的自定义功能都写在这个文件里面。\n\n我使用的脚本如下：\n\n```shell\nios_scheme_name = \"Livestar.tv\"\nios_ipa_name = \"Livestar\"\ndebug_ipa_path = \"/Users/pikeyoung/Documents/\" + Time.now.strftime(\"%Y-%m-%d\") + \"/Debug/\"\nrelease_ipa_path = \"/Users/pikeyoung/Documents/\" + Time.now.strftime(\"%Y-%m-%d\") + \"/Release/\"\n\nbefore_all do\n  # git_pull(only_tags: true)\n  cocoapods\nend\n\nafter_all do\n  # push_git_tags\nend\n\nlane :createDebugIPA do\n  ipa_path = debug_ipa_path\n  ipa_name = ios_ipa_name\n  ios_app_version = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleShortVersionString\")\n  ios_app_build = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleVersion\")\n  gym(\n    scheme: ios_scheme_name,\n    output_name: ipa_name + \"_\" + ios_app_build, # 输出的IPA名称\n    silent: true, # 隐藏不必要的信息\n    clean: true, # 在构建前先clean\n    configuration: \"Debug\", # 指定要打包的配置名\n    export_method: 'ad-hoc', # 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数\n    output_directory: ipa_path # IPA输出目录\n  )\nend\n```\n\n上面就是在指定目录下创建一个Debug的IPA，由于我司没有使用企业证书，构建的流程比较简单，所以没有使用很复杂的打包脚本。fastlane 支持从外部传入参数，指定打包的环境，增加build的版本号等action，目前都没用上。\n\n上传Bugly就很简单了，需要在Bugly官网下载upload的Ruby文件：\n\n{% asset_img WX20170514-142857.png fastlane-project %}\n\n然后还是通过fastlane执行action：\n\n```shell\nlane :uploadDebugIPA do\n  ios_app_version = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleShortVersionString\")\n  ios_app_build = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleVersion\")\n  debug_ipa_upload_path = debug_ipa_path + ios_ipa_name + \"_\" + ios_app_build + \".ipa\"\n  upload_app_to_bugly(\n    file_path: debug_ipa_upload_path,\n    app_key: \"123456\",\n    app_id: \"456123\",\n    pid: \"2\",\n    title: \"iOS-Debug-\" + Time.now.strftime(\"%Y-%m-%d %H:%M:%S\"),\n    desc: \"内部测试,请勿外泄\"\n  )\nend\n```\n\n假如，你需要从外部传入参数，确认需要打包的git分支，你可以这样：\n\n```shell\nlane :ci do|options|\n    branch = options[:branch] # 获取传入的git分支名\n    build_no = get_version_number + '.' + Time.new.strftime(\"%m%d%H%M\") # 生成build号，获取版本号+时间\n\n    puts \"Begin to run ci\"\n\n    # 确认分支、git状态、拉取最新代码\n    sh \"git checkout #{branch}\"\n    ensure_git_branch(branch: branch)\n    ensure_git_status_clean\n    git_pull\n\n    # 递增build number\n    increment_build_number(build_number: build_no)\n\n    #开始打包\n    gym(\n      export_method:\"development\",\n      output_directory:\"./fastlane/build\",\n    )\n\n    # 使用fir-cli上传ipa\n    sh \"fir publish ./build/LSTestDemo.ipa -T fasdfsdafas13213213sfs\"\n\nend\n```\n\n然后这样执行：\n\n```shell\nfastlane ci branch:dev1\n```\n\n## 总结\n\n上面的action还是比较简单的，上面的步骤其实还可以优化下，使用一台专门的Mac电脑配合`Jenkins`做打包操作。\n\n一些常用的 fastlane action 指令总结：\n\n```shell\ngit_pull: git拉取代码\ncocoapods: 更新pod库\npush_git_tags: git推送tags\nTime.now.strftime(\"%Y-%m-%d\"): 获取现在的时间，格式化显示格式\nTime.new.strftime(\"%m%d%H%M\"): 获取现在的时间，格式化显示格式（new与now的区别在于，new会调用initialize.）\nget_version_number: 获取项目version number\nensure_git_branch(branch: branch): 确认git分支\nensure_git_status_clean: 检查git状态\nincrement_build_number: 递增build version number\npush_to_git_remote: git推送代码到远程仓库\n```\n最后推荐下官方给的一些例子，是国外很多优秀的例子，可以直接借鉴过来：\nhttps://github.com/fastlane/examples\n\n## 参考链接\n\n* [fastlane docs](https://docs.fastlane.tools/)\n* [iOS菜鸟福利！带你一键轻松搞定项目构建、封包、上传](http://www.jianshu.com/p/38786933ba9c)\n* [记fastlane一次实践](http://www.jianshu.com/p/8e571c835844?utm_campaign=maleskine&utm_content=note&utm_medium=writer_share&utm_source=weibo)\n* [手把手教你利用Jenkins持续集成iOS项目](http://www.jianshu.com/p/41ecb06ae95f#)\n* [Jenkins一键发布「apk&ipa」 到Bugly](http://blog.csdn.net/zhf198909/article/details/53365812)\n* [fir-cli](https://github.com/FIRHQ/fir-cli)\n* [iOS可持续化集成: Jenkins+bundler+cocoapods+fastlane](http://www.cocoachina.com/ios/20150728/12733.html)\n* [fastlane Tutorial: Getting Started](https://www.raywenderlich.com/136168/fastlane-tutorial-getting-started-2)\n* [Fastlane入门:初级使用篇](http://www.jianshu.com/p/9f66b7a106ea)\n* [Fastlane 入门实战教程](https://libraries.io/github/mythkiven/AD_Fastlane)\n\n\n\n\n","source":"_posts/use-fastlane.md","raw":"---\ntitle: fastlane 实践\ndate: 2017-05-14 12:46:12\ntags: fastlane\ncategory: 能工巧匠\n---\n\n## 前言\n\n众所周知，现在APP迭代的速度非常快，对开发和测试都是严重的考验，有很多客观因素可以通过自动化集成来减少人力成本，增加开发效率。`fastlane` 就是一个可以提高打包效率的工具。\n\n## fastlane\n\nfastlane 如何安装，怎么使用，可以Google或者baidu，也可以访问[官网](https://docs.fastlane.tools/getting-started/android/setup/)，总的来说它是一套自动化打包的工具集，用 Ruby 写的，用于 iOS 和 Android 的自动化打包的发布等工作。gym是其中的打包命令。\n\nfastlane 主要有以下指令：\n\n* deliver: 上传屏幕截图、二进制程序数据和应用程序到App Store\n* snapshot: 自动截取你的程序在每个设备上的图片\n* frameit: 快速将截图放入对应的手机设备中\n* pem: 自动生成和更新应用推送通知描述文件\n* sigh: 生成配置文件\n* produce: 通过命令行在iTunes Connect创建一个新的iOS app\n* cert: 自动创建iOS证书\n* gym: 建立新的发布的版本，打包\n\n一个最完整的发布过程使用fastlane可以这样描述：\n\n```\nlane :appstore do\n  increment_build_number\n  cocoapods\n  xctool\n  snapshot\n  sigh\n  deliver\n  frameit\n  sh \"./customScript.sh\"\nslack end\n```\n\n1. 增加 build 的版本号\n2. cocoapods进行pod配置\n3. xctool进行编译\n4. snapshot自动生成截图\n5. sigh处理配置文件\n6. deliver上传截图\n7. frameit将应用截图快速放入对应的设备尺寸中\n8. 执行些自动化脚本\n\n## 实践\n\n现在实践：执行命令-->打包-->上传Bugly\n\n首先，cd到项目的根目录，执行\n\n```shell\nfastlane init\n```\n\n初始化的过程会让你填写一些项目信息，比如Apple ID，项目的Targets（如果你有多个的话），还会生成如下图的项目结构：\n\n{% asset_img WX20170514-140038.png fastlane-project %}\n\n* Appfile：里存放App基本信息包括app_identifier、apple_id、team_id。\n\n* Fastfile：就是编写执行action的文件，所有的自定义功能都写在这个文件里面。\n\n我使用的脚本如下：\n\n```shell\nios_scheme_name = \"Livestar.tv\"\nios_ipa_name = \"Livestar\"\ndebug_ipa_path = \"/Users/pikeyoung/Documents/\" + Time.now.strftime(\"%Y-%m-%d\") + \"/Debug/\"\nrelease_ipa_path = \"/Users/pikeyoung/Documents/\" + Time.now.strftime(\"%Y-%m-%d\") + \"/Release/\"\n\nbefore_all do\n  # git_pull(only_tags: true)\n  cocoapods\nend\n\nafter_all do\n  # push_git_tags\nend\n\nlane :createDebugIPA do\n  ipa_path = debug_ipa_path\n  ipa_name = ios_ipa_name\n  ios_app_version = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleShortVersionString\")\n  ios_app_build = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleVersion\")\n  gym(\n    scheme: ios_scheme_name,\n    output_name: ipa_name + \"_\" + ios_app_build, # 输出的IPA名称\n    silent: true, # 隐藏不必要的信息\n    clean: true, # 在构建前先clean\n    configuration: \"Debug\", # 指定要打包的配置名\n    export_method: 'ad-hoc', # 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数\n    output_directory: ipa_path # IPA输出目录\n  )\nend\n```\n\n上面就是在指定目录下创建一个Debug的IPA，由于我司没有使用企业证书，构建的流程比较简单，所以没有使用很复杂的打包脚本。fastlane 支持从外部传入参数，指定打包的环境，增加build的版本号等action，目前都没用上。\n\n上传Bugly就很简单了，需要在Bugly官网下载upload的Ruby文件：\n\n{% asset_img WX20170514-142857.png fastlane-project %}\n\n然后还是通过fastlane执行action：\n\n```shell\nlane :uploadDebugIPA do\n  ios_app_version = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleShortVersionString\")\n  ios_app_build = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleVersion\")\n  debug_ipa_upload_path = debug_ipa_path + ios_ipa_name + \"_\" + ios_app_build + \".ipa\"\n  upload_app_to_bugly(\n    file_path: debug_ipa_upload_path,\n    app_key: \"123456\",\n    app_id: \"456123\",\n    pid: \"2\",\n    title: \"iOS-Debug-\" + Time.now.strftime(\"%Y-%m-%d %H:%M:%S\"),\n    desc: \"内部测试,请勿外泄\"\n  )\nend\n```\n\n假如，你需要从外部传入参数，确认需要打包的git分支，你可以这样：\n\n```shell\nlane :ci do|options|\n    branch = options[:branch] # 获取传入的git分支名\n    build_no = get_version_number + '.' + Time.new.strftime(\"%m%d%H%M\") # 生成build号，获取版本号+时间\n\n    puts \"Begin to run ci\"\n\n    # 确认分支、git状态、拉取最新代码\n    sh \"git checkout #{branch}\"\n    ensure_git_branch(branch: branch)\n    ensure_git_status_clean\n    git_pull\n\n    # 递增build number\n    increment_build_number(build_number: build_no)\n\n    #开始打包\n    gym(\n      export_method:\"development\",\n      output_directory:\"./fastlane/build\",\n    )\n\n    # 使用fir-cli上传ipa\n    sh \"fir publish ./build/LSTestDemo.ipa -T fasdfsdafas13213213sfs\"\n\nend\n```\n\n然后这样执行：\n\n```shell\nfastlane ci branch:dev1\n```\n\n## 总结\n\n上面的action还是比较简单的，上面的步骤其实还可以优化下，使用一台专门的Mac电脑配合`Jenkins`做打包操作。\n\n一些常用的 fastlane action 指令总结：\n\n```shell\ngit_pull: git拉取代码\ncocoapods: 更新pod库\npush_git_tags: git推送tags\nTime.now.strftime(\"%Y-%m-%d\"): 获取现在的时间，格式化显示格式\nTime.new.strftime(\"%m%d%H%M\"): 获取现在的时间，格式化显示格式（new与now的区别在于，new会调用initialize.）\nget_version_number: 获取项目version number\nensure_git_branch(branch: branch): 确认git分支\nensure_git_status_clean: 检查git状态\nincrement_build_number: 递增build version number\npush_to_git_remote: git推送代码到远程仓库\n```\n最后推荐下官方给的一些例子，是国外很多优秀的例子，可以直接借鉴过来：\nhttps://github.com/fastlane/examples\n\n## 参考链接\n\n* [fastlane docs](https://docs.fastlane.tools/)\n* [iOS菜鸟福利！带你一键轻松搞定项目构建、封包、上传](http://www.jianshu.com/p/38786933ba9c)\n* [记fastlane一次实践](http://www.jianshu.com/p/8e571c835844?utm_campaign=maleskine&utm_content=note&utm_medium=writer_share&utm_source=weibo)\n* [手把手教你利用Jenkins持续集成iOS项目](http://www.jianshu.com/p/41ecb06ae95f#)\n* [Jenkins一键发布「apk&ipa」 到Bugly](http://blog.csdn.net/zhf198909/article/details/53365812)\n* [fir-cli](https://github.com/FIRHQ/fir-cli)\n* [iOS可持续化集成: Jenkins+bundler+cocoapods+fastlane](http://www.cocoachina.com/ios/20150728/12733.html)\n* [fastlane Tutorial: Getting Started](https://www.raywenderlich.com/136168/fastlane-tutorial-getting-started-2)\n* [Fastlane入门:初级使用篇](http://www.jianshu.com/p/9f66b7a106ea)\n* [Fastlane 入门实战教程](https://libraries.io/github/mythkiven/AD_Fastlane)\n\n\n\n\n","slug":"use-fastlane","published":1,"updated":"2017-05-14T07:24:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7m4002g8jpboap5sbvd","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>众所周知，现在APP迭代的速度非常快，对开发和测试都是严重的考验，有很多客观因素可以通过自动化集成来减少人力成本，增加开发效率。<code>fastlane</code> 就是一个可以提高打包效率的工具。</p>\n<h2 id=\"fastlane\"><a href=\"#fastlane\" class=\"headerlink\" title=\"fastlane\"></a>fastlane</h2><p>fastlane 如何安装，怎么使用，可以Google或者baidu，也可以访问<a href=\"https://docs.fastlane.tools/getting-started/android/setup/\" target=\"_blank\" rel=\"noopener\">官网</a>，总的来说它是一套自动化打包的工具集，用 Ruby 写的，用于 iOS 和 Android 的自动化打包的发布等工作。gym是其中的打包命令。</p>\n<p>fastlane 主要有以下指令：</p>\n<ul>\n<li>deliver: 上传屏幕截图、二进制程序数据和应用程序到App Store</li>\n<li>snapshot: 自动截取你的程序在每个设备上的图片</li>\n<li>frameit: 快速将截图放入对应的手机设备中</li>\n<li>pem: 自动生成和更新应用推送通知描述文件</li>\n<li>sigh: 生成配置文件</li>\n<li>produce: 通过命令行在iTunes Connect创建一个新的iOS app</li>\n<li>cert: 自动创建iOS证书</li>\n<li>gym: 建立新的发布的版本，打包</li>\n</ul>\n<p>一个最完整的发布过程使用fastlane可以这样描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lane :appstore do</span><br><span class=\"line\">  increment_build_number</span><br><span class=\"line\">  cocoapods</span><br><span class=\"line\">  xctool</span><br><span class=\"line\">  snapshot</span><br><span class=\"line\">  sigh</span><br><span class=\"line\">  deliver</span><br><span class=\"line\">  frameit</span><br><span class=\"line\">  sh &quot;./customScript.sh&quot;</span><br><span class=\"line\">slack end</span><br></pre></td></tr></table></figure>\n<ol>\n<li>增加 build 的版本号</li>\n<li>cocoapods进行pod配置</li>\n<li>xctool进行编译</li>\n<li>snapshot自动生成截图</li>\n<li>sigh处理配置文件</li>\n<li>deliver上传截图</li>\n<li>frameit将应用截图快速放入对应的设备尺寸中</li>\n<li>执行些自动化脚本</li>\n</ol>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>现在实践：执行命令–&gt;打包–&gt;上传Bugly</p>\n<p>首先，cd到项目的根目录，执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fastlane init</span><br></pre></td></tr></table></figure>\n<p>初始化的过程会让你填写一些项目信息，比如Apple ID，项目的Targets（如果你有多个的话），还会生成如下图的项目结构：</p>\n<img src=\"/2017/05/14/use-fastlane/WX20170514-140038.png\" title=\"fastlane-project\">\n<ul>\n<li><p>Appfile：里存放App基本信息包括app_identifier、apple_id、team_id。</p>\n</li>\n<li><p>Fastfile：就是编写执行action的文件，所有的自定义功能都写在这个文件里面。</p>\n</li>\n</ul>\n<p>我使用的脚本如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ios_scheme_name = \"Livestar.tv\"</span><br><span class=\"line\">ios_ipa_name = \"Livestar\"</span><br><span class=\"line\">debug_ipa_path = \"/Users/pikeyoung/Documents/\" + Time.now.strftime(\"%Y-%m-%d\") + \"/Debug/\"</span><br><span class=\"line\">release_ipa_path = \"/Users/pikeyoung/Documents/\" + Time.now.strftime(\"%Y-%m-%d\") + \"/Release/\"</span><br><span class=\"line\"></span><br><span class=\"line\">before_all do</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> git_pull(only_tags: <span class=\"literal\">true</span>)</span></span><br><span class=\"line\">  cocoapods</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">after_all do</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> push_git_tags</span></span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">lane :createDebugIPA do</span><br><span class=\"line\">  ipa_path = debug_ipa_path</span><br><span class=\"line\">  ipa_name = ios_ipa_name</span><br><span class=\"line\">  ios_app_version = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleShortVersionString\")</span><br><span class=\"line\">  ios_app_build = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleVersion\")</span><br><span class=\"line\">  gym(</span><br><span class=\"line\">    scheme: ios_scheme_name,</span><br><span class=\"line\">    output_name: ipa_name + \"_\" + ios_app_build, # 输出的IPA名称</span><br><span class=\"line\">    silent: true, # 隐藏不必要的信息</span><br><span class=\"line\">    clean: true, # 在构建前先clean</span><br><span class=\"line\">    configuration: \"Debug\", # 指定要打包的配置名</span><br><span class=\"line\">    export_method: 'ad-hoc', # 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数</span><br><span class=\"line\">    output_directory: ipa_path # IPA输出目录</span><br><span class=\"line\">  )</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>上面就是在指定目录下创建一个Debug的IPA，由于我司没有使用企业证书，构建的流程比较简单，所以没有使用很复杂的打包脚本。fastlane 支持从外部传入参数，指定打包的环境，增加build的版本号等action，目前都没用上。</p>\n<p>上传Bugly就很简单了，需要在Bugly官网下载upload的Ruby文件：</p>\n<img src=\"/2017/05/14/use-fastlane/WX20170514-142857.png\" title=\"fastlane-project\">\n<p>然后还是通过fastlane执行action：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lane :uploadDebugIPA do</span><br><span class=\"line\">  ios_app_version = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleShortVersionString\")</span><br><span class=\"line\">  ios_app_build = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleVersion\")</span><br><span class=\"line\">  debug_ipa_upload_path = debug_ipa_path + ios_ipa_name + \"_\" + ios_app_build + \".ipa\"</span><br><span class=\"line\">  upload_app_to_bugly(</span><br><span class=\"line\">    file_path: debug_ipa_upload_path,</span><br><span class=\"line\">    app_key: \"123456\",</span><br><span class=\"line\">    app_id: \"456123\",</span><br><span class=\"line\">    pid: \"2\",</span><br><span class=\"line\">    title: \"iOS-Debug-\" + Time.now.strftime(\"%Y-%m-%d %H:%M:%S\"),</span><br><span class=\"line\">    desc: \"内部测试,请勿外泄\"</span><br><span class=\"line\">  )</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>假如，你需要从外部传入参数，确认需要打包的git分支，你可以这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lane :ci do|options|</span><br><span class=\"line\">    branch = options[:branch] # 获取传入的git分支名</span><br><span class=\"line\">    build_no = get_version_number + '.' + Time.new.strftime(\"%m%d%H%M\") # 生成build号，获取版本号+时间</span><br><span class=\"line\"></span><br><span class=\"line\">    puts \"Begin to run ci\"</span><br><span class=\"line\"></span><br><span class=\"line\">    # 确认分支、git状态、拉取最新代码</span><br><span class=\"line\">    sh \"git checkout #&#123;branch&#125;\"</span><br><span class=\"line\">    ensure_git_branch(branch: branch)</span><br><span class=\"line\">    ensure_git_status_clean</span><br><span class=\"line\">    git_pull</span><br><span class=\"line\"></span><br><span class=\"line\">    # 递增build number</span><br><span class=\"line\">    increment_build_number(build_number: build_no)</span><br><span class=\"line\"></span><br><span class=\"line\">    #开始打包</span><br><span class=\"line\">    gym(</span><br><span class=\"line\">      export_method:\"development\",</span><br><span class=\"line\">      output_directory:\"./fastlane/build\",</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    # 使用fir-cli上传ipa</span><br><span class=\"line\">    sh \"fir publish ./build/LSTestDemo.ipa -T fasdfsdafas13213213sfs\"</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>然后这样执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fastlane ci branch:dev1</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面的action还是比较简单的，上面的步骤其实还可以优化下，使用一台专门的Mac电脑配合<code>Jenkins</code>做打包操作。</p>\n<p>一些常用的 fastlane action 指令总结：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git_pull: git拉取代码</span><br><span class=\"line\">cocoapods: 更新pod库</span><br><span class=\"line\">push_git_tags: git推送tags</span><br><span class=\"line\">Time.now.strftime(\"%Y-%m-%d\"): 获取现在的时间，格式化显示格式</span><br><span class=\"line\">Time.new.strftime(\"%m%d%H%M\"): 获取现在的时间，格式化显示格式（new与now的区别在于，new会调用initialize.）</span><br><span class=\"line\">get_version_number: 获取项目version number</span><br><span class=\"line\">ensure_git_branch(branch: branch): 确认git分支</span><br><span class=\"line\">ensure_git_status_clean: 检查git状态</span><br><span class=\"line\">increment_build_number: 递增build version number</span><br><span class=\"line\">push_to_git_remote: git推送代码到远程仓库</span><br></pre></td></tr></table></figure>\n<p>最后推荐下官方给的一些例子，是国外很多优秀的例子，可以直接借鉴过来：<br><a href=\"https://github.com/fastlane/examples\" target=\"_blank\" rel=\"noopener\">https://github.com/fastlane/examples</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://docs.fastlane.tools/\" target=\"_blank\" rel=\"noopener\">fastlane docs</a></li>\n<li><a href=\"http://www.jianshu.com/p/38786933ba9c\" target=\"_blank\" rel=\"noopener\">iOS菜鸟福利！带你一键轻松搞定项目构建、封包、上传</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e571c835844?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=writer_share&amp;utm_source=weibo\" target=\"_blank\" rel=\"noopener\">记fastlane一次实践</a></li>\n<li><a href=\"http://www.jianshu.com/p/41ecb06ae95f#\" target=\"_blank\" rel=\"noopener\">手把手教你利用Jenkins持续集成iOS项目</a></li>\n<li><a href=\"http://blog.csdn.net/zhf198909/article/details/53365812\" target=\"_blank\" rel=\"noopener\">Jenkins一键发布「apk&amp;ipa」 到Bugly</a></li>\n<li><a href=\"https://github.com/FIRHQ/fir-cli\" target=\"_blank\" rel=\"noopener\">fir-cli</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150728/12733.html\" target=\"_blank\" rel=\"noopener\">iOS可持续化集成: Jenkins+bundler+cocoapods+fastlane</a></li>\n<li><a href=\"https://www.raywenderlich.com/136168/fastlane-tutorial-getting-started-2\" target=\"_blank\" rel=\"noopener\">fastlane Tutorial: Getting Started</a></li>\n<li><a href=\"http://www.jianshu.com/p/9f66b7a106ea\" target=\"_blank\" rel=\"noopener\">Fastlane入门:初级使用篇</a></li>\n<li><a href=\"https://libraries.io/github/mythkiven/AD_Fastlane\" target=\"_blank\" rel=\"noopener\">Fastlane 入门实战教程</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>众所周知，现在APP迭代的速度非常快，对开发和测试都是严重的考验，有很多客观因素可以通过自动化集成来减少人力成本，增加开发效率。<code>fastlane</code> 就是一个可以提高打包效率的工具。</p>\n<h2 id=\"fastlane\"><a href=\"#fastlane\" class=\"headerlink\" title=\"fastlane\"></a>fastlane</h2><p>fastlane 如何安装，怎么使用，可以Google或者baidu，也可以访问<a href=\"https://docs.fastlane.tools/getting-started/android/setup/\" target=\"_blank\" rel=\"noopener\">官网</a>，总的来说它是一套自动化打包的工具集，用 Ruby 写的，用于 iOS 和 Android 的自动化打包的发布等工作。gym是其中的打包命令。</p>\n<p>fastlane 主要有以下指令：</p>\n<ul>\n<li>deliver: 上传屏幕截图、二进制程序数据和应用程序到App Store</li>\n<li>snapshot: 自动截取你的程序在每个设备上的图片</li>\n<li>frameit: 快速将截图放入对应的手机设备中</li>\n<li>pem: 自动生成和更新应用推送通知描述文件</li>\n<li>sigh: 生成配置文件</li>\n<li>produce: 通过命令行在iTunes Connect创建一个新的iOS app</li>\n<li>cert: 自动创建iOS证书</li>\n<li>gym: 建立新的发布的版本，打包</li>\n</ul>\n<p>一个最完整的发布过程使用fastlane可以这样描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lane :appstore do</span><br><span class=\"line\">  increment_build_number</span><br><span class=\"line\">  cocoapods</span><br><span class=\"line\">  xctool</span><br><span class=\"line\">  snapshot</span><br><span class=\"line\">  sigh</span><br><span class=\"line\">  deliver</span><br><span class=\"line\">  frameit</span><br><span class=\"line\">  sh &quot;./customScript.sh&quot;</span><br><span class=\"line\">slack end</span><br></pre></td></tr></table></figure>\n<ol>\n<li>增加 build 的版本号</li>\n<li>cocoapods进行pod配置</li>\n<li>xctool进行编译</li>\n<li>snapshot自动生成截图</li>\n<li>sigh处理配置文件</li>\n<li>deliver上传截图</li>\n<li>frameit将应用截图快速放入对应的设备尺寸中</li>\n<li>执行些自动化脚本</li>\n</ol>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>现在实践：执行命令–&gt;打包–&gt;上传Bugly</p>\n<p>首先，cd到项目的根目录，执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fastlane init</span><br></pre></td></tr></table></figure>\n<p>初始化的过程会让你填写一些项目信息，比如Apple ID，项目的Targets（如果你有多个的话），还会生成如下图的项目结构：</p>\n<img src=\"/2017/05/14/use-fastlane/WX20170514-140038.png\" title=\"fastlane-project\">\n<ul>\n<li><p>Appfile：里存放App基本信息包括app_identifier、apple_id、team_id。</p>\n</li>\n<li><p>Fastfile：就是编写执行action的文件，所有的自定义功能都写在这个文件里面。</p>\n</li>\n</ul>\n<p>我使用的脚本如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ios_scheme_name = \"Livestar.tv\"</span><br><span class=\"line\">ios_ipa_name = \"Livestar\"</span><br><span class=\"line\">debug_ipa_path = \"/Users/pikeyoung/Documents/\" + Time.now.strftime(\"%Y-%m-%d\") + \"/Debug/\"</span><br><span class=\"line\">release_ipa_path = \"/Users/pikeyoung/Documents/\" + Time.now.strftime(\"%Y-%m-%d\") + \"/Release/\"</span><br><span class=\"line\"></span><br><span class=\"line\">before_all do</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> git_pull(only_tags: <span class=\"literal\">true</span>)</span></span><br><span class=\"line\">  cocoapods</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">after_all do</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> push_git_tags</span></span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">lane :createDebugIPA do</span><br><span class=\"line\">  ipa_path = debug_ipa_path</span><br><span class=\"line\">  ipa_name = ios_ipa_name</span><br><span class=\"line\">  ios_app_version = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleShortVersionString\")</span><br><span class=\"line\">  ios_app_build = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleVersion\")</span><br><span class=\"line\">  gym(</span><br><span class=\"line\">    scheme: ios_scheme_name,</span><br><span class=\"line\">    output_name: ipa_name + \"_\" + ios_app_build, # 输出的IPA名称</span><br><span class=\"line\">    silent: true, # 隐藏不必要的信息</span><br><span class=\"line\">    clean: true, # 在构建前先clean</span><br><span class=\"line\">    configuration: \"Debug\", # 指定要打包的配置名</span><br><span class=\"line\">    export_method: 'ad-hoc', # 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数</span><br><span class=\"line\">    output_directory: ipa_path # IPA输出目录</span><br><span class=\"line\">  )</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>上面就是在指定目录下创建一个Debug的IPA，由于我司没有使用企业证书，构建的流程比较简单，所以没有使用很复杂的打包脚本。fastlane 支持从外部传入参数，指定打包的环境，增加build的版本号等action，目前都没用上。</p>\n<p>上传Bugly就很简单了，需要在Bugly官网下载upload的Ruby文件：</p>\n<img src=\"/2017/05/14/use-fastlane/WX20170514-142857.png\" title=\"fastlane-project\">\n<p>然后还是通过fastlane执行action：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lane :uploadDebugIPA do</span><br><span class=\"line\">  ios_app_version = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleShortVersionString\")</span><br><span class=\"line\">  ios_app_build = get_info_plist_value(path: \"./\" + ios_scheme_name + \"/Info.plist\", key: \"CFBundleVersion\")</span><br><span class=\"line\">  debug_ipa_upload_path = debug_ipa_path + ios_ipa_name + \"_\" + ios_app_build + \".ipa\"</span><br><span class=\"line\">  upload_app_to_bugly(</span><br><span class=\"line\">    file_path: debug_ipa_upload_path,</span><br><span class=\"line\">    app_key: \"123456\",</span><br><span class=\"line\">    app_id: \"456123\",</span><br><span class=\"line\">    pid: \"2\",</span><br><span class=\"line\">    title: \"iOS-Debug-\" + Time.now.strftime(\"%Y-%m-%d %H:%M:%S\"),</span><br><span class=\"line\">    desc: \"内部测试,请勿外泄\"</span><br><span class=\"line\">  )</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>假如，你需要从外部传入参数，确认需要打包的git分支，你可以这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lane :ci do|options|</span><br><span class=\"line\">    branch = options[:branch] # 获取传入的git分支名</span><br><span class=\"line\">    build_no = get_version_number + '.' + Time.new.strftime(\"%m%d%H%M\") # 生成build号，获取版本号+时间</span><br><span class=\"line\"></span><br><span class=\"line\">    puts \"Begin to run ci\"</span><br><span class=\"line\"></span><br><span class=\"line\">    # 确认分支、git状态、拉取最新代码</span><br><span class=\"line\">    sh \"git checkout #&#123;branch&#125;\"</span><br><span class=\"line\">    ensure_git_branch(branch: branch)</span><br><span class=\"line\">    ensure_git_status_clean</span><br><span class=\"line\">    git_pull</span><br><span class=\"line\"></span><br><span class=\"line\">    # 递增build number</span><br><span class=\"line\">    increment_build_number(build_number: build_no)</span><br><span class=\"line\"></span><br><span class=\"line\">    #开始打包</span><br><span class=\"line\">    gym(</span><br><span class=\"line\">      export_method:\"development\",</span><br><span class=\"line\">      output_directory:\"./fastlane/build\",</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    # 使用fir-cli上传ipa</span><br><span class=\"line\">    sh \"fir publish ./build/LSTestDemo.ipa -T fasdfsdafas13213213sfs\"</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>然后这样执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fastlane ci branch:dev1</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面的action还是比较简单的，上面的步骤其实还可以优化下，使用一台专门的Mac电脑配合<code>Jenkins</code>做打包操作。</p>\n<p>一些常用的 fastlane action 指令总结：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git_pull: git拉取代码</span><br><span class=\"line\">cocoapods: 更新pod库</span><br><span class=\"line\">push_git_tags: git推送tags</span><br><span class=\"line\">Time.now.strftime(\"%Y-%m-%d\"): 获取现在的时间，格式化显示格式</span><br><span class=\"line\">Time.new.strftime(\"%m%d%H%M\"): 获取现在的时间，格式化显示格式（new与now的区别在于，new会调用initialize.）</span><br><span class=\"line\">get_version_number: 获取项目version number</span><br><span class=\"line\">ensure_git_branch(branch: branch): 确认git分支</span><br><span class=\"line\">ensure_git_status_clean: 检查git状态</span><br><span class=\"line\">increment_build_number: 递增build version number</span><br><span class=\"line\">push_to_git_remote: git推送代码到远程仓库</span><br></pre></td></tr></table></figure>\n<p>最后推荐下官方给的一些例子，是国外很多优秀的例子，可以直接借鉴过来：<br><a href=\"https://github.com/fastlane/examples\" target=\"_blank\" rel=\"noopener\">https://github.com/fastlane/examples</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://docs.fastlane.tools/\" target=\"_blank\" rel=\"noopener\">fastlane docs</a></li>\n<li><a href=\"http://www.jianshu.com/p/38786933ba9c\" target=\"_blank\" rel=\"noopener\">iOS菜鸟福利！带你一键轻松搞定项目构建、封包、上传</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e571c835844?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=writer_share&amp;utm_source=weibo\" target=\"_blank\" rel=\"noopener\">记fastlane一次实践</a></li>\n<li><a href=\"http://www.jianshu.com/p/41ecb06ae95f#\" target=\"_blank\" rel=\"noopener\">手把手教你利用Jenkins持续集成iOS项目</a></li>\n<li><a href=\"http://blog.csdn.net/zhf198909/article/details/53365812\" target=\"_blank\" rel=\"noopener\">Jenkins一键发布「apk&amp;ipa」 到Bugly</a></li>\n<li><a href=\"https://github.com/FIRHQ/fir-cli\" target=\"_blank\" rel=\"noopener\">fir-cli</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150728/12733.html\" target=\"_blank\" rel=\"noopener\">iOS可持续化集成: Jenkins+bundler+cocoapods+fastlane</a></li>\n<li><a href=\"https://www.raywenderlich.com/136168/fastlane-tutorial-getting-started-2\" target=\"_blank\" rel=\"noopener\">fastlane Tutorial: Getting Started</a></li>\n<li><a href=\"http://www.jianshu.com/p/9f66b7a106ea\" target=\"_blank\" rel=\"noopener\">Fastlane入门:初级使用篇</a></li>\n<li><a href=\"https://libraries.io/github/mythkiven/AD_Fastlane\" target=\"_blank\" rel=\"noopener\">Fastlane 入门实战教程</a></li>\n</ul>\n"},{"title":"preferredStatusBarStyle 使用Tips","date":"2017-07-30T02:08:35.000Z","_content":"\n## 前言\n\n最近对公司 iOS 项目进行版本升级，最低支持 iOS 10，升级后有很多 API 已经过期了，其中就包括 **statusBarStyle**：\n\n```objc\n@property(readwrite, nonatomic) UIStatusBarStyle statusBarStyle NS_DEPRECATED_IOS(2_0, 9_0, \"Use -[UIViewController preferredStatusBarStyle]\") __TVOS_PROHIBITED;\n```\n\n根据提示使用 **preferredStatusBarStyle** 方法代替时，发现时而有效时而无效，非常纠结！\n\n```objc\n- (UIStatusBarStyle)preferredStatusBarStyle {\n    return UIStatusBarStyleLightContent;\n}\n```\n\n## 解决方法\n\n去网上Google了好久才发现原因：你的ViewController有可能嵌套到了 **UINavigationController** 或者 **UITabBarController** 中。\n\n系统会从 **window** 的 **rootViewController** 开始层层确认 **preferredStatusBarStyle**。\n\n所以需要从父类着手处理，创建创建一个 **UINavigationController** 或者 **UITabBarController** 的子类，然后重写 **childViewControllerForStatusBarStyle** 方法：\n\n```objc\n- (UIViewController *)childViewControllerForStatusBarStyle {\n    return self.selectedViewController;\n}\n```\n\n使用子类化的容器后，系统就会根据返回的 ViewController 的 **preferredStatusBarStyle** 方法来处理 status bar 的 style 了。\n\n以此类推 Status Bar Hidden 也是通过这种方式奏效：\n\n```objc\n- (UIViewController *)childViewControllerForStatusBarHidden {\n    return self.selectedViewController;\n}\n```\n\n还有个情况，当present一个ViewController时，**preferredStatusBarStyle** 又不工作了，这时候你需要在present前设置：\n\n```objc\nvc.modalPresentationStyle = UIModalPresentationCustom;\nvc.modalPresentationCapturesStatusBarAppearance = YES;\n```\n这样present出来的VC的 Status Bar 才生效。\n\n系统还提供了一个刷新 Status Bar 的方法，当需要强制刷新时，可以调用 **setNeedsStatusBarAppearanceUpdate** 来刷新。\n\n\n","source":"_posts/work-preferredStatusBarStyle.md","raw":"---\ntitle: preferredStatusBarStyle 使用Tips\ndate: 2017-07-30 10:08:35\ntags: preferredStatusBarStyle\ncategory: Tips\n---\n\n## 前言\n\n最近对公司 iOS 项目进行版本升级，最低支持 iOS 10，升级后有很多 API 已经过期了，其中就包括 **statusBarStyle**：\n\n```objc\n@property(readwrite, nonatomic) UIStatusBarStyle statusBarStyle NS_DEPRECATED_IOS(2_0, 9_0, \"Use -[UIViewController preferredStatusBarStyle]\") __TVOS_PROHIBITED;\n```\n\n根据提示使用 **preferredStatusBarStyle** 方法代替时，发现时而有效时而无效，非常纠结！\n\n```objc\n- (UIStatusBarStyle)preferredStatusBarStyle {\n    return UIStatusBarStyleLightContent;\n}\n```\n\n## 解决方法\n\n去网上Google了好久才发现原因：你的ViewController有可能嵌套到了 **UINavigationController** 或者 **UITabBarController** 中。\n\n系统会从 **window** 的 **rootViewController** 开始层层确认 **preferredStatusBarStyle**。\n\n所以需要从父类着手处理，创建创建一个 **UINavigationController** 或者 **UITabBarController** 的子类，然后重写 **childViewControllerForStatusBarStyle** 方法：\n\n```objc\n- (UIViewController *)childViewControllerForStatusBarStyle {\n    return self.selectedViewController;\n}\n```\n\n使用子类化的容器后，系统就会根据返回的 ViewController 的 **preferredStatusBarStyle** 方法来处理 status bar 的 style 了。\n\n以此类推 Status Bar Hidden 也是通过这种方式奏效：\n\n```objc\n- (UIViewController *)childViewControllerForStatusBarHidden {\n    return self.selectedViewController;\n}\n```\n\n还有个情况，当present一个ViewController时，**preferredStatusBarStyle** 又不工作了，这时候你需要在present前设置：\n\n```objc\nvc.modalPresentationStyle = UIModalPresentationCustom;\nvc.modalPresentationCapturesStatusBarAppearance = YES;\n```\n这样present出来的VC的 Status Bar 才生效。\n\n系统还提供了一个刷新 Status Bar 的方法，当需要强制刷新时，可以调用 **setNeedsStatusBarAppearanceUpdate** 来刷新。\n\n\n","slug":"work-preferredStatusBarStyle","published":1,"updated":"2018-01-20T02:50:20.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7md002j8jpbqvqihg3u","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近对公司 iOS 项目进行版本升级，最低支持 iOS 10，升级后有很多 API 已经过期了，其中就包括 <strong>statusBarStyle</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UIStatusBarStyle</span> statusBarStyle <span class=\"built_in\">NS_DEPRECATED_IOS</span>(<span class=\"number\">2</span>_0, <span class=\"number\">9</span>_0, <span class=\"string\">\"Use -[UIViewController preferredStatusBarStyle]\"</span>) __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>\n<p>根据提示使用 <strong>preferredStatusBarStyle</strong> 方法代替时，发现时而有效时而无效，非常纠结！</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIStatusBarStyle</span>)preferredStatusBarStyle &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">UIStatusBarStyleLightContent</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>去网上Google了好久才发现原因：你的ViewController有可能嵌套到了 <strong>UINavigationController</strong> 或者 <strong>UITabBarController</strong> 中。</p>\n<p>系统会从 <strong>window</strong> 的 <strong>rootViewController</strong> 开始层层确认 <strong>preferredStatusBarStyle</strong>。</p>\n<p>所以需要从父类着手处理，创建创建一个 <strong>UINavigationController</strong> 或者 <strong>UITabBarController</strong> 的子类，然后重写 <strong>childViewControllerForStatusBarStyle</strong> 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *)childViewControllerForStatusBarStyle &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.selectedViewController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用子类化的容器后，系统就会根据返回的 ViewController 的 <strong>preferredStatusBarStyle</strong> 方法来处理 status bar 的 style 了。</p>\n<p>以此类推 Status Bar Hidden 也是通过这种方式奏效：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *)childViewControllerForStatusBarHidden &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.selectedViewController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有个情况，当present一个ViewController时，<strong>preferredStatusBarStyle</strong> 又不工作了，这时候你需要在present前设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vc.modalPresentationStyle = <span class=\"built_in\">UIModalPresentationCustom</span>;</span><br><span class=\"line\">vc.modalPresentationCapturesStatusBarAppearance = <span class=\"literal\">YES</span>;</span><br></pre></td></tr></table></figure>\n<p>这样present出来的VC的 Status Bar 才生效。</p>\n<p>系统还提供了一个刷新 Status Bar 的方法，当需要强制刷新时，可以调用 <strong>setNeedsStatusBarAppearanceUpdate</strong> 来刷新。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近对公司 iOS 项目进行版本升级，最低支持 iOS 10，升级后有很多 API 已经过期了，其中就包括 <strong>statusBarStyle</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UIStatusBarStyle</span> statusBarStyle <span class=\"built_in\">NS_DEPRECATED_IOS</span>(<span class=\"number\">2</span>_0, <span class=\"number\">9</span>_0, <span class=\"string\">\"Use -[UIViewController preferredStatusBarStyle]\"</span>) __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>\n<p>根据提示使用 <strong>preferredStatusBarStyle</strong> 方法代替时，发现时而有效时而无效，非常纠结！</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIStatusBarStyle</span>)preferredStatusBarStyle &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">UIStatusBarStyleLightContent</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>去网上Google了好久才发现原因：你的ViewController有可能嵌套到了 <strong>UINavigationController</strong> 或者 <strong>UITabBarController</strong> 中。</p>\n<p>系统会从 <strong>window</strong> 的 <strong>rootViewController</strong> 开始层层确认 <strong>preferredStatusBarStyle</strong>。</p>\n<p>所以需要从父类着手处理，创建创建一个 <strong>UINavigationController</strong> 或者 <strong>UITabBarController</strong> 的子类，然后重写 <strong>childViewControllerForStatusBarStyle</strong> 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *)childViewControllerForStatusBarStyle &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.selectedViewController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用子类化的容器后，系统就会根据返回的 ViewController 的 <strong>preferredStatusBarStyle</strong> 方法来处理 status bar 的 style 了。</p>\n<p>以此类推 Status Bar Hidden 也是通过这种方式奏效：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *)childViewControllerForStatusBarHidden &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.selectedViewController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有个情况，当present一个ViewController时，<strong>preferredStatusBarStyle</strong> 又不工作了，这时候你需要在present前设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vc.modalPresentationStyle = <span class=\"built_in\">UIModalPresentationCustom</span>;</span><br><span class=\"line\">vc.modalPresentationCapturesStatusBarAppearance = <span class=\"literal\">YES</span>;</span><br></pre></td></tr></table></figure>\n<p>这样present出来的VC的 Status Bar 才生效。</p>\n<p>系统还提供了一个刷新 Status Bar 的方法，当需要强制刷新时，可以调用 <strong>setNeedsStatusBarAppearanceUpdate</strong> 来刷新。</p>\n"},{"title":"《Swifter - Swift 必备 Tips》总结（一）","date":"2017-11-11T07:50:51.000Z","_content":"\n## 前言\n\n本篇文章是对 [王巍 (@onevcat)](https://onevcat.com/) 的著作[《Swifter - Swift 必备 Tips》](https://onev.cat/publication/swifter/)的个人阅读总结和代码片段记录。\n\n\n## 正则表达式\n\nSwift 至今为止并没有在语言层面上支持正则表达式。我们可以使用 Cocoa 中的 **NSRegularExpression** 来做正则匹配。\n\n一个最简单的实现：\n\n```swift\nstruct RegexHelper {\n    let regex: NSRegularExpression\n    \n    init(_ pattern: String) throws {\n        try regex = NSRegularExpression(pattern: pattern, options: .caseInsensitive)\n    }\n    \n    func match(_ input: String) -> Bool {\n        let matches = regex.matches(in: input, options: [], range: NSMakeRange(0, input.utf16.count))\n        return matches.count > 0\n    }\n}\n```\n\n使用：\n\n```swift\nlet mailPattern = \"^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})$\"\n\nlet matcher: RegexHelper\ndo {\n    matcher = try RegexHelper(mailPattern)\n}\n\nlet maybeMailAddress = \"onev@onevcat.com\"\n\nif matcher.match(maybeMailAddress) {\n    print(\"有效的邮箱地址\")\n}\n```\n\n> 一个很棒的正则表达式文章[《正则表达式 30 分钟入门教程》](https://deerchao.net/tutorials/regex/regex.htm)，还有[《8个常用正则表达式》](https://code.tutsplus.com/tutorials/8-regular-expressions-you-should-know--net-6149)\n\n现在有了方便的封装，使用 **=~** 来实现：\n\n```swift\nprecedencegroup MatchPrecedence {\n    associativity: none\n    higherThan: DefaultPrecedence\n}\n\ninfix operator =~: MatchPrecedence\n\nfunc =~(lhs: String, rhs: String) -> Bool {\n    do {\n        return try RegexHelper(rhs).match(lhs)\n    } catch _ {\n        return false\n    }\n}\n```\n\n使用：\n\n```swift\nif \"onev@onevcat.com\" =~\n\"^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})$\" {\n    print(\"有效的邮箱地址\")\n}\n```\n\n## 单例\n\n在 Objective-C 中单例的公认写法类似这样：\n\n```objc\n@implementation MyManager\n+ (id)sharedManager {\n    static MyManager * staticInstance = nil;\n    static dispatch_once_t onceToken;\n\n    dispatch_once(&onceToken, ^{\n        staticInstance = [[self alloc] init];\n    });\n    return staticInstance;\n}\n@end\n```\n\nSwift 1.2 之后支持了 class 的 static let 和 static var 这样的存储变量后，有个推荐的写法：\n\n```swift\nclass MyManager  {\n    static let shared = MyManager()\n    private init() {}\n}\n```\n\n私有初始化方法，是让项目其他地方不能够通过 **init** 来生成自己的 **MyManager** 实例，保证了类型单例的唯一性。如果你需要的是类似 **default** 的形式的单例（也就是说这个类的使用者可以创建自己的实例）的话，可以去掉这个私有的 **init** 方法。\n\n## 条件编译\n\nSwift 中没有宏定义的概念，因此我们不能使用 **#ifdef** 的方法来检查某个符号是否经过宏定义。为了控制编译流程和内容，Swift 还是提供了几种简答的机制来根据需求定制编译内容。\n\n\n```\n#if <condition>\n\n#elseif <condition>\n\n#else\n\n#endif\n```\n\n使用例子：\n\n```\n@IBAction func someButtonPressed(sender: AnyObject!) {\n    #if FREE_VERSION\n        // 弹出购买提示，导航至商店等\n    #else\n        // 实际功能\n    #endif\n}\n```\n\n**FREE_VERSION** 这个编译符号代表免费版本，我们需要在项目的编一个选项中进行设置，在项目的 Build Settings 中，找到 Swift Compiler - Custom Flags，并在其中的 Other Swift Flags 加上 **-D FREE_VERSION** 就可以了。\n\n## 编译标记\n\n在 Objective-C 中，我们经常插入 **#param** 来标记代码的间距。Swift 中也有类似的标记：\n\n```swift\n// MARK:\n\n// TODO:\n\n// FIXME:\n```\n\n## 内存管理，weak 和 unowned\n\n**unowned** 更像以前的 **unsafe_unretained**，而 **weak** 就是以前的 **weak**。用通俗的话说，就是 unowned 设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 \"无效的\" 引用，它不能是 Optional 值，也不会被指向 nil。如果你尝试调用这个引用的方法或者访问成员属性的话，程序就会崩溃。而 weak 则友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil (因此被标记为@weak 的变量一定需要是 Optional 值)。\n\n关于两者使用的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。\n\n## 值类型和引用类型\n\nSwift 中的 struct 和 enum 定义的类型是值类型，使用 class 定义的为引用类型。很有意思的是，Swift 中的所有的内建类型都是值类型，不仅包括了传统意义像 Int，Bool 这些，甚至连 String，Array 以及 Dictionary 都是值类型的。\n\n在使用数组和字典时的最佳实践应该是，按照具体的数据规模和操作特点来决定到时是使用值类型的容器还是引用类型的容器：在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好，而对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary。\n\n## String 还是 NSString\n\n没有什么特别需要注意的话，尽量使用原生的 **String** 类型。\n\n具体原因查阅原文。\n\nString 唯一一个比较麻烦的地方在于它和 **Range** 的配合。在 NSString 中，我们在匹配字符串的时候通常使用 NSRange 来表征结果或者作为输入。而在使用 String 的对应的 API 时，NSRange 也会被映射成它在 Swift 中且对应 String 的特殊版本：**Range<String.Index>**。这有时候会让人非常讨厌： \n\n```swift \nlet levels = \"ABCDE\"\n\nlet nsRange = NSMakeRange(1, 4)\n// 编译错误\n// Cannot convert value of type `NSRanve` to expected argument type 'Range<Index>'\nlevels.replacingCharacters(in: nsRange, with: \"AAAA\")\n\nlet indexPositionOne = levels.index(levels.startIndex, offsetBy: 1)\nlet swiftRange = indexPositionOne ..< levels.index(levels.startIndex, offsetBy: 5)\nlevels.replacingCharacters(in: swiftRange, with: \"AAAA\")\n// 输出：\n// AAAAA\n```\n\n这样太麻烦了，这种情况下，将 **string** 转为 **NSString** 也许是个不错的选择：\n\n```swift\nlet nsRange = NSMakeRange(1, 4)\n(levels as NSString).replacingCharacters(in: nsRange, with: \"AAAA\")\n```\n\n## GCD 和延时调用\n\nGCD 里面有一个很好用的延时调用：\n\n```swift\nlet time: TimeInterval = 2.0\nDispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + time) {\n    print(\"2秒后输出\")\n}\n```\n👆代码非常简单，但是还可以稍微封装下，最好加上取消功能：\n\n```swift\ntypealias Task = (_ cancel : Bool) -> Void\n\nfunc delay(_ time: TimeInterval, task: @escaping ()->()) ->  Task? {\n    \n    func dispatch_later(block: @escaping ()->()) {\n        let t = DispatchTime.now() + time\n        DispatchQueue.main.asyncAfter(deadline: t, execute: block)\n    }\n    \n    var closure: (()->Void)? = task\n    var result: Task?\n    \n    let delayedClosure: Task = {\n        cancel in\n        if let internalClosure = closure {\n            if (cancel == false) {\n                DispatchQueue.main.async(execute: internalClosure)\n            }\n        }\n        closure = nil\n        result = nil\n    }\n    \n    result = delayedClosure\n    \n    dispatch_later {\n        if let delayedClosure = result {\n            delayedClosure(false)\n        }\n    }\n    \n    return result;\n}\n\nfunc cancel(_ task: Task?) {\n    task?(true)\n}\n```\n\n使用：\n\n```swift\ndelay(2) { print(\"2 秒后输出\") }\n\nlet task = delay(5) { print(\"拨打 110\") }\n\n// 仔细想一想..\n// 还是取消为妙..\ncancel(task)\n```\n\n## 调用C动态库\n\n生成 **MD5** 密钥：\n\n```swift\n// TargetName-Bridging-Header.h\n#import <CommonCrypto/CommonCrypto.h>\n\n// StringMD5.swift\nextension String {\n    var MD5: String {\n        var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n        if let data = data(using: .utf8) {\n            data.withUnsafeBytes { (bytes: UnsafePointer<UInt8>) -> Void in\n                CC_MD5(bytes, CC_LONG(data.count), &digest)\n            }\n        }\n        \n        var digestHex = \"\"\n        for index in 0..<Int(CC_MD5_DIGEST_LENGTH) {\n            digestHex += String(format: \"%02x\", digest[index])\n        }\n        \n        return digestHex\n    }\n}\n\n// 测试\nprint(\"swifter.tips\".MD5)\n\n// 输出\n// dff88de99ff03d109de22fed4f71a273\n```\n\n## 输出格式化\n\n在 **Objective-C** 中经常使用 **NSLog** 配合上 **%@** 来输出打印内容到控制台：\n\n```objc\nint a = 3;\nfloat b = 1.234567;\nNSString *c = @\"Hello\";\nNSLog(@\"int:%d float:%f string:%@\",a,b,c);\n// 输出：\n// int:3 float:1.234567 string:Hello \n```\n\n在 Swift 里，我们一般使用 **Print** 来打印：\n\n```swift\nlet a = 3;\nlet b = 1.234567  // 我们在这里不去区分 float 和 Double 了\nlet c = \"Hello\"\nprint(\"int:\\(a) double:\\(b) string:\\(c)\")\n// 输出：\n// int:3 double:1.234567 string:Hello\n```\n\n这时候我们常常遇到有些问题，比如打印👆 **b** 中的小数点后两位，在 Objective-C 中使用 **NSLog** 时可以写成：\n\n```objc\nNSLog(@\"float:%.2f\",b);\n// 输出：\n// float:1.23\n```\n\nSwift 的 **Print** 就没这么幸运了。**String** 的格式化初始化方法可以帮助我们利用格式化的字符串：\n\n```swift\nlet format = String(format:\"%.2f\", 1.234567)\nprint(\"double:\\(format)\")\n// 输出：\n// double:1.23\n```\n\n每次这么写也很麻烦。如果大量使用的话，还是写个 Double 的扩展：\n\n```swift\nextension Double {\n    func format(_ f: String) -> String {\n        return String(format: \"%\\(f)f\", self)\n    }\n}\n\nlet f = \".2\"\nprint(\"double:\\(1.234567.format(f))\")\n```\n\n## 数组 enumerate\n\n使用 **NSArray** 时经常遇到的是同时获取值和下标索引，在 Objective-C 中最方便的方式是使用 **enumerateObjectsUsingBlock:** 方法：\n\n```objc\nNSArray *arr = @[@1, @2, @3, @4, @5];\n__block NSInteger result = 0;\n[arr enumerateObjectsUsingBlock:^(NSNumber *num, NSUInteger idx, BOOL *stop) {\n    result += [num integerValue];\n    if (idx == 2) {\n        *stop = YES;\n    }\n}];\n\nNSLog(@\"%ld\", result);\n// 输出：6\n```\n\n停止遍历需要用到 ***stop** 来标记停止，在 Swift 中，这个 API 的 ***stop** 被转换为对应的 **UnsafeMutablePointer<ObjCBool>**：\n\n```swift\nlet arr: NSArray = [1,2,3,4,5]\nvar result = 0\narr.enumerateObjects ({ (num, idx, stop) -> Void in\n    result += num as! Int\n    if idx == 2 {\n        stop.pointee = true\n    }\n})\nprint(result)\n// 输出：6\n```\n\n虽然使用 **enumerateObjectsUsingBlock:** 很方便，但是其实从性能上来说这个方法并不理想（具体见原文章），另外它需要使用 **NSArray** 类型，已经不符合 Swift的编码方式了。\n\n在 Swift 上有个很好的替代：\n\n```swift\nvar result = 0\nfor (idx, num) in [1,2,3,4,5].enumerated() {\n    result += num\n    if idx == 2 {\n        break\n    }\n}\nprint(result)\n```\n\n## 小结\n\n以上代码片段全部出自 [王巍 (@onevcat)](https://onevcat.com/) 的著作[《Swifter - Swift 必备 Tips》](https://onev.cat/publication/swifter/)，仅供参考查阅使用，更加详细的内容请参考原著，请支持正版。\n\n\n","source":"_posts/2017-11-11-swifter-tips-summary-1.md","raw":"---\ntitle: 《Swifter - Swift 必备 Tips》总结（一）\ndate: 2017-11-11 15:50:51\ntags: Swift\ncategory: Tips\n---\n\n## 前言\n\n本篇文章是对 [王巍 (@onevcat)](https://onevcat.com/) 的著作[《Swifter - Swift 必备 Tips》](https://onev.cat/publication/swifter/)的个人阅读总结和代码片段记录。\n\n\n## 正则表达式\n\nSwift 至今为止并没有在语言层面上支持正则表达式。我们可以使用 Cocoa 中的 **NSRegularExpression** 来做正则匹配。\n\n一个最简单的实现：\n\n```swift\nstruct RegexHelper {\n    let regex: NSRegularExpression\n    \n    init(_ pattern: String) throws {\n        try regex = NSRegularExpression(pattern: pattern, options: .caseInsensitive)\n    }\n    \n    func match(_ input: String) -> Bool {\n        let matches = regex.matches(in: input, options: [], range: NSMakeRange(0, input.utf16.count))\n        return matches.count > 0\n    }\n}\n```\n\n使用：\n\n```swift\nlet mailPattern = \"^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})$\"\n\nlet matcher: RegexHelper\ndo {\n    matcher = try RegexHelper(mailPattern)\n}\n\nlet maybeMailAddress = \"onev@onevcat.com\"\n\nif matcher.match(maybeMailAddress) {\n    print(\"有效的邮箱地址\")\n}\n```\n\n> 一个很棒的正则表达式文章[《正则表达式 30 分钟入门教程》](https://deerchao.net/tutorials/regex/regex.htm)，还有[《8个常用正则表达式》](https://code.tutsplus.com/tutorials/8-regular-expressions-you-should-know--net-6149)\n\n现在有了方便的封装，使用 **=~** 来实现：\n\n```swift\nprecedencegroup MatchPrecedence {\n    associativity: none\n    higherThan: DefaultPrecedence\n}\n\ninfix operator =~: MatchPrecedence\n\nfunc =~(lhs: String, rhs: String) -> Bool {\n    do {\n        return try RegexHelper(rhs).match(lhs)\n    } catch _ {\n        return false\n    }\n}\n```\n\n使用：\n\n```swift\nif \"onev@onevcat.com\" =~\n\"^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})$\" {\n    print(\"有效的邮箱地址\")\n}\n```\n\n## 单例\n\n在 Objective-C 中单例的公认写法类似这样：\n\n```objc\n@implementation MyManager\n+ (id)sharedManager {\n    static MyManager * staticInstance = nil;\n    static dispatch_once_t onceToken;\n\n    dispatch_once(&onceToken, ^{\n        staticInstance = [[self alloc] init];\n    });\n    return staticInstance;\n}\n@end\n```\n\nSwift 1.2 之后支持了 class 的 static let 和 static var 这样的存储变量后，有个推荐的写法：\n\n```swift\nclass MyManager  {\n    static let shared = MyManager()\n    private init() {}\n}\n```\n\n私有初始化方法，是让项目其他地方不能够通过 **init** 来生成自己的 **MyManager** 实例，保证了类型单例的唯一性。如果你需要的是类似 **default** 的形式的单例（也就是说这个类的使用者可以创建自己的实例）的话，可以去掉这个私有的 **init** 方法。\n\n## 条件编译\n\nSwift 中没有宏定义的概念，因此我们不能使用 **#ifdef** 的方法来检查某个符号是否经过宏定义。为了控制编译流程和内容，Swift 还是提供了几种简答的机制来根据需求定制编译内容。\n\n\n```\n#if <condition>\n\n#elseif <condition>\n\n#else\n\n#endif\n```\n\n使用例子：\n\n```\n@IBAction func someButtonPressed(sender: AnyObject!) {\n    #if FREE_VERSION\n        // 弹出购买提示，导航至商店等\n    #else\n        // 实际功能\n    #endif\n}\n```\n\n**FREE_VERSION** 这个编译符号代表免费版本，我们需要在项目的编一个选项中进行设置，在项目的 Build Settings 中，找到 Swift Compiler - Custom Flags，并在其中的 Other Swift Flags 加上 **-D FREE_VERSION** 就可以了。\n\n## 编译标记\n\n在 Objective-C 中，我们经常插入 **#param** 来标记代码的间距。Swift 中也有类似的标记：\n\n```swift\n// MARK:\n\n// TODO:\n\n// FIXME:\n```\n\n## 内存管理，weak 和 unowned\n\n**unowned** 更像以前的 **unsafe_unretained**，而 **weak** 就是以前的 **weak**。用通俗的话说，就是 unowned 设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 \"无效的\" 引用，它不能是 Optional 值，也不会被指向 nil。如果你尝试调用这个引用的方法或者访问成员属性的话，程序就会崩溃。而 weak 则友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil (因此被标记为@weak 的变量一定需要是 Optional 值)。\n\n关于两者使用的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。\n\n## 值类型和引用类型\n\nSwift 中的 struct 和 enum 定义的类型是值类型，使用 class 定义的为引用类型。很有意思的是，Swift 中的所有的内建类型都是值类型，不仅包括了传统意义像 Int，Bool 这些，甚至连 String，Array 以及 Dictionary 都是值类型的。\n\n在使用数组和字典时的最佳实践应该是，按照具体的数据规模和操作特点来决定到时是使用值类型的容器还是引用类型的容器：在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好，而对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary。\n\n## String 还是 NSString\n\n没有什么特别需要注意的话，尽量使用原生的 **String** 类型。\n\n具体原因查阅原文。\n\nString 唯一一个比较麻烦的地方在于它和 **Range** 的配合。在 NSString 中，我们在匹配字符串的时候通常使用 NSRange 来表征结果或者作为输入。而在使用 String 的对应的 API 时，NSRange 也会被映射成它在 Swift 中且对应 String 的特殊版本：**Range<String.Index>**。这有时候会让人非常讨厌： \n\n```swift \nlet levels = \"ABCDE\"\n\nlet nsRange = NSMakeRange(1, 4)\n// 编译错误\n// Cannot convert value of type `NSRanve` to expected argument type 'Range<Index>'\nlevels.replacingCharacters(in: nsRange, with: \"AAAA\")\n\nlet indexPositionOne = levels.index(levels.startIndex, offsetBy: 1)\nlet swiftRange = indexPositionOne ..< levels.index(levels.startIndex, offsetBy: 5)\nlevels.replacingCharacters(in: swiftRange, with: \"AAAA\")\n// 输出：\n// AAAAA\n```\n\n这样太麻烦了，这种情况下，将 **string** 转为 **NSString** 也许是个不错的选择：\n\n```swift\nlet nsRange = NSMakeRange(1, 4)\n(levels as NSString).replacingCharacters(in: nsRange, with: \"AAAA\")\n```\n\n## GCD 和延时调用\n\nGCD 里面有一个很好用的延时调用：\n\n```swift\nlet time: TimeInterval = 2.0\nDispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + time) {\n    print(\"2秒后输出\")\n}\n```\n👆代码非常简单，但是还可以稍微封装下，最好加上取消功能：\n\n```swift\ntypealias Task = (_ cancel : Bool) -> Void\n\nfunc delay(_ time: TimeInterval, task: @escaping ()->()) ->  Task? {\n    \n    func dispatch_later(block: @escaping ()->()) {\n        let t = DispatchTime.now() + time\n        DispatchQueue.main.asyncAfter(deadline: t, execute: block)\n    }\n    \n    var closure: (()->Void)? = task\n    var result: Task?\n    \n    let delayedClosure: Task = {\n        cancel in\n        if let internalClosure = closure {\n            if (cancel == false) {\n                DispatchQueue.main.async(execute: internalClosure)\n            }\n        }\n        closure = nil\n        result = nil\n    }\n    \n    result = delayedClosure\n    \n    dispatch_later {\n        if let delayedClosure = result {\n            delayedClosure(false)\n        }\n    }\n    \n    return result;\n}\n\nfunc cancel(_ task: Task?) {\n    task?(true)\n}\n```\n\n使用：\n\n```swift\ndelay(2) { print(\"2 秒后输出\") }\n\nlet task = delay(5) { print(\"拨打 110\") }\n\n// 仔细想一想..\n// 还是取消为妙..\ncancel(task)\n```\n\n## 调用C动态库\n\n生成 **MD5** 密钥：\n\n```swift\n// TargetName-Bridging-Header.h\n#import <CommonCrypto/CommonCrypto.h>\n\n// StringMD5.swift\nextension String {\n    var MD5: String {\n        var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n        if let data = data(using: .utf8) {\n            data.withUnsafeBytes { (bytes: UnsafePointer<UInt8>) -> Void in\n                CC_MD5(bytes, CC_LONG(data.count), &digest)\n            }\n        }\n        \n        var digestHex = \"\"\n        for index in 0..<Int(CC_MD5_DIGEST_LENGTH) {\n            digestHex += String(format: \"%02x\", digest[index])\n        }\n        \n        return digestHex\n    }\n}\n\n// 测试\nprint(\"swifter.tips\".MD5)\n\n// 输出\n// dff88de99ff03d109de22fed4f71a273\n```\n\n## 输出格式化\n\n在 **Objective-C** 中经常使用 **NSLog** 配合上 **%@** 来输出打印内容到控制台：\n\n```objc\nint a = 3;\nfloat b = 1.234567;\nNSString *c = @\"Hello\";\nNSLog(@\"int:%d float:%f string:%@\",a,b,c);\n// 输出：\n// int:3 float:1.234567 string:Hello \n```\n\n在 Swift 里，我们一般使用 **Print** 来打印：\n\n```swift\nlet a = 3;\nlet b = 1.234567  // 我们在这里不去区分 float 和 Double 了\nlet c = \"Hello\"\nprint(\"int:\\(a) double:\\(b) string:\\(c)\")\n// 输出：\n// int:3 double:1.234567 string:Hello\n```\n\n这时候我们常常遇到有些问题，比如打印👆 **b** 中的小数点后两位，在 Objective-C 中使用 **NSLog** 时可以写成：\n\n```objc\nNSLog(@\"float:%.2f\",b);\n// 输出：\n// float:1.23\n```\n\nSwift 的 **Print** 就没这么幸运了。**String** 的格式化初始化方法可以帮助我们利用格式化的字符串：\n\n```swift\nlet format = String(format:\"%.2f\", 1.234567)\nprint(\"double:\\(format)\")\n// 输出：\n// double:1.23\n```\n\n每次这么写也很麻烦。如果大量使用的话，还是写个 Double 的扩展：\n\n```swift\nextension Double {\n    func format(_ f: String) -> String {\n        return String(format: \"%\\(f)f\", self)\n    }\n}\n\nlet f = \".2\"\nprint(\"double:\\(1.234567.format(f))\")\n```\n\n## 数组 enumerate\n\n使用 **NSArray** 时经常遇到的是同时获取值和下标索引，在 Objective-C 中最方便的方式是使用 **enumerateObjectsUsingBlock:** 方法：\n\n```objc\nNSArray *arr = @[@1, @2, @3, @4, @5];\n__block NSInteger result = 0;\n[arr enumerateObjectsUsingBlock:^(NSNumber *num, NSUInteger idx, BOOL *stop) {\n    result += [num integerValue];\n    if (idx == 2) {\n        *stop = YES;\n    }\n}];\n\nNSLog(@\"%ld\", result);\n// 输出：6\n```\n\n停止遍历需要用到 ***stop** 来标记停止，在 Swift 中，这个 API 的 ***stop** 被转换为对应的 **UnsafeMutablePointer<ObjCBool>**：\n\n```swift\nlet arr: NSArray = [1,2,3,4,5]\nvar result = 0\narr.enumerateObjects ({ (num, idx, stop) -> Void in\n    result += num as! Int\n    if idx == 2 {\n        stop.pointee = true\n    }\n})\nprint(result)\n// 输出：6\n```\n\n虽然使用 **enumerateObjectsUsingBlock:** 很方便，但是其实从性能上来说这个方法并不理想（具体见原文章），另外它需要使用 **NSArray** 类型，已经不符合 Swift的编码方式了。\n\n在 Swift 上有个很好的替代：\n\n```swift\nvar result = 0\nfor (idx, num) in [1,2,3,4,5].enumerated() {\n    result += num\n    if idx == 2 {\n        break\n    }\n}\nprint(result)\n```\n\n## 小结\n\n以上代码片段全部出自 [王巍 (@onevcat)](https://onevcat.com/) 的著作[《Swifter - Swift 必备 Tips》](https://onev.cat/publication/swifter/)，仅供参考查阅使用，更加详细的内容请参考原著，请支持正版。\n\n\n","slug":"2017-11-11-swifter-tips-summary-1","published":1,"updated":"2018-09-02T03:30:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7nj003r8jpbi56v3ddi","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇文章是对 <a href=\"https://onevcat.com/\" target=\"_blank\" rel=\"noopener\">王巍 (@onevcat)</a> 的著作<a href=\"https://onev.cat/publication/swifter/\" target=\"_blank\" rel=\"noopener\">《Swifter - Swift 必备 Tips》</a>的个人阅读总结和代码片段记录。</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>Swift 至今为止并没有在语言层面上支持正则表达式。我们可以使用 Cocoa 中的 <strong>NSRegularExpression</strong> 来做正则匹配。</p>\n<p>一个最简单的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RegexHelper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> regex: <span class=\"type\">NSRegularExpression</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"number\">_</span> pattern: <span class=\"type\">String</span>) <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> regex = <span class=\"type\">NSRegularExpression</span>(pattern: pattern, options: .caseInsensitive)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">match</span><span class=\"params\">(<span class=\"number\">_</span> input: String)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> matches = regex.matches(<span class=\"keyword\">in</span>: input, options: [], range: <span class=\"type\">NSMakeRange</span>(<span class=\"number\">0</span>, input.utf16.<span class=\"built_in\">count</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> matches.<span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mailPattern = <span class=\"string\">\"^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]&#123;2,6&#125;)$\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> matcher: <span class=\"type\">RegexHelper</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    matcher = <span class=\"keyword\">try</span> <span class=\"type\">RegexHelper</span>(mailPattern)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> maybeMailAddress = <span class=\"string\">\"onev@onevcat.com\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> matcher.match(maybeMailAddress) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"有效的邮箱地址\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>一个很棒的正则表达式文章<a href=\"https://deerchao.net/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"noopener\">《正则表达式 30 分钟入门教程》</a>，还有<a href=\"https://code.tutsplus.com/tutorials/8-regular-expressions-you-should-know--net-6149\" target=\"_blank\" rel=\"noopener\">《8个常用正则表达式》</a></p>\n</blockquote>\n<p>现在有了方便的封装，使用 <strong>=~</strong> 来实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precedencegroup <span class=\"type\">MatchPrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">associativity</span>: <span class=\"keyword\">none</span></span><br><span class=\"line\">    higherThan: <span class=\"type\">DefaultPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> =~: <span class=\"type\">MatchPrecedence</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> =~<span class=\"params\">(lhs: String, rhs: String)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> <span class=\"type\">RegexHelper</span>(rhs).match(lhs)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> <span class=\"number\">_</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"string\">\"onev@onevcat.com\"</span> =~</span><br><span class=\"line\"><span class=\"string\">\"^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]&#123;2,6&#125;)$\"</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"有效的邮箱地址\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"单例\"><a href=\"#单例\" class=\"headerlink\" title=\"单例\"></a>单例</h2><p>在 Objective-C 中单例的公认写法类似这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyManager</span></span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)sharedManager &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> MyManager * staticInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        staticInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> staticInstance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>Swift 1.2 之后支持了 class 的 static let 和 static var 这样的存储变量后，有个推荐的写法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyManager</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> shared = <span class=\"type\">MyManager</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">init</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>私有初始化方法，是让项目其他地方不能够通过 <strong>init</strong> 来生成自己的 <strong>MyManager</strong> 实例，保证了类型单例的唯一性。如果你需要的是类似 <strong>default</strong> 的形式的单例（也就是说这个类的使用者可以创建自己的实例）的话，可以去掉这个私有的 <strong>init</strong> 方法。</p>\n<h2 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h2><p>Swift 中没有宏定义的概念，因此我们不能使用 <strong>#ifdef</strong> 的方法来检查某个符号是否经过宏定义。为了控制编译流程和内容，Swift 还是提供了几种简答的机制来根据需求定制编译内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if &lt;condition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#elseif &lt;condition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#else</span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p>使用例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@IBAction func someButtonPressed(sender: AnyObject!) &#123;</span><br><span class=\"line\">    #if FREE_VERSION</span><br><span class=\"line\">        // 弹出购买提示，导航至商店等</span><br><span class=\"line\">    #else</span><br><span class=\"line\">        // 实际功能</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>FREE_VERSION</strong> 这个编译符号代表免费版本，我们需要在项目的编一个选项中进行设置，在项目的 Build Settings 中，找到 Swift Compiler - Custom Flags，并在其中的 Other Swift Flags 加上 <strong>-D FREE_VERSION</strong> 就可以了。</p>\n<h2 id=\"编译标记\"><a href=\"#编译标记\" class=\"headerlink\" title=\"编译标记\"></a>编译标记</h2><p>在 Objective-C 中，我们经常插入 <strong>#param</strong> 来标记代码的间距。Swift 中也有类似的标记：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MARK:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">FIXME:</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"内存管理，weak-和-unowned\"><a href=\"#内存管理，weak-和-unowned\" class=\"headerlink\" title=\"内存管理，weak 和 unowned\"></a>内存管理，weak 和 unowned</h2><p><strong>unowned</strong> 更像以前的 <strong>unsafe_unretained</strong>，而 <strong>weak</strong> 就是以前的 <strong>weak</strong>。用通俗的话说，就是 unowned 设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 “无效的” 引用，它不能是 Optional 值，也不会被指向 nil。如果你尝试调用这个引用的方法或者访问成员属性的话，程序就会崩溃。而 weak 则友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil (因此被标记为@weak 的变量一定需要是 Optional 值)。</p>\n<p>关于两者使用的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。</p>\n<h2 id=\"值类型和引用类型\"><a href=\"#值类型和引用类型\" class=\"headerlink\" title=\"值类型和引用类型\"></a>值类型和引用类型</h2><p>Swift 中的 struct 和 enum 定义的类型是值类型，使用 class 定义的为引用类型。很有意思的是，Swift 中的所有的内建类型都是值类型，不仅包括了传统意义像 Int，Bool 这些，甚至连 String，Array 以及 Dictionary 都是值类型的。</p>\n<p>在使用数组和字典时的最佳实践应该是，按照具体的数据规模和操作特点来决定到时是使用值类型的容器还是引用类型的容器：在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好，而对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary。</p>\n<h2 id=\"String-还是-NSString\"><a href=\"#String-还是-NSString\" class=\"headerlink\" title=\"String 还是 NSString\"></a>String 还是 NSString</h2><p>没有什么特别需要注意的话，尽量使用原生的 <strong>String</strong> 类型。</p>\n<p>具体原因查阅原文。</p>\n<p>String 唯一一个比较麻烦的地方在于它和 <strong>Range</strong> 的配合。在 NSString 中，我们在匹配字符串的时候通常使用 NSRange 来表征结果或者作为输入。而在使用 String 的对应的 API 时，NSRange 也会被映射成它在 Swift 中且对应 String 的特殊版本：<strong>Range&lt;String.Index&gt;</strong>。这有时候会让人非常讨厌： </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> levels = <span class=\"string\">\"ABCDE\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nsRange = <span class=\"type\">NSMakeRange</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// 编译错误</span></span><br><span class=\"line\"><span class=\"comment\">// Cannot convert value of type `NSRanve` to expected argument type 'Range&lt;Index&gt;'</span></span><br><span class=\"line\">levels.replacingCharacters(<span class=\"keyword\">in</span>: nsRange, with: <span class=\"string\">\"AAAA\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> indexPositionOne = levels.index(levels.startIndex, offsetBy: <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> swiftRange = indexPositionOne ..&lt; levels.index(levels.startIndex, offsetBy: <span class=\"number\">5</span>)</span><br><span class=\"line\">levels.replacingCharacters(<span class=\"keyword\">in</span>: swiftRange, with: <span class=\"string\">\"AAAA\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// AAAAA</span></span><br></pre></td></tr></table></figure>\n<p>这样太麻烦了，这种情况下，将 <strong>string</strong> 转为 <strong>NSString</strong> 也许是个不错的选择：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nsRange = <span class=\"type\">NSMakeRange</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">(levels <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).replacingCharacters(<span class=\"keyword\">in</span>: nsRange, with: <span class=\"string\">\"AAAA\"</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"GCD-和延时调用\"><a href=\"#GCD-和延时调用\" class=\"headerlink\" title=\"GCD 和延时调用\"></a>GCD 和延时调用</h2><p>GCD 里面有一个很好用的延时调用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> time: <span class=\"type\">TimeInterval</span> = <span class=\"number\">2.0</span></span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: <span class=\"type\">DispatchTime</span>.now() + time) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"2秒后输出\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆代码非常简单，但是还可以稍微封装下，最好加上取消功能：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">Task</span> = (<span class=\"number\">_</span> cancel : <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">Void</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">delay</span><span class=\"params\">(<span class=\"number\">_</span> time: TimeInterval, task: @escaping <span class=\"params\">()</span></span></span>-&gt;()) -&gt;  <span class=\"type\">Task?</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_later</span><span class=\"params\">(block: @escaping <span class=\"params\">()</span></span></span>-&gt;()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> t = <span class=\"type\">DispatchTime</span>.now() + time</span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: t, execute: block)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> closure: (()-&gt;<span class=\"type\">Void</span>)? = task</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result: <span class=\"type\">Task?</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> delayedClosure: <span class=\"type\">Task</span> = &#123;</span><br><span class=\"line\">        cancel <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> internalClosure = closure &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cancel == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">DispatchQueue</span>.main.async(execute: internalClosure)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        closure = <span class=\"literal\">nil</span></span><br><span class=\"line\">        result = <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    result = delayedClosure</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_later &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> delayedClosure = result &#123;</span><br><span class=\"line\">            delayedClosure(<span class=\"literal\">false</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"number\">_</span> task: Task?)</span></span> &#123;</span><br><span class=\"line\">    task?(<span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delay(<span class=\"number\">2</span>) &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"2 秒后输出\"</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> task = delay(<span class=\"number\">5</span>) &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"拨打 110\"</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 仔细想一想..</span></span><br><span class=\"line\"><span class=\"comment\">// 还是取消为妙..</span></span><br><span class=\"line\">cancel(task)</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用C动态库\"><a href=\"#调用C动态库\" class=\"headerlink\" title=\"调用C动态库\"></a>调用C动态库</h2><p>生成 <strong>MD5</strong> 密钥：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TargetName-Bridging-Header.h</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;CommonCrypto/CommonCrypto.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// StringMD5.swift</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"type\">MD5</span>: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> digest = [<span class=\"type\">UInt8</span>](repeating: <span class=\"number\">0</span>, <span class=\"built_in\">count</span>: <span class=\"type\">Int</span>(<span class=\"type\">CC_MD5_DIGEST_LENGTH</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = data(using: .utf8) &#123;</span><br><span class=\"line\">            data.withUnsafeBytes &#123; (bytes: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">UInt8</span>&gt;) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">                <span class=\"type\">CC_MD5</span>(bytes, <span class=\"type\">CC_LONG</span>(data.<span class=\"built_in\">count</span>), &amp;digest)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> digestHex = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"type\">Int</span>(<span class=\"type\">CC_MD5_DIGEST_LENGTH</span>) &#123;</span><br><span class=\"line\">            digestHex += <span class=\"type\">String</span>(format: <span class=\"string\">\"%02x\"</span>, digest[index])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> digestHex</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"swifter.tips\"</span>.<span class=\"type\">MD5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"comment\">// dff88de99ff03d109de22fed4f71a273</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"输出格式化\"><a href=\"#输出格式化\" class=\"headerlink\" title=\"输出格式化\"></a>输出格式化</h2><p>在 <strong>Objective-C</strong> 中经常使用 <strong>NSLog</strong> 配合上 <strong>%@</strong> 来输出打印内容到控制台：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> b = <span class=\"number\">1.234567</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *c = <span class=\"string\">@\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"int:%d float:%f string:%@\"</span>,a,b,c);</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// int:3 float:1.234567 string:Hello</span></span><br></pre></td></tr></table></figure>\n<p>在 Swift 里，我们一般使用 <strong>Print</strong> 来打印：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">1.234567</span>  <span class=\"comment\">// 我们在这里不去区分 float 和 Double 了</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">c</span> = <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"int:\\(a) double:\\(b) string:\\(c)\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// int:3 double:1.234567 string:Hello</span></span><br></pre></td></tr></table></figure>\n<p>这时候我们常常遇到有些问题，比如打印👆 <strong>b</strong> 中的小数点后两位，在 Objective-C 中使用 <strong>NSLog</strong> 时可以写成：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"float:%.2f\"</span>,b);</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// float:1.23</span></span><br></pre></td></tr></table></figure>\n<p>Swift 的 <strong>Print</strong> 就没这么幸运了。<strong>String</strong> 的格式化初始化方法可以帮助我们利用格式化的字符串：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> format = <span class=\"type\">String</span>(format:<span class=\"string\">\"%.2f\"</span>, <span class=\"number\">1.234567</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"double:\\(format)\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// double:1.23</span></span><br></pre></td></tr></table></figure>\n<p>每次这么写也很麻烦。如果大量使用的话，还是写个 Double 的扩展：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Double</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">format</span><span class=\"params\">(<span class=\"number\">_</span> f: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">String</span>(format: <span class=\"string\">\"%\\(f)f\"</span>, <span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> f = <span class=\"string\">\".2\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"double:\\(1.234567.format(f))\"</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组-enumerate\"><a href=\"#数组-enumerate\" class=\"headerlink\" title=\"数组 enumerate\"></a>数组 enumerate</h2><p>使用 <strong>NSArray</strong> 时经常遇到的是同时获取值和下标索引，在 Objective-C 中最方便的方式是使用 <strong>enumerateObjectsUsingBlock:</strong> 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *arr = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>, @<span class=\"number\">4</span>, @<span class=\"number\">5</span>];</span><br><span class=\"line\">__block <span class=\"built_in\">NSInteger</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">[arr enumerateObjectsUsingBlock:^(<span class=\"built_in\">NSNumber</span> *num, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    result += [num integerValue];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        *stop = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld\"</span>, result);</span><br><span class=\"line\"><span class=\"comment\">// 输出：6</span></span><br></pre></td></tr></table></figure>\n<p>停止遍历需要用到 <strong>*stop</strong> 来标记停止，在 Swift 中，这个 API 的 <strong>*stop</strong> 被转换为对应的 <strong>UnsafeMutablePointer<objcbool></objcbool></strong>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr: <span class=\"type\">NSArray</span> = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = <span class=\"number\">0</span></span><br><span class=\"line\">arr.enumerateObjects (&#123; (num, idx, stop) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    result += num <span class=\"keyword\">as</span>! <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> idx == <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        stop.pointee = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"comment\">// 输出：6</span></span><br></pre></td></tr></table></figure>\n<p>虽然使用 <strong>enumerateObjectsUsingBlock:</strong> 很方便，但是其实从性能上来说这个方法并不理想（具体见原文章），另外它需要使用 <strong>NSArray</strong> 类型，已经不符合 Swift的编码方式了。</p>\n<p>在 Swift 上有个很好的替代：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (idx, num) <span class=\"keyword\">in</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>].enumerated() &#123;</span><br><span class=\"line\">    result += num</span><br><span class=\"line\">    <span class=\"keyword\">if</span> idx == <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>以上代码片段全部出自 <a href=\"https://onevcat.com/\" target=\"_blank\" rel=\"noopener\">王巍 (@onevcat)</a> 的著作<a href=\"https://onev.cat/publication/swifter/\" target=\"_blank\" rel=\"noopener\">《Swifter - Swift 必备 Tips》</a>，仅供参考查阅使用，更加详细的内容请参考原著，请支持正版。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇文章是对 <a href=\"https://onevcat.com/\" target=\"_blank\" rel=\"noopener\">王巍 (@onevcat)</a> 的著作<a href=\"https://onev.cat/publication/swifter/\" target=\"_blank\" rel=\"noopener\">《Swifter - Swift 必备 Tips》</a>的个人阅读总结和代码片段记录。</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>Swift 至今为止并没有在语言层面上支持正则表达式。我们可以使用 Cocoa 中的 <strong>NSRegularExpression</strong> 来做正则匹配。</p>\n<p>一个最简单的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RegexHelper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> regex: <span class=\"type\">NSRegularExpression</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"number\">_</span> pattern: <span class=\"type\">String</span>) <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> regex = <span class=\"type\">NSRegularExpression</span>(pattern: pattern, options: .caseInsensitive)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">match</span><span class=\"params\">(<span class=\"number\">_</span> input: String)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> matches = regex.matches(<span class=\"keyword\">in</span>: input, options: [], range: <span class=\"type\">NSMakeRange</span>(<span class=\"number\">0</span>, input.utf16.<span class=\"built_in\">count</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> matches.<span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mailPattern = <span class=\"string\">\"^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]&#123;2,6&#125;)$\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> matcher: <span class=\"type\">RegexHelper</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    matcher = <span class=\"keyword\">try</span> <span class=\"type\">RegexHelper</span>(mailPattern)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> maybeMailAddress = <span class=\"string\">\"onev@onevcat.com\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> matcher.match(maybeMailAddress) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"有效的邮箱地址\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>一个很棒的正则表达式文章<a href=\"https://deerchao.net/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"noopener\">《正则表达式 30 分钟入门教程》</a>，还有<a href=\"https://code.tutsplus.com/tutorials/8-regular-expressions-you-should-know--net-6149\" target=\"_blank\" rel=\"noopener\">《8个常用正则表达式》</a></p>\n</blockquote>\n<p>现在有了方便的封装，使用 <strong>=~</strong> 来实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precedencegroup <span class=\"type\">MatchPrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">associativity</span>: <span class=\"keyword\">none</span></span><br><span class=\"line\">    higherThan: <span class=\"type\">DefaultPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> =~: <span class=\"type\">MatchPrecedence</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> =~<span class=\"params\">(lhs: String, rhs: String)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> <span class=\"type\">RegexHelper</span>(rhs).match(lhs)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> <span class=\"number\">_</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"string\">\"onev@onevcat.com\"</span> =~</span><br><span class=\"line\"><span class=\"string\">\"^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]&#123;2,6&#125;)$\"</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"有效的邮箱地址\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"单例\"><a href=\"#单例\" class=\"headerlink\" title=\"单例\"></a>单例</h2><p>在 Objective-C 中单例的公认写法类似这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyManager</span></span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)sharedManager &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> MyManager * staticInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        staticInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> staticInstance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>Swift 1.2 之后支持了 class 的 static let 和 static var 这样的存储变量后，有个推荐的写法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyManager</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> shared = <span class=\"type\">MyManager</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">init</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>私有初始化方法，是让项目其他地方不能够通过 <strong>init</strong> 来生成自己的 <strong>MyManager</strong> 实例，保证了类型单例的唯一性。如果你需要的是类似 <strong>default</strong> 的形式的单例（也就是说这个类的使用者可以创建自己的实例）的话，可以去掉这个私有的 <strong>init</strong> 方法。</p>\n<h2 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h2><p>Swift 中没有宏定义的概念，因此我们不能使用 <strong>#ifdef</strong> 的方法来检查某个符号是否经过宏定义。为了控制编译流程和内容，Swift 还是提供了几种简答的机制来根据需求定制编译内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if &lt;condition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#elseif &lt;condition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#else</span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p>使用例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@IBAction func someButtonPressed(sender: AnyObject!) &#123;</span><br><span class=\"line\">    #if FREE_VERSION</span><br><span class=\"line\">        // 弹出购买提示，导航至商店等</span><br><span class=\"line\">    #else</span><br><span class=\"line\">        // 实际功能</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>FREE_VERSION</strong> 这个编译符号代表免费版本，我们需要在项目的编一个选项中进行设置，在项目的 Build Settings 中，找到 Swift Compiler - Custom Flags，并在其中的 Other Swift Flags 加上 <strong>-D FREE_VERSION</strong> 就可以了。</p>\n<h2 id=\"编译标记\"><a href=\"#编译标记\" class=\"headerlink\" title=\"编译标记\"></a>编译标记</h2><p>在 Objective-C 中，我们经常插入 <strong>#param</strong> 来标记代码的间距。Swift 中也有类似的标记：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MARK:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">FIXME:</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"内存管理，weak-和-unowned\"><a href=\"#内存管理，weak-和-unowned\" class=\"headerlink\" title=\"内存管理，weak 和 unowned\"></a>内存管理，weak 和 unowned</h2><p><strong>unowned</strong> 更像以前的 <strong>unsafe_unretained</strong>，而 <strong>weak</strong> 就是以前的 <strong>weak</strong>。用通俗的话说，就是 unowned 设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 “无效的” 引用，它不能是 Optional 值，也不会被指向 nil。如果你尝试调用这个引用的方法或者访问成员属性的话，程序就会崩溃。而 weak 则友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil (因此被标记为@weak 的变量一定需要是 Optional 值)。</p>\n<p>关于两者使用的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。</p>\n<h2 id=\"值类型和引用类型\"><a href=\"#值类型和引用类型\" class=\"headerlink\" title=\"值类型和引用类型\"></a>值类型和引用类型</h2><p>Swift 中的 struct 和 enum 定义的类型是值类型，使用 class 定义的为引用类型。很有意思的是，Swift 中的所有的内建类型都是值类型，不仅包括了传统意义像 Int，Bool 这些，甚至连 String，Array 以及 Dictionary 都是值类型的。</p>\n<p>在使用数组和字典时的最佳实践应该是，按照具体的数据规模和操作特点来决定到时是使用值类型的容器还是引用类型的容器：在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好，而对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary。</p>\n<h2 id=\"String-还是-NSString\"><a href=\"#String-还是-NSString\" class=\"headerlink\" title=\"String 还是 NSString\"></a>String 还是 NSString</h2><p>没有什么特别需要注意的话，尽量使用原生的 <strong>String</strong> 类型。</p>\n<p>具体原因查阅原文。</p>\n<p>String 唯一一个比较麻烦的地方在于它和 <strong>Range</strong> 的配合。在 NSString 中，我们在匹配字符串的时候通常使用 NSRange 来表征结果或者作为输入。而在使用 String 的对应的 API 时，NSRange 也会被映射成它在 Swift 中且对应 String 的特殊版本：<strong>Range&lt;String.Index&gt;</strong>。这有时候会让人非常讨厌： </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> levels = <span class=\"string\">\"ABCDE\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nsRange = <span class=\"type\">NSMakeRange</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// 编译错误</span></span><br><span class=\"line\"><span class=\"comment\">// Cannot convert value of type `NSRanve` to expected argument type 'Range&lt;Index&gt;'</span></span><br><span class=\"line\">levels.replacingCharacters(<span class=\"keyword\">in</span>: nsRange, with: <span class=\"string\">\"AAAA\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> indexPositionOne = levels.index(levels.startIndex, offsetBy: <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> swiftRange = indexPositionOne ..&lt; levels.index(levels.startIndex, offsetBy: <span class=\"number\">5</span>)</span><br><span class=\"line\">levels.replacingCharacters(<span class=\"keyword\">in</span>: swiftRange, with: <span class=\"string\">\"AAAA\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// AAAAA</span></span><br></pre></td></tr></table></figure>\n<p>这样太麻烦了，这种情况下，将 <strong>string</strong> 转为 <strong>NSString</strong> 也许是个不错的选择：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nsRange = <span class=\"type\">NSMakeRange</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">(levels <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).replacingCharacters(<span class=\"keyword\">in</span>: nsRange, with: <span class=\"string\">\"AAAA\"</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"GCD-和延时调用\"><a href=\"#GCD-和延时调用\" class=\"headerlink\" title=\"GCD 和延时调用\"></a>GCD 和延时调用</h2><p>GCD 里面有一个很好用的延时调用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> time: <span class=\"type\">TimeInterval</span> = <span class=\"number\">2.0</span></span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: <span class=\"type\">DispatchTime</span>.now() + time) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"2秒后输出\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆代码非常简单，但是还可以稍微封装下，最好加上取消功能：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">Task</span> = (<span class=\"number\">_</span> cancel : <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">Void</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">delay</span><span class=\"params\">(<span class=\"number\">_</span> time: TimeInterval, task: @escaping <span class=\"params\">()</span></span></span>-&gt;()) -&gt;  <span class=\"type\">Task?</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_later</span><span class=\"params\">(block: @escaping <span class=\"params\">()</span></span></span>-&gt;()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> t = <span class=\"type\">DispatchTime</span>.now() + time</span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: t, execute: block)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> closure: (()-&gt;<span class=\"type\">Void</span>)? = task</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result: <span class=\"type\">Task?</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> delayedClosure: <span class=\"type\">Task</span> = &#123;</span><br><span class=\"line\">        cancel <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> internalClosure = closure &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cancel == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">DispatchQueue</span>.main.async(execute: internalClosure)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        closure = <span class=\"literal\">nil</span></span><br><span class=\"line\">        result = <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    result = delayedClosure</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_later &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> delayedClosure = result &#123;</span><br><span class=\"line\">            delayedClosure(<span class=\"literal\">false</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"number\">_</span> task: Task?)</span></span> &#123;</span><br><span class=\"line\">    task?(<span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delay(<span class=\"number\">2</span>) &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"2 秒后输出\"</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> task = delay(<span class=\"number\">5</span>) &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"拨打 110\"</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 仔细想一想..</span></span><br><span class=\"line\"><span class=\"comment\">// 还是取消为妙..</span></span><br><span class=\"line\">cancel(task)</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用C动态库\"><a href=\"#调用C动态库\" class=\"headerlink\" title=\"调用C动态库\"></a>调用C动态库</h2><p>生成 <strong>MD5</strong> 密钥：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TargetName-Bridging-Header.h</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;CommonCrypto/CommonCrypto.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// StringMD5.swift</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"type\">MD5</span>: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> digest = [<span class=\"type\">UInt8</span>](repeating: <span class=\"number\">0</span>, <span class=\"built_in\">count</span>: <span class=\"type\">Int</span>(<span class=\"type\">CC_MD5_DIGEST_LENGTH</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = data(using: .utf8) &#123;</span><br><span class=\"line\">            data.withUnsafeBytes &#123; (bytes: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">UInt8</span>&gt;) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">                <span class=\"type\">CC_MD5</span>(bytes, <span class=\"type\">CC_LONG</span>(data.<span class=\"built_in\">count</span>), &amp;digest)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> digestHex = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"type\">Int</span>(<span class=\"type\">CC_MD5_DIGEST_LENGTH</span>) &#123;</span><br><span class=\"line\">            digestHex += <span class=\"type\">String</span>(format: <span class=\"string\">\"%02x\"</span>, digest[index])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> digestHex</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"swifter.tips\"</span>.<span class=\"type\">MD5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"comment\">// dff88de99ff03d109de22fed4f71a273</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"输出格式化\"><a href=\"#输出格式化\" class=\"headerlink\" title=\"输出格式化\"></a>输出格式化</h2><p>在 <strong>Objective-C</strong> 中经常使用 <strong>NSLog</strong> 配合上 <strong>%@</strong> 来输出打印内容到控制台：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> b = <span class=\"number\">1.234567</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *c = <span class=\"string\">@\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"int:%d float:%f string:%@\"</span>,a,b,c);</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// int:3 float:1.234567 string:Hello</span></span><br></pre></td></tr></table></figure>\n<p>在 Swift 里，我们一般使用 <strong>Print</strong> 来打印：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">1.234567</span>  <span class=\"comment\">// 我们在这里不去区分 float 和 Double 了</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">c</span> = <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"int:\\(a) double:\\(b) string:\\(c)\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// int:3 double:1.234567 string:Hello</span></span><br></pre></td></tr></table></figure>\n<p>这时候我们常常遇到有些问题，比如打印👆 <strong>b</strong> 中的小数点后两位，在 Objective-C 中使用 <strong>NSLog</strong> 时可以写成：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"float:%.2f\"</span>,b);</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// float:1.23</span></span><br></pre></td></tr></table></figure>\n<p>Swift 的 <strong>Print</strong> 就没这么幸运了。<strong>String</strong> 的格式化初始化方法可以帮助我们利用格式化的字符串：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> format = <span class=\"type\">String</span>(format:<span class=\"string\">\"%.2f\"</span>, <span class=\"number\">1.234567</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"double:\\(format)\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// double:1.23</span></span><br></pre></td></tr></table></figure>\n<p>每次这么写也很麻烦。如果大量使用的话，还是写个 Double 的扩展：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Double</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">format</span><span class=\"params\">(<span class=\"number\">_</span> f: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">String</span>(format: <span class=\"string\">\"%\\(f)f\"</span>, <span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> f = <span class=\"string\">\".2\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"double:\\(1.234567.format(f))\"</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组-enumerate\"><a href=\"#数组-enumerate\" class=\"headerlink\" title=\"数组 enumerate\"></a>数组 enumerate</h2><p>使用 <strong>NSArray</strong> 时经常遇到的是同时获取值和下标索引，在 Objective-C 中最方便的方式是使用 <strong>enumerateObjectsUsingBlock:</strong> 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *arr = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>, @<span class=\"number\">4</span>, @<span class=\"number\">5</span>];</span><br><span class=\"line\">__block <span class=\"built_in\">NSInteger</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">[arr enumerateObjectsUsingBlock:^(<span class=\"built_in\">NSNumber</span> *num, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    result += [num integerValue];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        *stop = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld\"</span>, result);</span><br><span class=\"line\"><span class=\"comment\">// 输出：6</span></span><br></pre></td></tr></table></figure>\n<p>停止遍历需要用到 <strong>*stop</strong> 来标记停止，在 Swift 中，这个 API 的 <strong>*stop</strong> 被转换为对应的 <strong>UnsafeMutablePointer<objcbool></objcbool></strong>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr: <span class=\"type\">NSArray</span> = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = <span class=\"number\">0</span></span><br><span class=\"line\">arr.enumerateObjects (&#123; (num, idx, stop) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    result += num <span class=\"keyword\">as</span>! <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> idx == <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        stop.pointee = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"comment\">// 输出：6</span></span><br></pre></td></tr></table></figure>\n<p>虽然使用 <strong>enumerateObjectsUsingBlock:</strong> 很方便，但是其实从性能上来说这个方法并不理想（具体见原文章），另外它需要使用 <strong>NSArray</strong> 类型，已经不符合 Swift的编码方式了。</p>\n<p>在 Swift 上有个很好的替代：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (idx, num) <span class=\"keyword\">in</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>].enumerated() &#123;</span><br><span class=\"line\">    result += num</span><br><span class=\"line\">    <span class=\"keyword\">if</span> idx == <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>以上代码片段全部出自 <a href=\"https://onevcat.com/\" target=\"_blank\" rel=\"noopener\">王巍 (@onevcat)</a> 的著作<a href=\"https://onev.cat/publication/swifter/\" target=\"_blank\" rel=\"noopener\">《Swifter - Swift 必备 Tips》</a>，仅供参考查阅使用，更加详细的内容请参考原著，请支持正版。</p>\n"},{"title":"《Swifter - Swift 必备 Tips》总结（二）","date":"2017-11-12T06:50:51.000Z","_content":"\n## 前言\n\n本篇文章是对 [王巍 (@onevcat)](https://onevcat.com/) 的著作[《Swifter - Swift 必备 Tips》](https://onev.cat/publication/swifter/)的个人阅读总结和代码片段记录。\n\n\n## delegate\n\nCocoa 开发中协议-委托是种常用的设计模式，可以说完全离不开它。\n\n👇这段代码在 Swift 中怎么也不让编译通过：\n\n```swift\nprotocol MyClassDelegate {\n    func method()\n}\n\nclass MyClass {\n    weak var delegate: MyClassDelegate?\n}\n\nclass ViewController: UIViewController, MyClassDelegate {\n    // ...\n    var someInstance: MyClass!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        someInstance = MyClass()\n        someInstance.delegate = self\n    }\n\n    func method() {\n        print(\"Do something\")\n    }\n}\n\n// weak var delegate: MyClassDelegate? 编译错误\n// 'weak' cannot be applied to non-class type 'MyClassDelegate \n```\n\n这是因为 Swift 的 **protocol** 是可以被除了 **class** 以外的其他类型遵守的，而对于像 **struct** 或者 **enum** 这样的类型，本身就不能通过引用计数来管理内存，所以也不可能用 **weak** 这样的 ARC 的概念来进行修饰。\n\n想要在 Swift 中使用 weak delegate，我们就需要将 protocol 限制在 class 内。\n\n一种做法是将 protocol 声明为 Objective-C 的，通过在 protocol 前面加上 **@objc** 关键字来达到，Objective-C 的 protocol 都只有类能够实现，因此使用 weak 来修饰就合理了：\n\n```swift\n@objc protocol MyClassDelegate {\n    func method()\n}\n```\n\n另一种可能更好的办法是在 protocol 声明的名字后面加上 **class**，这可以为编译器显示地指明这个protocol 只能由 **class** 来实现。\n\n```swift\nprotocol MyClassDelegate: class {\n    func method()\n}\n```\n与添加 **@objc** 相比，后一种方法更能表现出问题的实质，同时也避免了过多的不必要的 Objective-C 兼容，可以说是一种更好的解决方式。\n\n## Associated Object\n\n得益于 Objective-C 的运行时和 Key-Value Coding 的特性，我们可以在运行时向一个对象添加值存储。**而在使用 Category 扩展现有的类的功能的时候，直接添加实例变量这种行为是不被允许的，这时候一般就使用 property 配合 Associated Object 的方式，将一个对象 “关联” 到已有的要扩展的对象上。**进行关联后，在对这个目标对象访问的时候，从外界看来，就似乎是直接在通过属性访问对象的实例变量一样，可以非常方便。\n\n在 Swift 上这样的方法依旧有效，只不过写法上有些不一样：\n\n```swift\n// MyClass.swift\nclass MyClass {\n}\n\n// MyClassExtension.swift\nprivate var key: Void?\n\nextension MyClass {\n    var title: String? {\n        get {\n            return objc_getAssociatedObject(self, &key) as? String\n        }\n\n        set {\n            objc_setAssociatedObject(self,\n                &key, newValue,\n                .OBJC_ASSOCIATION_RETAIN_NONATOMIC)\n        }\n    }\n}\n\n// 测试\nfunc printTitle(_ input: MyClass) {\n\t  if let title = input.title {\n        print(\"Title: \\(title)\")\n    } else {\n        print(\"没有设置\")\n    }\n}\n\nlet a = MyClass()\nprintTitle(a)\na.title = \"Swifter.tips\"\nprintTitle(a)\n\n// 输出：\n// 没有设置\n// Title: Swifter.tips”\n```\n\n## Lock\n\n只要涉及多线程并发，肯定会遇到锁。\n\n在 Cocoa 和 Objective-C 中加锁的方式有很多，但是其中在日常开发最常用的应该是 **@synchronized**，这个关键字可以用来修饰一个变量，并为其自动加上和解除互斥锁。举个例子：\n\n```objc\n- (void)myMethod:(id)anObj {\n    @synchronized(anObj) {\n        // 在括号内持有 anObj 锁\n    }\n}\n```\n👆这个方法虽然简单好用，但是它在 Swift 中已经（或者暂时）不存在了。其实 **@synchronized** 在幕后做的事情是调用了 **objc_sync** 中的 **objc_sync_enter** 和 **objc_sync_exit** 方法，并且加入了一些异常判断。因此，在 Swift 中，如果我们忽略掉那些异常，可以这么写：\n\n```swift\nfunc myMethod(anObj: AnyObject!) {\n    objc_sync_enter(anObj)\n\n    // 在 enter 和 exit 之间持有 anObj 锁\n\n    objc_sync_exit(anObj)\n} \n```\n\n更进一步，如果我们喜欢以前的那种形式，甚至可以写一个全局的方法，接受一个闭包，来将 **objc_sync_enter** 和 **objc_sync_exit** 封装起来：\n\n```swift\nfunc synchronized(_ lock: AnyObject, closure: () -> ()) {\n    objc_sync_enter(lock)\n    closure()\n    objc_sync_exit(lock)\n}\n```\n\n结合尾随闭包，使用起来就和 Objective-C 中很像了：\n\n```swift\nfunc myMethod(anObj: AnyObject!) {\n    synchronized(anObj){\n    \t\t// 在括号内持有 anObj 锁\n    }\n} \n```\n\n\n```swift\n// 一个实际的线程安全的 setter 例子\nclass Obj {\n    var _str = \"123\"\n    var str: String {\n        get {\n            return _str\n        }\n        set {\n            synchronized(self) {\n                _str = newValue\n            }\n        }\n    // 下略\n    }\n}\n```\n\n## 随机数生成\n\n在 Objective-C 中生成随机数一般使用 **arc4random**，在 Swift 中也可以使用。它会返回一个任意整数，我们想要在某个范围里的数的话，可以做模运算（%）取余数。\n\n\n```swift\n/// 这是错误代码\nlet diceFaceCount = 6\nlet randomRoll = Int(arc4random()) % diceFaceCount + 1\nprint(randomRoll)\n```\n因为 **arc4random** 返回的值不论在什么平台上都是一个 `UInt32`，于是在 32 位的平台上就有一半几率在进行 Int 转换时越界，时不时的崩溃也就不足为奇了。（iPhone 5 和前任都是32位的 CPU，之后的是64位，Swift 的 Int 和 CPU 架构有关，Int32 或者 Int64）。\n\n相对安全改良版本：\n\n```swift\nfunc arc4random_uniform(_: UInt32) -> UInt32\n```\n\n使用：\n\n```swift\nlet diceFaceCount: UInt32 = 6\nlet randomRoll = Int(arc4random_uniform(diceFaceCount)) + 1\nprint(randomRoll)\n```\n\n最佳实践是创建个 **Range** 的随机数的方法：\n\n```swift\nfunc random(in range: Range<Int>) -> Int {\n    let count = UInt32(range.upperBound - range.lowerBound)\n    return Int(arc4random_uniform(count)) + range.lowerBound\n}\n\nfor _ in 0...100 {\n    let range = Range<Int>(1...6)\n    print(random(in: range))\n}\n```\n\n## 断言\n\n断言的另一个优点是它是一个开发时的特性，只有在 Debug 编译的时候有效，而在运行时是不被编译执行的，因此断言并不会消耗运行时的性能。这就不用每次代码发布时，一一找出去除。\n\n在 Release 版本强制启用断言或者在 Debug 版本强制禁用断言配置，请参考原文，不推荐这样修改。\n\n如果我们需要在 Release 发布时在无法继续时将程序强行终止的话，应该选择使用 `fatalError`。\n\n## Playground 延时运行\n\n为了让 playground 具有延迟运行的能力，我们需要这么做：\n\n```swift\nimport PlaygroundSupport\n\nPlaygroundPage.current.needsIndefiniteExecution = true\n```\n默认情况下它会在顶层代码最后一句运行后20秒的时候停止执行。这个时间长度满足大部分需求了，如果你想要改变这个时间的话，可以通过 `Alt + Cmd + 回车` 来打开辅助编译器，在那里修改。\n\n## Log 输出\n\n在 Objective-C 中，我们常用 **NSLog** 来打印输出控制台，通常只会在 **Debug** 版本打印，**Release** 版本为了性能会屏蔽掉（因为也没人看）：\n\n```objc\n#ifdef DEBUG\n    #define DPrintf(fmt, ...)  printf(\"📍%s + %d🎈 %s\\n\", __PRETTY_FUNCTION__, __LINE__, [[NSString stringWithFormat:fmt, ##__VA_ARGS__]UTF8String])\n#else\n    #define DPrintf(fmt, ...)\n#endif\n```\n\n在 Swift 中，编译器也为我们准备了几个很有用的编译符号：\n\n* \\#file (String) 包含这个符号的文件的路径\n* \\#line (Int) 符号出现处的行号\n* \\#column (Int) 符号出现处的列\n* \\#function (String) 包含这个符号的方法名\n\n使用：\n\n```swift\nfunc printLog<T>(_ message: T,\n                    file: String = #file,\n                  method: String = #function,\n                    line: Int = #line)\n{\n    print(\"\\((file as NSString).lastPathComponent)[\\(line)], \\(method): \\(message)\")\n}\n```\n\n当需要在 Release 版本关闭输出时：\n\n```swift\nfunc printLog<T>(_ message: T,\n                    file: String = #file,\n                  method: String = #function,\n                    line: Int = #line)\n{\n    #if DEBUG\n    print(\"\\((file as NSString).lastPathComponent)[\\(line)], \\(method): \\(message)\")\n    #endif\n}\n```\n\n新版本的 LLVM 编译器在遇到这个空方法时，甚至会直接整个方法去掉，完全不去调用它，从而实现零成本。\n\n## 属性访问控制\n\nSwift 由低到高提供了 **private**，**fileprivate**，**internal**，**public** 和 **open** 五种访问控制的权限。默认是 **internal** 权限。\n\nprivate 让代码只能在当前作用域或者同一文件中同一类型的作用域中被使用，fileprivate 表示代码可以在当前文件中被访问，而不做类型限定。\n\npublic 和 open 的区别在于，只有被 open 标记的内容才能在别的框架中被继承或者重写。\n\n在开发中的时候，我们给某属性加上了 private 修饰符了，但是希望在类型之外也能够读取到这个类型，同时为了保证类型的封装和安全，只能在类型内部对其进行改变和设置：\n\n```swift\nclass MyClass {\n    private(set) var name: String?\n}\n```\n\n这样 set 被限制为 private，保证外部只能访问不能修改。\n\n这种写法没有对读取做限制，相当于使用了默认的 internal 权限。如果我们希望在别的 module 中也能访问这个属性，同时又保持只在当前作用域可以设置的话，我们需要将 get 的访问权限提高为 public。属性的访问控制可以通过两次的访问权限指定来实现，具体来说，将刚才的声明变为：\n\n```swift\npublic class MyClass {\n    public private(set) var name: String?\n}\n```\n> MyClass 也要加 public 是因为其他 module 连 MyClass 都不能访问的话，怎么访问 name\n\n## 小结\n\n以上代码片段全部出自 [王巍 (@onevcat)](https://onevcat.com/) 的著作[《Swifter - Swift 必备 Tips》](https://onev.cat/publication/swifter/)，仅供参考查阅使用，更加详细的内容请参考原著，请支持正版。\n\n\n","source":"_posts/2017-11-26-swifter-tips-summary-2.md","raw":"---\ntitle: 《Swifter - Swift 必备 Tips》总结（二）\ndate: 2017-11-12 14:50:51\ntags: Swift\ncategory: Tips\n---\n\n## 前言\n\n本篇文章是对 [王巍 (@onevcat)](https://onevcat.com/) 的著作[《Swifter - Swift 必备 Tips》](https://onev.cat/publication/swifter/)的个人阅读总结和代码片段记录。\n\n\n## delegate\n\nCocoa 开发中协议-委托是种常用的设计模式，可以说完全离不开它。\n\n👇这段代码在 Swift 中怎么也不让编译通过：\n\n```swift\nprotocol MyClassDelegate {\n    func method()\n}\n\nclass MyClass {\n    weak var delegate: MyClassDelegate?\n}\n\nclass ViewController: UIViewController, MyClassDelegate {\n    // ...\n    var someInstance: MyClass!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        someInstance = MyClass()\n        someInstance.delegate = self\n    }\n\n    func method() {\n        print(\"Do something\")\n    }\n}\n\n// weak var delegate: MyClassDelegate? 编译错误\n// 'weak' cannot be applied to non-class type 'MyClassDelegate \n```\n\n这是因为 Swift 的 **protocol** 是可以被除了 **class** 以外的其他类型遵守的，而对于像 **struct** 或者 **enum** 这样的类型，本身就不能通过引用计数来管理内存，所以也不可能用 **weak** 这样的 ARC 的概念来进行修饰。\n\n想要在 Swift 中使用 weak delegate，我们就需要将 protocol 限制在 class 内。\n\n一种做法是将 protocol 声明为 Objective-C 的，通过在 protocol 前面加上 **@objc** 关键字来达到，Objective-C 的 protocol 都只有类能够实现，因此使用 weak 来修饰就合理了：\n\n```swift\n@objc protocol MyClassDelegate {\n    func method()\n}\n```\n\n另一种可能更好的办法是在 protocol 声明的名字后面加上 **class**，这可以为编译器显示地指明这个protocol 只能由 **class** 来实现。\n\n```swift\nprotocol MyClassDelegate: class {\n    func method()\n}\n```\n与添加 **@objc** 相比，后一种方法更能表现出问题的实质，同时也避免了过多的不必要的 Objective-C 兼容，可以说是一种更好的解决方式。\n\n## Associated Object\n\n得益于 Objective-C 的运行时和 Key-Value Coding 的特性，我们可以在运行时向一个对象添加值存储。**而在使用 Category 扩展现有的类的功能的时候，直接添加实例变量这种行为是不被允许的，这时候一般就使用 property 配合 Associated Object 的方式，将一个对象 “关联” 到已有的要扩展的对象上。**进行关联后，在对这个目标对象访问的时候，从外界看来，就似乎是直接在通过属性访问对象的实例变量一样，可以非常方便。\n\n在 Swift 上这样的方法依旧有效，只不过写法上有些不一样：\n\n```swift\n// MyClass.swift\nclass MyClass {\n}\n\n// MyClassExtension.swift\nprivate var key: Void?\n\nextension MyClass {\n    var title: String? {\n        get {\n            return objc_getAssociatedObject(self, &key) as? String\n        }\n\n        set {\n            objc_setAssociatedObject(self,\n                &key, newValue,\n                .OBJC_ASSOCIATION_RETAIN_NONATOMIC)\n        }\n    }\n}\n\n// 测试\nfunc printTitle(_ input: MyClass) {\n\t  if let title = input.title {\n        print(\"Title: \\(title)\")\n    } else {\n        print(\"没有设置\")\n    }\n}\n\nlet a = MyClass()\nprintTitle(a)\na.title = \"Swifter.tips\"\nprintTitle(a)\n\n// 输出：\n// 没有设置\n// Title: Swifter.tips”\n```\n\n## Lock\n\n只要涉及多线程并发，肯定会遇到锁。\n\n在 Cocoa 和 Objective-C 中加锁的方式有很多，但是其中在日常开发最常用的应该是 **@synchronized**，这个关键字可以用来修饰一个变量，并为其自动加上和解除互斥锁。举个例子：\n\n```objc\n- (void)myMethod:(id)anObj {\n    @synchronized(anObj) {\n        // 在括号内持有 anObj 锁\n    }\n}\n```\n👆这个方法虽然简单好用，但是它在 Swift 中已经（或者暂时）不存在了。其实 **@synchronized** 在幕后做的事情是调用了 **objc_sync** 中的 **objc_sync_enter** 和 **objc_sync_exit** 方法，并且加入了一些异常判断。因此，在 Swift 中，如果我们忽略掉那些异常，可以这么写：\n\n```swift\nfunc myMethod(anObj: AnyObject!) {\n    objc_sync_enter(anObj)\n\n    // 在 enter 和 exit 之间持有 anObj 锁\n\n    objc_sync_exit(anObj)\n} \n```\n\n更进一步，如果我们喜欢以前的那种形式，甚至可以写一个全局的方法，接受一个闭包，来将 **objc_sync_enter** 和 **objc_sync_exit** 封装起来：\n\n```swift\nfunc synchronized(_ lock: AnyObject, closure: () -> ()) {\n    objc_sync_enter(lock)\n    closure()\n    objc_sync_exit(lock)\n}\n```\n\n结合尾随闭包，使用起来就和 Objective-C 中很像了：\n\n```swift\nfunc myMethod(anObj: AnyObject!) {\n    synchronized(anObj){\n    \t\t// 在括号内持有 anObj 锁\n    }\n} \n```\n\n\n```swift\n// 一个实际的线程安全的 setter 例子\nclass Obj {\n    var _str = \"123\"\n    var str: String {\n        get {\n            return _str\n        }\n        set {\n            synchronized(self) {\n                _str = newValue\n            }\n        }\n    // 下略\n    }\n}\n```\n\n## 随机数生成\n\n在 Objective-C 中生成随机数一般使用 **arc4random**，在 Swift 中也可以使用。它会返回一个任意整数，我们想要在某个范围里的数的话，可以做模运算（%）取余数。\n\n\n```swift\n/// 这是错误代码\nlet diceFaceCount = 6\nlet randomRoll = Int(arc4random()) % diceFaceCount + 1\nprint(randomRoll)\n```\n因为 **arc4random** 返回的值不论在什么平台上都是一个 `UInt32`，于是在 32 位的平台上就有一半几率在进行 Int 转换时越界，时不时的崩溃也就不足为奇了。（iPhone 5 和前任都是32位的 CPU，之后的是64位，Swift 的 Int 和 CPU 架构有关，Int32 或者 Int64）。\n\n相对安全改良版本：\n\n```swift\nfunc arc4random_uniform(_: UInt32) -> UInt32\n```\n\n使用：\n\n```swift\nlet diceFaceCount: UInt32 = 6\nlet randomRoll = Int(arc4random_uniform(diceFaceCount)) + 1\nprint(randomRoll)\n```\n\n最佳实践是创建个 **Range** 的随机数的方法：\n\n```swift\nfunc random(in range: Range<Int>) -> Int {\n    let count = UInt32(range.upperBound - range.lowerBound)\n    return Int(arc4random_uniform(count)) + range.lowerBound\n}\n\nfor _ in 0...100 {\n    let range = Range<Int>(1...6)\n    print(random(in: range))\n}\n```\n\n## 断言\n\n断言的另一个优点是它是一个开发时的特性，只有在 Debug 编译的时候有效，而在运行时是不被编译执行的，因此断言并不会消耗运行时的性能。这就不用每次代码发布时，一一找出去除。\n\n在 Release 版本强制启用断言或者在 Debug 版本强制禁用断言配置，请参考原文，不推荐这样修改。\n\n如果我们需要在 Release 发布时在无法继续时将程序强行终止的话，应该选择使用 `fatalError`。\n\n## Playground 延时运行\n\n为了让 playground 具有延迟运行的能力，我们需要这么做：\n\n```swift\nimport PlaygroundSupport\n\nPlaygroundPage.current.needsIndefiniteExecution = true\n```\n默认情况下它会在顶层代码最后一句运行后20秒的时候停止执行。这个时间长度满足大部分需求了，如果你想要改变这个时间的话，可以通过 `Alt + Cmd + 回车` 来打开辅助编译器，在那里修改。\n\n## Log 输出\n\n在 Objective-C 中，我们常用 **NSLog** 来打印输出控制台，通常只会在 **Debug** 版本打印，**Release** 版本为了性能会屏蔽掉（因为也没人看）：\n\n```objc\n#ifdef DEBUG\n    #define DPrintf(fmt, ...)  printf(\"📍%s + %d🎈 %s\\n\", __PRETTY_FUNCTION__, __LINE__, [[NSString stringWithFormat:fmt, ##__VA_ARGS__]UTF8String])\n#else\n    #define DPrintf(fmt, ...)\n#endif\n```\n\n在 Swift 中，编译器也为我们准备了几个很有用的编译符号：\n\n* \\#file (String) 包含这个符号的文件的路径\n* \\#line (Int) 符号出现处的行号\n* \\#column (Int) 符号出现处的列\n* \\#function (String) 包含这个符号的方法名\n\n使用：\n\n```swift\nfunc printLog<T>(_ message: T,\n                    file: String = #file,\n                  method: String = #function,\n                    line: Int = #line)\n{\n    print(\"\\((file as NSString).lastPathComponent)[\\(line)], \\(method): \\(message)\")\n}\n```\n\n当需要在 Release 版本关闭输出时：\n\n```swift\nfunc printLog<T>(_ message: T,\n                    file: String = #file,\n                  method: String = #function,\n                    line: Int = #line)\n{\n    #if DEBUG\n    print(\"\\((file as NSString).lastPathComponent)[\\(line)], \\(method): \\(message)\")\n    #endif\n}\n```\n\n新版本的 LLVM 编译器在遇到这个空方法时，甚至会直接整个方法去掉，完全不去调用它，从而实现零成本。\n\n## 属性访问控制\n\nSwift 由低到高提供了 **private**，**fileprivate**，**internal**，**public** 和 **open** 五种访问控制的权限。默认是 **internal** 权限。\n\nprivate 让代码只能在当前作用域或者同一文件中同一类型的作用域中被使用，fileprivate 表示代码可以在当前文件中被访问，而不做类型限定。\n\npublic 和 open 的区别在于，只有被 open 标记的内容才能在别的框架中被继承或者重写。\n\n在开发中的时候，我们给某属性加上了 private 修饰符了，但是希望在类型之外也能够读取到这个类型，同时为了保证类型的封装和安全，只能在类型内部对其进行改变和设置：\n\n```swift\nclass MyClass {\n    private(set) var name: String?\n}\n```\n\n这样 set 被限制为 private，保证外部只能访问不能修改。\n\n这种写法没有对读取做限制，相当于使用了默认的 internal 权限。如果我们希望在别的 module 中也能访问这个属性，同时又保持只在当前作用域可以设置的话，我们需要将 get 的访问权限提高为 public。属性的访问控制可以通过两次的访问权限指定来实现，具体来说，将刚才的声明变为：\n\n```swift\npublic class MyClass {\n    public private(set) var name: String?\n}\n```\n> MyClass 也要加 public 是因为其他 module 连 MyClass 都不能访问的话，怎么访问 name\n\n## 小结\n\n以上代码片段全部出自 [王巍 (@onevcat)](https://onevcat.com/) 的著作[《Swifter - Swift 必备 Tips》](https://onev.cat/publication/swifter/)，仅供参考查阅使用，更加详细的内容请参考原著，请支持正版。\n\n\n","slug":"2017-11-26-swifter-tips-summary-2","published":1,"updated":"2018-09-02T03:32:33.287Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7nm003s8jpbhl2jqb8k","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇文章是对 <a href=\"https://onevcat.com/\" target=\"_blank\" rel=\"noopener\">王巍 (@onevcat)</a> 的著作<a href=\"https://onev.cat/publication/swifter/\" target=\"_blank\" rel=\"noopener\">《Swifter - Swift 必备 Tips》</a>的个人阅读总结和代码片段记录。</p>\n<h2 id=\"delegate\"><a href=\"#delegate\" class=\"headerlink\" title=\"delegate\"></a>delegate</h2><p>Cocoa 开发中协议-委托是种常用的设计模式，可以说完全离不开它。</p>\n<p>👇这段代码在 Swift 中怎么也不让编译通过：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">MyClassDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">method</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> delegate: <span class=\"type\">MyClassDelegate?</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">MyClassDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> someInstance: <span class=\"type\">MyClass!</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\"></span><br><span class=\"line\">        someInstance = <span class=\"type\">MyClass</span>()</span><br><span class=\"line\">        someInstance.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">method</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Do something\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// weak var delegate: MyClassDelegate? 编译错误</span></span><br><span class=\"line\"><span class=\"comment\">// 'weak' cannot be applied to non-class type 'MyClassDelegate</span></span><br></pre></td></tr></table></figure>\n<p>这是因为 Swift 的 <strong>protocol</strong> 是可以被除了 <strong>class</strong> 以外的其他类型遵守的，而对于像 <strong>struct</strong> 或者 <strong>enum</strong> 这样的类型，本身就不能通过引用计数来管理内存，所以也不可能用 <strong>weak</strong> 这样的 ARC 的概念来进行修饰。</p>\n<p>想要在 Swift 中使用 weak delegate，我们就需要将 protocol 限制在 class 内。</p>\n<p>一种做法是将 protocol 声明为 Objective-C 的，通过在 protocol 前面加上 <strong>@objc</strong> 关键字来达到，Objective-C 的 protocol 都只有类能够实现，因此使用 weak 来修饰就合理了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">MyClassDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">method</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一种可能更好的办法是在 protocol 声明的名字后面加上 <strong>class</strong>，这可以为编译器显示地指明这个protocol 只能由 <strong>class</strong> 来实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">MyClassDelegate</span>: <span class=\"title\">class</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">method</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与添加 <strong>@objc</strong> 相比，后一种方法更能表现出问题的实质，同时也避免了过多的不必要的 Objective-C 兼容，可以说是一种更好的解决方式。</p>\n<h2 id=\"Associated-Object\"><a href=\"#Associated-Object\" class=\"headerlink\" title=\"Associated Object\"></a>Associated Object</h2><p>得益于 Objective-C 的运行时和 Key-Value Coding 的特性，我们可以在运行时向一个对象添加值存储。<strong>而在使用 Category 扩展现有的类的功能的时候，直接添加实例变量这种行为是不被允许的，这时候一般就使用 property 配合 Associated Object 的方式，将一个对象 “关联” 到已有的要扩展的对象上。</strong>进行关联后，在对这个目标对象访问的时候，从外界看来，就似乎是直接在通过属性访问对象的实例变量一样，可以非常方便。</p>\n<p>在 Swift 上这样的方法依旧有效，只不过写法上有些不一样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MyClass.swift</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MyClassExtension.swift</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> key: <span class=\"type\">Void?</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> title: <span class=\"type\">String?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;key) <span class=\"keyword\">as</span>? <span class=\"type\">String</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>,</span><br><span class=\"line\">                &amp;key, newValue,</span><br><span class=\"line\">                .<span class=\"type\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printTitle</span><span class=\"params\">(<span class=\"number\">_</span> input: MyClass)</span></span> &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> title = input.title &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Title: \\(title)\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"没有设置\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"type\">MyClass</span>()</span><br><span class=\"line\">printTitle(a)</span><br><span class=\"line\">a.title = <span class=\"string\">\"Swifter.tips\"</span></span><br><span class=\"line\">printTitle(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// 没有设置</span></span><br><span class=\"line\"><span class=\"comment\">// Title: Swifter.tips”</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h2><p>只要涉及多线程并发，肯定会遇到锁。</p>\n<p>在 Cocoa 和 Objective-C 中加锁的方式有很多，但是其中在日常开发最常用的应该是 <strong>@synchronized</strong>，这个关键字可以用来修饰一个变量，并为其自动加上和解除互斥锁。举个例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)myMethod:(<span class=\"keyword\">id</span>)anObj &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@synchronized</span>(anObj) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在括号内持有 anObj 锁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆这个方法虽然简单好用，但是它在 Swift 中已经（或者暂时）不存在了。其实 <strong>@synchronized</strong> 在幕后做的事情是调用了 <strong>objc_sync</strong> 中的 <strong>objc_sync_enter</strong> 和 <strong>objc_sync_exit</strong> 方法，并且加入了一些异常判断。因此，在 Swift 中，如果我们忽略掉那些异常，可以这么写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myMethod</span><span class=\"params\">(anObj: AnyObject!)</span></span> &#123;</span><br><span class=\"line\">    objc_sync_enter(anObj)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在 enter 和 exit 之间持有 anObj 锁</span></span><br><span class=\"line\"></span><br><span class=\"line\">    objc_sync_exit(anObj)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更进一步，如果我们喜欢以前的那种形式，甚至可以写一个全局的方法，接受一个闭包，来将 <strong>objc_sync_enter</strong> 和 <strong>objc_sync_exit</strong> 封装起来：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">synchronized</span><span class=\"params\">(<span class=\"number\">_</span> lock: AnyObject, closure: <span class=\"params\">()</span></span></span> -&gt; ()) &#123;</span><br><span class=\"line\">    objc_sync_enter(lock)</span><br><span class=\"line\">    closure()</span><br><span class=\"line\">    objc_sync_exit(lock)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结合尾随闭包，使用起来就和 Objective-C 中很像了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myMethod</span><span class=\"params\">(anObj: AnyObject!)</span></span> &#123;</span><br><span class=\"line\">    synchronized(anObj)&#123;</span><br><span class=\"line\">    \t\t<span class=\"comment\">// 在括号内持有 anObj 锁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个实际的线程安全的 setter 例子</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Obj</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _str = <span class=\"string\">\"123\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> str: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> _str</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            synchronized(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">                _str = newValue</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 下略</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"随机数生成\"><a href=\"#随机数生成\" class=\"headerlink\" title=\"随机数生成\"></a>随机数生成</h2><p>在 Objective-C 中生成随机数一般使用 <strong>arc4random</strong>，在 Swift 中也可以使用。它会返回一个任意整数，我们想要在某个范围里的数的话，可以做模运算（%）取余数。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 这是错误代码</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> diceFaceCount = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> randomRoll = <span class=\"type\">Int</span>(arc4random()) % diceFaceCount + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(randomRoll)</span><br></pre></td></tr></table></figure>\n<p>因为 <strong>arc4random</strong> 返回的值不论在什么平台上都是一个 <code>UInt32</code>，于是在 32 位的平台上就有一半几率在进行 Int 转换时越界，时不时的崩溃也就不足为奇了。（iPhone 5 和前任都是32位的 CPU，之后的是64位，Swift 的 Int 和 CPU 架构有关，Int32 或者 Int64）。</p>\n<p>相对安全改良版本：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">arc4random_uniform</span><span class=\"params\">(<span class=\"number\">_</span>: UInt32)</span></span> -&gt; <span class=\"type\">UInt32</span></span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> diceFaceCount: <span class=\"type\">UInt32</span> = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> randomRoll = <span class=\"type\">Int</span>(arc4random_uniform(diceFaceCount)) + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(randomRoll)</span><br></pre></td></tr></table></figure>\n<p>最佳实践是创建个 <strong>Range</strong> 的随机数的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">random</span><span class=\"params\">(<span class=\"keyword\">in</span> range: Range&lt;Int&gt;)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = <span class=\"type\">UInt32</span>(range.upperBound - range.lowerBound)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">Int</span>(arc4random_uniform(<span class=\"built_in\">count</span>)) + range.lowerBound</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>...<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> range = <span class=\"type\">Range</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span>...<span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(random(<span class=\"keyword\">in</span>: range))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h2><p>断言的另一个优点是它是一个开发时的特性，只有在 Debug 编译的时候有效，而在运行时是不被编译执行的，因此断言并不会消耗运行时的性能。这就不用每次代码发布时，一一找出去除。</p>\n<p>在 Release 版本强制启用断言或者在 Debug 版本强制禁用断言配置，请参考原文，不推荐这样修改。</p>\n<p>如果我们需要在 Release 发布时在无法继续时将程序强行终止的话，应该选择使用 <code>fatalError</code>。</p>\n<h2 id=\"Playground-延时运行\"><a href=\"#Playground-延时运行\" class=\"headerlink\" title=\"Playground 延时运行\"></a>Playground 延时运行</h2><p>为了让 playground 具有延迟运行的能力，我们需要这么做：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>默认情况下它会在顶层代码最后一句运行后20秒的时候停止执行。这个时间长度满足大部分需求了，如果你想要改变这个时间的话，可以通过 <code>Alt + Cmd + 回车</code> 来打开辅助编译器，在那里修改。</p>\n<h2 id=\"Log-输出\"><a href=\"#Log-输出\" class=\"headerlink\" title=\"Log 输出\"></a>Log 输出</h2><p>在 Objective-C 中，我们常用 <strong>NSLog</strong> 来打印输出控制台，通常只会在 <strong>Debug</strong> 版本打印，<strong>Release</strong> 版本为了性能会屏蔽掉（因为也没人看）：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifdef DEBUG</span></span><br><span class=\"line\">    <span class=\"meta\">#define DPrintf(fmt, ...)  printf(<span class=\"meta-string\">\"📍%s + %d🎈 %s\\n\"</span>, __PRETTY_FUNCTION__, __LINE__, [[NSString stringWithFormat:fmt, ##__VA_ARGS__]UTF8String])</span></span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\">    <span class=\"meta\">#define DPrintf(fmt, ...)</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>在 Swift 中，编译器也为我们准备了几个很有用的编译符号：</p>\n<ul>\n<li>#file (String) 包含这个符号的文件的路径</li>\n<li>#line (Int) 符号出现处的行号</li>\n<li>#column (Int) 符号出现处的列</li>\n<li>#function (String) 包含这个符号的方法名</li>\n</ul>\n<p>使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printLog</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> message: T,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    file: String = #file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  method: String = #function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    line: Int = #line)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"\\((file as NSString).lastPathComponent)[\\(line)], \\(method): \\(message)\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当需要在 Release 版本关闭输出时：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printLog</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> message: T,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    file: String = #file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  method: String = #function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    line: Int = #line)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    #<span class=\"keyword\">if</span> <span class=\"type\">DEBUG</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"\\((file as NSString).lastPathComponent)[\\(line)], \\(method): \\(message)\"</span>)</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新版本的 LLVM 编译器在遇到这个空方法时，甚至会直接整个方法去掉，完全不去调用它，从而实现零成本。</p>\n<h2 id=\"属性访问控制\"><a href=\"#属性访问控制\" class=\"headerlink\" title=\"属性访问控制\"></a>属性访问控制</h2><p>Swift 由低到高提供了 <strong>private</strong>，<strong>fileprivate</strong>，<strong>internal</strong>，<strong>public</strong> 和 <strong>open</strong> 五种访问控制的权限。默认是 <strong>internal</strong> 权限。</p>\n<p>private 让代码只能在当前作用域或者同一文件中同一类型的作用域中被使用，fileprivate 表示代码可以在当前文件中被访问，而不做类型限定。</p>\n<p>public 和 open 的区别在于，只有被 open 标记的内容才能在别的框架中被继承或者重写。</p>\n<p>在开发中的时候，我们给某属性加上了 private 修饰符了，但是希望在类型之外也能够读取到这个类型，同时为了保证类型的封装和安全，只能在类型内部对其进行改变和设置：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>(<span class=\"keyword\">set</span>) <span class=\"keyword\">var</span> name: <span class=\"type\">String?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样 set 被限制为 private，保证外部只能访问不能修改。</p>\n<p>这种写法没有对读取做限制，相当于使用了默认的 internal 权限。如果我们希望在别的 module 中也能访问这个属性，同时又保持只在当前作用域可以设置的话，我们需要将 get 的访问权限提高为 public。属性的访问控制可以通过两次的访问权限指定来实现，具体来说，将刚才的声明变为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">private</span>(<span class=\"keyword\">set</span>) <span class=\"keyword\">var</span> name: <span class=\"type\">String?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>MyClass 也要加 public 是因为其他 module 连 MyClass 都不能访问的话，怎么访问 name</p>\n</blockquote>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>以上代码片段全部出自 <a href=\"https://onevcat.com/\" target=\"_blank\" rel=\"noopener\">王巍 (@onevcat)</a> 的著作<a href=\"https://onev.cat/publication/swifter/\" target=\"_blank\" rel=\"noopener\">《Swifter - Swift 必备 Tips》</a>，仅供参考查阅使用，更加详细的内容请参考原著，请支持正版。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇文章是对 <a href=\"https://onevcat.com/\" target=\"_blank\" rel=\"noopener\">王巍 (@onevcat)</a> 的著作<a href=\"https://onev.cat/publication/swifter/\" target=\"_blank\" rel=\"noopener\">《Swifter - Swift 必备 Tips》</a>的个人阅读总结和代码片段记录。</p>\n<h2 id=\"delegate\"><a href=\"#delegate\" class=\"headerlink\" title=\"delegate\"></a>delegate</h2><p>Cocoa 开发中协议-委托是种常用的设计模式，可以说完全离不开它。</p>\n<p>👇这段代码在 Swift 中怎么也不让编译通过：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">MyClassDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">method</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> delegate: <span class=\"type\">MyClassDelegate?</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">MyClassDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> someInstance: <span class=\"type\">MyClass!</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\"></span><br><span class=\"line\">        someInstance = <span class=\"type\">MyClass</span>()</span><br><span class=\"line\">        someInstance.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">method</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Do something\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// weak var delegate: MyClassDelegate? 编译错误</span></span><br><span class=\"line\"><span class=\"comment\">// 'weak' cannot be applied to non-class type 'MyClassDelegate</span></span><br></pre></td></tr></table></figure>\n<p>这是因为 Swift 的 <strong>protocol</strong> 是可以被除了 <strong>class</strong> 以外的其他类型遵守的，而对于像 <strong>struct</strong> 或者 <strong>enum</strong> 这样的类型，本身就不能通过引用计数来管理内存，所以也不可能用 <strong>weak</strong> 这样的 ARC 的概念来进行修饰。</p>\n<p>想要在 Swift 中使用 weak delegate，我们就需要将 protocol 限制在 class 内。</p>\n<p>一种做法是将 protocol 声明为 Objective-C 的，通过在 protocol 前面加上 <strong>@objc</strong> 关键字来达到，Objective-C 的 protocol 都只有类能够实现，因此使用 weak 来修饰就合理了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">MyClassDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">method</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一种可能更好的办法是在 protocol 声明的名字后面加上 <strong>class</strong>，这可以为编译器显示地指明这个protocol 只能由 <strong>class</strong> 来实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">MyClassDelegate</span>: <span class=\"title\">class</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">method</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与添加 <strong>@objc</strong> 相比，后一种方法更能表现出问题的实质，同时也避免了过多的不必要的 Objective-C 兼容，可以说是一种更好的解决方式。</p>\n<h2 id=\"Associated-Object\"><a href=\"#Associated-Object\" class=\"headerlink\" title=\"Associated Object\"></a>Associated Object</h2><p>得益于 Objective-C 的运行时和 Key-Value Coding 的特性，我们可以在运行时向一个对象添加值存储。<strong>而在使用 Category 扩展现有的类的功能的时候，直接添加实例变量这种行为是不被允许的，这时候一般就使用 property 配合 Associated Object 的方式，将一个对象 “关联” 到已有的要扩展的对象上。</strong>进行关联后，在对这个目标对象访问的时候，从外界看来，就似乎是直接在通过属性访问对象的实例变量一样，可以非常方便。</p>\n<p>在 Swift 上这样的方法依旧有效，只不过写法上有些不一样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MyClass.swift</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MyClassExtension.swift</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> key: <span class=\"type\">Void?</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> title: <span class=\"type\">String?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;key) <span class=\"keyword\">as</span>? <span class=\"type\">String</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>,</span><br><span class=\"line\">                &amp;key, newValue,</span><br><span class=\"line\">                .<span class=\"type\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printTitle</span><span class=\"params\">(<span class=\"number\">_</span> input: MyClass)</span></span> &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> title = input.title &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Title: \\(title)\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"没有设置\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"type\">MyClass</span>()</span><br><span class=\"line\">printTitle(a)</span><br><span class=\"line\">a.title = <span class=\"string\">\"Swifter.tips\"</span></span><br><span class=\"line\">printTitle(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// 没有设置</span></span><br><span class=\"line\"><span class=\"comment\">// Title: Swifter.tips”</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h2><p>只要涉及多线程并发，肯定会遇到锁。</p>\n<p>在 Cocoa 和 Objective-C 中加锁的方式有很多，但是其中在日常开发最常用的应该是 <strong>@synchronized</strong>，这个关键字可以用来修饰一个变量，并为其自动加上和解除互斥锁。举个例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)myMethod:(<span class=\"keyword\">id</span>)anObj &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@synchronized</span>(anObj) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在括号内持有 anObj 锁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆这个方法虽然简单好用，但是它在 Swift 中已经（或者暂时）不存在了。其实 <strong>@synchronized</strong> 在幕后做的事情是调用了 <strong>objc_sync</strong> 中的 <strong>objc_sync_enter</strong> 和 <strong>objc_sync_exit</strong> 方法，并且加入了一些异常判断。因此，在 Swift 中，如果我们忽略掉那些异常，可以这么写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myMethod</span><span class=\"params\">(anObj: AnyObject!)</span></span> &#123;</span><br><span class=\"line\">    objc_sync_enter(anObj)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在 enter 和 exit 之间持有 anObj 锁</span></span><br><span class=\"line\"></span><br><span class=\"line\">    objc_sync_exit(anObj)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更进一步，如果我们喜欢以前的那种形式，甚至可以写一个全局的方法，接受一个闭包，来将 <strong>objc_sync_enter</strong> 和 <strong>objc_sync_exit</strong> 封装起来：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">synchronized</span><span class=\"params\">(<span class=\"number\">_</span> lock: AnyObject, closure: <span class=\"params\">()</span></span></span> -&gt; ()) &#123;</span><br><span class=\"line\">    objc_sync_enter(lock)</span><br><span class=\"line\">    closure()</span><br><span class=\"line\">    objc_sync_exit(lock)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结合尾随闭包，使用起来就和 Objective-C 中很像了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myMethod</span><span class=\"params\">(anObj: AnyObject!)</span></span> &#123;</span><br><span class=\"line\">    synchronized(anObj)&#123;</span><br><span class=\"line\">    \t\t<span class=\"comment\">// 在括号内持有 anObj 锁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个实际的线程安全的 setter 例子</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Obj</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _str = <span class=\"string\">\"123\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> str: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> _str</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            synchronized(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">                _str = newValue</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 下略</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"随机数生成\"><a href=\"#随机数生成\" class=\"headerlink\" title=\"随机数生成\"></a>随机数生成</h2><p>在 Objective-C 中生成随机数一般使用 <strong>arc4random</strong>，在 Swift 中也可以使用。它会返回一个任意整数，我们想要在某个范围里的数的话，可以做模运算（%）取余数。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 这是错误代码</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> diceFaceCount = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> randomRoll = <span class=\"type\">Int</span>(arc4random()) % diceFaceCount + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(randomRoll)</span><br></pre></td></tr></table></figure>\n<p>因为 <strong>arc4random</strong> 返回的值不论在什么平台上都是一个 <code>UInt32</code>，于是在 32 位的平台上就有一半几率在进行 Int 转换时越界，时不时的崩溃也就不足为奇了。（iPhone 5 和前任都是32位的 CPU，之后的是64位，Swift 的 Int 和 CPU 架构有关，Int32 或者 Int64）。</p>\n<p>相对安全改良版本：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">arc4random_uniform</span><span class=\"params\">(<span class=\"number\">_</span>: UInt32)</span></span> -&gt; <span class=\"type\">UInt32</span></span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> diceFaceCount: <span class=\"type\">UInt32</span> = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> randomRoll = <span class=\"type\">Int</span>(arc4random_uniform(diceFaceCount)) + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(randomRoll)</span><br></pre></td></tr></table></figure>\n<p>最佳实践是创建个 <strong>Range</strong> 的随机数的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">random</span><span class=\"params\">(<span class=\"keyword\">in</span> range: Range&lt;Int&gt;)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = <span class=\"type\">UInt32</span>(range.upperBound - range.lowerBound)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">Int</span>(arc4random_uniform(<span class=\"built_in\">count</span>)) + range.lowerBound</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>...<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> range = <span class=\"type\">Range</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span>...<span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(random(<span class=\"keyword\">in</span>: range))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h2><p>断言的另一个优点是它是一个开发时的特性，只有在 Debug 编译的时候有效，而在运行时是不被编译执行的，因此断言并不会消耗运行时的性能。这就不用每次代码发布时，一一找出去除。</p>\n<p>在 Release 版本强制启用断言或者在 Debug 版本强制禁用断言配置，请参考原文，不推荐这样修改。</p>\n<p>如果我们需要在 Release 发布时在无法继续时将程序强行终止的话，应该选择使用 <code>fatalError</code>。</p>\n<h2 id=\"Playground-延时运行\"><a href=\"#Playground-延时运行\" class=\"headerlink\" title=\"Playground 延时运行\"></a>Playground 延时运行</h2><p>为了让 playground 具有延迟运行的能力，我们需要这么做：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>默认情况下它会在顶层代码最后一句运行后20秒的时候停止执行。这个时间长度满足大部分需求了，如果你想要改变这个时间的话，可以通过 <code>Alt + Cmd + 回车</code> 来打开辅助编译器，在那里修改。</p>\n<h2 id=\"Log-输出\"><a href=\"#Log-输出\" class=\"headerlink\" title=\"Log 输出\"></a>Log 输出</h2><p>在 Objective-C 中，我们常用 <strong>NSLog</strong> 来打印输出控制台，通常只会在 <strong>Debug</strong> 版本打印，<strong>Release</strong> 版本为了性能会屏蔽掉（因为也没人看）：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifdef DEBUG</span></span><br><span class=\"line\">    <span class=\"meta\">#define DPrintf(fmt, ...)  printf(<span class=\"meta-string\">\"📍%s + %d🎈 %s\\n\"</span>, __PRETTY_FUNCTION__, __LINE__, [[NSString stringWithFormat:fmt, ##__VA_ARGS__]UTF8String])</span></span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\">    <span class=\"meta\">#define DPrintf(fmt, ...)</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>在 Swift 中，编译器也为我们准备了几个很有用的编译符号：</p>\n<ul>\n<li>#file (String) 包含这个符号的文件的路径</li>\n<li>#line (Int) 符号出现处的行号</li>\n<li>#column (Int) 符号出现处的列</li>\n<li>#function (String) 包含这个符号的方法名</li>\n</ul>\n<p>使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printLog</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> message: T,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    file: String = #file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  method: String = #function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    line: Int = #line)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"\\((file as NSString).lastPathComponent)[\\(line)], \\(method): \\(message)\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当需要在 Release 版本关闭输出时：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printLog</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> message: T,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    file: String = #file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  method: String = #function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    line: Int = #line)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    #<span class=\"keyword\">if</span> <span class=\"type\">DEBUG</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"\\((file as NSString).lastPathComponent)[\\(line)], \\(method): \\(message)\"</span>)</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新版本的 LLVM 编译器在遇到这个空方法时，甚至会直接整个方法去掉，完全不去调用它，从而实现零成本。</p>\n<h2 id=\"属性访问控制\"><a href=\"#属性访问控制\" class=\"headerlink\" title=\"属性访问控制\"></a>属性访问控制</h2><p>Swift 由低到高提供了 <strong>private</strong>，<strong>fileprivate</strong>，<strong>internal</strong>，<strong>public</strong> 和 <strong>open</strong> 五种访问控制的权限。默认是 <strong>internal</strong> 权限。</p>\n<p>private 让代码只能在当前作用域或者同一文件中同一类型的作用域中被使用，fileprivate 表示代码可以在当前文件中被访问，而不做类型限定。</p>\n<p>public 和 open 的区别在于，只有被 open 标记的内容才能在别的框架中被继承或者重写。</p>\n<p>在开发中的时候，我们给某属性加上了 private 修饰符了，但是希望在类型之外也能够读取到这个类型，同时为了保证类型的封装和安全，只能在类型内部对其进行改变和设置：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>(<span class=\"keyword\">set</span>) <span class=\"keyword\">var</span> name: <span class=\"type\">String?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样 set 被限制为 private，保证外部只能访问不能修改。</p>\n<p>这种写法没有对读取做限制，相当于使用了默认的 internal 权限。如果我们希望在别的 module 中也能访问这个属性，同时又保持只在当前作用域可以设置的话，我们需要将 get 的访问权限提高为 public。属性的访问控制可以通过两次的访问权限指定来实现，具体来说，将刚才的声明变为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">private</span>(<span class=\"keyword\">set</span>) <span class=\"keyword\">var</span> name: <span class=\"type\">String?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>MyClass 也要加 public 是因为其他 module 连 MyClass 都不能访问的话，怎么访问 name</p>\n</blockquote>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>以上代码片段全部出自 <a href=\"https://onevcat.com/\" target=\"_blank\" rel=\"noopener\">王巍 (@onevcat)</a> 的著作<a href=\"https://onev.cat/publication/swifter/\" target=\"_blank\" rel=\"noopener\">《Swifter - Swift 必备 Tips》</a>，仅供参考查阅使用，更加详细的内容请参考原著，请支持正版。</p>\n"},{"title":"MJRefresh 源码分析","date":"2017-12-16T02:50:51.000Z","_content":"\n## 前言\n\n下拉刷新，上拉加载更多是现在 APP 中非常常见的功能，本文就来看看 **MJRefresh** 是的源码，分析它如何实现的\n\n## 下拉刷新的基本原理\n\n一般的下拉刷新都是用 **ScrollView** 的 `contentInset` 来实现的，我们常用在 TableView 的顶部， TableView 在导航栏下方，它的 **contentInset.top** 就是 `64`，**contentOffset.y** 就是 `-64`。\n\n在下面的代码中打印可以看出：\n\n```objc\n// MJRefreshComponent.m\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context\n{\n    NSLog(@\"contentInset ---> %f\", _scrollView.contentInset.top);\n    NSLog(@\"contentOffset ---> %f\", _scrollView.contentOffset.y);\n    \n    // ......\n}\n```\n\n继续下拉 **contentInset.top** 不变，**contentOffset.y** 变小，上拉 **contentOffset.y** 变大，直到 ScrollView 达到屏幕的左上角变为0。\n\n默认情况下，下拉 TableView ，松手后会弹回初始位置，而下拉刷新控件就是放在 TableView 的的上方，初始 y 设置为负数，所以平时不会显示出来，只有下拉的时候才会出现。在 Loading 的时候，临时把 **contentInset.top** 变大，就把 TableView 往下挤，这样刷新控件就停留在上面，刷新完成后，再把 **contentInset.top** 改回原来的值，实现回弹的效果。\n\n## 关键代码分析\n\n```objc\n// 下拉刷新\ntableView.mj_header= [MJRefreshNormalHeader headerWithRefreshingBlock:^{\n    // 模拟延迟加载数据，因此2秒后才调用（真实开发中，可以移除这段gcd代码）\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        // 结束刷新\n        [tableView.mj_header endRefreshing];\n    });\n}];\n```\n\n上面的代码是将刷新控件添加到 `mj_header` 属性中，实际上控件并不是添加到 **TableView** 上，而是是添加到 **ScrollView** 上：\n\n```objc\n// UIScrollView+MJRefresh.m\n- (void)setMj_header:(MJRefreshHeader *)mj_header {\n    if (mj_header != self.mj_header) {\n        // 删除旧的，添加新的\n        [self.mj_header removeFromSuperview];\n        [self insertSubview:mj_header atIndex:0];\n        \n        // 存储新的\n        objc_setAssociatedObject(self, &MJRefreshHeaderKey,\n                                 mj_header, OBJC_ASSOCIATION_ASSIGN);\n    }\n}\n```\n上面代码是在 **ScrollView** 的 category 中，给 **UIScrollView** 添加了属性 header 和 footer。通常 category 是不能直接添加实例变量的，所以用到了 `objc_setAssociatedObject` 关联对象，所以刷新控件是添加到了 **UIScrollView** 的 subView 中，并保留了引用。\n\n在 MJRefresh 中，所有的刷新控件都是继承自一个公共的父类 **MJRefreshComponent**，如果要实现自定义的控件，可以通过继承它，重写它的代码。**MJRefreshComponent** 还重写 UIView 的方法：\n\n```objc\n- (void)willMoveToSuperview:(UIView *)newSuperview {\n    [super willMoveToSuperview:newSuperview];\n    \n    // 如果不是UIScrollView，不做任何事情\n    if (newSuperview && ![newSuperview isKindOfClass:[UIScrollView class]]) return;\n    \n    // 旧的父控件移除监听\n    [self removeObservers];\n    \n    if (newSuperview) { // 新的父控件\n        // 设置宽度\n        self.mj_w = newSuperview.mj_w;\n        // 设置位置\n        self.mj_x = -_scrollView.mj_insetL;\n        \n        // 记录UIScrollView\n        _scrollView = (UIScrollView *)newSuperview;\n        // 设置永远支持垂直弹簧效果\n        _scrollView.alwaysBounceVertical = YES;\n        // 记录UIScrollView最开始的contentInset\n        _scrollViewOriginalInset = _scrollView.mj_inset;\n        \n        // 添加监听\n        [self addObservers];\n    }\n}\n```\n\n当刷新控件添加到 ScrollView 上时，即 **setMj_header** 的 **[self insertSubview:mj_header atIndex:0];** 将会触发 **willMoveToSuperview** ，然后还会触发：\n\n```objc\n- (void)layoutSubviews {\n    [self placeSubviews];\n    \n    [super layoutSubviews];\n}\n```\n子控件通过重写 **placeSubviews** 来布局子控件：\n\n```objc\n// MJRefreshNormalHeader.m\n- (void)placeSubviews {\n    [super placeSubviews];\n    \n    // 箭头的中心点\n    CGFloat arrowCenterX = self.mj_w * 0.5;\n    if (!self.stateLabel.hidden) {\n        CGFloat stateWidth = self.stateLabel.mj_textWith;\n        CGFloat timeWidth = 0.0;\n        if (!self.lastUpdatedTimeLabel.hidden) {\n            timeWidth = self.lastUpdatedTimeLabel.mj_textWith;\n        }\n        CGFloat textWidth = MAX(stateWidth, timeWidth);\n        arrowCenterX -= textWidth / 2 + self.labelLeftInset;\n    }\n    CGFloat arrowCenterY = self.mj_h * 0.5;\n    CGPoint arrowCenter = CGPointMake(arrowCenterX, arrowCenterY);\n    \n    // 箭头\n    if (self.arrowView.constraints.count == 0) {\n        self.arrowView.mj_size = self.arrowView.image.size;\n        self.arrowView.center = arrowCenter;\n    }\n        \n    // 圈圈\n    if (self.loadingView.constraints.count == 0) {\n        self.loadingView.center = arrowCenter;\n    }\n    \n    self.arrowView.tintColor = self.stateLabel.textColor;\n}\n```\n\n**willMoveToSuperview** 方法中还添加了监听，监听 **UIScrollView** 的 **contentInset** 和 **contentOffset**：\n\n```objc\n// MJRefreshComponent.m\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n    \n    // 遇到这些情况就直接返回\n    if (!self.userInteractionEnabled) return;\n    \n    // 这个就算看不见也需要处理\n    if ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) {\n        [self scrollViewContentSizeDidChange:change];\n    }\n    \n    // 看不见\n    if (self.hidden) return;\n    if ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) {\n        [self scrollViewContentOffsetDidChange:change];\n    } else if ([keyPath isEqualToString:MJRefreshKeyPathPanState]) {\n        [self scrollViewPanStateDidChange:change];\n    }\n}\n```\n\n\n```objc\n// MJRefreshHeader.m\n- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change {\n    [super scrollViewContentOffsetDidChange:change];\n    \n    // 在刷新的refreshing状态\n    if (self.state == MJRefreshStateRefreshing) {\n        // 暂时保留\n        if (self.window == nil) return;\n        \n        // sectionheader停留解决\n        CGFloat insetT = - self.scrollView.mj_offsetY > _scrollViewOriginalInset.top ? - self.scrollView.mj_offsetY : _scrollViewOriginalInset.top;\n        insetT = insetT > self.mj_h + _scrollViewOriginalInset.top ? self.mj_h + _scrollViewOriginalInset.top : insetT;\n        self.scrollView.mj_insetT = insetT;\n        \n        self.insetTDelta = _scrollViewOriginalInset.top - insetT;\n        return;\n    }\n    \n    // 跳转到下一个控制器时，contentInset可能会变\n     _scrollViewOriginalInset = self.scrollView.mj_inset;\n    \n    // 当前的contentOffset\n    CGFloat offsetY = self.scrollView.mj_offsetY;\n    // 头部控件刚好出现的offsetY\n    CGFloat happenOffsetY = - self.scrollViewOriginalInset.top;\n    \n    // 如果是向上滚动到看不见头部控件，直接返回\n    // >= -> >\n    if (offsetY > happenOffsetY) return;\n    \n    // 普通 和 即将刷新 的临界点\n    CGFloat normal2pullingOffsetY = happenOffsetY - self.mj_h;\n    CGFloat pullingPercent = (happenOffsetY - offsetY) / self.mj_h;\n    \n    if (self.scrollView.isDragging) { // 如果正在拖拽\n        self.pullingPercent = pullingPercent;\n        if (self.state == MJRefreshStateIdle && offsetY < normal2pullingOffsetY) {\n            // 转为即将刷新状态\n            self.state = MJRefreshStatePulling;\n        } else if (self.state == MJRefreshStatePulling && offsetY >= normal2pullingOffsetY) {\n            // 转为普通状态\n            self.state = MJRefreshStateIdle;\n        }\n    } else if (self.state == MJRefreshStatePulling) {// 即将刷新 && 手松开\n        // 开始刷新\n        [self beginRefreshing];\n    } else if (pullingPercent < 1) {\n        self.pullingPercent = pullingPercent;\n    }\n}\n```\n\n👆方法中根据 **contentOffset** 的位置计算刷新控件的状态更新控件的UI：\n\n```objc\n// MJRefreshComponent.m\n- (void)setState:(MJRefreshState)state {\n    _state = state;\n    \n    // 加入主队列的目的是等setState:方法调用完毕、设置完文字后再去布局子控件\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self setNeedsLayout];\n    });\n}\n```\n\n```objc\n// MJRefreshHeader.m\n- (void)setState:(MJRefreshState)state {\n    MJRefreshCheckState\n    \n    // 根据状态做事情\n    if (state == MJRefreshStateIdle) {\n        if (oldState != MJRefreshStateRefreshing) return;\n        \n        // 保存刷新时间\n        [[NSUserDefaults standardUserDefaults] setObject:[NSDate date] forKey:self.lastUpdatedTimeKey];\n        [[NSUserDefaults standardUserDefaults] synchronize];\n        \n        // 恢复inset和offset\n        [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^{\n            self.scrollView.mj_insetT += self.insetTDelta;\n            \n            // 自动调整透明度\n            if (self.isAutomaticallyChangeAlpha) self.alpha = 0.0;\n        } completion:^(BOOL finished) {\n            self.pullingPercent = 0.0;\n            \n            if (self.endRefreshingCompletionBlock) {\n                self.endRefreshingCompletionBlock();\n            }\n        }];\n    } else if (state == MJRefreshStateRefreshing) {\n         dispatch_async(dispatch_get_main_queue(), ^{\n            [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{\n                CGFloat top = self.scrollViewOriginalInset.top + self.mj_h;\n                // 增加滚动区域top\n                self.scrollView.mj_insetT = top;\n                // 设置滚动位置\n                CGPoint offset = self.scrollView.contentOffset;\n                offset.y = -top;\n                [self.scrollView setContentOffset:offset animated:NO];\n            } completion:^(BOOL finished) {\n                [self executeRefreshingCallback];\n            }];\n         });\n    }\n}\n```\n\n如果正在刷新，增大 contentInset ，让 Header 保留在屏幕上，执行 Callback 结束后恢复原来位置。\n\n## 总结\n\n从上面可以得出结论，可以看出来下拉刷新的过程大致是：\n初始化下拉刷新控件 -> 设置Frame，布局子控件 -> 控件添加监听 -> 监控contentOffset -> 判断contentOffset并做出相应回调。\n\n\n","source":"_posts/2017-12-16-mjrefresh-analysis.md","raw":"---\ntitle: MJRefresh 源码分析\ndate: 2017-12-16 10:50:51\ntags: MJRefresh\ncategory: Source Code Analyze\n---\n\n## 前言\n\n下拉刷新，上拉加载更多是现在 APP 中非常常见的功能，本文就来看看 **MJRefresh** 是的源码，分析它如何实现的\n\n## 下拉刷新的基本原理\n\n一般的下拉刷新都是用 **ScrollView** 的 `contentInset` 来实现的，我们常用在 TableView 的顶部， TableView 在导航栏下方，它的 **contentInset.top** 就是 `64`，**contentOffset.y** 就是 `-64`。\n\n在下面的代码中打印可以看出：\n\n```objc\n// MJRefreshComponent.m\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context\n{\n    NSLog(@\"contentInset ---> %f\", _scrollView.contentInset.top);\n    NSLog(@\"contentOffset ---> %f\", _scrollView.contentOffset.y);\n    \n    // ......\n}\n```\n\n继续下拉 **contentInset.top** 不变，**contentOffset.y** 变小，上拉 **contentOffset.y** 变大，直到 ScrollView 达到屏幕的左上角变为0。\n\n默认情况下，下拉 TableView ，松手后会弹回初始位置，而下拉刷新控件就是放在 TableView 的的上方，初始 y 设置为负数，所以平时不会显示出来，只有下拉的时候才会出现。在 Loading 的时候，临时把 **contentInset.top** 变大，就把 TableView 往下挤，这样刷新控件就停留在上面，刷新完成后，再把 **contentInset.top** 改回原来的值，实现回弹的效果。\n\n## 关键代码分析\n\n```objc\n// 下拉刷新\ntableView.mj_header= [MJRefreshNormalHeader headerWithRefreshingBlock:^{\n    // 模拟延迟加载数据，因此2秒后才调用（真实开发中，可以移除这段gcd代码）\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        // 结束刷新\n        [tableView.mj_header endRefreshing];\n    });\n}];\n```\n\n上面的代码是将刷新控件添加到 `mj_header` 属性中，实际上控件并不是添加到 **TableView** 上，而是是添加到 **ScrollView** 上：\n\n```objc\n// UIScrollView+MJRefresh.m\n- (void)setMj_header:(MJRefreshHeader *)mj_header {\n    if (mj_header != self.mj_header) {\n        // 删除旧的，添加新的\n        [self.mj_header removeFromSuperview];\n        [self insertSubview:mj_header atIndex:0];\n        \n        // 存储新的\n        objc_setAssociatedObject(self, &MJRefreshHeaderKey,\n                                 mj_header, OBJC_ASSOCIATION_ASSIGN);\n    }\n}\n```\n上面代码是在 **ScrollView** 的 category 中，给 **UIScrollView** 添加了属性 header 和 footer。通常 category 是不能直接添加实例变量的，所以用到了 `objc_setAssociatedObject` 关联对象，所以刷新控件是添加到了 **UIScrollView** 的 subView 中，并保留了引用。\n\n在 MJRefresh 中，所有的刷新控件都是继承自一个公共的父类 **MJRefreshComponent**，如果要实现自定义的控件，可以通过继承它，重写它的代码。**MJRefreshComponent** 还重写 UIView 的方法：\n\n```objc\n- (void)willMoveToSuperview:(UIView *)newSuperview {\n    [super willMoveToSuperview:newSuperview];\n    \n    // 如果不是UIScrollView，不做任何事情\n    if (newSuperview && ![newSuperview isKindOfClass:[UIScrollView class]]) return;\n    \n    // 旧的父控件移除监听\n    [self removeObservers];\n    \n    if (newSuperview) { // 新的父控件\n        // 设置宽度\n        self.mj_w = newSuperview.mj_w;\n        // 设置位置\n        self.mj_x = -_scrollView.mj_insetL;\n        \n        // 记录UIScrollView\n        _scrollView = (UIScrollView *)newSuperview;\n        // 设置永远支持垂直弹簧效果\n        _scrollView.alwaysBounceVertical = YES;\n        // 记录UIScrollView最开始的contentInset\n        _scrollViewOriginalInset = _scrollView.mj_inset;\n        \n        // 添加监听\n        [self addObservers];\n    }\n}\n```\n\n当刷新控件添加到 ScrollView 上时，即 **setMj_header** 的 **[self insertSubview:mj_header atIndex:0];** 将会触发 **willMoveToSuperview** ，然后还会触发：\n\n```objc\n- (void)layoutSubviews {\n    [self placeSubviews];\n    \n    [super layoutSubviews];\n}\n```\n子控件通过重写 **placeSubviews** 来布局子控件：\n\n```objc\n// MJRefreshNormalHeader.m\n- (void)placeSubviews {\n    [super placeSubviews];\n    \n    // 箭头的中心点\n    CGFloat arrowCenterX = self.mj_w * 0.5;\n    if (!self.stateLabel.hidden) {\n        CGFloat stateWidth = self.stateLabel.mj_textWith;\n        CGFloat timeWidth = 0.0;\n        if (!self.lastUpdatedTimeLabel.hidden) {\n            timeWidth = self.lastUpdatedTimeLabel.mj_textWith;\n        }\n        CGFloat textWidth = MAX(stateWidth, timeWidth);\n        arrowCenterX -= textWidth / 2 + self.labelLeftInset;\n    }\n    CGFloat arrowCenterY = self.mj_h * 0.5;\n    CGPoint arrowCenter = CGPointMake(arrowCenterX, arrowCenterY);\n    \n    // 箭头\n    if (self.arrowView.constraints.count == 0) {\n        self.arrowView.mj_size = self.arrowView.image.size;\n        self.arrowView.center = arrowCenter;\n    }\n        \n    // 圈圈\n    if (self.loadingView.constraints.count == 0) {\n        self.loadingView.center = arrowCenter;\n    }\n    \n    self.arrowView.tintColor = self.stateLabel.textColor;\n}\n```\n\n**willMoveToSuperview** 方法中还添加了监听，监听 **UIScrollView** 的 **contentInset** 和 **contentOffset**：\n\n```objc\n// MJRefreshComponent.m\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n    \n    // 遇到这些情况就直接返回\n    if (!self.userInteractionEnabled) return;\n    \n    // 这个就算看不见也需要处理\n    if ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) {\n        [self scrollViewContentSizeDidChange:change];\n    }\n    \n    // 看不见\n    if (self.hidden) return;\n    if ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) {\n        [self scrollViewContentOffsetDidChange:change];\n    } else if ([keyPath isEqualToString:MJRefreshKeyPathPanState]) {\n        [self scrollViewPanStateDidChange:change];\n    }\n}\n```\n\n\n```objc\n// MJRefreshHeader.m\n- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change {\n    [super scrollViewContentOffsetDidChange:change];\n    \n    // 在刷新的refreshing状态\n    if (self.state == MJRefreshStateRefreshing) {\n        // 暂时保留\n        if (self.window == nil) return;\n        \n        // sectionheader停留解决\n        CGFloat insetT = - self.scrollView.mj_offsetY > _scrollViewOriginalInset.top ? - self.scrollView.mj_offsetY : _scrollViewOriginalInset.top;\n        insetT = insetT > self.mj_h + _scrollViewOriginalInset.top ? self.mj_h + _scrollViewOriginalInset.top : insetT;\n        self.scrollView.mj_insetT = insetT;\n        \n        self.insetTDelta = _scrollViewOriginalInset.top - insetT;\n        return;\n    }\n    \n    // 跳转到下一个控制器时，contentInset可能会变\n     _scrollViewOriginalInset = self.scrollView.mj_inset;\n    \n    // 当前的contentOffset\n    CGFloat offsetY = self.scrollView.mj_offsetY;\n    // 头部控件刚好出现的offsetY\n    CGFloat happenOffsetY = - self.scrollViewOriginalInset.top;\n    \n    // 如果是向上滚动到看不见头部控件，直接返回\n    // >= -> >\n    if (offsetY > happenOffsetY) return;\n    \n    // 普通 和 即将刷新 的临界点\n    CGFloat normal2pullingOffsetY = happenOffsetY - self.mj_h;\n    CGFloat pullingPercent = (happenOffsetY - offsetY) / self.mj_h;\n    \n    if (self.scrollView.isDragging) { // 如果正在拖拽\n        self.pullingPercent = pullingPercent;\n        if (self.state == MJRefreshStateIdle && offsetY < normal2pullingOffsetY) {\n            // 转为即将刷新状态\n            self.state = MJRefreshStatePulling;\n        } else if (self.state == MJRefreshStatePulling && offsetY >= normal2pullingOffsetY) {\n            // 转为普通状态\n            self.state = MJRefreshStateIdle;\n        }\n    } else if (self.state == MJRefreshStatePulling) {// 即将刷新 && 手松开\n        // 开始刷新\n        [self beginRefreshing];\n    } else if (pullingPercent < 1) {\n        self.pullingPercent = pullingPercent;\n    }\n}\n```\n\n👆方法中根据 **contentOffset** 的位置计算刷新控件的状态更新控件的UI：\n\n```objc\n// MJRefreshComponent.m\n- (void)setState:(MJRefreshState)state {\n    _state = state;\n    \n    // 加入主队列的目的是等setState:方法调用完毕、设置完文字后再去布局子控件\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self setNeedsLayout];\n    });\n}\n```\n\n```objc\n// MJRefreshHeader.m\n- (void)setState:(MJRefreshState)state {\n    MJRefreshCheckState\n    \n    // 根据状态做事情\n    if (state == MJRefreshStateIdle) {\n        if (oldState != MJRefreshStateRefreshing) return;\n        \n        // 保存刷新时间\n        [[NSUserDefaults standardUserDefaults] setObject:[NSDate date] forKey:self.lastUpdatedTimeKey];\n        [[NSUserDefaults standardUserDefaults] synchronize];\n        \n        // 恢复inset和offset\n        [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^{\n            self.scrollView.mj_insetT += self.insetTDelta;\n            \n            // 自动调整透明度\n            if (self.isAutomaticallyChangeAlpha) self.alpha = 0.0;\n        } completion:^(BOOL finished) {\n            self.pullingPercent = 0.0;\n            \n            if (self.endRefreshingCompletionBlock) {\n                self.endRefreshingCompletionBlock();\n            }\n        }];\n    } else if (state == MJRefreshStateRefreshing) {\n         dispatch_async(dispatch_get_main_queue(), ^{\n            [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{\n                CGFloat top = self.scrollViewOriginalInset.top + self.mj_h;\n                // 增加滚动区域top\n                self.scrollView.mj_insetT = top;\n                // 设置滚动位置\n                CGPoint offset = self.scrollView.contentOffset;\n                offset.y = -top;\n                [self.scrollView setContentOffset:offset animated:NO];\n            } completion:^(BOOL finished) {\n                [self executeRefreshingCallback];\n            }];\n         });\n    }\n}\n```\n\n如果正在刷新，增大 contentInset ，让 Header 保留在屏幕上，执行 Callback 结束后恢复原来位置。\n\n## 总结\n\n从上面可以得出结论，可以看出来下拉刷新的过程大致是：\n初始化下拉刷新控件 -> 设置Frame，布局子控件 -> 控件添加监听 -> 监控contentOffset -> 判断contentOffset并做出相应回调。\n\n\n","slug":"2017-12-16-mjrefresh-analysis","published":1,"updated":"2018-09-02T03:33:37.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7nq003u8jpbyrtf8sn8","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>下拉刷新，上拉加载更多是现在 APP 中非常常见的功能，本文就来看看 <strong>MJRefresh</strong> 是的源码，分析它如何实现的</p>\n<h2 id=\"下拉刷新的基本原理\"><a href=\"#下拉刷新的基本原理\" class=\"headerlink\" title=\"下拉刷新的基本原理\"></a>下拉刷新的基本原理</h2><p>一般的下拉刷新都是用 <strong>ScrollView</strong> 的 <code>contentInset</code> 来实现的，我们常用在 TableView 的顶部， TableView 在导航栏下方，它的 <strong>contentInset.top</strong> 就是 <code>64</code>，<strong>contentOffset.y</strong> 就是 <code>-64</code>。</p>\n<p>在下面的代码中打印可以看出：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshComponent.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span> *)change context:(<span class=\"keyword\">void</span> *)context</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"contentInset ---&gt; %f\"</span>, _scrollView.contentInset.top);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"contentOffset ---&gt; %f\"</span>, _scrollView.contentOffset.y);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续下拉 <strong>contentInset.top</strong> 不变，<strong>contentOffset.y</strong> 变小，上拉 <strong>contentOffset.y</strong> 变大，直到 ScrollView 达到屏幕的左上角变为0。</p>\n<p>默认情况下，下拉 TableView ，松手后会弹回初始位置，而下拉刷新控件就是放在 TableView 的的上方，初始 y 设置为负数，所以平时不会显示出来，只有下拉的时候才会出现。在 Loading 的时候，临时把 <strong>contentInset.top</strong> 变大，就把 TableView 往下挤，这样刷新控件就停留在上面，刷新完成后，再把 <strong>contentInset.top</strong> 改回原来的值，实现回弹的效果。</p>\n<h2 id=\"关键代码分析\"><a href=\"#关键代码分析\" class=\"headerlink\" title=\"关键代码分析\"></a>关键代码分析</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下拉刷新</span></span><br><span class=\"line\">tableView.mj_header= [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟延迟加载数据，因此2秒后才调用（真实开发中，可以移除这段gcd代码）</span></span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 结束刷新</span></span><br><span class=\"line\">        [tableView.mj_header endRefreshing];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>上面的代码是将刷新控件添加到 <code>mj_header</code> 属性中，实际上控件并不是添加到 <strong>TableView</strong> 上，而是是添加到 <strong>ScrollView</strong> 上：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// UIScrollView+MJRefresh.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setMj_header:(MJRefreshHeader *)mj_header &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mj_header != <span class=\"keyword\">self</span>.mj_header) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 删除旧的，添加新的</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.mj_header removeFromSuperview];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> insertSubview:mj_header atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 存储新的</span></span><br><span class=\"line\">        objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;MJRefreshHeaderKey,</span><br><span class=\"line\">                                 mj_header, OBJC_ASSOCIATION_ASSIGN);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码是在 <strong>ScrollView</strong> 的 category 中，给 <strong>UIScrollView</strong> 添加了属性 header 和 footer。通常 category 是不能直接添加实例变量的，所以用到了 <code>objc_setAssociatedObject</code> 关联对象，所以刷新控件是添加到了 <strong>UIScrollView</strong> 的 subView 中，并保留了引用。</p>\n<p>在 MJRefresh 中，所有的刷新控件都是继承自一个公共的父类 <strong>MJRefreshComponent</strong>，如果要实现自定义的控件，可以通过继承它，重写它的代码。<strong>MJRefreshComponent</strong> 还重写 UIView 的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)willMoveToSuperview:(<span class=\"built_in\">UIView</span> *)newSuperview &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> willMoveToSuperview:newSuperview];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果不是UIScrollView，不做任何事情</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newSuperview &amp;&amp; ![newSuperview isKindOfClass:[<span class=\"built_in\">UIScrollView</span> <span class=\"keyword\">class</span>]]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 旧的父控件移除监听</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeObservers];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newSuperview) &#123; <span class=\"comment\">// 新的父控件</span></span><br><span class=\"line\">        <span class=\"comment\">// 设置宽度</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.mj_w = newSuperview.mj_w;</span><br><span class=\"line\">        <span class=\"comment\">// 设置位置</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.mj_x = -_scrollView.mj_insetL;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 记录UIScrollView</span></span><br><span class=\"line\">        _scrollView = (<span class=\"built_in\">UIScrollView</span> *)newSuperview;</span><br><span class=\"line\">        <span class=\"comment\">// 设置永远支持垂直弹簧效果</span></span><br><span class=\"line\">        _scrollView.alwaysBounceVertical = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 记录UIScrollView最开始的contentInset</span></span><br><span class=\"line\">        _scrollViewOriginalInset = _scrollView.mj_inset;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 添加监听</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addObservers];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当刷新控件添加到 ScrollView 上时，即 <strong>setMj_header</strong> 的 <strong>[self insertSubview:mj_header atIndex:0];</strong> 将会触发 <strong>willMoveToSuperview</strong> ，然后还会触发：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)layoutSubviews &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> placeSubviews];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">super</span> layoutSubviews];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>子控件通过重写 <strong>placeSubviews</strong> 来布局子控件：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshNormalHeader.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)placeSubviews &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> placeSubviews];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 箭头的中心点</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> arrowCenterX = <span class=\"keyword\">self</span>.mj_w * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.stateLabel.hidden) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CGFloat</span> stateWidth = <span class=\"keyword\">self</span>.stateLabel.mj_textWith;</span><br><span class=\"line\">        <span class=\"built_in\">CGFloat</span> timeWidth = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.lastUpdatedTimeLabel.hidden) &#123;</span><br><span class=\"line\">            timeWidth = <span class=\"keyword\">self</span>.lastUpdatedTimeLabel.mj_textWith;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</span><br><span class=\"line\">        arrowCenterX -= textWidth / <span class=\"number\">2</span> + <span class=\"keyword\">self</span>.labelLeftInset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> arrowCenterY = <span class=\"keyword\">self</span>.mj_h * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> arrowCenter = <span class=\"built_in\">CGPointMake</span>(arrowCenterX, arrowCenterY);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 箭头</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.arrowView.constraints.count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.arrowView.mj_size = <span class=\"keyword\">self</span>.arrowView.image.size;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.arrowView.center = arrowCenter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// 圈圈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.loadingView.constraints.count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.loadingView.center = arrowCenter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.arrowView.tintColor = <span class=\"keyword\">self</span>.stateLabel.textColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>willMoveToSuperview</strong> 方法中还添加了监听，监听 <strong>UIScrollView</strong> 的 <strong>contentInset</strong> 和 <strong>contentOffset</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshComponent.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span> *)change context:(<span class=\"keyword\">void</span> *)context &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 遇到这些情况就直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.userInteractionEnabled) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 这个就算看不见也需要处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> scrollViewContentSizeDidChange:change];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 看不见</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.hidden) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> scrollViewContentOffsetDidChange:change];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> scrollViewPanStateDidChange:change];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshHeader.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewContentOffsetDidChange:(<span class=\"built_in\">NSDictionary</span> *)change &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> scrollViewContentOffsetDidChange:change];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在刷新的refreshing状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.state == MJRefreshStateRefreshing) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 暂时保留</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.window == <span class=\"literal\">nil</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// sectionheader停留解决</span></span><br><span class=\"line\">        <span class=\"built_in\">CGFloat</span> insetT = - <span class=\"keyword\">self</span>.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - <span class=\"keyword\">self</span>.scrollView.mj_offsetY : _scrollViewOriginalInset.top;</span><br><span class=\"line\">        insetT = insetT &gt; <span class=\"keyword\">self</span>.mj_h + _scrollViewOriginalInset.top ? <span class=\"keyword\">self</span>.mj_h + _scrollViewOriginalInset.top : insetT;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.scrollView.mj_insetT = insetT;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">self</span>.insetTDelta = _scrollViewOriginalInset.top - insetT;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 跳转到下一个控制器时，contentInset可能会变</span></span><br><span class=\"line\">     _scrollViewOriginalInset = <span class=\"keyword\">self</span>.scrollView.mj_inset;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 当前的contentOffset</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> offsetY = <span class=\"keyword\">self</span>.scrollView.mj_offsetY;</span><br><span class=\"line\">    <span class=\"comment\">// 头部控件刚好出现的offsetY</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> happenOffsetY = - <span class=\"keyword\">self</span>.scrollViewOriginalInset.top;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果是向上滚动到看不见头部控件，直接返回</span></span><br><span class=\"line\">    <span class=\"comment\">// &gt;= -&gt; &gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offsetY &gt; happenOffsetY) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 普通 和 即将刷新 的临界点</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> normal2pullingOffsetY = happenOffsetY - <span class=\"keyword\">self</span>.mj_h;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> pullingPercent = (happenOffsetY - offsetY) / <span class=\"keyword\">self</span>.mj_h;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.scrollView.isDragging) &#123; <span class=\"comment\">// 如果正在拖拽</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pullingPercent = pullingPercent;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 转为即将刷新状态</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.state = MJRefreshStatePulling;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= normal2pullingOffsetY) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 转为普通状态</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.state = MJRefreshStateIdle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.state == MJRefreshStatePulling) &#123;<span class=\"comment\">// 即将刷新 &amp;&amp; 手松开</span></span><br><span class=\"line\">        <span class=\"comment\">// 开始刷新</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span> beginRefreshing];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pullingPercent &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pullingPercent = pullingPercent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆方法中根据 <strong>contentOffset</strong> 的位置计算刷新控件的状态更新控件的UI：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshComponent.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setState:(MJRefreshState)state &#123;</span><br><span class=\"line\">    _state = state;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 加入主队列的目的是等setState:方法调用完毕、设置完文字后再去布局子控件</span></span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setNeedsLayout];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshHeader.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setState:(MJRefreshState)state &#123;</span><br><span class=\"line\">    MJRefreshCheckState</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 根据状态做事情</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state == MJRefreshStateIdle) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldState != MJRefreshStateRefreshing) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 保存刷新时间</span></span><br><span class=\"line\">        [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:[<span class=\"built_in\">NSDate</span> date] forKey:<span class=\"keyword\">self</span>.lastUpdatedTimeKey];</span><br><span class=\"line\">        [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] synchronize];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 恢复inset和offset</span></span><br><span class=\"line\">        [<span class=\"built_in\">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.scrollView.mj_insetT += <span class=\"keyword\">self</span>.insetTDelta;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 自动调整透明度</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.isAutomaticallyChangeAlpha) <span class=\"keyword\">self</span>.alpha = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">        &#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.pullingPercent = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.endRefreshingCompletionBlock) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.endRefreshingCompletionBlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == MJRefreshStateRefreshing) &#123;</span><br><span class=\"line\">         <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            [<span class=\"built_in\">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</span><br><span class=\"line\">                <span class=\"built_in\">CGFloat</span> top = <span class=\"keyword\">self</span>.scrollViewOriginalInset.top + <span class=\"keyword\">self</span>.mj_h;</span><br><span class=\"line\">                <span class=\"comment\">// 增加滚动区域top</span></span><br><span class=\"line\">                <span class=\"keyword\">self</span>.scrollView.mj_insetT = top;</span><br><span class=\"line\">                <span class=\"comment\">// 设置滚动位置</span></span><br><span class=\"line\">                <span class=\"built_in\">CGPoint</span> offset = <span class=\"keyword\">self</span>.scrollView.contentOffset;</span><br><span class=\"line\">                offset.y = -top;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.scrollView setContentOffset:offset animated:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">            &#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span> executeRefreshingCallback];</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">         &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果正在刷新，增大 contentInset ，让 Header 保留在屏幕上，执行 Callback 结束后恢复原来位置。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>从上面可以得出结论，可以看出来下拉刷新的过程大致是：<br>初始化下拉刷新控件 -&gt; 设置Frame，布局子控件 -&gt; 控件添加监听 -&gt; 监控contentOffset -&gt; 判断contentOffset并做出相应回调。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>下拉刷新，上拉加载更多是现在 APP 中非常常见的功能，本文就来看看 <strong>MJRefresh</strong> 是的源码，分析它如何实现的</p>\n<h2 id=\"下拉刷新的基本原理\"><a href=\"#下拉刷新的基本原理\" class=\"headerlink\" title=\"下拉刷新的基本原理\"></a>下拉刷新的基本原理</h2><p>一般的下拉刷新都是用 <strong>ScrollView</strong> 的 <code>contentInset</code> 来实现的，我们常用在 TableView 的顶部， TableView 在导航栏下方，它的 <strong>contentInset.top</strong> 就是 <code>64</code>，<strong>contentOffset.y</strong> 就是 <code>-64</code>。</p>\n<p>在下面的代码中打印可以看出：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshComponent.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span> *)change context:(<span class=\"keyword\">void</span> *)context</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"contentInset ---&gt; %f\"</span>, _scrollView.contentInset.top);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"contentOffset ---&gt; %f\"</span>, _scrollView.contentOffset.y);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续下拉 <strong>contentInset.top</strong> 不变，<strong>contentOffset.y</strong> 变小，上拉 <strong>contentOffset.y</strong> 变大，直到 ScrollView 达到屏幕的左上角变为0。</p>\n<p>默认情况下，下拉 TableView ，松手后会弹回初始位置，而下拉刷新控件就是放在 TableView 的的上方，初始 y 设置为负数，所以平时不会显示出来，只有下拉的时候才会出现。在 Loading 的时候，临时把 <strong>contentInset.top</strong> 变大，就把 TableView 往下挤，这样刷新控件就停留在上面，刷新完成后，再把 <strong>contentInset.top</strong> 改回原来的值，实现回弹的效果。</p>\n<h2 id=\"关键代码分析\"><a href=\"#关键代码分析\" class=\"headerlink\" title=\"关键代码分析\"></a>关键代码分析</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下拉刷新</span></span><br><span class=\"line\">tableView.mj_header= [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟延迟加载数据，因此2秒后才调用（真实开发中，可以移除这段gcd代码）</span></span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 结束刷新</span></span><br><span class=\"line\">        [tableView.mj_header endRefreshing];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>上面的代码是将刷新控件添加到 <code>mj_header</code> 属性中，实际上控件并不是添加到 <strong>TableView</strong> 上，而是是添加到 <strong>ScrollView</strong> 上：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// UIScrollView+MJRefresh.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setMj_header:(MJRefreshHeader *)mj_header &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mj_header != <span class=\"keyword\">self</span>.mj_header) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 删除旧的，添加新的</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.mj_header removeFromSuperview];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> insertSubview:mj_header atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 存储新的</span></span><br><span class=\"line\">        objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;MJRefreshHeaderKey,</span><br><span class=\"line\">                                 mj_header, OBJC_ASSOCIATION_ASSIGN);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码是在 <strong>ScrollView</strong> 的 category 中，给 <strong>UIScrollView</strong> 添加了属性 header 和 footer。通常 category 是不能直接添加实例变量的，所以用到了 <code>objc_setAssociatedObject</code> 关联对象，所以刷新控件是添加到了 <strong>UIScrollView</strong> 的 subView 中，并保留了引用。</p>\n<p>在 MJRefresh 中，所有的刷新控件都是继承自一个公共的父类 <strong>MJRefreshComponent</strong>，如果要实现自定义的控件，可以通过继承它，重写它的代码。<strong>MJRefreshComponent</strong> 还重写 UIView 的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)willMoveToSuperview:(<span class=\"built_in\">UIView</span> *)newSuperview &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> willMoveToSuperview:newSuperview];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果不是UIScrollView，不做任何事情</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newSuperview &amp;&amp; ![newSuperview isKindOfClass:[<span class=\"built_in\">UIScrollView</span> <span class=\"keyword\">class</span>]]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 旧的父控件移除监听</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeObservers];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newSuperview) &#123; <span class=\"comment\">// 新的父控件</span></span><br><span class=\"line\">        <span class=\"comment\">// 设置宽度</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.mj_w = newSuperview.mj_w;</span><br><span class=\"line\">        <span class=\"comment\">// 设置位置</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.mj_x = -_scrollView.mj_insetL;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 记录UIScrollView</span></span><br><span class=\"line\">        _scrollView = (<span class=\"built_in\">UIScrollView</span> *)newSuperview;</span><br><span class=\"line\">        <span class=\"comment\">// 设置永远支持垂直弹簧效果</span></span><br><span class=\"line\">        _scrollView.alwaysBounceVertical = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 记录UIScrollView最开始的contentInset</span></span><br><span class=\"line\">        _scrollViewOriginalInset = _scrollView.mj_inset;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 添加监听</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addObservers];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当刷新控件添加到 ScrollView 上时，即 <strong>setMj_header</strong> 的 <strong>[self insertSubview:mj_header atIndex:0];</strong> 将会触发 <strong>willMoveToSuperview</strong> ，然后还会触发：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)layoutSubviews &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> placeSubviews];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">super</span> layoutSubviews];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>子控件通过重写 <strong>placeSubviews</strong> 来布局子控件：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshNormalHeader.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)placeSubviews &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> placeSubviews];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 箭头的中心点</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> arrowCenterX = <span class=\"keyword\">self</span>.mj_w * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.stateLabel.hidden) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CGFloat</span> stateWidth = <span class=\"keyword\">self</span>.stateLabel.mj_textWith;</span><br><span class=\"line\">        <span class=\"built_in\">CGFloat</span> timeWidth = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.lastUpdatedTimeLabel.hidden) &#123;</span><br><span class=\"line\">            timeWidth = <span class=\"keyword\">self</span>.lastUpdatedTimeLabel.mj_textWith;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</span><br><span class=\"line\">        arrowCenterX -= textWidth / <span class=\"number\">2</span> + <span class=\"keyword\">self</span>.labelLeftInset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> arrowCenterY = <span class=\"keyword\">self</span>.mj_h * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> arrowCenter = <span class=\"built_in\">CGPointMake</span>(arrowCenterX, arrowCenterY);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 箭头</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.arrowView.constraints.count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.arrowView.mj_size = <span class=\"keyword\">self</span>.arrowView.image.size;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.arrowView.center = arrowCenter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// 圈圈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.loadingView.constraints.count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.loadingView.center = arrowCenter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.arrowView.tintColor = <span class=\"keyword\">self</span>.stateLabel.textColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>willMoveToSuperview</strong> 方法中还添加了监听，监听 <strong>UIScrollView</strong> 的 <strong>contentInset</strong> 和 <strong>contentOffset</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshComponent.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span> *)change context:(<span class=\"keyword\">void</span> *)context &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 遇到这些情况就直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.userInteractionEnabled) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 这个就算看不见也需要处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> scrollViewContentSizeDidChange:change];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 看不见</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.hidden) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> scrollViewContentOffsetDidChange:change];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> scrollViewPanStateDidChange:change];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshHeader.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewContentOffsetDidChange:(<span class=\"built_in\">NSDictionary</span> *)change &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> scrollViewContentOffsetDidChange:change];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在刷新的refreshing状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.state == MJRefreshStateRefreshing) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 暂时保留</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.window == <span class=\"literal\">nil</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// sectionheader停留解决</span></span><br><span class=\"line\">        <span class=\"built_in\">CGFloat</span> insetT = - <span class=\"keyword\">self</span>.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - <span class=\"keyword\">self</span>.scrollView.mj_offsetY : _scrollViewOriginalInset.top;</span><br><span class=\"line\">        insetT = insetT &gt; <span class=\"keyword\">self</span>.mj_h + _scrollViewOriginalInset.top ? <span class=\"keyword\">self</span>.mj_h + _scrollViewOriginalInset.top : insetT;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.scrollView.mj_insetT = insetT;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">self</span>.insetTDelta = _scrollViewOriginalInset.top - insetT;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 跳转到下一个控制器时，contentInset可能会变</span></span><br><span class=\"line\">     _scrollViewOriginalInset = <span class=\"keyword\">self</span>.scrollView.mj_inset;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 当前的contentOffset</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> offsetY = <span class=\"keyword\">self</span>.scrollView.mj_offsetY;</span><br><span class=\"line\">    <span class=\"comment\">// 头部控件刚好出现的offsetY</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> happenOffsetY = - <span class=\"keyword\">self</span>.scrollViewOriginalInset.top;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果是向上滚动到看不见头部控件，直接返回</span></span><br><span class=\"line\">    <span class=\"comment\">// &gt;= -&gt; &gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offsetY &gt; happenOffsetY) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 普通 和 即将刷新 的临界点</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> normal2pullingOffsetY = happenOffsetY - <span class=\"keyword\">self</span>.mj_h;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> pullingPercent = (happenOffsetY - offsetY) / <span class=\"keyword\">self</span>.mj_h;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.scrollView.isDragging) &#123; <span class=\"comment\">// 如果正在拖拽</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pullingPercent = pullingPercent;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 转为即将刷新状态</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.state = MJRefreshStatePulling;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= normal2pullingOffsetY) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 转为普通状态</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.state = MJRefreshStateIdle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.state == MJRefreshStatePulling) &#123;<span class=\"comment\">// 即将刷新 &amp;&amp; 手松开</span></span><br><span class=\"line\">        <span class=\"comment\">// 开始刷新</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span> beginRefreshing];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pullingPercent &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pullingPercent = pullingPercent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆方法中根据 <strong>contentOffset</strong> 的位置计算刷新控件的状态更新控件的UI：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshComponent.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setState:(MJRefreshState)state &#123;</span><br><span class=\"line\">    _state = state;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 加入主队列的目的是等setState:方法调用完毕、设置完文字后再去布局子控件</span></span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setNeedsLayout];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MJRefreshHeader.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setState:(MJRefreshState)state &#123;</span><br><span class=\"line\">    MJRefreshCheckState</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 根据状态做事情</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state == MJRefreshStateIdle) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldState != MJRefreshStateRefreshing) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 保存刷新时间</span></span><br><span class=\"line\">        [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:[<span class=\"built_in\">NSDate</span> date] forKey:<span class=\"keyword\">self</span>.lastUpdatedTimeKey];</span><br><span class=\"line\">        [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] synchronize];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 恢复inset和offset</span></span><br><span class=\"line\">        [<span class=\"built_in\">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.scrollView.mj_insetT += <span class=\"keyword\">self</span>.insetTDelta;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 自动调整透明度</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.isAutomaticallyChangeAlpha) <span class=\"keyword\">self</span>.alpha = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">        &#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.pullingPercent = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.endRefreshingCompletionBlock) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.endRefreshingCompletionBlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == MJRefreshStateRefreshing) &#123;</span><br><span class=\"line\">         <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            [<span class=\"built_in\">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</span><br><span class=\"line\">                <span class=\"built_in\">CGFloat</span> top = <span class=\"keyword\">self</span>.scrollViewOriginalInset.top + <span class=\"keyword\">self</span>.mj_h;</span><br><span class=\"line\">                <span class=\"comment\">// 增加滚动区域top</span></span><br><span class=\"line\">                <span class=\"keyword\">self</span>.scrollView.mj_insetT = top;</span><br><span class=\"line\">                <span class=\"comment\">// 设置滚动位置</span></span><br><span class=\"line\">                <span class=\"built_in\">CGPoint</span> offset = <span class=\"keyword\">self</span>.scrollView.contentOffset;</span><br><span class=\"line\">                offset.y = -top;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.scrollView setContentOffset:offset animated:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">            &#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span> executeRefreshingCallback];</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">         &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果正在刷新，增大 contentInset ，让 Header 保留在屏幕上，执行 Callback 结束后恢复原来位置。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>从上面可以得出结论，可以看出来下拉刷新的过程大致是：<br>初始化下拉刷新控件 -&gt; 设置Frame，布局子控件 -&gt; 控件添加监听 -&gt; 监控contentOffset -&gt; 判断contentOffset并做出相应回调。</p>\n"},{"title":"AFNetworkReachabilityManager 监听网络状态（三）","date":"2016-12-31T09:55:59.000Z","_content":"\n## 前言\n最近公司项目赶进度，博客更新的不勤，AFNetworking源码一直也没有时间看。今天看一下 AFNetworkReachabilityManager 这个网络监听类。\n\nAFNetworkReachabilityManager 是对 **SystemConfiguration** 网络模块的封装，苹果其实也有个监听网络状态的开源项目 [Reachability](https://developer.apple.com/library/content/samplecode/Reachability/Introduction/Intro.html)，不过它们的实现都是类似的。\n\n## AFNetworkReachabilityManager\n\nAFURLSessionManager 对网络状态的监控是由 AFNetworkReachabilityManager 来负责的，它仅仅是持有一个 AFNetworkReachabilityManager 的对象。\n\nAFNetworkReachabilityManager 可以用来做一些网络判断，比如一个直播的APP，非常耗费流量，有时候用户在不知不觉中使用了3G/4G来看，这样用户估计会把这个APP给删了，那么在用户点击某个直播时候，提示用户一下，他正在使用3G/4G，或者有个开关直接来设置只允许在WiFi下看直播。\n\nAFNetworkReachabilityManager 的使用很简单：\n\n```objc\n// 1.初始化AFNetworkReachabilityManager，获取单例\nAFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];\n// 2.设置networkReachabilityStatusBlock，根据不同网络状态，用户自定义处理方式\n[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {\n    NSLog(@\"network status '%@'\", AFStringFromNetworkReachabilityStatus(status));\n}];\n// 3.启动网络监听\n[manager startMonitoring];\n```\n\n## 初始化 AFNetworkReachabilityManager\n\nAFNetworkReachabilityManager 的初始化可以参考这张图，一步一步看它的调用就可以知道：\n{% asset_img Snip20170125_3.png AFURLSessionManagerTaskDelegate-NSURLSession %}\n\n其中有个参数 **SCNetworkReachabilityRef** 是监听网络的句柄，它在两个初始化方法中会被创建：\n\n```objc\n+ (instancetype)managerForDomain:(NSString *)domain {\n    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);\n\n    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];\n    \n    CFRelease(reachability);\n\n    return manager;\n}\n\n+ (instancetype)managerForAddress:(const void *)address {\n    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr *)address);\n    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];\n\n    CFRelease(reachability);\n    \n    return manager;\n}\n```\n\n1. 这两个方法一个通过**域名**，另一个通过**sockaddr_in6**生成一个 SCNetworkReachabilityRef\n2. 调用**- [AFNetworkReachabilityManager initWithReachability:]**方法把生成的SCNetworkReachabilityRef 引用传递给 **networkReachability**\n3. 设置默认的网络状态 networkReachabilityStatus\n\n```objc\n- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n\n    _networkReachability = CFRetain(reachability);\n    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;\n\n    return self;\n}\n```\n\n## 启动网络监听\n\n初始化完成 AFNetworkReachabilityManager 后，可以开始监听网络状态。\n\n```objc\n- (void)startMonitoring {\n    // 先停止之前的监听\n    [self stopMonitoring];\n    // networkReachability表示的是需要检测的网络地址的句柄\n    if (!self.networkReachability) {\n        return;\n    }\n\n    __weak __typeof(self)weakSelf = self;\n    // networkReachabilityStatusBlock 就是设置的回调block\n    // 创建每次网络状态改变的回调\n    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {\n        __strong __typeof(weakSelf)strongSelf = weakSelf;\n        // 每次回调被调用时重新设置 networkReachabilityStatus\n        strongSelf.networkReachabilityStatus = status;\n        // 调用 networkReachabilityStatusBlock\n        if (strongSelf.networkReachabilityStatusBlock) {\n            strongSelf.networkReachabilityStatusBlock(status);\n        }\n\n    };\n    \n    // 创建网络状态结构体，之后会说明\n    SCNetworkReachabilityContext context = {0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL};\n    // 当网络状态改变时，会调用传入的回调\n    SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &context);\n    // 在main RunLoop中以kCFRunLoopCommonModes形式处理self.networkingReachability\n    SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);\n\n    // 创建子线程，在后台获取当前的 self.networkReachability 的网络状态，调用callback\n  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^{\n        SCNetworkReachabilityFlags flags;\n        if (SCNetworkReachabilityGetFlags(self.networkReachability, &flags)) {\n            // AFPostReachabilityStatusChange函数就是先将flags转化为对应的AFNetworkReachabilityStatus变量，然后给我们的callback处理，后面会详解此函数\n            AFPostReachabilityStatusChange(flags, callback);\n        }\n    });\n}\n```\n\n### 创建一个 SCNetworkReachabilityContext\n\n```objc\ntypedef struct {\n\tCFIndex\t\tversion;\n\tvoid *\t\t__nullable info;\n\tconst void\t* __nonnull (* __nullable retain)(const void *info);\n\tvoid\t\t(* __nullable release)(const void *info);\n\tCFStringRef\t__nonnull (* __nullable copyDescription)(const void *info);\n} SCNetworkReachabilityContext;\n\nSCNetworkReachabilityContext context = {\n    0,\n    (__bridge void *)callback,\n    AFNetworkReachabilityRetainCallback, \n    AFNetworkReachabilityReleaseCallback, \n    NULL\n};\n```\n\n* callback 就是上一步创建的 AFNetworkReachabilityStatusBlock\n* AFNetworkReachabilityRetainCallback 和 AFNetworkReachabilityReleaseCallback 都只是对 block 使用 `Block_copy` 和 `Block_release`，传入的 info 会以参数的形式在 AFNetworkReachabilityCallback 执行时传入\n\n\n\n\n## 设置 networkReachabilityStatusBlock 以及回调\n在 Main RunLoop 中对网络状态进行监控扣，每次网络状态改变，都会调用 **AFNetworkReachabilityCallback**\n\n```objc\nstatic void AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, void *info) {\n    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);\n}\n```\n这里会从 info 中取出之前存在 context 中的 **AFNetworkReachabilityStatusBlock**。\n\n取出 block 后，调用 **AFPostReachabilityStatusChange** 方法，传入 block。\n\n### AFPostReachabilityStatusChange\n```objc\nstatic void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) {\n    // 使用AFNetworkReachabilityStatusForFlags函数获取当前网络可达性，将flags转化为status，提供给下面block使用\n    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);\n    dispatch_async(dispatch_get_main_queue(), ^{\n        if (block) {\n            block(status);\n        }\n        // 发出一个网络状态变化的通知，对于用户，可以使用KVO来监听status的变化，用户可以在userInfo[AFNetworkingReachabilityNotificationStatusItem]中获取相应的status\n        NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];\n        NSDictionary *userInfo = @{ AFNetworkingReachabilityNotificationStatusItem: @(status) };\n        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo];\n    });\n}\n```\n\n### AFNetworkReachabilityStatusForFlags\n因为 flags 是 SCNetworkReachabilityFlags，它的不同位代表了不同的网络可达性状态，通过 flags 的位操作，获取当前的状态信息 AFNetworkReachabilityStatus。\n\n```objc\nstatic AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) {\n    // 该网络地址可达\n    BOOL isReachable = ((flags & kSCNetworkReachabilityFlagsReachable) != 0);\n    // 该网络地址虽然可达，但是需要先建立一个connection\n    BOOL needsConnection = ((flags & kSCNetworkReachabilityFlagsConnectionRequired) != 0);\n    // 该网络虽然也需要先建立一个connection，但是它是可以自动去connect的\n    BOOL canConnectionAutomatically = (((flags & kSCNetworkReachabilityFlagsConnectionOnDemand ) != 0) || ((flags & kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0));\n    // 不需要用户交互，就可以connect上（用户交互一般指的是提供网络的账户和密码）\n    BOOL canConnectWithoutUserInteraction = (canConnectionAutomatically && (flags & kSCNetworkReachabilityFlagsInterventionRequired) == 0);\n    // 如果isReachable==YES，那么就需要判断是不是得先建立一个connection，如果需要，那就认为不可达，或者虽然需要先建立一个connection，但是不需要用户交互，那么认为也是可达的\n    BOOL isNetworkReachable = (isReachable && (!needsConnection || canConnectWithoutUserInteraction));\n    \n    // AFNetworkReachabilityStatus 的四种状态根据字面意思很好理解\n    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;\n    if (isNetworkReachable == NO) {\n        status = AFNetworkReachabilityStatusNotReachable;\n    }\n#if\tTARGET_OS_IPHONE\n    else if ((flags & kSCNetworkReachabilityFlagsIsWWAN) != 0) {\n        status = AFNetworkReachabilityStatusReachableViaWWAN;\n    }\n#endif\n    else {\n        status = AFNetworkReachabilityStatusReachableViaWiFi;\n    }\n\n    return status;\n}\n\n```\n\n## 与 AFNetworking 关联\nAFNetworkReachabilityManager 与 整个框架无太大耦合，在 AFURLSessionManager 中也只是持有一个 AFNetworkReachabilityManager 对象。\n\n```objc\nself.reachabilityManager = [AFNetworkReachabilityManager sharedManager];\n```\n\n搜索整个工程，除了 AFNetworkReachabilityManager.h/m 文件，只有在 AFURLSessionManager 中唯一引用了这个类。\n\n## 总结\n1. AFNetworkReachabilityManager 是对底层 SystemConfiguration 库网络状态获取的封装，对外提供了 Objective-C 的 API\n2. AFNetworkReachabilityManager是个即插即用的模块\n\n\n\n## 参考链接\n* [AFNetworking](https://github.com/AFNetworking/AFNetworking)\n* [AFNetworking源码阅读（六）](http://www.cnblogs.com/polobymulberry/p/5174298.html)\n* [AFNetworkReachabilityManager 监控网络状态（四）](https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/AFNetworkReachabilityManager%20%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%EF%BC%88%E5%9B%9B%EF%BC%89.md)\n\n\n","source":"_posts/AFNetworking-AFNetworkReachabilityManager-3.md","raw":"---\ntitle: AFNetworkReachabilityManager 监听网络状态（三）\ndate: 2016-12-31 17:55:59\ntags: AFNetworking\ncategory: Source Code Analyze\n---\n\n## 前言\n最近公司项目赶进度，博客更新的不勤，AFNetworking源码一直也没有时间看。今天看一下 AFNetworkReachabilityManager 这个网络监听类。\n\nAFNetworkReachabilityManager 是对 **SystemConfiguration** 网络模块的封装，苹果其实也有个监听网络状态的开源项目 [Reachability](https://developer.apple.com/library/content/samplecode/Reachability/Introduction/Intro.html)，不过它们的实现都是类似的。\n\n## AFNetworkReachabilityManager\n\nAFURLSessionManager 对网络状态的监控是由 AFNetworkReachabilityManager 来负责的，它仅仅是持有一个 AFNetworkReachabilityManager 的对象。\n\nAFNetworkReachabilityManager 可以用来做一些网络判断，比如一个直播的APP，非常耗费流量，有时候用户在不知不觉中使用了3G/4G来看，这样用户估计会把这个APP给删了，那么在用户点击某个直播时候，提示用户一下，他正在使用3G/4G，或者有个开关直接来设置只允许在WiFi下看直播。\n\nAFNetworkReachabilityManager 的使用很简单：\n\n```objc\n// 1.初始化AFNetworkReachabilityManager，获取单例\nAFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];\n// 2.设置networkReachabilityStatusBlock，根据不同网络状态，用户自定义处理方式\n[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {\n    NSLog(@\"network status '%@'\", AFStringFromNetworkReachabilityStatus(status));\n}];\n// 3.启动网络监听\n[manager startMonitoring];\n```\n\n## 初始化 AFNetworkReachabilityManager\n\nAFNetworkReachabilityManager 的初始化可以参考这张图，一步一步看它的调用就可以知道：\n{% asset_img Snip20170125_3.png AFURLSessionManagerTaskDelegate-NSURLSession %}\n\n其中有个参数 **SCNetworkReachabilityRef** 是监听网络的句柄，它在两个初始化方法中会被创建：\n\n```objc\n+ (instancetype)managerForDomain:(NSString *)domain {\n    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);\n\n    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];\n    \n    CFRelease(reachability);\n\n    return manager;\n}\n\n+ (instancetype)managerForAddress:(const void *)address {\n    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr *)address);\n    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];\n\n    CFRelease(reachability);\n    \n    return manager;\n}\n```\n\n1. 这两个方法一个通过**域名**，另一个通过**sockaddr_in6**生成一个 SCNetworkReachabilityRef\n2. 调用**- [AFNetworkReachabilityManager initWithReachability:]**方法把生成的SCNetworkReachabilityRef 引用传递给 **networkReachability**\n3. 设置默认的网络状态 networkReachabilityStatus\n\n```objc\n- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n\n    _networkReachability = CFRetain(reachability);\n    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;\n\n    return self;\n}\n```\n\n## 启动网络监听\n\n初始化完成 AFNetworkReachabilityManager 后，可以开始监听网络状态。\n\n```objc\n- (void)startMonitoring {\n    // 先停止之前的监听\n    [self stopMonitoring];\n    // networkReachability表示的是需要检测的网络地址的句柄\n    if (!self.networkReachability) {\n        return;\n    }\n\n    __weak __typeof(self)weakSelf = self;\n    // networkReachabilityStatusBlock 就是设置的回调block\n    // 创建每次网络状态改变的回调\n    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {\n        __strong __typeof(weakSelf)strongSelf = weakSelf;\n        // 每次回调被调用时重新设置 networkReachabilityStatus\n        strongSelf.networkReachabilityStatus = status;\n        // 调用 networkReachabilityStatusBlock\n        if (strongSelf.networkReachabilityStatusBlock) {\n            strongSelf.networkReachabilityStatusBlock(status);\n        }\n\n    };\n    \n    // 创建网络状态结构体，之后会说明\n    SCNetworkReachabilityContext context = {0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL};\n    // 当网络状态改变时，会调用传入的回调\n    SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &context);\n    // 在main RunLoop中以kCFRunLoopCommonModes形式处理self.networkingReachability\n    SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);\n\n    // 创建子线程，在后台获取当前的 self.networkReachability 的网络状态，调用callback\n  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^{\n        SCNetworkReachabilityFlags flags;\n        if (SCNetworkReachabilityGetFlags(self.networkReachability, &flags)) {\n            // AFPostReachabilityStatusChange函数就是先将flags转化为对应的AFNetworkReachabilityStatus变量，然后给我们的callback处理，后面会详解此函数\n            AFPostReachabilityStatusChange(flags, callback);\n        }\n    });\n}\n```\n\n### 创建一个 SCNetworkReachabilityContext\n\n```objc\ntypedef struct {\n\tCFIndex\t\tversion;\n\tvoid *\t\t__nullable info;\n\tconst void\t* __nonnull (* __nullable retain)(const void *info);\n\tvoid\t\t(* __nullable release)(const void *info);\n\tCFStringRef\t__nonnull (* __nullable copyDescription)(const void *info);\n} SCNetworkReachabilityContext;\n\nSCNetworkReachabilityContext context = {\n    0,\n    (__bridge void *)callback,\n    AFNetworkReachabilityRetainCallback, \n    AFNetworkReachabilityReleaseCallback, \n    NULL\n};\n```\n\n* callback 就是上一步创建的 AFNetworkReachabilityStatusBlock\n* AFNetworkReachabilityRetainCallback 和 AFNetworkReachabilityReleaseCallback 都只是对 block 使用 `Block_copy` 和 `Block_release`，传入的 info 会以参数的形式在 AFNetworkReachabilityCallback 执行时传入\n\n\n\n\n## 设置 networkReachabilityStatusBlock 以及回调\n在 Main RunLoop 中对网络状态进行监控扣，每次网络状态改变，都会调用 **AFNetworkReachabilityCallback**\n\n```objc\nstatic void AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, void *info) {\n    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);\n}\n```\n这里会从 info 中取出之前存在 context 中的 **AFNetworkReachabilityStatusBlock**。\n\n取出 block 后，调用 **AFPostReachabilityStatusChange** 方法，传入 block。\n\n### AFPostReachabilityStatusChange\n```objc\nstatic void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) {\n    // 使用AFNetworkReachabilityStatusForFlags函数获取当前网络可达性，将flags转化为status，提供给下面block使用\n    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);\n    dispatch_async(dispatch_get_main_queue(), ^{\n        if (block) {\n            block(status);\n        }\n        // 发出一个网络状态变化的通知，对于用户，可以使用KVO来监听status的变化，用户可以在userInfo[AFNetworkingReachabilityNotificationStatusItem]中获取相应的status\n        NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];\n        NSDictionary *userInfo = @{ AFNetworkingReachabilityNotificationStatusItem: @(status) };\n        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo];\n    });\n}\n```\n\n### AFNetworkReachabilityStatusForFlags\n因为 flags 是 SCNetworkReachabilityFlags，它的不同位代表了不同的网络可达性状态，通过 flags 的位操作，获取当前的状态信息 AFNetworkReachabilityStatus。\n\n```objc\nstatic AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) {\n    // 该网络地址可达\n    BOOL isReachable = ((flags & kSCNetworkReachabilityFlagsReachable) != 0);\n    // 该网络地址虽然可达，但是需要先建立一个connection\n    BOOL needsConnection = ((flags & kSCNetworkReachabilityFlagsConnectionRequired) != 0);\n    // 该网络虽然也需要先建立一个connection，但是它是可以自动去connect的\n    BOOL canConnectionAutomatically = (((flags & kSCNetworkReachabilityFlagsConnectionOnDemand ) != 0) || ((flags & kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0));\n    // 不需要用户交互，就可以connect上（用户交互一般指的是提供网络的账户和密码）\n    BOOL canConnectWithoutUserInteraction = (canConnectionAutomatically && (flags & kSCNetworkReachabilityFlagsInterventionRequired) == 0);\n    // 如果isReachable==YES，那么就需要判断是不是得先建立一个connection，如果需要，那就认为不可达，或者虽然需要先建立一个connection，但是不需要用户交互，那么认为也是可达的\n    BOOL isNetworkReachable = (isReachable && (!needsConnection || canConnectWithoutUserInteraction));\n    \n    // AFNetworkReachabilityStatus 的四种状态根据字面意思很好理解\n    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;\n    if (isNetworkReachable == NO) {\n        status = AFNetworkReachabilityStatusNotReachable;\n    }\n#if\tTARGET_OS_IPHONE\n    else if ((flags & kSCNetworkReachabilityFlagsIsWWAN) != 0) {\n        status = AFNetworkReachabilityStatusReachableViaWWAN;\n    }\n#endif\n    else {\n        status = AFNetworkReachabilityStatusReachableViaWiFi;\n    }\n\n    return status;\n}\n\n```\n\n## 与 AFNetworking 关联\nAFNetworkReachabilityManager 与 整个框架无太大耦合，在 AFURLSessionManager 中也只是持有一个 AFNetworkReachabilityManager 对象。\n\n```objc\nself.reachabilityManager = [AFNetworkReachabilityManager sharedManager];\n```\n\n搜索整个工程，除了 AFNetworkReachabilityManager.h/m 文件，只有在 AFURLSessionManager 中唯一引用了这个类。\n\n## 总结\n1. AFNetworkReachabilityManager 是对底层 SystemConfiguration 库网络状态获取的封装，对外提供了 Objective-C 的 API\n2. AFNetworkReachabilityManager是个即插即用的模块\n\n\n\n## 参考链接\n* [AFNetworking](https://github.com/AFNetworking/AFNetworking)\n* [AFNetworking源码阅读（六）](http://www.cnblogs.com/polobymulberry/p/5174298.html)\n* [AFNetworkReachabilityManager 监控网络状态（四）](https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/AFNetworkReachabilityManager%20%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%EF%BC%88%E5%9B%9B%EF%BC%89.md)\n\n\n","slug":"AFNetworking-AFNetworkReachabilityManager-3","published":1,"updated":"2017-01-26T03:47:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7ns003v8jpb39vluf73","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近公司项目赶进度，博客更新的不勤，AFNetworking源码一直也没有时间看。今天看一下 AFNetworkReachabilityManager 这个网络监听类。</p>\n<p>AFNetworkReachabilityManager 是对 <strong>SystemConfiguration</strong> 网络模块的封装，苹果其实也有个监听网络状态的开源项目 <a href=\"https://developer.apple.com/library/content/samplecode/Reachability/Introduction/Intro.html\" target=\"_blank\" rel=\"noopener\">Reachability</a>，不过它们的实现都是类似的。</p>\n<h2 id=\"AFNetworkReachabilityManager\"><a href=\"#AFNetworkReachabilityManager\" class=\"headerlink\" title=\"AFNetworkReachabilityManager\"></a>AFNetworkReachabilityManager</h2><p>AFURLSessionManager 对网络状态的监控是由 AFNetworkReachabilityManager 来负责的，它仅仅是持有一个 AFNetworkReachabilityManager 的对象。</p>\n<p>AFNetworkReachabilityManager 可以用来做一些网络判断，比如一个直播的APP，非常耗费流量，有时候用户在不知不觉中使用了3G/4G来看，这样用户估计会把这个APP给删了，那么在用户点击某个直播时候，提示用户一下，他正在使用3G/4G，或者有个开关直接来设置只允许在WiFi下看直播。</p>\n<p>AFNetworkReachabilityManager 的使用很简单：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.初始化AFNetworkReachabilityManager，获取单例</span></span><br><span class=\"line\">AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];</span><br><span class=\"line\"><span class=\"comment\">// 2.设置networkReachabilityStatusBlock，根据不同网络状态，用户自定义处理方式</span></span><br><span class=\"line\">[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"network status '%@'\"</span>, AFStringFromNetworkReachabilityStatus(status));</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"comment\">// 3.启动网络监听</span></span><br><span class=\"line\">[manager startMonitoring];</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化-AFNetworkReachabilityManager\"><a href=\"#初始化-AFNetworkReachabilityManager\" class=\"headerlink\" title=\"初始化 AFNetworkReachabilityManager\"></a>初始化 AFNetworkReachabilityManager</h2><p>AFNetworkReachabilityManager 的初始化可以参考这张图，一步一步看它的调用就可以知道：<br><img src=\"/2016/12/31/AFNetworking-AFNetworkReachabilityManager-3/Snip20170125_3.png\" title=\"AFURLSessionManagerTaskDelegate-NSURLSession\"></p>\n<p>其中有个参数 <strong>SCNetworkReachabilityRef</strong> 是监听网络的句柄，它在两个初始化方法中会被创建：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)managerForDomain:(<span class=\"built_in\">NSString</span> *)domain &#123;</span><br><span class=\"line\">    <span class=\"built_in\">SCNetworkReachabilityRef</span> reachability = <span class=\"built_in\">SCNetworkReachabilityCreateWithName</span>(kCFAllocatorDefault, [domain UTF8String]);</span><br><span class=\"line\"></span><br><span class=\"line\">    AFNetworkReachabilityManager *manager = [[<span class=\"keyword\">self</span> alloc] initWithReachability:reachability];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(reachability);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> manager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)managerForAddress:(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)address &#123;</span><br><span class=\"line\">    <span class=\"built_in\">SCNetworkReachabilityRef</span> reachability = <span class=\"built_in\">SCNetworkReachabilityCreateWithAddress</span>(kCFAllocatorDefault, (<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> sockaddr *)address);</span><br><span class=\"line\">    AFNetworkReachabilityManager *manager = [[<span class=\"keyword\">self</span> alloc] initWithReachability:reachability];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(reachability);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> manager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>这两个方法一个通过<strong>域名</strong>，另一个通过<strong>sockaddr_in6</strong>生成一个 SCNetworkReachabilityRef</li>\n<li>调用<strong>- [AFNetworkReachabilityManager initWithReachability:]</strong>方法把生成的SCNetworkReachabilityRef 引用传递给 <strong>networkReachability</strong></li>\n<li>设置默认的网络状态 networkReachabilityStatus</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithReachability:(<span class=\"built_in\">SCNetworkReachabilityRef</span>)reachability &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _networkReachability = <span class=\"built_in\">CFRetain</span>(reachability);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动网络监听\"><a href=\"#启动网络监听\" class=\"headerlink\" title=\"启动网络监听\"></a>启动网络监听</h2><p>初始化完成 AFNetworkReachabilityManager 后，可以开始监听网络状态。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)startMonitoring &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先停止之前的监听</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> stopMonitoring];</span><br><span class=\"line\">    <span class=\"comment\">// networkReachability表示的是需要检测的网络地址的句柄</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.networkReachability) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> __<span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>)weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"comment\">// networkReachabilityStatusBlock 就是设置的回调block</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建每次网络状态改变的回调</span></span><br><span class=\"line\">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class=\"line\">        __<span class=\"keyword\">strong</span> __<span class=\"keyword\">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class=\"line\">        <span class=\"comment\">// 每次回调被调用时重新设置 networkReachabilityStatus</span></span><br><span class=\"line\">        strongSelf.networkReachabilityStatus = status;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 networkReachabilityStatusBlock</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class=\"line\">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建网络状态结构体，之后会说明</span></span><br><span class=\"line\">    <span class=\"built_in\">SCNetworkReachabilityContext</span> context = &#123;<span class=\"number\">0</span>, (__bridge <span class=\"keyword\">void</span> *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, <span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 当网络状态改变时，会调用传入的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">SCNetworkReachabilitySetCallback</span>(<span class=\"keyword\">self</span>.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class=\"line\">    <span class=\"comment\">// 在main RunLoop中以kCFRunLoopCommonModes形式处理self.networkingReachability</span></span><br><span class=\"line\">    <span class=\"built_in\">SCNetworkReachabilityScheduleWithRunLoop</span>(<span class=\"keyword\">self</span>.networkReachability, <span class=\"built_in\">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建子线程，在后台获取当前的 self.networkReachability 的网络状态，调用callback</span></span><br><span class=\"line\">  <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class=\"number\">0</span>),^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">SCNetworkReachabilityFlags</span> flags;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">SCNetworkReachabilityGetFlags</span>(<span class=\"keyword\">self</span>.networkReachability, &amp;flags)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// AFPostReachabilityStatusChange函数就是先将flags转化为对应的AFNetworkReachabilityStatus变量，然后给我们的callback处理，后面会详解此函数</span></span><br><span class=\"line\">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建一个-SCNetworkReachabilityContext\"><a href=\"#创建一个-SCNetworkReachabilityContext\" class=\"headerlink\" title=\"创建一个 SCNetworkReachabilityContext\"></a>创建一个 SCNetworkReachabilityContext</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">CFIndex</span>\t\tversion;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *\t\t__<span class=\"keyword\">nullable</span> info;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>\t* __<span class=\"keyword\">nonnull</span> (* __<span class=\"keyword\">nullable</span> <span class=\"keyword\">retain</span>)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *info);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t(* __<span class=\"keyword\">nullable</span> release)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *info);</span><br><span class=\"line\">\t<span class=\"built_in\">CFStringRef</span>\t__<span class=\"keyword\">nonnull</span> (* __<span class=\"keyword\">nullable</span> copyDescription)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *info);</span><br><span class=\"line\">&#125; <span class=\"built_in\">SCNetworkReachabilityContext</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">SCNetworkReachabilityContext</span> context = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    (__bridge <span class=\"keyword\">void</span> *)callback,</span><br><span class=\"line\">    AFNetworkReachabilityRetainCallback, </span><br><span class=\"line\">    AFNetworkReachabilityReleaseCallback, </span><br><span class=\"line\">    <span class=\"literal\">NULL</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>callback 就是上一步创建的 AFNetworkReachabilityStatusBlock</li>\n<li>AFNetworkReachabilityRetainCallback 和 AFNetworkReachabilityReleaseCallback 都只是对 block 使用 <code>Block_copy</code> 和 <code>Block_release</code>，传入的 info 会以参数的形式在 AFNetworkReachabilityCallback 执行时传入</li>\n</ul>\n<h2 id=\"设置-networkReachabilityStatusBlock-以及回调\"><a href=\"#设置-networkReachabilityStatusBlock-以及回调\" class=\"headerlink\" title=\"设置 networkReachabilityStatusBlock 以及回调\"></a>设置 networkReachabilityStatusBlock 以及回调</h2><p>在 Main RunLoop 中对网络状态进行监控扣，每次网络状态改变，都会调用 <strong>AFNetworkReachabilityCallback</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> AFNetworkReachabilityCallback(<span class=\"built_in\">SCNetworkReachabilityRef</span> __unused target, <span class=\"built_in\">SCNetworkReachabilityFlags</span> flags, <span class=\"keyword\">void</span> *info) &#123;</span><br><span class=\"line\">    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里会从 info 中取出之前存在 context 中的 <strong>AFNetworkReachabilityStatusBlock</strong>。</p>\n<p>取出 block 后，调用 <strong>AFPostReachabilityStatusChange</strong> 方法，传入 block。</p>\n<h3 id=\"AFPostReachabilityStatusChange\"><a href=\"#AFPostReachabilityStatusChange\" class=\"headerlink\" title=\"AFPostReachabilityStatusChange\"></a>AFPostReachabilityStatusChange</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> AFPostReachabilityStatusChange(<span class=\"built_in\">SCNetworkReachabilityFlags</span> flags, AFNetworkReachabilityStatusBlock block) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用AFNetworkReachabilityStatusForFlags函数获取当前网络可达性，将flags转化为status，提供给下面block使用</span></span><br><span class=\"line\">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (block) &#123;</span><br><span class=\"line\">            block(status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 发出一个网络状态变化的通知，对于用户，可以使用KVO来监听status的变化，用户可以在userInfo[AFNetworkingReachabilityNotificationStatusItem]中获取相应的status</span></span><br><span class=\"line\">        <span class=\"built_in\">NSNotificationCenter</span> *notificationCenter = [<span class=\"built_in\">NSNotificationCenter</span> defaultCenter];</span><br><span class=\"line\">        <span class=\"built_in\">NSDictionary</span> *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</span><br><span class=\"line\">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:<span class=\"literal\">nil</span> userInfo:userInfo];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AFNetworkReachabilityStatusForFlags\"><a href=\"#AFNetworkReachabilityStatusForFlags\" class=\"headerlink\" title=\"AFNetworkReachabilityStatusForFlags\"></a>AFNetworkReachabilityStatusForFlags</h3><p>因为 flags 是 SCNetworkReachabilityFlags，它的不同位代表了不同的网络可达性状态，通过 flags 的位操作，获取当前的状态信息 AFNetworkReachabilityStatus。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(<span class=\"built_in\">SCNetworkReachabilityFlags</span> flags) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该网络地址可达</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 该网络地址虽然可达，但是需要先建立一个connection</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 该网络虽然也需要先建立一个connection，但是它是可以自动去connect的</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> canConnectionAutomatically = (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != <span class=\"number\">0</span>) || ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 不需要用户交互，就可以connect上（用户交互一般指的是提供网络的账户和密码）</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 如果isReachable==YES，那么就需要判断是不是得先建立一个connection，如果需要，那就认为不可达，或者虽然需要先建立一个connection，但是不需要用户交互，那么认为也是可达的</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// AFNetworkReachabilityStatus 的四种状态根据字面意思很好理解</span></span><br><span class=\"line\">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isNetworkReachable == <span class=\"literal\">NO</span>) &#123;</span><br><span class=\"line\">        status = AFNetworkReachabilityStatusNotReachable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#if\tTARGET_OS_IPHONE</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        status = AFNetworkReachabilityStatusReachableViaWWAN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        status = AFNetworkReachabilityStatusReachableViaWiFi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> status;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"与-AFNetworking-关联\"><a href=\"#与-AFNetworking-关联\" class=\"headerlink\" title=\"与 AFNetworking 关联\"></a>与 AFNetworking 关联</h2><p>AFNetworkReachabilityManager 与 整个框架无太大耦合，在 AFURLSessionManager 中也只是持有一个 AFNetworkReachabilityManager 对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br></pre></td></tr></table></figure>\n<p>搜索整个工程，除了 AFNetworkReachabilityManager.h/m 文件，只有在 AFURLSessionManager 中唯一引用了这个类。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>AFNetworkReachabilityManager 是对底层 SystemConfiguration 库网络状态获取的封装，对外提供了 Objective-C 的 API</li>\n<li>AFNetworkReachabilityManager是个即插即用的模块</li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a></li>\n<li><a href=\"http://www.cnblogs.com/polobymulberry/p/5174298.html\" target=\"_blank\" rel=\"noopener\">AFNetworking源码阅读（六）</a></li>\n<li><a href=\"https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/AFNetworkReachabilityManager%20%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%EF%BC%88%E5%9B%9B%EF%BC%89.md\" target=\"_blank\" rel=\"noopener\">AFNetworkReachabilityManager 监控网络状态（四）</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近公司项目赶进度，博客更新的不勤，AFNetworking源码一直也没有时间看。今天看一下 AFNetworkReachabilityManager 这个网络监听类。</p>\n<p>AFNetworkReachabilityManager 是对 <strong>SystemConfiguration</strong> 网络模块的封装，苹果其实也有个监听网络状态的开源项目 <a href=\"https://developer.apple.com/library/content/samplecode/Reachability/Introduction/Intro.html\" target=\"_blank\" rel=\"noopener\">Reachability</a>，不过它们的实现都是类似的。</p>\n<h2 id=\"AFNetworkReachabilityManager\"><a href=\"#AFNetworkReachabilityManager\" class=\"headerlink\" title=\"AFNetworkReachabilityManager\"></a>AFNetworkReachabilityManager</h2><p>AFURLSessionManager 对网络状态的监控是由 AFNetworkReachabilityManager 来负责的，它仅仅是持有一个 AFNetworkReachabilityManager 的对象。</p>\n<p>AFNetworkReachabilityManager 可以用来做一些网络判断，比如一个直播的APP，非常耗费流量，有时候用户在不知不觉中使用了3G/4G来看，这样用户估计会把这个APP给删了，那么在用户点击某个直播时候，提示用户一下，他正在使用3G/4G，或者有个开关直接来设置只允许在WiFi下看直播。</p>\n<p>AFNetworkReachabilityManager 的使用很简单：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.初始化AFNetworkReachabilityManager，获取单例</span></span><br><span class=\"line\">AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];</span><br><span class=\"line\"><span class=\"comment\">// 2.设置networkReachabilityStatusBlock，根据不同网络状态，用户自定义处理方式</span></span><br><span class=\"line\">[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"network status '%@'\"</span>, AFStringFromNetworkReachabilityStatus(status));</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"comment\">// 3.启动网络监听</span></span><br><span class=\"line\">[manager startMonitoring];</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化-AFNetworkReachabilityManager\"><a href=\"#初始化-AFNetworkReachabilityManager\" class=\"headerlink\" title=\"初始化 AFNetworkReachabilityManager\"></a>初始化 AFNetworkReachabilityManager</h2><p>AFNetworkReachabilityManager 的初始化可以参考这张图，一步一步看它的调用就可以知道：<br><img src=\"/2016/12/31/AFNetworking-AFNetworkReachabilityManager-3/Snip20170125_3.png\" title=\"AFURLSessionManagerTaskDelegate-NSURLSession\"></p>\n<p>其中有个参数 <strong>SCNetworkReachabilityRef</strong> 是监听网络的句柄，它在两个初始化方法中会被创建：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)managerForDomain:(<span class=\"built_in\">NSString</span> *)domain &#123;</span><br><span class=\"line\">    <span class=\"built_in\">SCNetworkReachabilityRef</span> reachability = <span class=\"built_in\">SCNetworkReachabilityCreateWithName</span>(kCFAllocatorDefault, [domain UTF8String]);</span><br><span class=\"line\"></span><br><span class=\"line\">    AFNetworkReachabilityManager *manager = [[<span class=\"keyword\">self</span> alloc] initWithReachability:reachability];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(reachability);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> manager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)managerForAddress:(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)address &#123;</span><br><span class=\"line\">    <span class=\"built_in\">SCNetworkReachabilityRef</span> reachability = <span class=\"built_in\">SCNetworkReachabilityCreateWithAddress</span>(kCFAllocatorDefault, (<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> sockaddr *)address);</span><br><span class=\"line\">    AFNetworkReachabilityManager *manager = [[<span class=\"keyword\">self</span> alloc] initWithReachability:reachability];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(reachability);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> manager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>这两个方法一个通过<strong>域名</strong>，另一个通过<strong>sockaddr_in6</strong>生成一个 SCNetworkReachabilityRef</li>\n<li>调用<strong>- [AFNetworkReachabilityManager initWithReachability:]</strong>方法把生成的SCNetworkReachabilityRef 引用传递给 <strong>networkReachability</strong></li>\n<li>设置默认的网络状态 networkReachabilityStatus</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithReachability:(<span class=\"built_in\">SCNetworkReachabilityRef</span>)reachability &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _networkReachability = <span class=\"built_in\">CFRetain</span>(reachability);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动网络监听\"><a href=\"#启动网络监听\" class=\"headerlink\" title=\"启动网络监听\"></a>启动网络监听</h2><p>初始化完成 AFNetworkReachabilityManager 后，可以开始监听网络状态。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)startMonitoring &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先停止之前的监听</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> stopMonitoring];</span><br><span class=\"line\">    <span class=\"comment\">// networkReachability表示的是需要检测的网络地址的句柄</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.networkReachability) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> __<span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>)weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"comment\">// networkReachabilityStatusBlock 就是设置的回调block</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建每次网络状态改变的回调</span></span><br><span class=\"line\">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class=\"line\">        __<span class=\"keyword\">strong</span> __<span class=\"keyword\">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class=\"line\">        <span class=\"comment\">// 每次回调被调用时重新设置 networkReachabilityStatus</span></span><br><span class=\"line\">        strongSelf.networkReachabilityStatus = status;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 networkReachabilityStatusBlock</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class=\"line\">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建网络状态结构体，之后会说明</span></span><br><span class=\"line\">    <span class=\"built_in\">SCNetworkReachabilityContext</span> context = &#123;<span class=\"number\">0</span>, (__bridge <span class=\"keyword\">void</span> *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, <span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 当网络状态改变时，会调用传入的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">SCNetworkReachabilitySetCallback</span>(<span class=\"keyword\">self</span>.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class=\"line\">    <span class=\"comment\">// 在main RunLoop中以kCFRunLoopCommonModes形式处理self.networkingReachability</span></span><br><span class=\"line\">    <span class=\"built_in\">SCNetworkReachabilityScheduleWithRunLoop</span>(<span class=\"keyword\">self</span>.networkReachability, <span class=\"built_in\">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建子线程，在后台获取当前的 self.networkReachability 的网络状态，调用callback</span></span><br><span class=\"line\">  <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class=\"number\">0</span>),^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">SCNetworkReachabilityFlags</span> flags;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">SCNetworkReachabilityGetFlags</span>(<span class=\"keyword\">self</span>.networkReachability, &amp;flags)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// AFPostReachabilityStatusChange函数就是先将flags转化为对应的AFNetworkReachabilityStatus变量，然后给我们的callback处理，后面会详解此函数</span></span><br><span class=\"line\">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建一个-SCNetworkReachabilityContext\"><a href=\"#创建一个-SCNetworkReachabilityContext\" class=\"headerlink\" title=\"创建一个 SCNetworkReachabilityContext\"></a>创建一个 SCNetworkReachabilityContext</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">CFIndex</span>\t\tversion;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *\t\t__<span class=\"keyword\">nullable</span> info;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>\t* __<span class=\"keyword\">nonnull</span> (* __<span class=\"keyword\">nullable</span> <span class=\"keyword\">retain</span>)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *info);</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>\t\t(* __<span class=\"keyword\">nullable</span> release)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *info);</span><br><span class=\"line\">\t<span class=\"built_in\">CFStringRef</span>\t__<span class=\"keyword\">nonnull</span> (* __<span class=\"keyword\">nullable</span> copyDescription)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *info);</span><br><span class=\"line\">&#125; <span class=\"built_in\">SCNetworkReachabilityContext</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">SCNetworkReachabilityContext</span> context = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    (__bridge <span class=\"keyword\">void</span> *)callback,</span><br><span class=\"line\">    AFNetworkReachabilityRetainCallback, </span><br><span class=\"line\">    AFNetworkReachabilityReleaseCallback, </span><br><span class=\"line\">    <span class=\"literal\">NULL</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>callback 就是上一步创建的 AFNetworkReachabilityStatusBlock</li>\n<li>AFNetworkReachabilityRetainCallback 和 AFNetworkReachabilityReleaseCallback 都只是对 block 使用 <code>Block_copy</code> 和 <code>Block_release</code>，传入的 info 会以参数的形式在 AFNetworkReachabilityCallback 执行时传入</li>\n</ul>\n<h2 id=\"设置-networkReachabilityStatusBlock-以及回调\"><a href=\"#设置-networkReachabilityStatusBlock-以及回调\" class=\"headerlink\" title=\"设置 networkReachabilityStatusBlock 以及回调\"></a>设置 networkReachabilityStatusBlock 以及回调</h2><p>在 Main RunLoop 中对网络状态进行监控扣，每次网络状态改变，都会调用 <strong>AFNetworkReachabilityCallback</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> AFNetworkReachabilityCallback(<span class=\"built_in\">SCNetworkReachabilityRef</span> __unused target, <span class=\"built_in\">SCNetworkReachabilityFlags</span> flags, <span class=\"keyword\">void</span> *info) &#123;</span><br><span class=\"line\">    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里会从 info 中取出之前存在 context 中的 <strong>AFNetworkReachabilityStatusBlock</strong>。</p>\n<p>取出 block 后，调用 <strong>AFPostReachabilityStatusChange</strong> 方法，传入 block。</p>\n<h3 id=\"AFPostReachabilityStatusChange\"><a href=\"#AFPostReachabilityStatusChange\" class=\"headerlink\" title=\"AFPostReachabilityStatusChange\"></a>AFPostReachabilityStatusChange</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> AFPostReachabilityStatusChange(<span class=\"built_in\">SCNetworkReachabilityFlags</span> flags, AFNetworkReachabilityStatusBlock block) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用AFNetworkReachabilityStatusForFlags函数获取当前网络可达性，将flags转化为status，提供给下面block使用</span></span><br><span class=\"line\">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (block) &#123;</span><br><span class=\"line\">            block(status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 发出一个网络状态变化的通知，对于用户，可以使用KVO来监听status的变化，用户可以在userInfo[AFNetworkingReachabilityNotificationStatusItem]中获取相应的status</span></span><br><span class=\"line\">        <span class=\"built_in\">NSNotificationCenter</span> *notificationCenter = [<span class=\"built_in\">NSNotificationCenter</span> defaultCenter];</span><br><span class=\"line\">        <span class=\"built_in\">NSDictionary</span> *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</span><br><span class=\"line\">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:<span class=\"literal\">nil</span> userInfo:userInfo];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AFNetworkReachabilityStatusForFlags\"><a href=\"#AFNetworkReachabilityStatusForFlags\" class=\"headerlink\" title=\"AFNetworkReachabilityStatusForFlags\"></a>AFNetworkReachabilityStatusForFlags</h3><p>因为 flags 是 SCNetworkReachabilityFlags，它的不同位代表了不同的网络可达性状态，通过 flags 的位操作，获取当前的状态信息 AFNetworkReachabilityStatus。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(<span class=\"built_in\">SCNetworkReachabilityFlags</span> flags) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该网络地址可达</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 该网络地址虽然可达，但是需要先建立一个connection</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 该网络虽然也需要先建立一个connection，但是它是可以自动去connect的</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> canConnectionAutomatically = (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != <span class=\"number\">0</span>) || ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 不需要用户交互，就可以connect上（用户交互一般指的是提供网络的账户和密码）</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 如果isReachable==YES，那么就需要判断是不是得先建立一个connection，如果需要，那就认为不可达，或者虽然需要先建立一个connection，但是不需要用户交互，那么认为也是可达的</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// AFNetworkReachabilityStatus 的四种状态根据字面意思很好理解</span></span><br><span class=\"line\">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isNetworkReachable == <span class=\"literal\">NO</span>) &#123;</span><br><span class=\"line\">        status = AFNetworkReachabilityStatusNotReachable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#if\tTARGET_OS_IPHONE</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        status = AFNetworkReachabilityStatusReachableViaWWAN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        status = AFNetworkReachabilityStatusReachableViaWiFi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> status;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"与-AFNetworking-关联\"><a href=\"#与-AFNetworking-关联\" class=\"headerlink\" title=\"与 AFNetworking 关联\"></a>与 AFNetworking 关联</h2><p>AFNetworkReachabilityManager 与 整个框架无太大耦合，在 AFURLSessionManager 中也只是持有一个 AFNetworkReachabilityManager 对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br></pre></td></tr></table></figure>\n<p>搜索整个工程，除了 AFNetworkReachabilityManager.h/m 文件，只有在 AFURLSessionManager 中唯一引用了这个类。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>AFNetworkReachabilityManager 是对底层 SystemConfiguration 库网络状态获取的封装，对外提供了 Objective-C 的 API</li>\n<li>AFNetworkReachabilityManager是个即插即用的模块</li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a></li>\n<li><a href=\"http://www.cnblogs.com/polobymulberry/p/5174298.html\" target=\"_blank\" rel=\"noopener\">AFNetworking源码阅读（六）</a></li>\n<li><a href=\"https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/AFNetworkReachabilityManager%20%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%EF%BC%88%E5%9B%9B%EF%BC%89.md\" target=\"_blank\" rel=\"noopener\">AFNetworkReachabilityManager 监控网络状态（四）</a></li>\n</ul>\n"},{"title":"AFSecurityPolicy 网络安全策略（五）","date":"2017-01-26T01:56:17.000Z","_content":"\n## 前言\n终于放假了，回到家，准备过年，乘着年前把 AFNetworking 源码阅读的最后一篇po出来。\n\n这一篇分析下 AFSecurityPolicy 文件，看看AFNetworking的网络安全策略，特别的是苹果强制要求2017年全部APP支持 HTTPS 后（由于各种原因推迟了），不了解 HTTPS 的可以看下\n\n* [《写给 iOS 开发者看的 HTTPS 指南》](https://autolayout.club/2016/12/22/%E5%86%99%E7%BB%99-iOS-%E5%BC%80%E5%8F%91%E8%80%85%E7%9C%8B%E7%9A%84-HTTPS-%E6%8C%87%E5%8D%97/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io) \n* [《iOS安全系列之一：HTTPS》](http://oncenote.com/2014/10/21/Security-1-HTTPS/)\n\nAFSecurityPolicy 的主要作用就是验证 HTTPS 请求的证书是否有效，如果 app 中有敏感的信息或者资金流动的信息，一定要使用 HTTPS 来保证交易的信息安全。\n\n## AFSSLPinningMode\n\n首先一眼看到的是 **AFSSLPinningMode** ，验证服务器是否被信任的三种模式：\n\n```objc\ntypedef NS_ENUM(NSUInteger, AFSSLPinningMode) {\n    AFSSLPinningModeNone,\n    AFSSLPinningModePublicKey,\n    AFSSLPinningModeCertificate,\n};\n```\n\n* AFSSLPinningModeNone: 表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。\n* AFSSLPinningModePublicKey: 用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。\n* AFSSLPinningModeCertificate: 也是用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。\n\n## 初始化\n使用前，需要先初始化使用哪种验证方式：\n\n```objc\n+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode {\n    return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];\n}\n\n+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates {\n    AFSecurityPolicy *securityPolicy = [[self alloc] init];\n    securityPolicy.SSLPinningMode = pinningMode;\n\n    [securityPolicy setPinnedCertificates:pinnedCertificates];\n\n    return securityPolicy;\n}\n\n```\n\n从证书里面取出公钥，保存在 **pinnedPublicKeys**\n```objc\n- (void)setPinnedCertificates:(NSSet *)pinnedCertificates {\n    _pinnedCertificates = pinnedCertificates;\n\n    if (self.pinnedCertificates) {\n        NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]];\n        for (NSData *certificate in self.pinnedCertificates) {\n            id publicKey = AFPublicKeyForCertificate(certificate);\n            if (!publicKey) {\n                continue;\n            }\n            [mutablePinnedPublicKeys addObject:publicKey];\n        }\n        self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys];\n    } else {\n        self.pinnedPublicKeys = nil;\n    }\n}\n```\n\n## AFPublicKeyForCertificate\n\n### 取出公钥\n\n取出公钥的时候，使用了 **AFPublicKeyForCertificate** 函数：\n\n```objc\nstatic id AFPublicKeyForCertificate(NSData *certificate) {\n    // 初始化一些临时变量\n    id allowedPublicKey = nil;\n    SecCertificateRef allowedCertificate;\n    SecPolicyRef policy = nil;\n    SecTrustRef allowedTrust = nil;\n    SecTrustResultType result;\n    \n    // 因为此处传入的certificate参数是NSData类型的，所以需要使用SecCertificateCreateWithData来将NSData对象转化为SecCertificateRef对象\n    allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);\n    __Require_Quiet(allowedCertificate != NULL, _out);\n\n    // 创建符合X509标准的 SecPolicyRef，然后和证书创建的 SecPolicyRef 比较，确认证书是否值得信任\n    policy = SecPolicyCreateBasicX509();\n    __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &allowedTrust), _out);\n    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &result), _out);\n    \n    // 获取证书的公钥，__bridge_transfer 会将结果桥接成 NSObject 对象，然后将 SecTrustCopyPublicKey 返回的指针释放。\n    allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);\n\n// 释放各种指针\n_out:\n    if (allowedTrust) {\n        CFRelease(allowedTrust);\n    }\n\n    if (policy) {\n        CFRelease(policy);\n    }\n\n    if (allowedCertificate) {\n        CFRelease(allowedCertificate);\n    }\n\n    return allowedPublicKey;\n}\n```\n\n### __Require_Quiet\n\n取出公钥的时候用到一个宏，**__Require_Quiet**，它会判断 allowedCertificate != NULL 是否成立，如果 allowedCertificate 为空就会跳到 _out 标签处继续执行：\n\n```objc\n#ifndef __Require_Quiet\n\t#define __Require_Quiet(assertion, exceptionLabel)                            \\\n\t  do                                                                          \\\n\t  {                                                                           \\\n\t\t  if ( __builtin_expect(!(assertion), 0) )                                \\\n\t\t  {                                                                       \\\n\t\t\t  goto exceptionLabel;                                                \\\n\t\t  }                                                                       \\\n\t  } while ( 0 )\n#endif\n```\n\n**__Require_noErr_Quiet** 也是差不多的原理。\n\n## evaluateServerTrust\n\n初始化完成后，就要验证服务器是否能够信任了，调用 **- [AFSecurityPolicy evaluateServerTrust:forDomain:]** 方法\n\n```objc\n- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust\n                  forDomain:(NSString *)domain\n{\n    #1: 不能隐式地信任自己签发的证书\n\n    #2: 设置 policies\n\n    #3: 验证证书是否有效\n\n    #4: 根据 SSLPinningMode 对服务端进行验证\n        \n    return NO;\n}\n\n```\n\n### 不能隐式地信任自己签发的证书\n\n```objc\nif (domain && self.allowInvalidCertificates && self.validatesDomainName && (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) {\n        NSLog(@\"In order to validate a domain name for self signed certificates, you MUST use pinning.\");\n        return NO;\n    }\n```\n\n如果不提供证书或者不验证证书，并且设置 allowInvalidCertificates = YES，满足了所有条件，说明这次验证是不安全的，直接返回 NO。\n\n### 设置 policies \n\n```objc\nNSMutableArray *policies = [NSMutableArray array];\n    if (self.validatesDomainName) {\n        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];\n    } else {\n        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];\n    }\n```\n\n如果要验证的域名存在，使用域名创建 SecPolicyRef，否则会创建一个符合 X509 标准的默认 SecPolicyRef 对象。\n\n### 验证证书的有效性\n\n```objc\nSecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);\n\nif (self.SSLPinningMode == AFSSLPinningModeNone) {\n   return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);\n} else if (!AFServerTrustIsValid(serverTrust) && !self.allowInvalidCertificates) {\n   return NO;\n}\n```\n\n* 如果 SSLPinningMode == AFSSLPinningModeNone 。如果允许无效证书，直接return YES。不允许，跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。\n\n* 如果 SSLPinningMode != AFSSLPinningModeNone，如果服务器信任无效，并且不允许无效证书，return NO。\n\n### 根据 SSLPinningMode 对服务器信任进行验证\n\n\n```objc\nswitch (self.SSLPinningMode) {\n   case AFSSLPinningModeNone:\n   default:\n       return NO;\n   case AFSSLPinningModeCertificate: {\n       \n   }\n   case AFSSLPinningModePublicKey: {\n\n   }\n}\n```\n\n**AFSSLPinningModeNone** 直接返回 NO\n\n**AFSSLPinningModeCertificate**\n\n```objc\nNSMutableArray *pinnedCertificates = [NSMutableArray array];\n// 遍历获取证书\nfor (NSData *certificateData in self.pinnedCertificates) {\n [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];\n}\n// 为服务器信任设置证书\nSecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);\n\n// 服务器是否能信任\nif (!AFServerTrustIsValid(serverTrust)) {\n return NO;\n}\n\n// 获取服务器信任的全部证书\nNSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);\n\n// 遍历，如果有相同的，return YES\nfor (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) {\n if ([self.pinnedCertificates containsObject:trustChainCertificate]) {\n     return YES;\n }\n}\n  \nreturn NO;\n```\n\n**AFSSLPinningModePublicKey** \n\n```objc\nNSUInteger trustedPublicKeyCount = 0;\nNSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);\n\nfor (id trustChainPublicKey in publicKeys) {\n for (id pinnedPublicKey in self.pinnedPublicKeys) {\n     if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) {\n         trustedPublicKeyCount += 1;\n     }\n }\n}\nreturn trustedPublicKeyCount > 0;\n```\n这里只验证公钥，先从服务器信任中获取公钥，如果 pinnedPublicKeys 中的公钥与服务器信任中的公钥相同的数量大于 0，就会 return YES。\n\n## 在 AFURLSessionManager 的使用\n\n在 AFURLSessionManager 中使用 **- (BOOL)evaluateServerTrust:forDomain:** 方法的有两处地方 \n\n* **- URLSession:didReceiveChallenge:completionHandler:**\n* **- URLSession:task:didReceiveChallenge:completionHandler:**\n\n\n```objc\nif ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {\n disposition = NSURLSessionAuthChallengeUseCredential;\n credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];\n} else {\n disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;\n}\n```\n\nNSURLAuthenticationChallenge 表示一个认证的挑战，提供了关于这次认证的全部信息。它有一个非常重要的属性 protectionSpace，这里保存了需要认证的保护空间, 每一个 NSURLProtectionSpace 对象都保存了主机地址，端口和认证方法等重要信息。\n\n调用认证方法后，根据认证的结果，会在 completionHandler 中传入不同的 disposition 和 credential 参数。\n\n## 总结\n\nAFSecurityPolicy 作为一个 AFNetworking 的工具类验证证书的有效性，给 APP 网络安全把关。iOS 全面使用 HTTPS 只是时间早晚的问题。\n\n## 参考链接\n* [AFNetworking](https://github.com/AFNetworking/AFNetworking)\n* [AFNetworking源码阅读（六）](http://www.cnblogs.com/polobymulberry/p/5174298.html)\n* [验证 HTTPS 请求的证书（五）](https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/%E9%AA%8C%E8%AF%81%20HTTPS%20%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%81%E4%B9%A6%EF%BC%88%E4%BA%94%EF%BC%89.md)\n\n\n\n","source":"_posts/AFNetworking-AFSecurityPolicy-5.md","raw":"---\ntitle: AFSecurityPolicy 网络安全策略（五）\ndate: 2017-01-26 09:56:17\ntags: AFNetworking\ncategory: Source Code Analyze\n---\n\n## 前言\n终于放假了，回到家，准备过年，乘着年前把 AFNetworking 源码阅读的最后一篇po出来。\n\n这一篇分析下 AFSecurityPolicy 文件，看看AFNetworking的网络安全策略，特别的是苹果强制要求2017年全部APP支持 HTTPS 后（由于各种原因推迟了），不了解 HTTPS 的可以看下\n\n* [《写给 iOS 开发者看的 HTTPS 指南》](https://autolayout.club/2016/12/22/%E5%86%99%E7%BB%99-iOS-%E5%BC%80%E5%8F%91%E8%80%85%E7%9C%8B%E7%9A%84-HTTPS-%E6%8C%87%E5%8D%97/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io) \n* [《iOS安全系列之一：HTTPS》](http://oncenote.com/2014/10/21/Security-1-HTTPS/)\n\nAFSecurityPolicy 的主要作用就是验证 HTTPS 请求的证书是否有效，如果 app 中有敏感的信息或者资金流动的信息，一定要使用 HTTPS 来保证交易的信息安全。\n\n## AFSSLPinningMode\n\n首先一眼看到的是 **AFSSLPinningMode** ，验证服务器是否被信任的三种模式：\n\n```objc\ntypedef NS_ENUM(NSUInteger, AFSSLPinningMode) {\n    AFSSLPinningModeNone,\n    AFSSLPinningModePublicKey,\n    AFSSLPinningModeCertificate,\n};\n```\n\n* AFSSLPinningModeNone: 表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。\n* AFSSLPinningModePublicKey: 用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。\n* AFSSLPinningModeCertificate: 也是用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。\n\n## 初始化\n使用前，需要先初始化使用哪种验证方式：\n\n```objc\n+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode {\n    return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];\n}\n\n+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates {\n    AFSecurityPolicy *securityPolicy = [[self alloc] init];\n    securityPolicy.SSLPinningMode = pinningMode;\n\n    [securityPolicy setPinnedCertificates:pinnedCertificates];\n\n    return securityPolicy;\n}\n\n```\n\n从证书里面取出公钥，保存在 **pinnedPublicKeys**\n```objc\n- (void)setPinnedCertificates:(NSSet *)pinnedCertificates {\n    _pinnedCertificates = pinnedCertificates;\n\n    if (self.pinnedCertificates) {\n        NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]];\n        for (NSData *certificate in self.pinnedCertificates) {\n            id publicKey = AFPublicKeyForCertificate(certificate);\n            if (!publicKey) {\n                continue;\n            }\n            [mutablePinnedPublicKeys addObject:publicKey];\n        }\n        self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys];\n    } else {\n        self.pinnedPublicKeys = nil;\n    }\n}\n```\n\n## AFPublicKeyForCertificate\n\n### 取出公钥\n\n取出公钥的时候，使用了 **AFPublicKeyForCertificate** 函数：\n\n```objc\nstatic id AFPublicKeyForCertificate(NSData *certificate) {\n    // 初始化一些临时变量\n    id allowedPublicKey = nil;\n    SecCertificateRef allowedCertificate;\n    SecPolicyRef policy = nil;\n    SecTrustRef allowedTrust = nil;\n    SecTrustResultType result;\n    \n    // 因为此处传入的certificate参数是NSData类型的，所以需要使用SecCertificateCreateWithData来将NSData对象转化为SecCertificateRef对象\n    allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);\n    __Require_Quiet(allowedCertificate != NULL, _out);\n\n    // 创建符合X509标准的 SecPolicyRef，然后和证书创建的 SecPolicyRef 比较，确认证书是否值得信任\n    policy = SecPolicyCreateBasicX509();\n    __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &allowedTrust), _out);\n    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &result), _out);\n    \n    // 获取证书的公钥，__bridge_transfer 会将结果桥接成 NSObject 对象，然后将 SecTrustCopyPublicKey 返回的指针释放。\n    allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);\n\n// 释放各种指针\n_out:\n    if (allowedTrust) {\n        CFRelease(allowedTrust);\n    }\n\n    if (policy) {\n        CFRelease(policy);\n    }\n\n    if (allowedCertificate) {\n        CFRelease(allowedCertificate);\n    }\n\n    return allowedPublicKey;\n}\n```\n\n### __Require_Quiet\n\n取出公钥的时候用到一个宏，**__Require_Quiet**，它会判断 allowedCertificate != NULL 是否成立，如果 allowedCertificate 为空就会跳到 _out 标签处继续执行：\n\n```objc\n#ifndef __Require_Quiet\n\t#define __Require_Quiet(assertion, exceptionLabel)                            \\\n\t  do                                                                          \\\n\t  {                                                                           \\\n\t\t  if ( __builtin_expect(!(assertion), 0) )                                \\\n\t\t  {                                                                       \\\n\t\t\t  goto exceptionLabel;                                                \\\n\t\t  }                                                                       \\\n\t  } while ( 0 )\n#endif\n```\n\n**__Require_noErr_Quiet** 也是差不多的原理。\n\n## evaluateServerTrust\n\n初始化完成后，就要验证服务器是否能够信任了，调用 **- [AFSecurityPolicy evaluateServerTrust:forDomain:]** 方法\n\n```objc\n- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust\n                  forDomain:(NSString *)domain\n{\n    #1: 不能隐式地信任自己签发的证书\n\n    #2: 设置 policies\n\n    #3: 验证证书是否有效\n\n    #4: 根据 SSLPinningMode 对服务端进行验证\n        \n    return NO;\n}\n\n```\n\n### 不能隐式地信任自己签发的证书\n\n```objc\nif (domain && self.allowInvalidCertificates && self.validatesDomainName && (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) {\n        NSLog(@\"In order to validate a domain name for self signed certificates, you MUST use pinning.\");\n        return NO;\n    }\n```\n\n如果不提供证书或者不验证证书，并且设置 allowInvalidCertificates = YES，满足了所有条件，说明这次验证是不安全的，直接返回 NO。\n\n### 设置 policies \n\n```objc\nNSMutableArray *policies = [NSMutableArray array];\n    if (self.validatesDomainName) {\n        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];\n    } else {\n        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];\n    }\n```\n\n如果要验证的域名存在，使用域名创建 SecPolicyRef，否则会创建一个符合 X509 标准的默认 SecPolicyRef 对象。\n\n### 验证证书的有效性\n\n```objc\nSecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);\n\nif (self.SSLPinningMode == AFSSLPinningModeNone) {\n   return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);\n} else if (!AFServerTrustIsValid(serverTrust) && !self.allowInvalidCertificates) {\n   return NO;\n}\n```\n\n* 如果 SSLPinningMode == AFSSLPinningModeNone 。如果允许无效证书，直接return YES。不允许，跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。\n\n* 如果 SSLPinningMode != AFSSLPinningModeNone，如果服务器信任无效，并且不允许无效证书，return NO。\n\n### 根据 SSLPinningMode 对服务器信任进行验证\n\n\n```objc\nswitch (self.SSLPinningMode) {\n   case AFSSLPinningModeNone:\n   default:\n       return NO;\n   case AFSSLPinningModeCertificate: {\n       \n   }\n   case AFSSLPinningModePublicKey: {\n\n   }\n}\n```\n\n**AFSSLPinningModeNone** 直接返回 NO\n\n**AFSSLPinningModeCertificate**\n\n```objc\nNSMutableArray *pinnedCertificates = [NSMutableArray array];\n// 遍历获取证书\nfor (NSData *certificateData in self.pinnedCertificates) {\n [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];\n}\n// 为服务器信任设置证书\nSecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);\n\n// 服务器是否能信任\nif (!AFServerTrustIsValid(serverTrust)) {\n return NO;\n}\n\n// 获取服务器信任的全部证书\nNSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);\n\n// 遍历，如果有相同的，return YES\nfor (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) {\n if ([self.pinnedCertificates containsObject:trustChainCertificate]) {\n     return YES;\n }\n}\n  \nreturn NO;\n```\n\n**AFSSLPinningModePublicKey** \n\n```objc\nNSUInteger trustedPublicKeyCount = 0;\nNSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);\n\nfor (id trustChainPublicKey in publicKeys) {\n for (id pinnedPublicKey in self.pinnedPublicKeys) {\n     if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) {\n         trustedPublicKeyCount += 1;\n     }\n }\n}\nreturn trustedPublicKeyCount > 0;\n```\n这里只验证公钥，先从服务器信任中获取公钥，如果 pinnedPublicKeys 中的公钥与服务器信任中的公钥相同的数量大于 0，就会 return YES。\n\n## 在 AFURLSessionManager 的使用\n\n在 AFURLSessionManager 中使用 **- (BOOL)evaluateServerTrust:forDomain:** 方法的有两处地方 \n\n* **- URLSession:didReceiveChallenge:completionHandler:**\n* **- URLSession:task:didReceiveChallenge:completionHandler:**\n\n\n```objc\nif ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {\n disposition = NSURLSessionAuthChallengeUseCredential;\n credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];\n} else {\n disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;\n}\n```\n\nNSURLAuthenticationChallenge 表示一个认证的挑战，提供了关于这次认证的全部信息。它有一个非常重要的属性 protectionSpace，这里保存了需要认证的保护空间, 每一个 NSURLProtectionSpace 对象都保存了主机地址，端口和认证方法等重要信息。\n\n调用认证方法后，根据认证的结果，会在 completionHandler 中传入不同的 disposition 和 credential 参数。\n\n## 总结\n\nAFSecurityPolicy 作为一个 AFNetworking 的工具类验证证书的有效性，给 APP 网络安全把关。iOS 全面使用 HTTPS 只是时间早晚的问题。\n\n## 参考链接\n* [AFNetworking](https://github.com/AFNetworking/AFNetworking)\n* [AFNetworking源码阅读（六）](http://www.cnblogs.com/polobymulberry/p/5174298.html)\n* [验证 HTTPS 请求的证书（五）](https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/%E9%AA%8C%E8%AF%81%20HTTPS%20%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%81%E4%B9%A6%EF%BC%88%E4%BA%94%EF%BC%89.md)\n\n\n\n","slug":"AFNetworking-AFSecurityPolicy-5","published":1,"updated":"2017-01-27T03:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7nu003x8jpbqordghof","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>终于放假了，回到家，准备过年，乘着年前把 AFNetworking 源码阅读的最后一篇po出来。</p>\n<p>这一篇分析下 AFSecurityPolicy 文件，看看AFNetworking的网络安全策略，特别的是苹果强制要求2017年全部APP支持 HTTPS 后（由于各种原因推迟了），不了解 HTTPS 的可以看下</p>\n<ul>\n<li><a href=\"https://autolayout.club/2016/12/22/%E5%86%99%E7%BB%99-iOS-%E5%BC%80%E5%8F%91%E8%80%85%E7%9C%8B%E7%9A%84-HTTPS-%E6%8C%87%E5%8D%97/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" rel=\"noopener\">《写给 iOS 开发者看的 HTTPS 指南》</a> </li>\n<li><a href=\"http://oncenote.com/2014/10/21/Security-1-HTTPS/\" target=\"_blank\" rel=\"noopener\">《iOS安全系列之一：HTTPS》</a></li>\n</ul>\n<p>AFSecurityPolicy 的主要作用就是验证 HTTPS 请求的证书是否有效，如果 app 中有敏感的信息或者资金流动的信息，一定要使用 HTTPS 来保证交易的信息安全。</p>\n<h2 id=\"AFSSLPinningMode\"><a href=\"#AFSSLPinningMode\" class=\"headerlink\" title=\"AFSSLPinningMode\"></a>AFSSLPinningMode</h2><p>首先一眼看到的是 <strong>AFSSLPinningMode</strong> ，验证服务器是否被信任的三种模式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class=\"line\">    AFSSLPinningModeNone,</span><br><span class=\"line\">    AFSSLPinningModePublicKey,</span><br><span class=\"line\">    AFSSLPinningModeCertificate,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>AFSSLPinningModeNone: 表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。</li>\n<li>AFSSLPinningModePublicKey: 用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</li>\n<li>AFSSLPinningModeCertificate: 也是用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。</li>\n</ul>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>使用前，需要先初始化使用哪种验证方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> policyWithPinningMode:pinningMode withPinnedCertificates:[<span class=\"keyword\">self</span> defaultPinnedCertificates]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(<span class=\"built_in\">NSSet</span> *)pinnedCertificates &#123;</span><br><span class=\"line\">    AFSecurityPolicy *securityPolicy = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    securityPolicy.SSLPinningMode = pinningMode;</span><br><span class=\"line\"></span><br><span class=\"line\">    [securityPolicy setPinnedCertificates:pinnedCertificates];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> securityPolicy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从证书里面取出公钥，保存在 <strong>pinnedPublicKeys</strong><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setPinnedCertificates:(<span class=\"built_in\">NSSet</span> *)pinnedCertificates &#123;</span><br><span class=\"line\">    _pinnedCertificates = pinnedCertificates;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.pinnedCertificates) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class=\"built_in\">NSMutableSet</span> setWithCapacity:[<span class=\"keyword\">self</span>.pinnedCertificates count]];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSData</span> *certificate <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.pinnedCertificates) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!publicKey) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pinnedPublicKeys = [<span class=\"built_in\">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pinnedPublicKeys = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"AFPublicKeyForCertificate\"><a href=\"#AFPublicKeyForCertificate\" class=\"headerlink\" title=\"AFPublicKeyForCertificate\"></a>AFPublicKeyForCertificate</h2><h3 id=\"取出公钥\"><a href=\"#取出公钥\" class=\"headerlink\" title=\"取出公钥\"></a>取出公钥</h3><p>取出公钥的时候，使用了 <strong>AFPublicKeyForCertificate</strong> 函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">id</span> AFPublicKeyForCertificate(<span class=\"built_in\">NSData</span> *certificate) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化一些临时变量</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> allowedPublicKey = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    SecCertificateRef allowedCertificate;</span><br><span class=\"line\">    SecPolicyRef policy = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    SecTrustRef allowedTrust = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    SecTrustResultType result;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 因为此处传入的certificate参数是NSData类型的，所以需要使用SecCertificateCreateWithData来将NSData对象转化为SecCertificateRef对象</span></span><br><span class=\"line\">    allowedCertificate = SecCertificateCreateWithData(<span class=\"literal\">NULL</span>, (__bridge <span class=\"built_in\">CFDataRef</span>)certificate);</span><br><span class=\"line\">    __Require_Quiet(allowedCertificate != <span class=\"literal\">NULL</span>, _<span class=\"keyword\">out</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建符合X509标准的 SecPolicyRef，然后和证书创建的 SecPolicyRef 比较，确认证书是否值得信任</span></span><br><span class=\"line\">    policy = SecPolicyCreateBasicX509();</span><br><span class=\"line\">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _<span class=\"keyword\">out</span>);</span><br><span class=\"line\">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _<span class=\"keyword\">out</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取证书的公钥，__bridge_transfer 会将结果桥接成 NSObject 对象，然后将 SecTrustCopyPublicKey 返回的指针释放。</span></span><br><span class=\"line\">    allowedPublicKey = (__bridge_transfer <span class=\"keyword\">id</span>)SecTrustCopyPublicKey(allowedTrust);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放各种指针</span></span><br><span class=\"line\">_<span class=\"keyword\">out</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowedTrust) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRelease</span>(allowedTrust);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (policy) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRelease</span>(policy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowedCertificate) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRelease</span>(allowedCertificate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> allowedPublicKey;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Require-Quiet\"><a href=\"#Require-Quiet\" class=\"headerlink\" title=\"__Require_Quiet\"></a>__Require_Quiet</h3><p>取出公钥的时候用到一个宏，<strong>__Require_Quiet</strong>，它会判断 allowedCertificate != NULL 是否成立，如果 allowedCertificate 为空就会跳到 _out 标签处继续执行：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifndef __Require_Quiet</span></span><br><span class=\"line\">\t<span class=\"meta\">#define __Require_Quiet(assertion, exceptionLabel)                            \\</span></span><br><span class=\"line\">\t  <span class=\"keyword\">do</span>                                                                          \\</span><br><span class=\"line\">\t  &#123;                                                                           \\</span><br><span class=\"line\">\t\t  <span class=\"keyword\">if</span> ( __builtin_expect(!(assertion), <span class=\"number\">0</span>) )                                \\</span><br><span class=\"line\">\t\t  &#123;                                                                       \\</span><br><span class=\"line\">\t\t\t  <span class=\"keyword\">goto</span> exceptionLabel;                                                \\</span><br><span class=\"line\">\t\t  &#125;                                                                       \\</span><br><span class=\"line\">\t  &#125; <span class=\"keyword\">while</span> ( <span class=\"number\">0</span> )</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p><strong>__Require_noErr_Quiet</strong> 也是差不多的原理。</p>\n<h2 id=\"evaluateServerTrust\"><a href=\"#evaluateServerTrust\" class=\"headerlink\" title=\"evaluateServerTrust\"></a>evaluateServerTrust</h2><p>初始化完成后，就要验证服务器是否能够信任了，调用 <strong>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</strong> 方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class=\"line\">                  forDomain:(<span class=\"built_in\">NSString</span> *)domain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"meta\">#1: 不能隐式地信任自己签发的证书</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#2: 设置 policies</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#3: 验证证书是否有效</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#4: 根据 SSLPinningMode 对服务端进行验证</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不能隐式地信任自己签发的证书\"><a href=\"#不能隐式地信任自己签发的证书\" class=\"headerlink\" title=\"不能隐式地信任自己签发的证书\"></a>不能隐式地信任自己签发的证书</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (domain &amp;&amp; <span class=\"keyword\">self</span>.allowInvalidCertificates &amp;&amp; <span class=\"keyword\">self</span>.validatesDomainName &amp;&amp; (<span class=\"keyword\">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class=\"keyword\">self</span>.pinnedCertificates count] == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"In order to validate a domain name for self signed certificates, you MUST use pinning.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果不提供证书或者不验证证书，并且设置 allowInvalidCertificates = YES，满足了所有条件，说明这次验证是不安全的，直接返回 NO。</p>\n<h3 id=\"设置-policies\"><a href=\"#设置-policies\" class=\"headerlink\" title=\"设置 policies\"></a>设置 policies</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *policies = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.validatesDomainName) &#123;</span><br><span class=\"line\">        [policies addObject:(__bridge_transfer <span class=\"keyword\">id</span>)SecPolicyCreateSSL(<span class=\"literal\">true</span>, (__bridge <span class=\"built_in\">CFStringRef</span>)domain)];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        [policies addObject:(__bridge_transfer <span class=\"keyword\">id</span>)SecPolicyCreateBasicX509()];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果要验证的域名存在，使用域名创建 SecPolicyRef，否则会创建一个符合 X509 标准的默认 SecPolicyRef 对象。</p>\n<h3 id=\"验证证书的有效性\"><a href=\"#验证证书的有效性\" class=\"headerlink\" title=\"验证证书的有效性\"></a>验证证书的有效性</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SecTrustSetPolicies(serverTrust, (__bridge <span class=\"built_in\">CFArrayRef</span>)policies);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class=\"keyword\">self</span>.allowInvalidCertificates) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>如果 SSLPinningMode == AFSSLPinningModeNone 。如果允许无效证书，直接return YES。不允许，跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。</p>\n</li>\n<li><p>如果 SSLPinningMode != AFSSLPinningModeNone，如果服务器信任无效，并且不允许无效证书，return NO。</p>\n</li>\n</ul>\n<h3 id=\"根据-SSLPinningMode-对服务器信任进行验证\"><a href=\"#根据-SSLPinningMode-对服务器信任进行验证\" class=\"headerlink\" title=\"根据 SSLPinningMode 对服务器信任进行验证\"></a>根据 SSLPinningMode 对服务器信任进行验证</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (<span class=\"keyword\">self</span>.SSLPinningMode) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">case</span> AFSSLPinningModeNone:</span><br><span class=\"line\">   <span class=\"keyword\">default</span>:</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">   <span class=\"keyword\">case</span> AFSSLPinningModeCertificate: &#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">case</span> AFSSLPinningModePublicKey: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>AFSSLPinningModeNone</strong> 直接返回 NO</p>\n<p><strong>AFSSLPinningModeCertificate</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *pinnedCertificates = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"comment\">// 遍历获取证书</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSData</span> *certificateData <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.pinnedCertificates) &#123;</span><br><span class=\"line\"> [pinnedCertificates addObject:(__bridge_transfer <span class=\"keyword\">id</span>)SecCertificateCreateWithData(<span class=\"literal\">NULL</span>, (__bridge <span class=\"built_in\">CFDataRef</span>)certificateData)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 为服务器信任设置证书</span></span><br><span class=\"line\">SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class=\"built_in\">CFArrayRef</span>)pinnedCertificates);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 服务器是否能信任</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取服务器信任的全部证书</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历，如果有相同的，return YES</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSData</span> *trustChainCertificate <span class=\"keyword\">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>AFSSLPinningModePublicKey</strong> </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUInteger</span> trustedPublicKeyCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> trustChainPublicKey <span class=\"keyword\">in</span> publicKeys) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> pinnedPublicKey <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.pinnedPublicKeys) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class=\"line\">         trustedPublicKeyCount += <span class=\"number\">1</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> trustedPublicKeyCount &gt; <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>这里只验证公钥，先从服务器信任中获取公钥，如果 pinnedPublicKeys 中的公钥与服务器信任中的公钥相同的数量大于 0，就会 return YES。</p>\n<h2 id=\"在-AFURLSessionManager-的使用\"><a href=\"#在-AFURLSessionManager-的使用\" class=\"headerlink\" title=\"在 AFURLSessionManager 的使用\"></a>在 AFURLSessionManager 的使用</h2><p>在 AFURLSessionManager 中使用 <strong>- (BOOL)evaluateServerTrust:forDomain:</strong> 方法的有两处地方 </p>\n<ul>\n<li><strong>- URLSession:didReceiveChallenge:completionHandler:</strong></li>\n<li><strong>- URLSession:task:didReceiveChallenge:completionHandler:</strong></li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class=\"line\"> disposition = <span class=\"built_in\">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class=\"line\"> credential = [<span class=\"built_in\">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"> disposition = <span class=\"built_in\">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NSURLAuthenticationChallenge 表示一个认证的挑战，提供了关于这次认证的全部信息。它有一个非常重要的属性 protectionSpace，这里保存了需要认证的保护空间, 每一个 NSURLProtectionSpace 对象都保存了主机地址，端口和认证方法等重要信息。</p>\n<p>调用认证方法后，根据认证的结果，会在 completionHandler 中传入不同的 disposition 和 credential 参数。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>AFSecurityPolicy 作为一个 AFNetworking 的工具类验证证书的有效性，给 APP 网络安全把关。iOS 全面使用 HTTPS 只是时间早晚的问题。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a></li>\n<li><a href=\"http://www.cnblogs.com/polobymulberry/p/5174298.html\" target=\"_blank\" rel=\"noopener\">AFNetworking源码阅读（六）</a></li>\n<li><a href=\"https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/%E9%AA%8C%E8%AF%81%20HTTPS%20%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%81%E4%B9%A6%EF%BC%88%E4%BA%94%EF%BC%89.md\" target=\"_blank\" rel=\"noopener\">验证 HTTPS 请求的证书（五）</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>终于放假了，回到家，准备过年，乘着年前把 AFNetworking 源码阅读的最后一篇po出来。</p>\n<p>这一篇分析下 AFSecurityPolicy 文件，看看AFNetworking的网络安全策略，特别的是苹果强制要求2017年全部APP支持 HTTPS 后（由于各种原因推迟了），不了解 HTTPS 的可以看下</p>\n<ul>\n<li><a href=\"https://autolayout.club/2016/12/22/%E5%86%99%E7%BB%99-iOS-%E5%BC%80%E5%8F%91%E8%80%85%E7%9C%8B%E7%9A%84-HTTPS-%E6%8C%87%E5%8D%97/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" rel=\"noopener\">《写给 iOS 开发者看的 HTTPS 指南》</a> </li>\n<li><a href=\"http://oncenote.com/2014/10/21/Security-1-HTTPS/\" target=\"_blank\" rel=\"noopener\">《iOS安全系列之一：HTTPS》</a></li>\n</ul>\n<p>AFSecurityPolicy 的主要作用就是验证 HTTPS 请求的证书是否有效，如果 app 中有敏感的信息或者资金流动的信息，一定要使用 HTTPS 来保证交易的信息安全。</p>\n<h2 id=\"AFSSLPinningMode\"><a href=\"#AFSSLPinningMode\" class=\"headerlink\" title=\"AFSSLPinningMode\"></a>AFSSLPinningMode</h2><p>首先一眼看到的是 <strong>AFSSLPinningMode</strong> ，验证服务器是否被信任的三种模式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class=\"line\">    AFSSLPinningModeNone,</span><br><span class=\"line\">    AFSSLPinningModePublicKey,</span><br><span class=\"line\">    AFSSLPinningModeCertificate,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>AFSSLPinningModeNone: 表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。</li>\n<li>AFSSLPinningModePublicKey: 用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</li>\n<li>AFSSLPinningModeCertificate: 也是用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。</li>\n</ul>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>使用前，需要先初始化使用哪种验证方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> policyWithPinningMode:pinningMode withPinnedCertificates:[<span class=\"keyword\">self</span> defaultPinnedCertificates]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(<span class=\"built_in\">NSSet</span> *)pinnedCertificates &#123;</span><br><span class=\"line\">    AFSecurityPolicy *securityPolicy = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    securityPolicy.SSLPinningMode = pinningMode;</span><br><span class=\"line\"></span><br><span class=\"line\">    [securityPolicy setPinnedCertificates:pinnedCertificates];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> securityPolicy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从证书里面取出公钥，保存在 <strong>pinnedPublicKeys</strong><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setPinnedCertificates:(<span class=\"built_in\">NSSet</span> *)pinnedCertificates &#123;</span><br><span class=\"line\">    _pinnedCertificates = pinnedCertificates;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.pinnedCertificates) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class=\"built_in\">NSMutableSet</span> setWithCapacity:[<span class=\"keyword\">self</span>.pinnedCertificates count]];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSData</span> *certificate <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.pinnedCertificates) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!publicKey) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pinnedPublicKeys = [<span class=\"built_in\">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pinnedPublicKeys = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"AFPublicKeyForCertificate\"><a href=\"#AFPublicKeyForCertificate\" class=\"headerlink\" title=\"AFPublicKeyForCertificate\"></a>AFPublicKeyForCertificate</h2><h3 id=\"取出公钥\"><a href=\"#取出公钥\" class=\"headerlink\" title=\"取出公钥\"></a>取出公钥</h3><p>取出公钥的时候，使用了 <strong>AFPublicKeyForCertificate</strong> 函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">id</span> AFPublicKeyForCertificate(<span class=\"built_in\">NSData</span> *certificate) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化一些临时变量</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> allowedPublicKey = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    SecCertificateRef allowedCertificate;</span><br><span class=\"line\">    SecPolicyRef policy = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    SecTrustRef allowedTrust = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    SecTrustResultType result;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 因为此处传入的certificate参数是NSData类型的，所以需要使用SecCertificateCreateWithData来将NSData对象转化为SecCertificateRef对象</span></span><br><span class=\"line\">    allowedCertificate = SecCertificateCreateWithData(<span class=\"literal\">NULL</span>, (__bridge <span class=\"built_in\">CFDataRef</span>)certificate);</span><br><span class=\"line\">    __Require_Quiet(allowedCertificate != <span class=\"literal\">NULL</span>, _<span class=\"keyword\">out</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建符合X509标准的 SecPolicyRef，然后和证书创建的 SecPolicyRef 比较，确认证书是否值得信任</span></span><br><span class=\"line\">    policy = SecPolicyCreateBasicX509();</span><br><span class=\"line\">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _<span class=\"keyword\">out</span>);</span><br><span class=\"line\">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _<span class=\"keyword\">out</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取证书的公钥，__bridge_transfer 会将结果桥接成 NSObject 对象，然后将 SecTrustCopyPublicKey 返回的指针释放。</span></span><br><span class=\"line\">    allowedPublicKey = (__bridge_transfer <span class=\"keyword\">id</span>)SecTrustCopyPublicKey(allowedTrust);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放各种指针</span></span><br><span class=\"line\">_<span class=\"keyword\">out</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowedTrust) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRelease</span>(allowedTrust);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (policy) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRelease</span>(policy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowedCertificate) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRelease</span>(allowedCertificate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> allowedPublicKey;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Require-Quiet\"><a href=\"#Require-Quiet\" class=\"headerlink\" title=\"__Require_Quiet\"></a>__Require_Quiet</h3><p>取出公钥的时候用到一个宏，<strong>__Require_Quiet</strong>，它会判断 allowedCertificate != NULL 是否成立，如果 allowedCertificate 为空就会跳到 _out 标签处继续执行：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifndef __Require_Quiet</span></span><br><span class=\"line\">\t<span class=\"meta\">#define __Require_Quiet(assertion, exceptionLabel)                            \\</span></span><br><span class=\"line\">\t  <span class=\"keyword\">do</span>                                                                          \\</span><br><span class=\"line\">\t  &#123;                                                                           \\</span><br><span class=\"line\">\t\t  <span class=\"keyword\">if</span> ( __builtin_expect(!(assertion), <span class=\"number\">0</span>) )                                \\</span><br><span class=\"line\">\t\t  &#123;                                                                       \\</span><br><span class=\"line\">\t\t\t  <span class=\"keyword\">goto</span> exceptionLabel;                                                \\</span><br><span class=\"line\">\t\t  &#125;                                                                       \\</span><br><span class=\"line\">\t  &#125; <span class=\"keyword\">while</span> ( <span class=\"number\">0</span> )</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p><strong>__Require_noErr_Quiet</strong> 也是差不多的原理。</p>\n<h2 id=\"evaluateServerTrust\"><a href=\"#evaluateServerTrust\" class=\"headerlink\" title=\"evaluateServerTrust\"></a>evaluateServerTrust</h2><p>初始化完成后，就要验证服务器是否能够信任了，调用 <strong>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</strong> 方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class=\"line\">                  forDomain:(<span class=\"built_in\">NSString</span> *)domain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"meta\">#1: 不能隐式地信任自己签发的证书</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#2: 设置 policies</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#3: 验证证书是否有效</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#4: 根据 SSLPinningMode 对服务端进行验证</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不能隐式地信任自己签发的证书\"><a href=\"#不能隐式地信任自己签发的证书\" class=\"headerlink\" title=\"不能隐式地信任自己签发的证书\"></a>不能隐式地信任自己签发的证书</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (domain &amp;&amp; <span class=\"keyword\">self</span>.allowInvalidCertificates &amp;&amp; <span class=\"keyword\">self</span>.validatesDomainName &amp;&amp; (<span class=\"keyword\">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class=\"keyword\">self</span>.pinnedCertificates count] == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"In order to validate a domain name for self signed certificates, you MUST use pinning.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果不提供证书或者不验证证书，并且设置 allowInvalidCertificates = YES，满足了所有条件，说明这次验证是不安全的，直接返回 NO。</p>\n<h3 id=\"设置-policies\"><a href=\"#设置-policies\" class=\"headerlink\" title=\"设置 policies\"></a>设置 policies</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *policies = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.validatesDomainName) &#123;</span><br><span class=\"line\">        [policies addObject:(__bridge_transfer <span class=\"keyword\">id</span>)SecPolicyCreateSSL(<span class=\"literal\">true</span>, (__bridge <span class=\"built_in\">CFStringRef</span>)domain)];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        [policies addObject:(__bridge_transfer <span class=\"keyword\">id</span>)SecPolicyCreateBasicX509()];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果要验证的域名存在，使用域名创建 SecPolicyRef，否则会创建一个符合 X509 标准的默认 SecPolicyRef 对象。</p>\n<h3 id=\"验证证书的有效性\"><a href=\"#验证证书的有效性\" class=\"headerlink\" title=\"验证证书的有效性\"></a>验证证书的有效性</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SecTrustSetPolicies(serverTrust, (__bridge <span class=\"built_in\">CFArrayRef</span>)policies);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class=\"keyword\">self</span>.allowInvalidCertificates) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>如果 SSLPinningMode == AFSSLPinningModeNone 。如果允许无效证书，直接return YES。不允许，跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。</p>\n</li>\n<li><p>如果 SSLPinningMode != AFSSLPinningModeNone，如果服务器信任无效，并且不允许无效证书，return NO。</p>\n</li>\n</ul>\n<h3 id=\"根据-SSLPinningMode-对服务器信任进行验证\"><a href=\"#根据-SSLPinningMode-对服务器信任进行验证\" class=\"headerlink\" title=\"根据 SSLPinningMode 对服务器信任进行验证\"></a>根据 SSLPinningMode 对服务器信任进行验证</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (<span class=\"keyword\">self</span>.SSLPinningMode) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">case</span> AFSSLPinningModeNone:</span><br><span class=\"line\">   <span class=\"keyword\">default</span>:</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">   <span class=\"keyword\">case</span> AFSSLPinningModeCertificate: &#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">case</span> AFSSLPinningModePublicKey: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>AFSSLPinningModeNone</strong> 直接返回 NO</p>\n<p><strong>AFSSLPinningModeCertificate</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *pinnedCertificates = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"comment\">// 遍历获取证书</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSData</span> *certificateData <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.pinnedCertificates) &#123;</span><br><span class=\"line\"> [pinnedCertificates addObject:(__bridge_transfer <span class=\"keyword\">id</span>)SecCertificateCreateWithData(<span class=\"literal\">NULL</span>, (__bridge <span class=\"built_in\">CFDataRef</span>)certificateData)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 为服务器信任设置证书</span></span><br><span class=\"line\">SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class=\"built_in\">CFArrayRef</span>)pinnedCertificates);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 服务器是否能信任</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取服务器信任的全部证书</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历，如果有相同的，return YES</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSData</span> *trustChainCertificate <span class=\"keyword\">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>AFSSLPinningModePublicKey</strong> </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUInteger</span> trustedPublicKeyCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> trustChainPublicKey <span class=\"keyword\">in</span> publicKeys) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> pinnedPublicKey <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.pinnedPublicKeys) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class=\"line\">         trustedPublicKeyCount += <span class=\"number\">1</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> trustedPublicKeyCount &gt; <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>这里只验证公钥，先从服务器信任中获取公钥，如果 pinnedPublicKeys 中的公钥与服务器信任中的公钥相同的数量大于 0，就会 return YES。</p>\n<h2 id=\"在-AFURLSessionManager-的使用\"><a href=\"#在-AFURLSessionManager-的使用\" class=\"headerlink\" title=\"在 AFURLSessionManager 的使用\"></a>在 AFURLSessionManager 的使用</h2><p>在 AFURLSessionManager 中使用 <strong>- (BOOL)evaluateServerTrust:forDomain:</strong> 方法的有两处地方 </p>\n<ul>\n<li><strong>- URLSession:didReceiveChallenge:completionHandler:</strong></li>\n<li><strong>- URLSession:task:didReceiveChallenge:completionHandler:</strong></li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class=\"line\"> disposition = <span class=\"built_in\">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class=\"line\"> credential = [<span class=\"built_in\">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"> disposition = <span class=\"built_in\">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NSURLAuthenticationChallenge 表示一个认证的挑战，提供了关于这次认证的全部信息。它有一个非常重要的属性 protectionSpace，这里保存了需要认证的保护空间, 每一个 NSURLProtectionSpace 对象都保存了主机地址，端口和认证方法等重要信息。</p>\n<p>调用认证方法后，根据认证的结果，会在 completionHandler 中传入不同的 disposition 和 credential 参数。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>AFSecurityPolicy 作为一个 AFNetworking 的工具类验证证书的有效性，给 APP 网络安全把关。iOS 全面使用 HTTPS 只是时间早晚的问题。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a></li>\n<li><a href=\"http://www.cnblogs.com/polobymulberry/p/5174298.html\" target=\"_blank\" rel=\"noopener\">AFNetworking源码阅读（六）</a></li>\n<li><a href=\"https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/%E9%AA%8C%E8%AF%81%20HTTPS%20%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%81%E4%B9%A6%EF%BC%88%E4%BA%94%EF%BC%89.md\" target=\"_blank\" rel=\"noopener\">验证 HTTPS 请求的证书（五）</a></li>\n</ul>\n"},{"title":"GitHub Pages + Hexo搭建博客","date":"2016-08-31T14:24:25.000Z","_content":"\n这篇博客是使用**Github Pages + Hexo** 搭建本博客的总结。\n\n作为一个有多年开发经验的人来说，没有搭建自己的博客，记录自己的开发点点滴滴，实在有点遗憾，以前总以为搭建博客得买服务器，域名等复杂的步骤，然后选择了国内老牌的博客CSDN或博客园来写博客，但可拓展性太低，千篇一律。\n\n最近经过朋友的介绍使用GitHub Pages + Hexo搭建免费的独立博客，痛下决心来做一次。\n\n## 前言\n搭建博客需要先了解几个知识点\n* [Git](https://git-scm.com/book/zh/v2)\n* [GitHub](https://github.com/)\n* [GitHub Pages](https://pages.github.com/)\n* [Hexo](https://hexo.io/zh-cn/)\n* [Markdown](http://www.appinn.com/markdown/#overview)\n\n## 环境配置\n### 安装Hexo\n由于安装Hexo需要Node.js和Git，所以在[Hexo](https://hexo.io/zh-cn/)官网上有安装的详细说明（中文版），不再赘述（Mac电脑有自带Git的）。\n\n当Node.js和Git都安装完成后，开始正式安装Hexo，在终端上执行\n``` bash\n$ sudo npm install -g hexo\n```\n需要输入管理员密码（Mac登录密码）。(`sudo`：Linux管理员指令，`-g`：全局安装)\n> 坑一：[Hexo官网](https://hexo.io/zh-cn/)上的安装命令是`$ npm install -g hexo-cli`，安装时不要忘记前面加上`sudo`，否则会因为权限问题报错。\n\n### 初始化博客\n终端cd到你想创建博客的文件夹，然后中执行终端命令\n```bash\n$ hexo init blog\n```\nblog是你新建的博客文件夹，cd到这个文件夹，然后执行命令安装npm\n\n```bash\n$ npm install\n```\n最后执行命令，开启Hexo本地服务器\n\n```bash\n$ hexo s // 全称：hexo server\n```\n终端中会提示在浏览器打开 http://localhost:4000 这个网址就可以看到（**因为我配置了主题内容，请忽略图片上的文字，之后将会讲到主题**）\n{% asset_img Snip20160831_1.png hexo init image %}\n\n## 关联Github\n### 创建仓库\n在前言的[GitHub Pages](https://pages.github.com/)中介绍了Pages仓库，所以要创建一个名为`用户名.github.io`固定写法的参考，例如`piglikeyoung.github.io`，如下图所示\n{% asset_img Snip20160831_2.png github Pages image %}\n\n本地的blog目录结构\n\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n用文本编辑器打开`_config.yml`\n修改下列代码\n\n```\n\t deploy:\n    type: git\n    repository: https://github.com/piglikeYoung/piglikeyoung.github.io.git\n    branch: master\n```\n你需要把`repository`替换成你自己的github地址\n> 坑二：在配置所有的`_config.yml`文件时（包括theme中的），在所有的`冒号:`后边都要加一个`空格`，否则执行hexo命令会报错，切记 切记\n\n在 blog文件夹目录下执行下面命令生成静态页面\n```bash\n$ hexo g        //全称：hexo generate\n```\n\n```\n如果出现如下报错：\nERROR Local hexo not found in ~/blog\nERROR Try runing: 'npm install hexo --save'\n则执行命令：\nnpm install hexo --save\n若无报错，自行忽略此步骤。\n```\n再执行命令部署静态网页\n```bash\n$ hexo d            //全称：hexo deploy\n```\n> 坑三：执行`hexo d`报错无法连接git或找不到git，执行这个命令 \n```bash\n$ npm install hexo-deployer-git --save\n```\n\n再次执行`hexo g`和`hexo d`命令。\n\n如果你的电脑没有管理Github，执行`hexo d`时终端会提示你输入Github的用户名和密码\n\n```bash\nUsername for 'https://github.com':\nPassword for 'https://github.com':\n```\n当`hexo d`执行成功，在浏览器上输入 http://piglikeyoung.github.io 就会显示 http://localhost:4000 一样的页面。\n\n**为了避免每次都输入Github用户名和密码，可以参考下一章来配置SSH Keys**\n\n## 添加SSH Key到Github\n### 判断是否已经生成了SSH Key\n如果已经生成了SSH Key会在`~/.ssh/id_rsa.pub`目录下面找到`id_rsa`和`id_rsa.pub`这两个文件。\n如果没有生成执行下面命令生成\n```bash\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n```\n其中`your_email@example.com`是你的Github邮箱。\n在Github上有这个[Help文档](https://help.github.com/articles/generating-an-ssh-key/)指导你如何生成SSH Key，按照步骤一步步来。\n\n最后在Github网页上个人设置找到SSH Key填写界面，把`id_rsa.pub`里面的内容复制粘贴进去就完成了。\n{% asset_img Snip20160901_2.png github SSH key %}\n\n## 发布文章\n终端cd到`blog`目录下执行新建文件的指令\n\n```bash\nhexo new \"postName\"\n```\n`postName`是新建的md文件的名称，会在`/blog/source/_posts`目录下生成一个名为`postName.md`的文件。可以使用`MWeb`编辑器修改文章，支持预览，由于MWeb是收费的，可以使用免费的Mou编辑器。\n\n当文章编辑完成，在blog目录下，执行下面命令\n\n```bash\nhexo g //生成静态页面\nhexo d //将文章部署到Github\n```\n**浏览器打开`http://piglikeyoung.github.io`已经能够访问到基于Github的Hexo的博客了。**\n\n> Tips：Hexo支持热更新，所以不用每次修改了一点文章内容都部署到Github上查看变化，你可以本地开启Hexo，一边本地修改，一边在浏览器上刷新 http://localhost:4000/ ，就可以看到刚才的修改。\n\n## 主题安装\nHexo支持很多主题，它有个[主题网址](https://hexo.io/themes/)，在上面能够找到很多主题。\n\n我使用的是[jacman](https://github.com/wuchong/jacman)这个主题。打开jacman网址有个中文说明教程来指导你如何安装主题，在blog目录下执行命令\n\n```bash\ngit clone https://github.com/wuchong/jacman.git themes/jacman\n```\n\n修改博客根目录下的配置文件 `_config.yml`，把`theme`的值修改为 `jacman`。\n执行命令重新部署Hexo\n\n```bash\nhexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)\nhexo g //生成静态页面\nhexo d //将文章部署到Github\n```\n**如果要详细配置主题请参考[jacman](https://github.com/wuchong/jacman)上的中文文档，相当详细。**\n\n我个人fork了一份原版的主题，做了些许修改，如果你要做修改可以参考我的fork提交[myJacman](https://github.com/piglikeYoung/jacman)\n\n## 绑定个人域名\n有的朋友不太喜欢那个访问域名，因为那个Github提供的二级域名，喜欢个性化的朋友可以购买自己的域名。购买域名有很多途径，比如[GoDaddy](https://sg.godaddy.com/zh/)，[阿里万网](http://wanwang.aliyun.com/)。在国内买域名，好处是网站是中文的方便后期维护，坏处是解析域名大部分要实名认证，上传身份证复印件，国外就没这个要求。\n\n### 主题添加域名\n在**/blog/themes/jacman/source**目录下新建一个名为`CNAME`的文件，不带后缀，直接把自己购买的域名`piglikeyoung.com`写入。\n重新部署Hexo，就可以实现域名跳转（如果域名已经解析完成）。\n\n### 域名解析\n域名购买完成，必须经过解析才能实现跳转，如果在阿里万网上购买，可以直接点击添加解析，如果在国外购买可以使用[DNSPOD](https://www.dnspod.cn/)来解析域名。\n参考下图来添加解析\n{% asset_img Snip20160902_4.png DNS %}\n\n记录类型：CNAME\n主机记录：example.com（不要www），填写@或者不填\n记录值：piglikeyoung.github.io. (不要忘记最后的.，piglikeyoung改为你自己的用户名)，点击保存即可\n\n此时，点击 http://piglikeyoung.com/ 已经可以实现跳转，http://piglikeyoung.com/ 和 http://piglikeyoung.github.io. 会显示一样内容。\n\n\n## 优化部署和管理\n通过上面的内容，相信你已经能够顺利的完成Hexo部署，将你的md文件转化为静态网页了。此时也许你会问：\n* 当我在自己电脑写博客，到了公司也想用公司的电脑写博客\n* 重装电脑了博客文章怎么办\n\n这样你得做好备份了，使用百度云或者U盘等等，但是，你不觉得这不够优雅吗？放着一个Github不用，去用别的备份工具。为此我搜索了很多解决方案。\n最简单的就是利用`分支`。\n\n**一个Github Pages仓库，至少创建2个分支，一个是`master`用于部署网站，一个是`hexo`用来存放你的博客文件。**\n\n### 创建步骤\n* 创建仓库`piglikeyoung.github.io`\n* 创建两个分支：`master`（默认就存在）和`hexo`\n* 切换到`hexo`分支，clone到本地\n* 在`hexo`分支下，执行`hexo init blog`，`npm install`等初始化博客命令，并且执行git版本控制命令，提交到github\n* 修改`_config.yml`里面的deploy参数，设置部署分支为`master`\n* 最后执行`hexo g -d`生成静态网页并部署到github上\n\n**总之，在piglikeyoung.github.io仓库就有了两个分支，master用于部署生成的网页，hexo用于管理博客文件。**\n\n### 日常维护\n你只需要在hexo的分支下完成博客的增删改查，通过Hexo指令部署到master分支。\n\n当你使用另一台电脑修改博客，你只需这么做：\n* 把piglikeyoung.github.io仓库clone到本地，切换到`hexo`分支\n* 在clone的本地仓库文件夹下依次执行：`npm install hexo`、`npm install`、`npm install hexo-deployer-git`（切记，不需要执行hexo init这条指令，它会重新创建一个新的博客）。\n\n## 后记\n本博客的第一篇文章总算写完了，其中参考很多网上优秀博文才能顺利搭建完成，非常感谢他们的无私贡献。\n* [Mac上搭建基于GitHub的Hexo博客](http://gonghonglou.com/2016/02/03/firstblog/)\n* [从 Octopress 迁移到 Hexo](http://blog.devtang.com/2016/02/16/from-octopress-to-hexo/)\n\n\n\n\n\n\n","source":"_posts/GitHub-Pages-Hexo搭建博客.md","raw":"---\ntitle: GitHub Pages + Hexo搭建博客\ndate: 2016-08-31 22:24:25\ntags: Hexo\ncategory: 能工巧匠\n---\n\n这篇博客是使用**Github Pages + Hexo** 搭建本博客的总结。\n\n作为一个有多年开发经验的人来说，没有搭建自己的博客，记录自己的开发点点滴滴，实在有点遗憾，以前总以为搭建博客得买服务器，域名等复杂的步骤，然后选择了国内老牌的博客CSDN或博客园来写博客，但可拓展性太低，千篇一律。\n\n最近经过朋友的介绍使用GitHub Pages + Hexo搭建免费的独立博客，痛下决心来做一次。\n\n## 前言\n搭建博客需要先了解几个知识点\n* [Git](https://git-scm.com/book/zh/v2)\n* [GitHub](https://github.com/)\n* [GitHub Pages](https://pages.github.com/)\n* [Hexo](https://hexo.io/zh-cn/)\n* [Markdown](http://www.appinn.com/markdown/#overview)\n\n## 环境配置\n### 安装Hexo\n由于安装Hexo需要Node.js和Git，所以在[Hexo](https://hexo.io/zh-cn/)官网上有安装的详细说明（中文版），不再赘述（Mac电脑有自带Git的）。\n\n当Node.js和Git都安装完成后，开始正式安装Hexo，在终端上执行\n``` bash\n$ sudo npm install -g hexo\n```\n需要输入管理员密码（Mac登录密码）。(`sudo`：Linux管理员指令，`-g`：全局安装)\n> 坑一：[Hexo官网](https://hexo.io/zh-cn/)上的安装命令是`$ npm install -g hexo-cli`，安装时不要忘记前面加上`sudo`，否则会因为权限问题报错。\n\n### 初始化博客\n终端cd到你想创建博客的文件夹，然后中执行终端命令\n```bash\n$ hexo init blog\n```\nblog是你新建的博客文件夹，cd到这个文件夹，然后执行命令安装npm\n\n```bash\n$ npm install\n```\n最后执行命令，开启Hexo本地服务器\n\n```bash\n$ hexo s // 全称：hexo server\n```\n终端中会提示在浏览器打开 http://localhost:4000 这个网址就可以看到（**因为我配置了主题内容，请忽略图片上的文字，之后将会讲到主题**）\n{% asset_img Snip20160831_1.png hexo init image %}\n\n## 关联Github\n### 创建仓库\n在前言的[GitHub Pages](https://pages.github.com/)中介绍了Pages仓库，所以要创建一个名为`用户名.github.io`固定写法的参考，例如`piglikeyoung.github.io`，如下图所示\n{% asset_img Snip20160831_2.png github Pages image %}\n\n本地的blog目录结构\n\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n用文本编辑器打开`_config.yml`\n修改下列代码\n\n```\n\t deploy:\n    type: git\n    repository: https://github.com/piglikeYoung/piglikeyoung.github.io.git\n    branch: master\n```\n你需要把`repository`替换成你自己的github地址\n> 坑二：在配置所有的`_config.yml`文件时（包括theme中的），在所有的`冒号:`后边都要加一个`空格`，否则执行hexo命令会报错，切记 切记\n\n在 blog文件夹目录下执行下面命令生成静态页面\n```bash\n$ hexo g        //全称：hexo generate\n```\n\n```\n如果出现如下报错：\nERROR Local hexo not found in ~/blog\nERROR Try runing: 'npm install hexo --save'\n则执行命令：\nnpm install hexo --save\n若无报错，自行忽略此步骤。\n```\n再执行命令部署静态网页\n```bash\n$ hexo d            //全称：hexo deploy\n```\n> 坑三：执行`hexo d`报错无法连接git或找不到git，执行这个命令 \n```bash\n$ npm install hexo-deployer-git --save\n```\n\n再次执行`hexo g`和`hexo d`命令。\n\n如果你的电脑没有管理Github，执行`hexo d`时终端会提示你输入Github的用户名和密码\n\n```bash\nUsername for 'https://github.com':\nPassword for 'https://github.com':\n```\n当`hexo d`执行成功，在浏览器上输入 http://piglikeyoung.github.io 就会显示 http://localhost:4000 一样的页面。\n\n**为了避免每次都输入Github用户名和密码，可以参考下一章来配置SSH Keys**\n\n## 添加SSH Key到Github\n### 判断是否已经生成了SSH Key\n如果已经生成了SSH Key会在`~/.ssh/id_rsa.pub`目录下面找到`id_rsa`和`id_rsa.pub`这两个文件。\n如果没有生成执行下面命令生成\n```bash\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n```\n其中`your_email@example.com`是你的Github邮箱。\n在Github上有这个[Help文档](https://help.github.com/articles/generating-an-ssh-key/)指导你如何生成SSH Key，按照步骤一步步来。\n\n最后在Github网页上个人设置找到SSH Key填写界面，把`id_rsa.pub`里面的内容复制粘贴进去就完成了。\n{% asset_img Snip20160901_2.png github SSH key %}\n\n## 发布文章\n终端cd到`blog`目录下执行新建文件的指令\n\n```bash\nhexo new \"postName\"\n```\n`postName`是新建的md文件的名称，会在`/blog/source/_posts`目录下生成一个名为`postName.md`的文件。可以使用`MWeb`编辑器修改文章，支持预览，由于MWeb是收费的，可以使用免费的Mou编辑器。\n\n当文章编辑完成，在blog目录下，执行下面命令\n\n```bash\nhexo g //生成静态页面\nhexo d //将文章部署到Github\n```\n**浏览器打开`http://piglikeyoung.github.io`已经能够访问到基于Github的Hexo的博客了。**\n\n> Tips：Hexo支持热更新，所以不用每次修改了一点文章内容都部署到Github上查看变化，你可以本地开启Hexo，一边本地修改，一边在浏览器上刷新 http://localhost:4000/ ，就可以看到刚才的修改。\n\n## 主题安装\nHexo支持很多主题，它有个[主题网址](https://hexo.io/themes/)，在上面能够找到很多主题。\n\n我使用的是[jacman](https://github.com/wuchong/jacman)这个主题。打开jacman网址有个中文说明教程来指导你如何安装主题，在blog目录下执行命令\n\n```bash\ngit clone https://github.com/wuchong/jacman.git themes/jacman\n```\n\n修改博客根目录下的配置文件 `_config.yml`，把`theme`的值修改为 `jacman`。\n执行命令重新部署Hexo\n\n```bash\nhexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)\nhexo g //生成静态页面\nhexo d //将文章部署到Github\n```\n**如果要详细配置主题请参考[jacman](https://github.com/wuchong/jacman)上的中文文档，相当详细。**\n\n我个人fork了一份原版的主题，做了些许修改，如果你要做修改可以参考我的fork提交[myJacman](https://github.com/piglikeYoung/jacman)\n\n## 绑定个人域名\n有的朋友不太喜欢那个访问域名，因为那个Github提供的二级域名，喜欢个性化的朋友可以购买自己的域名。购买域名有很多途径，比如[GoDaddy](https://sg.godaddy.com/zh/)，[阿里万网](http://wanwang.aliyun.com/)。在国内买域名，好处是网站是中文的方便后期维护，坏处是解析域名大部分要实名认证，上传身份证复印件，国外就没这个要求。\n\n### 主题添加域名\n在**/blog/themes/jacman/source**目录下新建一个名为`CNAME`的文件，不带后缀，直接把自己购买的域名`piglikeyoung.com`写入。\n重新部署Hexo，就可以实现域名跳转（如果域名已经解析完成）。\n\n### 域名解析\n域名购买完成，必须经过解析才能实现跳转，如果在阿里万网上购买，可以直接点击添加解析，如果在国外购买可以使用[DNSPOD](https://www.dnspod.cn/)来解析域名。\n参考下图来添加解析\n{% asset_img Snip20160902_4.png DNS %}\n\n记录类型：CNAME\n主机记录：example.com（不要www），填写@或者不填\n记录值：piglikeyoung.github.io. (不要忘记最后的.，piglikeyoung改为你自己的用户名)，点击保存即可\n\n此时，点击 http://piglikeyoung.com/ 已经可以实现跳转，http://piglikeyoung.com/ 和 http://piglikeyoung.github.io. 会显示一样内容。\n\n\n## 优化部署和管理\n通过上面的内容，相信你已经能够顺利的完成Hexo部署，将你的md文件转化为静态网页了。此时也许你会问：\n* 当我在自己电脑写博客，到了公司也想用公司的电脑写博客\n* 重装电脑了博客文章怎么办\n\n这样你得做好备份了，使用百度云或者U盘等等，但是，你不觉得这不够优雅吗？放着一个Github不用，去用别的备份工具。为此我搜索了很多解决方案。\n最简单的就是利用`分支`。\n\n**一个Github Pages仓库，至少创建2个分支，一个是`master`用于部署网站，一个是`hexo`用来存放你的博客文件。**\n\n### 创建步骤\n* 创建仓库`piglikeyoung.github.io`\n* 创建两个分支：`master`（默认就存在）和`hexo`\n* 切换到`hexo`分支，clone到本地\n* 在`hexo`分支下，执行`hexo init blog`，`npm install`等初始化博客命令，并且执行git版本控制命令，提交到github\n* 修改`_config.yml`里面的deploy参数，设置部署分支为`master`\n* 最后执行`hexo g -d`生成静态网页并部署到github上\n\n**总之，在piglikeyoung.github.io仓库就有了两个分支，master用于部署生成的网页，hexo用于管理博客文件。**\n\n### 日常维护\n你只需要在hexo的分支下完成博客的增删改查，通过Hexo指令部署到master分支。\n\n当你使用另一台电脑修改博客，你只需这么做：\n* 把piglikeyoung.github.io仓库clone到本地，切换到`hexo`分支\n* 在clone的本地仓库文件夹下依次执行：`npm install hexo`、`npm install`、`npm install hexo-deployer-git`（切记，不需要执行hexo init这条指令，它会重新创建一个新的博客）。\n\n## 后记\n本博客的第一篇文章总算写完了，其中参考很多网上优秀博文才能顺利搭建完成，非常感谢他们的无私贡献。\n* [Mac上搭建基于GitHub的Hexo博客](http://gonghonglou.com/2016/02/03/firstblog/)\n* [从 Octopress 迁移到 Hexo](http://blog.devtang.com/2016/02/16/from-octopress-to-hexo/)\n\n\n\n\n\n\n","slug":"GitHub-Pages-Hexo搭建博客","published":1,"updated":"2016-09-11T05:41:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7nv00418jpbpl5zj52u","content":"<p>这篇博客是使用<strong>Github Pages + Hexo</strong> 搭建本博客的总结。</p>\n<p>作为一个有多年开发经验的人来说，没有搭建自己的博客，记录自己的开发点点滴滴，实在有点遗憾，以前总以为搭建博客得买服务器，域名等复杂的步骤，然后选择了国内老牌的博客CSDN或博客园来写博客，但可拓展性太低，千篇一律。</p>\n<p>最近经过朋友的介绍使用GitHub Pages + Hexo搭建免费的独立博客，痛下决心来做一次。</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>搭建博客需要先了解几个知识点</p>\n<ul>\n<li><a href=\"https://git-scm.com/book/zh/v2\" target=\"_blank\" rel=\"noopener\">Git</a></li>\n<li><a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">GitHub</a></li>\n<li><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">GitHub Pages</a></li>\n<li><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a></li>\n<li><a href=\"http://www.appinn.com/markdown/#overview\" target=\"_blank\" rel=\"noopener\">Markdown</a></li>\n</ul>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><p>由于安装Hexo需要Node.js和Git，所以在<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>官网上有安装的详细说明（中文版），不再赘述（Mac电脑有自带Git的）。</p>\n<p>当Node.js和Git都安装完成后，开始正式安装Hexo，在终端上执行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm install -g hexo</span><br></pre></td></tr></table></figure></p>\n<p>需要输入管理员密码（Mac登录密码）。(<code>sudo</code>：Linux管理员指令，<code>-g</code>：全局安装)</p>\n<blockquote>\n<p>坑一：<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo官网</a>上的安装命令是<code>$ npm install -g hexo-cli</code>，安装时不要忘记前面加上<code>sudo</code>，否则会因为权限问题报错。</p>\n</blockquote>\n<h3 id=\"初始化博客\"><a href=\"#初始化博客\" class=\"headerlink\" title=\"初始化博客\"></a>初始化博客</h3><p>终端cd到你想创建博客的文件夹，然后中执行终端命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog</span><br></pre></td></tr></table></figure></p>\n<p>blog是你新建的博客文件夹，cd到这个文件夹，然后执行命令安装npm</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>最后执行命令，开启Hexo本地服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s // 全称：hexo server</span><br></pre></td></tr></table></figure>\n<p>终端中会提示在浏览器打开 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 这个网址就可以看到（<strong>因为我配置了主题内容，请忽略图片上的文字，之后将会讲到主题</strong>）<br><img src=\"/2016/08/31/GitHub-Pages-Hexo搭建博客/Snip20160831_1.png\" title=\"hexo init image\"></p>\n<h2 id=\"关联Github\"><a href=\"#关联Github\" class=\"headerlink\" title=\"关联Github\"></a>关联Github</h2><h3 id=\"创建仓库\"><a href=\"#创建仓库\" class=\"headerlink\" title=\"创建仓库\"></a>创建仓库</h3><p>在前言的<a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">GitHub Pages</a>中介绍了Pages仓库，所以要创建一个名为<code>用户名.github.io</code>固定写法的参考，例如<code>piglikeyoung.github.io</code>，如下图所示<br><img src=\"/2016/08/31/GitHub-Pages-Hexo搭建博客/Snip20160831_2.png\" title=\"github Pages image\"></p>\n<p>本地的blog目录结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<p>用文本编辑器打开<code>_config.yml</code><br>修改下列代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: https://github.com/piglikeYoung/piglikeyoung.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>你需要把<code>repository</code>替换成你自己的github地址</p>\n<blockquote>\n<p>坑二：在配置所有的<code>_config.yml</code>文件时（包括theme中的），在所有的<code>冒号:</code>后边都要加一个<code>空格</code>，否则执行hexo命令会报错，切记 切记</p>\n</blockquote>\n<p>在 blog文件夹目录下执行下面命令生成静态页面<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g        //全称：hexo generate</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果出现如下报错：</span><br><span class=\"line\">ERROR Local hexo not found in ~/blog</span><br><span class=\"line\">ERROR Try runing: &apos;npm install hexo --save&apos;</span><br><span class=\"line\">则执行命令：</span><br><span class=\"line\">npm install hexo --save</span><br><span class=\"line\">若无报错，自行忽略此步骤。</span><br></pre></td></tr></table></figure>\n<p>再执行命令部署静态网页<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d            //全称：hexo deploy</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>坑三：执行<code>hexo d</code>报错无法连接git或找不到git，执行这个命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>再次执行<code>hexo g</code>和<code>hexo d</code>命令。</p>\n<p>如果你的电脑没有管理Github，执行<code>hexo d</code>时终端会提示你输入Github的用户名和密码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Username <span class=\"keyword\">for</span> <span class=\"string\">'https://github.com'</span>:</span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"string\">'https://github.com'</span>:</span><br></pre></td></tr></table></figure>\n<p>当<code>hexo d</code>执行成功，在浏览器上输入 <a href=\"http://piglikeyoung.github.io\" target=\"_blank\" rel=\"noopener\">http://piglikeyoung.github.io</a> 就会显示 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 一样的页面。</p>\n<p><strong>为了避免每次都输入Github用户名和密码，可以参考下一章来配置SSH Keys</strong></p>\n<h2 id=\"添加SSH-Key到Github\"><a href=\"#添加SSH-Key到Github\" class=\"headerlink\" title=\"添加SSH Key到Github\"></a>添加SSH Key到Github</h2><h3 id=\"判断是否已经生成了SSH-Key\"><a href=\"#判断是否已经生成了SSH-Key\" class=\"headerlink\" title=\"判断是否已经生成了SSH Key\"></a>判断是否已经生成了SSH Key</h3><p>如果已经生成了SSH Key会在<code>~/.ssh/id_rsa.pub</code>目录下面找到<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件。<br>如果没有生成执行下面命令生成<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C <span class=\"string\">\"your_email@example.com\"</span></span><br></pre></td></tr></table></figure></p>\n<p>其中<a href=\"mailto:`your_email@example.com\" target=\"_blank\" rel=\"noopener\">`your_email@example.com</a>`是你的Github邮箱。<br>在Github上有这个<a href=\"https://help.github.com/articles/generating-an-ssh-key/\" target=\"_blank\" rel=\"noopener\">Help文档</a>指导你如何生成SSH Key，按照步骤一步步来。</p>\n<p>最后在Github网页上个人设置找到SSH Key填写界面，把<code>id_rsa.pub</code>里面的内容复制粘贴进去就完成了。<br><img src=\"/2016/08/31/GitHub-Pages-Hexo搭建博客/Snip20160901_2.png\" title=\"github SSH key\"></p>\n<h2 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h2><p>终端cd到<code>blog</code>目录下执行新建文件的指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span></span><br></pre></td></tr></table></figure>\n<p><code>postName</code>是新建的md文件的名称，会在<code>/blog/source/_posts</code>目录下生成一个名为<code>postName.md</code>的文件。可以使用<code>MWeb</code>编辑器修改文章，支持预览，由于MWeb是收费的，可以使用免费的Mou编辑器。</p>\n<p>当文章编辑完成，在blog目录下，执行下面命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g //生成静态页面</span><br><span class=\"line\">hexo d //将文章部署到Github</span><br></pre></td></tr></table></figure>\n<p><strong>浏览器打开<code>http://piglikeyoung.github.io</code>已经能够访问到基于Github的Hexo的博客了。</strong></p>\n<blockquote>\n<p>Tips：Hexo支持热更新，所以不用每次修改了一点文章内容都部署到Github上查看变化，你可以本地开启Hexo，一边本地修改，一边在浏览器上刷新 <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a> ，就可以看到刚才的修改。</p>\n</blockquote>\n<h2 id=\"主题安装\"><a href=\"#主题安装\" class=\"headerlink\" title=\"主题安装\"></a>主题安装</h2><p>Hexo支持很多主题，它有个<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">主题网址</a>，在上面能够找到很多主题。</p>\n<p>我使用的是<a href=\"https://github.com/wuchong/jacman\" target=\"_blank\" rel=\"noopener\">jacman</a>这个主题。打开jacman网址有个中文说明教程来指导你如何安装主题，在blog目录下执行命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/wuchong/jacman.git themes/jacman</span><br></pre></td></tr></table></figure>\n<p>修改博客根目录下的配置文件 <code>_config.yml</code>，把<code>theme</code>的值修改为 <code>jacman</code>。<br>执行命令重新部署Hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class=\"line\">hexo g //生成静态页面</span><br><span class=\"line\">hexo d //将文章部署到Github</span><br></pre></td></tr></table></figure>\n<p><strong>如果要详细配置主题请参考<a href=\"https://github.com/wuchong/jacman\" target=\"_blank\" rel=\"noopener\">jacman</a>上的中文文档，相当详细。</strong></p>\n<p>我个人fork了一份原版的主题，做了些许修改，如果你要做修改可以参考我的fork提交<a href=\"https://github.com/piglikeYoung/jacman\" target=\"_blank\" rel=\"noopener\">myJacman</a></p>\n<h2 id=\"绑定个人域名\"><a href=\"#绑定个人域名\" class=\"headerlink\" title=\"绑定个人域名\"></a>绑定个人域名</h2><p>有的朋友不太喜欢那个访问域名，因为那个Github提供的二级域名，喜欢个性化的朋友可以购买自己的域名。购买域名有很多途径，比如<a href=\"https://sg.godaddy.com/zh/\" target=\"_blank\" rel=\"noopener\">GoDaddy</a>，<a href=\"http://wanwang.aliyun.com/\" target=\"_blank\" rel=\"noopener\">阿里万网</a>。在国内买域名，好处是网站是中文的方便后期维护，坏处是解析域名大部分要实名认证，上传身份证复印件，国外就没这个要求。</p>\n<h3 id=\"主题添加域名\"><a href=\"#主题添加域名\" class=\"headerlink\" title=\"主题添加域名\"></a>主题添加域名</h3><p>在<strong>/blog/themes/jacman/source</strong>目录下新建一个名为<code>CNAME</code>的文件，不带后缀，直接把自己购买的域名<code>piglikeyoung.com</code>写入。<br>重新部署Hexo，就可以实现域名跳转（如果域名已经解析完成）。</p>\n<h3 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h3><p>域名购买完成，必须经过解析才能实现跳转，如果在阿里万网上购买，可以直接点击添加解析，如果在国外购买可以使用<a href=\"https://www.dnspod.cn/\" target=\"_blank\" rel=\"noopener\">DNSPOD</a>来解析域名。<br>参考下图来添加解析<br><img src=\"/2016/08/31/GitHub-Pages-Hexo搭建博客/Snip20160902_4.png\" title=\"DNS\"></p>\n<p>记录类型：CNAME<br>主机记录：example.com（不要www），填写@或者不填<br>记录值：piglikeyoung.github.io. (不要忘记最后的.，piglikeyoung改为你自己的用户名)，点击保存即可</p>\n<p>此时，点击 <a href=\"http://piglikeyoung.com/\">http://piglikeyoung.com/</a> 已经可以实现跳转，<a href=\"http://piglikeyoung.com/\">http://piglikeyoung.com/</a> 和 <a href=\"http://piglikeyoung.github.io\" target=\"_blank\" rel=\"noopener\">http://piglikeyoung.github.io</a>. 会显示一样内容。</p>\n<h2 id=\"优化部署和管理\"><a href=\"#优化部署和管理\" class=\"headerlink\" title=\"优化部署和管理\"></a>优化部署和管理</h2><p>通过上面的内容，相信你已经能够顺利的完成Hexo部署，将你的md文件转化为静态网页了。此时也许你会问：</p>\n<ul>\n<li>当我在自己电脑写博客，到了公司也想用公司的电脑写博客</li>\n<li>重装电脑了博客文章怎么办</li>\n</ul>\n<p>这样你得做好备份了，使用百度云或者U盘等等，但是，你不觉得这不够优雅吗？放着一个Github不用，去用别的备份工具。为此我搜索了很多解决方案。<br>最简单的就是利用<code>分支</code>。</p>\n<p><strong>一个Github Pages仓库，至少创建2个分支，一个是<code>master</code>用于部署网站，一个是<code>hexo</code>用来存放你的博客文件。</strong></p>\n<h3 id=\"创建步骤\"><a href=\"#创建步骤\" class=\"headerlink\" title=\"创建步骤\"></a>创建步骤</h3><ul>\n<li>创建仓库<code>piglikeyoung.github.io</code></li>\n<li>创建两个分支：<code>master</code>（默认就存在）和<code>hexo</code></li>\n<li>切换到<code>hexo</code>分支，clone到本地</li>\n<li>在<code>hexo</code>分支下，执行<code>hexo init blog</code>，<code>npm install</code>等初始化博客命令，并且执行git版本控制命令，提交到github</li>\n<li>修改<code>_config.yml</code>里面的deploy参数，设置部署分支为<code>master</code></li>\n<li>最后执行<code>hexo g -d</code>生成静态网页并部署到github上</li>\n</ul>\n<p><strong>总之，在piglikeyoung.github.io仓库就有了两个分支，master用于部署生成的网页，hexo用于管理博客文件。</strong></p>\n<h3 id=\"日常维护\"><a href=\"#日常维护\" class=\"headerlink\" title=\"日常维护\"></a>日常维护</h3><p>你只需要在hexo的分支下完成博客的增删改查，通过Hexo指令部署到master分支。</p>\n<p>当你使用另一台电脑修改博客，你只需这么做：</p>\n<ul>\n<li>把piglikeyoung.github.io仓库clone到本地，切换到<code>hexo</code>分支</li>\n<li>在clone的本地仓库文件夹下依次执行：<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>（切记，不需要执行hexo init这条指令，它会重新创建一个新的博客）。</li>\n</ul>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>本博客的第一篇文章总算写完了，其中参考很多网上优秀博文才能顺利搭建完成，非常感谢他们的无私贡献。</p>\n<ul>\n<li><a href=\"http://gonghonglou.com/2016/02/03/firstblog/\" target=\"_blank\" rel=\"noopener\">Mac上搭建基于GitHub的Hexo博客</a></li>\n<li><a href=\"http://blog.devtang.com/2016/02/16/from-octopress-to-hexo/\" target=\"_blank\" rel=\"noopener\">从 Octopress 迁移到 Hexo</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇博客是使用<strong>Github Pages + Hexo</strong> 搭建本博客的总结。</p>\n<p>作为一个有多年开发经验的人来说，没有搭建自己的博客，记录自己的开发点点滴滴，实在有点遗憾，以前总以为搭建博客得买服务器，域名等复杂的步骤，然后选择了国内老牌的博客CSDN或博客园来写博客，但可拓展性太低，千篇一律。</p>\n<p>最近经过朋友的介绍使用GitHub Pages + Hexo搭建免费的独立博客，痛下决心来做一次。</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>搭建博客需要先了解几个知识点</p>\n<ul>\n<li><a href=\"https://git-scm.com/book/zh/v2\" target=\"_blank\" rel=\"noopener\">Git</a></li>\n<li><a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">GitHub</a></li>\n<li><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">GitHub Pages</a></li>\n<li><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a></li>\n<li><a href=\"http://www.appinn.com/markdown/#overview\" target=\"_blank\" rel=\"noopener\">Markdown</a></li>\n</ul>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><p>由于安装Hexo需要Node.js和Git，所以在<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>官网上有安装的详细说明（中文版），不再赘述（Mac电脑有自带Git的）。</p>\n<p>当Node.js和Git都安装完成后，开始正式安装Hexo，在终端上执行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm install -g hexo</span><br></pre></td></tr></table></figure></p>\n<p>需要输入管理员密码（Mac登录密码）。(<code>sudo</code>：Linux管理员指令，<code>-g</code>：全局安装)</p>\n<blockquote>\n<p>坑一：<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo官网</a>上的安装命令是<code>$ npm install -g hexo-cli</code>，安装时不要忘记前面加上<code>sudo</code>，否则会因为权限问题报错。</p>\n</blockquote>\n<h3 id=\"初始化博客\"><a href=\"#初始化博客\" class=\"headerlink\" title=\"初始化博客\"></a>初始化博客</h3><p>终端cd到你想创建博客的文件夹，然后中执行终端命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog</span><br></pre></td></tr></table></figure></p>\n<p>blog是你新建的博客文件夹，cd到这个文件夹，然后执行命令安装npm</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>最后执行命令，开启Hexo本地服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s // 全称：hexo server</span><br></pre></td></tr></table></figure>\n<p>终端中会提示在浏览器打开 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 这个网址就可以看到（<strong>因为我配置了主题内容，请忽略图片上的文字，之后将会讲到主题</strong>）<br><img src=\"/2016/08/31/GitHub-Pages-Hexo搭建博客/Snip20160831_1.png\" title=\"hexo init image\"></p>\n<h2 id=\"关联Github\"><a href=\"#关联Github\" class=\"headerlink\" title=\"关联Github\"></a>关联Github</h2><h3 id=\"创建仓库\"><a href=\"#创建仓库\" class=\"headerlink\" title=\"创建仓库\"></a>创建仓库</h3><p>在前言的<a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">GitHub Pages</a>中介绍了Pages仓库，所以要创建一个名为<code>用户名.github.io</code>固定写法的参考，例如<code>piglikeyoung.github.io</code>，如下图所示<br><img src=\"/2016/08/31/GitHub-Pages-Hexo搭建博客/Snip20160831_2.png\" title=\"github Pages image\"></p>\n<p>本地的blog目录结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<p>用文本编辑器打开<code>_config.yml</code><br>修改下列代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: https://github.com/piglikeYoung/piglikeyoung.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>你需要把<code>repository</code>替换成你自己的github地址</p>\n<blockquote>\n<p>坑二：在配置所有的<code>_config.yml</code>文件时（包括theme中的），在所有的<code>冒号:</code>后边都要加一个<code>空格</code>，否则执行hexo命令会报错，切记 切记</p>\n</blockquote>\n<p>在 blog文件夹目录下执行下面命令生成静态页面<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g        //全称：hexo generate</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果出现如下报错：</span><br><span class=\"line\">ERROR Local hexo not found in ~/blog</span><br><span class=\"line\">ERROR Try runing: &apos;npm install hexo --save&apos;</span><br><span class=\"line\">则执行命令：</span><br><span class=\"line\">npm install hexo --save</span><br><span class=\"line\">若无报错，自行忽略此步骤。</span><br></pre></td></tr></table></figure>\n<p>再执行命令部署静态网页<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d            //全称：hexo deploy</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>坑三：执行<code>hexo d</code>报错无法连接git或找不到git，执行这个命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>再次执行<code>hexo g</code>和<code>hexo d</code>命令。</p>\n<p>如果你的电脑没有管理Github，执行<code>hexo d</code>时终端会提示你输入Github的用户名和密码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Username <span class=\"keyword\">for</span> <span class=\"string\">'https://github.com'</span>:</span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"string\">'https://github.com'</span>:</span><br></pre></td></tr></table></figure>\n<p>当<code>hexo d</code>执行成功，在浏览器上输入 <a href=\"http://piglikeyoung.github.io\" target=\"_blank\" rel=\"noopener\">http://piglikeyoung.github.io</a> 就会显示 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 一样的页面。</p>\n<p><strong>为了避免每次都输入Github用户名和密码，可以参考下一章来配置SSH Keys</strong></p>\n<h2 id=\"添加SSH-Key到Github\"><a href=\"#添加SSH-Key到Github\" class=\"headerlink\" title=\"添加SSH Key到Github\"></a>添加SSH Key到Github</h2><h3 id=\"判断是否已经生成了SSH-Key\"><a href=\"#判断是否已经生成了SSH-Key\" class=\"headerlink\" title=\"判断是否已经生成了SSH Key\"></a>判断是否已经生成了SSH Key</h3><p>如果已经生成了SSH Key会在<code>~/.ssh/id_rsa.pub</code>目录下面找到<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件。<br>如果没有生成执行下面命令生成<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C <span class=\"string\">\"your_email@example.com\"</span></span><br></pre></td></tr></table></figure></p>\n<p>其中<a href=\"mailto:`your_email@example.com\" target=\"_blank\" rel=\"noopener\">`your_email@example.com</a>`是你的Github邮箱。<br>在Github上有这个<a href=\"https://help.github.com/articles/generating-an-ssh-key/\" target=\"_blank\" rel=\"noopener\">Help文档</a>指导你如何生成SSH Key，按照步骤一步步来。</p>\n<p>最后在Github网页上个人设置找到SSH Key填写界面，把<code>id_rsa.pub</code>里面的内容复制粘贴进去就完成了。<br><img src=\"/2016/08/31/GitHub-Pages-Hexo搭建博客/Snip20160901_2.png\" title=\"github SSH key\"></p>\n<h2 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h2><p>终端cd到<code>blog</code>目录下执行新建文件的指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span></span><br></pre></td></tr></table></figure>\n<p><code>postName</code>是新建的md文件的名称，会在<code>/blog/source/_posts</code>目录下生成一个名为<code>postName.md</code>的文件。可以使用<code>MWeb</code>编辑器修改文章，支持预览，由于MWeb是收费的，可以使用免费的Mou编辑器。</p>\n<p>当文章编辑完成，在blog目录下，执行下面命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g //生成静态页面</span><br><span class=\"line\">hexo d //将文章部署到Github</span><br></pre></td></tr></table></figure>\n<p><strong>浏览器打开<code>http://piglikeyoung.github.io</code>已经能够访问到基于Github的Hexo的博客了。</strong></p>\n<blockquote>\n<p>Tips：Hexo支持热更新，所以不用每次修改了一点文章内容都部署到Github上查看变化，你可以本地开启Hexo，一边本地修改，一边在浏览器上刷新 <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a> ，就可以看到刚才的修改。</p>\n</blockquote>\n<h2 id=\"主题安装\"><a href=\"#主题安装\" class=\"headerlink\" title=\"主题安装\"></a>主题安装</h2><p>Hexo支持很多主题，它有个<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">主题网址</a>，在上面能够找到很多主题。</p>\n<p>我使用的是<a href=\"https://github.com/wuchong/jacman\" target=\"_blank\" rel=\"noopener\">jacman</a>这个主题。打开jacman网址有个中文说明教程来指导你如何安装主题，在blog目录下执行命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/wuchong/jacman.git themes/jacman</span><br></pre></td></tr></table></figure>\n<p>修改博客根目录下的配置文件 <code>_config.yml</code>，把<code>theme</code>的值修改为 <code>jacman</code>。<br>执行命令重新部署Hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class=\"line\">hexo g //生成静态页面</span><br><span class=\"line\">hexo d //将文章部署到Github</span><br></pre></td></tr></table></figure>\n<p><strong>如果要详细配置主题请参考<a href=\"https://github.com/wuchong/jacman\" target=\"_blank\" rel=\"noopener\">jacman</a>上的中文文档，相当详细。</strong></p>\n<p>我个人fork了一份原版的主题，做了些许修改，如果你要做修改可以参考我的fork提交<a href=\"https://github.com/piglikeYoung/jacman\" target=\"_blank\" rel=\"noopener\">myJacman</a></p>\n<h2 id=\"绑定个人域名\"><a href=\"#绑定个人域名\" class=\"headerlink\" title=\"绑定个人域名\"></a>绑定个人域名</h2><p>有的朋友不太喜欢那个访问域名，因为那个Github提供的二级域名，喜欢个性化的朋友可以购买自己的域名。购买域名有很多途径，比如<a href=\"https://sg.godaddy.com/zh/\" target=\"_blank\" rel=\"noopener\">GoDaddy</a>，<a href=\"http://wanwang.aliyun.com/\" target=\"_blank\" rel=\"noopener\">阿里万网</a>。在国内买域名，好处是网站是中文的方便后期维护，坏处是解析域名大部分要实名认证，上传身份证复印件，国外就没这个要求。</p>\n<h3 id=\"主题添加域名\"><a href=\"#主题添加域名\" class=\"headerlink\" title=\"主题添加域名\"></a>主题添加域名</h3><p>在<strong>/blog/themes/jacman/source</strong>目录下新建一个名为<code>CNAME</code>的文件，不带后缀，直接把自己购买的域名<code>piglikeyoung.com</code>写入。<br>重新部署Hexo，就可以实现域名跳转（如果域名已经解析完成）。</p>\n<h3 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h3><p>域名购买完成，必须经过解析才能实现跳转，如果在阿里万网上购买，可以直接点击添加解析，如果在国外购买可以使用<a href=\"https://www.dnspod.cn/\" target=\"_blank\" rel=\"noopener\">DNSPOD</a>来解析域名。<br>参考下图来添加解析<br><img src=\"/2016/08/31/GitHub-Pages-Hexo搭建博客/Snip20160902_4.png\" title=\"DNS\"></p>\n<p>记录类型：CNAME<br>主机记录：example.com（不要www），填写@或者不填<br>记录值：piglikeyoung.github.io. (不要忘记最后的.，piglikeyoung改为你自己的用户名)，点击保存即可</p>\n<p>此时，点击 <a href=\"http://piglikeyoung.com/\">http://piglikeyoung.com/</a> 已经可以实现跳转，<a href=\"http://piglikeyoung.com/\">http://piglikeyoung.com/</a> 和 <a href=\"http://piglikeyoung.github.io\" target=\"_blank\" rel=\"noopener\">http://piglikeyoung.github.io</a>. 会显示一样内容。</p>\n<h2 id=\"优化部署和管理\"><a href=\"#优化部署和管理\" class=\"headerlink\" title=\"优化部署和管理\"></a>优化部署和管理</h2><p>通过上面的内容，相信你已经能够顺利的完成Hexo部署，将你的md文件转化为静态网页了。此时也许你会问：</p>\n<ul>\n<li>当我在自己电脑写博客，到了公司也想用公司的电脑写博客</li>\n<li>重装电脑了博客文章怎么办</li>\n</ul>\n<p>这样你得做好备份了，使用百度云或者U盘等等，但是，你不觉得这不够优雅吗？放着一个Github不用，去用别的备份工具。为此我搜索了很多解决方案。<br>最简单的就是利用<code>分支</code>。</p>\n<p><strong>一个Github Pages仓库，至少创建2个分支，一个是<code>master</code>用于部署网站，一个是<code>hexo</code>用来存放你的博客文件。</strong></p>\n<h3 id=\"创建步骤\"><a href=\"#创建步骤\" class=\"headerlink\" title=\"创建步骤\"></a>创建步骤</h3><ul>\n<li>创建仓库<code>piglikeyoung.github.io</code></li>\n<li>创建两个分支：<code>master</code>（默认就存在）和<code>hexo</code></li>\n<li>切换到<code>hexo</code>分支，clone到本地</li>\n<li>在<code>hexo</code>分支下，执行<code>hexo init blog</code>，<code>npm install</code>等初始化博客命令，并且执行git版本控制命令，提交到github</li>\n<li>修改<code>_config.yml</code>里面的deploy参数，设置部署分支为<code>master</code></li>\n<li>最后执行<code>hexo g -d</code>生成静态网页并部署到github上</li>\n</ul>\n<p><strong>总之，在piglikeyoung.github.io仓库就有了两个分支，master用于部署生成的网页，hexo用于管理博客文件。</strong></p>\n<h3 id=\"日常维护\"><a href=\"#日常维护\" class=\"headerlink\" title=\"日常维护\"></a>日常维护</h3><p>你只需要在hexo的分支下完成博客的增删改查，通过Hexo指令部署到master分支。</p>\n<p>当你使用另一台电脑修改博客，你只需这么做：</p>\n<ul>\n<li>把piglikeyoung.github.io仓库clone到本地，切换到<code>hexo</code>分支</li>\n<li>在clone的本地仓库文件夹下依次执行：<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>（切记，不需要执行hexo init这条指令，它会重新创建一个新的博客）。</li>\n</ul>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>本博客的第一篇文章总算写完了，其中参考很多网上优秀博文才能顺利搭建完成，非常感谢他们的无私贡献。</p>\n<ul>\n<li><a href=\"http://gonghonglou.com/2016/02/03/firstblog/\" target=\"_blank\" rel=\"noopener\">Mac上搭建基于GitHub的Hexo博客</a></li>\n<li><a href=\"http://blog.devtang.com/2016/02/16/from-octopress-to-hexo/\" target=\"_blank\" rel=\"noopener\">从 Octopress 迁移到 Hexo</a></li>\n</ul>\n"},{"title":"学习ReactNative基础（二）","date":"2017-03-18T09:44:11.000Z","_content":"\n## 前言\n上一篇文章介绍了 ReactNative 背景以及优缺点，分析了测试安装工程的工程结构，以及index.ios.js 的代码结构。\n开始学习RN前，需要学习React的一些语法，本篇文章就带你学习些简单的React语法。\n\n## React\n有过Web前端开发基础的人都知道，写网页就是写HTML文件，所以先创建个HTML5的文件。引入以下js文件：\n\n```JavaScript\n<!-- react.js 是React的核心库 -->\n<script src=\"https://unpkg.com/react@15/dist/react.js\"  charset=\"utf-8\"></script>\n<!-- react-dom.js的作用是提供与DOM相关的功能 -->\n<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"  charset=\"utf-8\"></script>\n<!-- browser.js的作用是将JSX语法转换成JavaScript的语法 -->\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.38/browser.js\" charset=\"utf-8\"></script>\n```\n\n并且在 body 标签中加入这行代码：\n\n```\n<div id=\"example\"></div>\n```\n\n在React开发中，使用JSX，跟JavaScript不兼容，在使用JSX的地方，需要设置type:text/babel，babel是一个转换编译器，ES6转成可以在浏览器运行的代码\n\n```JavaScript\n<script type=\"text/babel\">\n</script>\n```\n\n然后，我们的React代码就可以在里面编写了，先介绍个React的最基本的方法，用于将模板转换成HTML语言：\n\n```JavaScript\n/*\nReactDOM.render()\nReact的最基本方法，用于将模板转换成HTML语言，渲染DOM\n\n3个参数\n第一个：模板的渲染内容（HTML形式）\n第二个：这段模板需要插入的DOM节点\n第三个：渲染后的回调，一般不用\n*/\nReactDOM.render(\n\t<h1>Hello, world!</h1>,\n\tdocument.getElementById('example')\n);\n```\n将HTML文件放到浏览器上运行，就能看到 Hello World 效果了。\n\n### JSX\n前面提到了 JSX ，它不是一门新语言，是个语法糖，有以下特点：\n1. 必须借助React环境运行\n2. JSX标签其实就是HTML标签，只不过我们不需要和JavaScript中一样，用“”包裹起来\n3. 转换：JSX语法能够让我们更加直观的看到组件的DOM结构，不能直接在浏览器上运行，最终会转换成JavaScript代码\n\n改写前一个例子：\n\n```JavaScript\n// 在JSX中运行JavaScript代码\n// 使用{}括起来\nvar text = \"你好\";\nReactDOM.render(\n\t<h1>{text}</h1>,\n\tdocument.getElementById('example')\n);\n```\n\n### 定义组件\n创建组件有几个规则要遵守：\n1. React中创建的组件类以大写字母开头，驼峰命名法\n2. 在React中使用React.createClass方法创建一个组件类\n3. 核心代码：每个组件类必须实现自己的render方法。输出定义好的组件模板。返回值：null、false、组件模板\n4. 注意：组件类只能包含一个顶层标签\n\n例子1：创建一个组件类，用于输出 Hello React\n\n```JavaScript\nvar HelloMessage = React.createClass({\n\trender: function () {\n\t\treturn <h1>Hello React</h1>;\n\t}\n});\n\nReactDOM.render(\n\t<HelloMessage/>,\n\tdocument.getElementById('example')\n);\n```\n\n例子2：实现组件从外部接收内容，并进行展示\n```JavaScript\nvar HelloMessage = React.createClass({\n\trender: function () {\n\t\t/*\n\t\t\tthis表示当前这个组件对象\n\t\t\tthis.props.helloText 可以解释：当前组件对象的props对象中存储的helloText属性中的值\n\t\t*/\n\t\treturn <h1>{this.props.helloText}</h1>;\n\t}\n});\n\nReactDOM.render(\n\t<HelloMessage helloText=\"你好\"/>,\n\tdocument.getElementById('example')\n);\n```\n\n设置组件样式有三种：\n1. 内联样式\n2. 对象样式\n3. 选择器样式\n\n注意：在React和HTML5中设置样式时的书写格式区别：\n1. HTML5以;结尾，React以,结尾\n2. HTML5中key、value都不加引号，React中属于JavaScript对象，key的名字不能出现“-”，需要使用驼峰命名法。如果value为字符串，需要加引号。\n3. HTML5中，value如果是数字，需要带单位，React中不需要带单位\n\n注意：在React中使用选择器样式设置组件样式时，属性名不能使用class，需要使用className替换\n\n\n```JavaScript\n\n<style>\n\t.pStyle {\n\t\tfont-size: 20px;\n\t}\n</style>\n\nvar hstyle = {\n\tbackgroundColor: \"green\",\n\tcolor: \"red\",\n}\n\nvar ShowMessage = React.createClass({\n\trender: function () {\n\t\treturn (\n\t\t\t<div style={{backgroundColor:\"yellow\", borderWidth:5, borderColor:\"black\", borderStyle:\"solid\"}}>\n\t\t\t\t<h1 style={hStyle}>{this.props.firstRow}</h1>\n\t\t\t\t<p className=\"pStyle\">{this.props.secondRow}</p>\n\t\t\t</div>\n\t\t);\n\t}\n});\n```\n\n### 复合组件\n\n复合组件，又也叫做组合组件，创建多个组件合成一个组件\n\n例子1：定义一个组件WebShow。功能：输出网站名字和网址，网址是一个可以点击的链接\n分析：定义一个组件WebName负责输出网站名字，定义组件WebLink显示网站网址，并可以点击\n\n\n```JavaScript\n  // 定义WebName\n  var WebName = React.createClass({\n      render: function () {\n          return <h1>{this.props.webname}</h1>;\n      }\n  });\n\n  // 定义WebLink\n  var WebLink = React.createClass({\n      render: function () {\n          return <a href={this.props.weblink}>{this.props.weblink}</a>\n      }\n  });\n\n  // 定义WebShow\n  var WebShow = React.createClass({\n      render: function () {\n          return (\n              <div>\n                  <WebName webname={this.props.wname}/>\n                  <WebLink weblink={this.props.wlink}/>\n              </div>\n          )\n      }\n  });\n\n  ReactDOM.render(\n      <WebShow wname=\"淘宝\" wlink=\"https://www.taobao.com\"/>,\n      document.getElementById('example')\n  );\n```\n\n### props、state\n\nprops 是组件自身的属性，一般用于嵌套的内外层组件中，负责传递信息（通常是由浮层组件向子层组件传递）。\n\n注意：props对象中属性与组件的属性一一对应，不要直接去修改props中属性的值。\n\n\n#### ...this.props\n\n其中props提供了一个语法糖：`...this.props`，可以将父组件中的全部属性都复制给子组件\n\n例子：定义一个link，link组件中只包含一个超链接，不写任何属性，任何属性从父组件中拿到\n\n\n```JavaScript\n  var Link = React.createClass({\n      render: function () {\n          return <a {...this.props}>{this.props.name}</a>\n      }\n  });\n\n  ReactDOM.render(\n      <Link href=\"https://www.taobao.com\" name='淘宝'/>,\n      document.getElementById('example')\n  );\n```\n\n#### this.props.childern\n\nchildren是个例外，不是跟组件的属性对应，表示组件的所有子节点。\n\n例子：定义一个列表组件，列表项中显示的内容，以及列表项的数量都由外部决定\n\n\n```JavaScript\n  var ListComponent = React.createClass({\n     render: function () {\n         return (\n           <ul>\n               {\n                   /*\n                   *  列表项数量以及内容不确定，在创建模板时确定\n                   *  利用this.props.children从父组件获取需要展示的内容\n                   *\n                   *  获取到列表内容后，需要遍历设置\n                   *  使用this.props.map方法\n                   *  返回值：数组对象。这里数组中的元素是<li>\n                   * */\n\n                   React.Children.map(this.props.children, function (child) {\n                       // child是遍历得到的父组件的子节点\n                       return <li>{child}</li>\n                   })\n               }\n           </ul>\n         );\n     }\n  });\n\n  ReactDOM.render(\n      (\n          <ListComponent>\n              <h1>淘宝</h1>\n              <a href=\"https://www.taobao.com\">taobao</a>\n          </ListComponent>\n      ),\n      document.getElementById('example')\n  );\n```\n\n#### 属性验证 propType\n\n用于验证组件实例的属性是否符合要求.\n\n\n```JavaScript\n  var ShowTitle = React.createClass({\n      propTypes: {\n          // title属性类型必须输字符串\n          title: React.PropTypes.string.isRequired\n      },\n      render: function () {\n          return <h1>{this.props.title}</h1>\n      }\n  })\n\n  ReactDOM.render(\n      <ShowTitle title=123 />,\n      document.getElementById('example')\n  );\n```\n\n#### 设置组件属性的默认值\n\n通过实现组件的getDefaultProps方法，对组件设置默认值\n\n\n```JavaScript\n  var MyTitel = React.createClass({\n      getDefaultProps: function () {\n          return {\n              title: 'O(∩_∩)O哈哈~'\n          }\n      },\n\n      render: function () {\n          return <h1>{this.props.title}</h1>\n      }\n  });\n\n  ReactDOM.render(\n      <MyTitel/>,\n      document.getElementById('example')\n  );\n```\n\n\n#### 事件处理\n\n例子： 定义一个组件，组件中包括一个button，给button绑定onClick事件\n\n\n```JavaScript\n  var MyButton = React.createClass({\n\n      handleClick: function () {\n        alert(\"点击了\");\n      },\n      render: function () {\n          return (\n              <button onClick={this.handleClick}>{this.props.buttonTitle}</button>\n          )\n      }\n  });\n\n  ReactDOM.render(\n      <MyButton buttonTitle=\"我是个按钮\"/>,\n      document.getElementById('example')\n  );\n```\n\n#### state 状态\n\n例子1： 创建一个CheckButton组件，包含一个checkBox类型的输入框，复选框在选中和未选中两种状态下会显示不同的文字，即根据状态渲染。\n\n```JavaScript\n  var CheckButton = React.createClass({\n     // 定义初始状态\n      getInitialState: function () {\n          return {\n              isCheck: false\n          }\n      },\n      // 定义事件绑定的方法\n      handleChange: function () {\n          // 修改状态值，通过this.state读取设置的状态\n          this.setState({\n             isCheck: !this.state.isCheck\n          });\n      },\n      render: function () {\n          // 根据状态值，设置显示的文字\n          // 在JSX语法中，不能直接使用if，使用三目运算符\n          var text = this.state.isCheck ? '已选中' : '未选中';\n\n          return (\n                <div>\n                    <input type=\"checkbox\" onChange={this.handleChange} />\n                    {text}\n                </div>\n          );\n      }\n  });\n\n  ReactDOM.render(\n      <CheckButton/>,\n      document.getElementById('example')\n  );\n```\n\n例子2：定义一个组件，将用户在输入框内输入的内容实时显示\n\n\n```JavaScript\n\tvar Input = React.createClass({\n       getInitialState: function () {\n          return {\n              value: '请输入'\n          };\n       },\n       handleChange:function (event) {\n           // 通过event.target.value读取用户输入的内容\n           this.setState({\n               value: event.target.value\n           });\n       },\n       render: function () {\n           var value = this.state.value;\n           return (\n               <div>\n                   <input type=\"text\" value={value} onChange={this.handleChange}/>\n                   <p>{value}</p>\n               </div>\n           );\n       }\n   });\n\n   ReactDOM.render(\n       <Input/>,\n       document.getElementById('example')\n   );\n```\n\n## 总结\n本章了解了JSX语法，学习了如何定义组件、设置组就按样式、创建符合组件，给组件设置属性等等，为之后学习ReactNative打基础。\n\n\n","source":"_posts/Learn-ReactNative-2.md","raw":"---\ntitle: 学习ReactNative基础（二）\ndate: 2017-03-18 17:44:11\ntags: RN\ncategory: ReactNative\n---\n\n## 前言\n上一篇文章介绍了 ReactNative 背景以及优缺点，分析了测试安装工程的工程结构，以及index.ios.js 的代码结构。\n开始学习RN前，需要学习React的一些语法，本篇文章就带你学习些简单的React语法。\n\n## React\n有过Web前端开发基础的人都知道，写网页就是写HTML文件，所以先创建个HTML5的文件。引入以下js文件：\n\n```JavaScript\n<!-- react.js 是React的核心库 -->\n<script src=\"https://unpkg.com/react@15/dist/react.js\"  charset=\"utf-8\"></script>\n<!-- react-dom.js的作用是提供与DOM相关的功能 -->\n<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"  charset=\"utf-8\"></script>\n<!-- browser.js的作用是将JSX语法转换成JavaScript的语法 -->\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.38/browser.js\" charset=\"utf-8\"></script>\n```\n\n并且在 body 标签中加入这行代码：\n\n```\n<div id=\"example\"></div>\n```\n\n在React开发中，使用JSX，跟JavaScript不兼容，在使用JSX的地方，需要设置type:text/babel，babel是一个转换编译器，ES6转成可以在浏览器运行的代码\n\n```JavaScript\n<script type=\"text/babel\">\n</script>\n```\n\n然后，我们的React代码就可以在里面编写了，先介绍个React的最基本的方法，用于将模板转换成HTML语言：\n\n```JavaScript\n/*\nReactDOM.render()\nReact的最基本方法，用于将模板转换成HTML语言，渲染DOM\n\n3个参数\n第一个：模板的渲染内容（HTML形式）\n第二个：这段模板需要插入的DOM节点\n第三个：渲染后的回调，一般不用\n*/\nReactDOM.render(\n\t<h1>Hello, world!</h1>,\n\tdocument.getElementById('example')\n);\n```\n将HTML文件放到浏览器上运行，就能看到 Hello World 效果了。\n\n### JSX\n前面提到了 JSX ，它不是一门新语言，是个语法糖，有以下特点：\n1. 必须借助React环境运行\n2. JSX标签其实就是HTML标签，只不过我们不需要和JavaScript中一样，用“”包裹起来\n3. 转换：JSX语法能够让我们更加直观的看到组件的DOM结构，不能直接在浏览器上运行，最终会转换成JavaScript代码\n\n改写前一个例子：\n\n```JavaScript\n// 在JSX中运行JavaScript代码\n// 使用{}括起来\nvar text = \"你好\";\nReactDOM.render(\n\t<h1>{text}</h1>,\n\tdocument.getElementById('example')\n);\n```\n\n### 定义组件\n创建组件有几个规则要遵守：\n1. React中创建的组件类以大写字母开头，驼峰命名法\n2. 在React中使用React.createClass方法创建一个组件类\n3. 核心代码：每个组件类必须实现自己的render方法。输出定义好的组件模板。返回值：null、false、组件模板\n4. 注意：组件类只能包含一个顶层标签\n\n例子1：创建一个组件类，用于输出 Hello React\n\n```JavaScript\nvar HelloMessage = React.createClass({\n\trender: function () {\n\t\treturn <h1>Hello React</h1>;\n\t}\n});\n\nReactDOM.render(\n\t<HelloMessage/>,\n\tdocument.getElementById('example')\n);\n```\n\n例子2：实现组件从外部接收内容，并进行展示\n```JavaScript\nvar HelloMessage = React.createClass({\n\trender: function () {\n\t\t/*\n\t\t\tthis表示当前这个组件对象\n\t\t\tthis.props.helloText 可以解释：当前组件对象的props对象中存储的helloText属性中的值\n\t\t*/\n\t\treturn <h1>{this.props.helloText}</h1>;\n\t}\n});\n\nReactDOM.render(\n\t<HelloMessage helloText=\"你好\"/>,\n\tdocument.getElementById('example')\n);\n```\n\n设置组件样式有三种：\n1. 内联样式\n2. 对象样式\n3. 选择器样式\n\n注意：在React和HTML5中设置样式时的书写格式区别：\n1. HTML5以;结尾，React以,结尾\n2. HTML5中key、value都不加引号，React中属于JavaScript对象，key的名字不能出现“-”，需要使用驼峰命名法。如果value为字符串，需要加引号。\n3. HTML5中，value如果是数字，需要带单位，React中不需要带单位\n\n注意：在React中使用选择器样式设置组件样式时，属性名不能使用class，需要使用className替换\n\n\n```JavaScript\n\n<style>\n\t.pStyle {\n\t\tfont-size: 20px;\n\t}\n</style>\n\nvar hstyle = {\n\tbackgroundColor: \"green\",\n\tcolor: \"red\",\n}\n\nvar ShowMessage = React.createClass({\n\trender: function () {\n\t\treturn (\n\t\t\t<div style={{backgroundColor:\"yellow\", borderWidth:5, borderColor:\"black\", borderStyle:\"solid\"}}>\n\t\t\t\t<h1 style={hStyle}>{this.props.firstRow}</h1>\n\t\t\t\t<p className=\"pStyle\">{this.props.secondRow}</p>\n\t\t\t</div>\n\t\t);\n\t}\n});\n```\n\n### 复合组件\n\n复合组件，又也叫做组合组件，创建多个组件合成一个组件\n\n例子1：定义一个组件WebShow。功能：输出网站名字和网址，网址是一个可以点击的链接\n分析：定义一个组件WebName负责输出网站名字，定义组件WebLink显示网站网址，并可以点击\n\n\n```JavaScript\n  // 定义WebName\n  var WebName = React.createClass({\n      render: function () {\n          return <h1>{this.props.webname}</h1>;\n      }\n  });\n\n  // 定义WebLink\n  var WebLink = React.createClass({\n      render: function () {\n          return <a href={this.props.weblink}>{this.props.weblink}</a>\n      }\n  });\n\n  // 定义WebShow\n  var WebShow = React.createClass({\n      render: function () {\n          return (\n              <div>\n                  <WebName webname={this.props.wname}/>\n                  <WebLink weblink={this.props.wlink}/>\n              </div>\n          )\n      }\n  });\n\n  ReactDOM.render(\n      <WebShow wname=\"淘宝\" wlink=\"https://www.taobao.com\"/>,\n      document.getElementById('example')\n  );\n```\n\n### props、state\n\nprops 是组件自身的属性，一般用于嵌套的内外层组件中，负责传递信息（通常是由浮层组件向子层组件传递）。\n\n注意：props对象中属性与组件的属性一一对应，不要直接去修改props中属性的值。\n\n\n#### ...this.props\n\n其中props提供了一个语法糖：`...this.props`，可以将父组件中的全部属性都复制给子组件\n\n例子：定义一个link，link组件中只包含一个超链接，不写任何属性，任何属性从父组件中拿到\n\n\n```JavaScript\n  var Link = React.createClass({\n      render: function () {\n          return <a {...this.props}>{this.props.name}</a>\n      }\n  });\n\n  ReactDOM.render(\n      <Link href=\"https://www.taobao.com\" name='淘宝'/>,\n      document.getElementById('example')\n  );\n```\n\n#### this.props.childern\n\nchildren是个例外，不是跟组件的属性对应，表示组件的所有子节点。\n\n例子：定义一个列表组件，列表项中显示的内容，以及列表项的数量都由外部决定\n\n\n```JavaScript\n  var ListComponent = React.createClass({\n     render: function () {\n         return (\n           <ul>\n               {\n                   /*\n                   *  列表项数量以及内容不确定，在创建模板时确定\n                   *  利用this.props.children从父组件获取需要展示的内容\n                   *\n                   *  获取到列表内容后，需要遍历设置\n                   *  使用this.props.map方法\n                   *  返回值：数组对象。这里数组中的元素是<li>\n                   * */\n\n                   React.Children.map(this.props.children, function (child) {\n                       // child是遍历得到的父组件的子节点\n                       return <li>{child}</li>\n                   })\n               }\n           </ul>\n         );\n     }\n  });\n\n  ReactDOM.render(\n      (\n          <ListComponent>\n              <h1>淘宝</h1>\n              <a href=\"https://www.taobao.com\">taobao</a>\n          </ListComponent>\n      ),\n      document.getElementById('example')\n  );\n```\n\n#### 属性验证 propType\n\n用于验证组件实例的属性是否符合要求.\n\n\n```JavaScript\n  var ShowTitle = React.createClass({\n      propTypes: {\n          // title属性类型必须输字符串\n          title: React.PropTypes.string.isRequired\n      },\n      render: function () {\n          return <h1>{this.props.title}</h1>\n      }\n  })\n\n  ReactDOM.render(\n      <ShowTitle title=123 />,\n      document.getElementById('example')\n  );\n```\n\n#### 设置组件属性的默认值\n\n通过实现组件的getDefaultProps方法，对组件设置默认值\n\n\n```JavaScript\n  var MyTitel = React.createClass({\n      getDefaultProps: function () {\n          return {\n              title: 'O(∩_∩)O哈哈~'\n          }\n      },\n\n      render: function () {\n          return <h1>{this.props.title}</h1>\n      }\n  });\n\n  ReactDOM.render(\n      <MyTitel/>,\n      document.getElementById('example')\n  );\n```\n\n\n#### 事件处理\n\n例子： 定义一个组件，组件中包括一个button，给button绑定onClick事件\n\n\n```JavaScript\n  var MyButton = React.createClass({\n\n      handleClick: function () {\n        alert(\"点击了\");\n      },\n      render: function () {\n          return (\n              <button onClick={this.handleClick}>{this.props.buttonTitle}</button>\n          )\n      }\n  });\n\n  ReactDOM.render(\n      <MyButton buttonTitle=\"我是个按钮\"/>,\n      document.getElementById('example')\n  );\n```\n\n#### state 状态\n\n例子1： 创建一个CheckButton组件，包含一个checkBox类型的输入框，复选框在选中和未选中两种状态下会显示不同的文字，即根据状态渲染。\n\n```JavaScript\n  var CheckButton = React.createClass({\n     // 定义初始状态\n      getInitialState: function () {\n          return {\n              isCheck: false\n          }\n      },\n      // 定义事件绑定的方法\n      handleChange: function () {\n          // 修改状态值，通过this.state读取设置的状态\n          this.setState({\n             isCheck: !this.state.isCheck\n          });\n      },\n      render: function () {\n          // 根据状态值，设置显示的文字\n          // 在JSX语法中，不能直接使用if，使用三目运算符\n          var text = this.state.isCheck ? '已选中' : '未选中';\n\n          return (\n                <div>\n                    <input type=\"checkbox\" onChange={this.handleChange} />\n                    {text}\n                </div>\n          );\n      }\n  });\n\n  ReactDOM.render(\n      <CheckButton/>,\n      document.getElementById('example')\n  );\n```\n\n例子2：定义一个组件，将用户在输入框内输入的内容实时显示\n\n\n```JavaScript\n\tvar Input = React.createClass({\n       getInitialState: function () {\n          return {\n              value: '请输入'\n          };\n       },\n       handleChange:function (event) {\n           // 通过event.target.value读取用户输入的内容\n           this.setState({\n               value: event.target.value\n           });\n       },\n       render: function () {\n           var value = this.state.value;\n           return (\n               <div>\n                   <input type=\"text\" value={value} onChange={this.handleChange}/>\n                   <p>{value}</p>\n               </div>\n           );\n       }\n   });\n\n   ReactDOM.render(\n       <Input/>,\n       document.getElementById('example')\n   );\n```\n\n## 总结\n本章了解了JSX语法，学习了如何定义组件、设置组就按样式、创建符合组件，给组件设置属性等等，为之后学习ReactNative打基础。\n\n\n","slug":"Learn-ReactNative-2","published":1,"updated":"2017-04-30T12:23:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7nw00448jpbpu5xa771","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇文章介绍了 ReactNative 背景以及优缺点，分析了测试安装工程的工程结构，以及index.ios.js 的代码结构。<br>开始学习RN前，需要学习React的一些语法，本篇文章就带你学习些简单的React语法。</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>有过Web前端开发基础的人都知道，写网页就是写HTML文件，所以先创建个HTML5的文件。引入以下js文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- react.js 是React的核心库 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.js\"</span>  charset=<span class=\"string\">\"utf-8\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;!-- react-dom.js的作用是提供与DOM相关的功能 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.js\"</span>  charset=<span class=\"string\">\"utf-8\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;!-- browser.js的作用是将JSX语法转换成JavaScript的语法 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.38/browser.js\"</span> charset=<span class=\"string\">\"utf-8\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>并且在 body 标签中加入这行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>在React开发中，使用JSX，跟JavaScript不兼容，在使用JSX的地方，需要设置type:text/babel，babel是一个转换编译器，ES6转成可以在浏览器运行的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/babel\"</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后，我们的React代码就可以在里面编写了，先介绍个React的最基本的方法，用于将模板转换成HTML语言：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">ReactDOM.render()</span></span><br><span class=\"line\"><span class=\"comment\">React的最基本方法，用于将模板转换成HTML语言，渲染DOM</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">3个参数</span></span><br><span class=\"line\"><span class=\"comment\">第一个：模板的渲染内容（HTML形式）</span></span><br><span class=\"line\"><span class=\"comment\">第二个：这段模板需要插入的DOM节点</span></span><br><span class=\"line\"><span class=\"comment\">第三个：渲染后的回调，一般不用</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">\t&lt;h1&gt;Hello, world!&lt;/h1&gt;,</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>将HTML文件放到浏览器上运行，就能看到 Hello World 效果了。</p>\n<h3 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h3><p>前面提到了 JSX ，它不是一门新语言，是个语法糖，有以下特点：</p>\n<ol>\n<li>必须借助React环境运行</li>\n<li>JSX标签其实就是HTML标签，只不过我们不需要和JavaScript中一样，用“”包裹起来</li>\n<li>转换：JSX语法能够让我们更加直观的看到组件的DOM结构，不能直接在浏览器上运行，最终会转换成JavaScript代码</li>\n</ol>\n<p>改写前一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在JSX中运行JavaScript代码</span></span><br><span class=\"line\"><span class=\"comment\">// 使用&#123;&#125;括起来</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> text = <span class=\"string\">\"你好\"</span>;</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">\t&lt;h1&gt;&#123;text&#125;&lt;<span class=\"regexp\">/h1&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">\tdocument.getElementById('example')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"定义组件\"><a href=\"#定义组件\" class=\"headerlink\" title=\"定义组件\"></a>定义组件</h3><p>创建组件有几个规则要遵守：</p>\n<ol>\n<li>React中创建的组件类以大写字母开头，驼峰命名法</li>\n<li>在React中使用React.createClass方法创建一个组件类</li>\n<li>核心代码：每个组件类必须实现自己的render方法。输出定义好的组件模板。返回值：null、false、组件模板</li>\n<li>注意：组件类只能包含一个顶层标签</li>\n</ol>\n<p>例子1：创建一个组件类，用于输出 Hello React</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">\trender: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &lt;h1&gt;Hello React&lt;/h1&gt;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">\t&lt;HelloMessage/&gt;,</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>例子2：实现组件从外部接收内容，并进行展示<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">\trender: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tthis表示当前这个组件对象</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tthis.props.helloText 可以解释：当前组件对象的props对象中存储的helloText属性中的值</span></span><br><span class=\"line\"><span class=\"comment\">\t\t*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &lt;h1&gt;&#123;this.props.helloText&#125;&lt;/h1&gt;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">\t&lt;HelloMessage helloText=<span class=\"string\">\"你好\"</span>/&gt;,</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>设置组件样式有三种：</p>\n<ol>\n<li>内联样式</li>\n<li>对象样式</li>\n<li>选择器样式</li>\n</ol>\n<p>注意：在React和HTML5中设置样式时的书写格式区别：</p>\n<ol>\n<li>HTML5以;结尾，React以,结尾</li>\n<li>HTML5中key、value都不加引号，React中属于JavaScript对象，key的名字不能出现“-”，需要使用驼峰命名法。如果value为字符串，需要加引号。</li>\n<li>HTML5中，value如果是数字，需要带单位，React中不需要带单位</li>\n</ol>\n<p>注意：在React中使用选择器样式设置组件样式时，属性名不能使用class，需要使用className替换</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">\t.pStyle &#123;</span><br><span class=\"line\">\t\tfont-size: <span class=\"number\">20</span>px;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/style&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var hstyle = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">\tbackgroundColor: \"green\",</span></span><br><span class=\"line\"><span class=\"regexp\">\tcolor: \"red\",</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var ShowMessage = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">\trender: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\treturn (</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t&lt;div style=&#123;&#123;backgroundColor:\"yellow\", borderWidth:5, borderColor:\"black\", borderStyle:\"solid\"&#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t\t&lt;h1 style=&#123;hStyle&#125;&gt;&#123;this.props.firstRow&#125;&lt;/</span>h1&gt;</span><br><span class=\"line\">\t\t\t\t&lt;p className=<span class=\"string\">\"pStyle\"</span>&gt;&#123;<span class=\"keyword\">this</span>.props.secondRow&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t&lt;/</span>div&gt;</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"复合组件\"><a href=\"#复合组件\" class=\"headerlink\" title=\"复合组件\"></a>复合组件</h3><p>复合组件，又也叫做组合组件，创建多个组件合成一个组件</p>\n<p>例子1：定义一个组件WebShow。功能：输出网站名字和网址，网址是一个可以点击的链接<br>分析：定义一个组件WebName负责输出网站名字，定义组件WebLink显示网站网址，并可以点击</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义WebName</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> WebName = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;h1&gt;&#123;this.props.webname&#125;&lt;/h1&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义WebLink</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> WebLink = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;a href=&#123;this.props.weblink&#125;&gt;&#123;this.props.weblink&#125;&lt;/a&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义WebShow</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> WebShow = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;WebName webname=&#123;<span class=\"keyword\">this</span>.props.wname&#125;/&gt;</span><br><span class=\"line\">                &lt;WebLink weblink=&#123;<span class=\"keyword\">this</span>.props.wlink&#125;/&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;WebShow wname=\"淘宝\" wlink=\"https:/</span><span class=\"regexp\">/www.taobao.com\"/</span>&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"props、state\"><a href=\"#props、state\" class=\"headerlink\" title=\"props、state\"></a>props、state</h3><p>props 是组件自身的属性，一般用于嵌套的内外层组件中，负责传递信息（通常是由浮层组件向子层组件传递）。</p>\n<p>注意：props对象中属性与组件的属性一一对应，不要直接去修改props中属性的值。</p>\n<h4 id=\"…this-props\"><a href=\"#…this-props\" class=\"headerlink\" title=\"…this.props\"></a>…this.props</h4><p>其中props提供了一个语法糖：<code>...this.props</code>，可以将父组件中的全部属性都复制给子组件</p>\n<p>例子：定义一个link，link组件中只包含一个超链接，不写任何属性，任何属性从父组件中拿到</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Link = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;a &#123;...this.props&#125;&gt;&#123;this.props.name&#125;&lt;/a&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    &lt;Link href=<span class=\"string\">\"https://www.taobao.com\"</span> name=<span class=\"string\">'淘宝'</span>/&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"this-props-childern\"><a href=\"#this-props-childern\" class=\"headerlink\" title=\"this.props.childern\"></a>this.props.childern</h4><p>children是个例外，不是跟组件的属性对应，表示组件的所有子节点。</p>\n<p>例子：定义一个列表组件，列表项中显示的内容，以及列表项的数量都由外部决定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ListComponent = React.createClass(&#123;</span><br><span class=\"line\">   render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (</span><br><span class=\"line\">         &lt;ul&gt;</span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                 <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                 *  列表项数量以及内容不确定，在创建模板时确定</span></span><br><span class=\"line\"><span class=\"comment\">                 *  利用this.props.children从父组件获取需要展示的内容</span></span><br><span class=\"line\"><span class=\"comment\">                 *</span></span><br><span class=\"line\"><span class=\"comment\">                 *  获取到列表内容后，需要遍历设置</span></span><br><span class=\"line\"><span class=\"comment\">                 *  使用this.props.map方法</span></span><br><span class=\"line\"><span class=\"comment\">                 *  返回值：数组对象。这里数组中的元素是&lt;li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">                 * */</span></span><br><span class=\"line\"></span><br><span class=\"line\">                 React.Children.map(<span class=\"keyword\">this</span>.props.children, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">child</span>) </span>&#123;</span><br><span class=\"line\">                     <span class=\"comment\">// child是遍历得到的父组件的子节点</span></span><br><span class=\"line\">                     <span class=\"keyword\">return</span> &lt;li&gt;&#123;child&#125;&lt;/li&gt;</span><br><span class=\"line\">                 &#125;)</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">       );</span></span><br><span class=\"line\"><span class=\"regexp\">   &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    (</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;ListComponent&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;h1&gt;淘宝&lt;/</span>h1&gt;</span><br><span class=\"line\">            &lt;a href=<span class=\"string\">\"https://www.taobao.com\"</span>&gt;taobao&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ListComponent&gt;</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"属性验证-propType\"><a href=\"#属性验证-propType\" class=\"headerlink\" title=\"属性验证 propType\"></a>属性验证 propType</h4><p>用于验证组件实例的属性是否符合要求.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ShowTitle = React.createClass(&#123;</span><br><span class=\"line\">    propTypes: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// title属性类型必须输字符串</span></span><br><span class=\"line\">        title: React.PropTypes.string.isRequired</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    &lt;ShowTitle title=<span class=\"number\">123</span> /&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"设置组件属性的默认值\"><a href=\"#设置组件属性的默认值\" class=\"headerlink\" title=\"设置组件属性的默认值\"></a>设置组件属性的默认值</h4><p>通过实现组件的getDefaultProps方法，对组件设置默认值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyTitel = React.createClass(&#123;</span><br><span class=\"line\">    getDefaultProps: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            title: <span class=\"string\">'O(∩_∩)O哈哈~'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    &lt;MyTitel/&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h4><p>例子： 定义一个组件，组件中包括一个button，给button绑定onClick事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyButton = React.createClass(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleClick: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      alert(<span class=\"string\">\"点击了\"</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;button onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;&#123;<span class=\"keyword\">this</span>.props.buttonTitle&#125;&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;MyButton buttonTitle=\"我是个按钮\"/</span>&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"state-状态\"><a href=\"#state-状态\" class=\"headerlink\" title=\"state 状态\"></a>state 状态</h4><p>例子1： 创建一个CheckButton组件，包含一个checkBox类型的输入框，复选框在选中和未选中两种状态下会显示不同的文字，即根据状态渲染。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CheckButton = React.createClass(&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 定义初始状态</span></span><br><span class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            isCheck: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 定义事件绑定的方法</span></span><br><span class=\"line\">    handleChange: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 修改状态值，通过this.state读取设置的状态</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">           isCheck: !<span class=\"keyword\">this</span>.state.isCheck</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据状态值，设置显示的文字</span></span><br><span class=\"line\">        <span class=\"comment\">// 在JSX语法中，不能直接使用if，使用三目运算符</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> text = <span class=\"keyword\">this</span>.state.isCheck ? <span class=\"string\">'已选中'</span> : <span class=\"string\">'未选中'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">              &lt;div&gt;</span><br><span class=\"line\">                  &lt;input type=<span class=\"string\">\"checkbox\"</span> onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; /&gt;</span><br><span class=\"line\">                  &#123;text&#125;</span><br><span class=\"line\">              &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;CheckButton/</span>&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>例子2：定义一个组件，将用户在输入框内输入的内容实时显示</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Input = React.createClass(&#123;</span><br><span class=\"line\">      getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">             value: <span class=\"string\">'请输入'</span></span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      handleChange:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 通过event.target.value读取用户输入的内容</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">              value: event.target.value</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> value = <span class=\"keyword\">this</span>.state.value;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> (</span><br><span class=\"line\">              &lt;div&gt;</span><br><span class=\"line\">                  &lt;input type=<span class=\"string\">\"text\"</span> value=&#123;value&#125; onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125;/&gt;</span><br><span class=\"line\">                  &lt;p&gt;&#123;value&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;/</span>div&gt;</span><br><span class=\"line\">          );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">      &lt;Input/&gt;,</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本章了解了JSX语法，学习了如何定义组件、设置组就按样式、创建符合组件，给组件设置属性等等，为之后学习ReactNative打基础。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇文章介绍了 ReactNative 背景以及优缺点，分析了测试安装工程的工程结构，以及index.ios.js 的代码结构。<br>开始学习RN前，需要学习React的一些语法，本篇文章就带你学习些简单的React语法。</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>有过Web前端开发基础的人都知道，写网页就是写HTML文件，所以先创建个HTML5的文件。引入以下js文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- react.js 是React的核心库 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.js\"</span>  charset=<span class=\"string\">\"utf-8\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;!-- react-dom.js的作用是提供与DOM相关的功能 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.js\"</span>  charset=<span class=\"string\">\"utf-8\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;!-- browser.js的作用是将JSX语法转换成JavaScript的语法 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.38/browser.js\"</span> charset=<span class=\"string\">\"utf-8\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>并且在 body 标签中加入这行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>在React开发中，使用JSX，跟JavaScript不兼容，在使用JSX的地方，需要设置type:text/babel，babel是一个转换编译器，ES6转成可以在浏览器运行的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/babel\"</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后，我们的React代码就可以在里面编写了，先介绍个React的最基本的方法，用于将模板转换成HTML语言：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">ReactDOM.render()</span></span><br><span class=\"line\"><span class=\"comment\">React的最基本方法，用于将模板转换成HTML语言，渲染DOM</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">3个参数</span></span><br><span class=\"line\"><span class=\"comment\">第一个：模板的渲染内容（HTML形式）</span></span><br><span class=\"line\"><span class=\"comment\">第二个：这段模板需要插入的DOM节点</span></span><br><span class=\"line\"><span class=\"comment\">第三个：渲染后的回调，一般不用</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">\t&lt;h1&gt;Hello, world!&lt;/h1&gt;,</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>将HTML文件放到浏览器上运行，就能看到 Hello World 效果了。</p>\n<h3 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h3><p>前面提到了 JSX ，它不是一门新语言，是个语法糖，有以下特点：</p>\n<ol>\n<li>必须借助React环境运行</li>\n<li>JSX标签其实就是HTML标签，只不过我们不需要和JavaScript中一样，用“”包裹起来</li>\n<li>转换：JSX语法能够让我们更加直观的看到组件的DOM结构，不能直接在浏览器上运行，最终会转换成JavaScript代码</li>\n</ol>\n<p>改写前一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在JSX中运行JavaScript代码</span></span><br><span class=\"line\"><span class=\"comment\">// 使用&#123;&#125;括起来</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> text = <span class=\"string\">\"你好\"</span>;</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">\t&lt;h1&gt;&#123;text&#125;&lt;<span class=\"regexp\">/h1&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">\tdocument.getElementById('example')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"定义组件\"><a href=\"#定义组件\" class=\"headerlink\" title=\"定义组件\"></a>定义组件</h3><p>创建组件有几个规则要遵守：</p>\n<ol>\n<li>React中创建的组件类以大写字母开头，驼峰命名法</li>\n<li>在React中使用React.createClass方法创建一个组件类</li>\n<li>核心代码：每个组件类必须实现自己的render方法。输出定义好的组件模板。返回值：null、false、组件模板</li>\n<li>注意：组件类只能包含一个顶层标签</li>\n</ol>\n<p>例子1：创建一个组件类，用于输出 Hello React</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">\trender: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &lt;h1&gt;Hello React&lt;/h1&gt;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">\t&lt;HelloMessage/&gt;,</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>例子2：实现组件从外部接收内容，并进行展示<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">\trender: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tthis表示当前这个组件对象</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tthis.props.helloText 可以解释：当前组件对象的props对象中存储的helloText属性中的值</span></span><br><span class=\"line\"><span class=\"comment\">\t\t*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &lt;h1&gt;&#123;this.props.helloText&#125;&lt;/h1&gt;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">\t&lt;HelloMessage helloText=<span class=\"string\">\"你好\"</span>/&gt;,</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>设置组件样式有三种：</p>\n<ol>\n<li>内联样式</li>\n<li>对象样式</li>\n<li>选择器样式</li>\n</ol>\n<p>注意：在React和HTML5中设置样式时的书写格式区别：</p>\n<ol>\n<li>HTML5以;结尾，React以,结尾</li>\n<li>HTML5中key、value都不加引号，React中属于JavaScript对象，key的名字不能出现“-”，需要使用驼峰命名法。如果value为字符串，需要加引号。</li>\n<li>HTML5中，value如果是数字，需要带单位，React中不需要带单位</li>\n</ol>\n<p>注意：在React中使用选择器样式设置组件样式时，属性名不能使用class，需要使用className替换</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">\t.pStyle &#123;</span><br><span class=\"line\">\t\tfont-size: <span class=\"number\">20</span>px;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/style&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var hstyle = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">\tbackgroundColor: \"green\",</span></span><br><span class=\"line\"><span class=\"regexp\">\tcolor: \"red\",</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var ShowMessage = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">\trender: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\treturn (</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t&lt;div style=&#123;&#123;backgroundColor:\"yellow\", borderWidth:5, borderColor:\"black\", borderStyle:\"solid\"&#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t\t&lt;h1 style=&#123;hStyle&#125;&gt;&#123;this.props.firstRow&#125;&lt;/</span>h1&gt;</span><br><span class=\"line\">\t\t\t\t&lt;p className=<span class=\"string\">\"pStyle\"</span>&gt;&#123;<span class=\"keyword\">this</span>.props.secondRow&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t&lt;/</span>div&gt;</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"复合组件\"><a href=\"#复合组件\" class=\"headerlink\" title=\"复合组件\"></a>复合组件</h3><p>复合组件，又也叫做组合组件，创建多个组件合成一个组件</p>\n<p>例子1：定义一个组件WebShow。功能：输出网站名字和网址，网址是一个可以点击的链接<br>分析：定义一个组件WebName负责输出网站名字，定义组件WebLink显示网站网址，并可以点击</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义WebName</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> WebName = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;h1&gt;&#123;this.props.webname&#125;&lt;/h1&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义WebLink</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> WebLink = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;a href=&#123;this.props.weblink&#125;&gt;&#123;this.props.weblink&#125;&lt;/a&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义WebShow</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> WebShow = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;WebName webname=&#123;<span class=\"keyword\">this</span>.props.wname&#125;/&gt;</span><br><span class=\"line\">                &lt;WebLink weblink=&#123;<span class=\"keyword\">this</span>.props.wlink&#125;/&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;WebShow wname=\"淘宝\" wlink=\"https:/</span><span class=\"regexp\">/www.taobao.com\"/</span>&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"props、state\"><a href=\"#props、state\" class=\"headerlink\" title=\"props、state\"></a>props、state</h3><p>props 是组件自身的属性，一般用于嵌套的内外层组件中，负责传递信息（通常是由浮层组件向子层组件传递）。</p>\n<p>注意：props对象中属性与组件的属性一一对应，不要直接去修改props中属性的值。</p>\n<h4 id=\"…this-props\"><a href=\"#…this-props\" class=\"headerlink\" title=\"…this.props\"></a>…this.props</h4><p>其中props提供了一个语法糖：<code>...this.props</code>，可以将父组件中的全部属性都复制给子组件</p>\n<p>例子：定义一个link，link组件中只包含一个超链接，不写任何属性，任何属性从父组件中拿到</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Link = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;a &#123;...this.props&#125;&gt;&#123;this.props.name&#125;&lt;/a&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    &lt;Link href=<span class=\"string\">\"https://www.taobao.com\"</span> name=<span class=\"string\">'淘宝'</span>/&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"this-props-childern\"><a href=\"#this-props-childern\" class=\"headerlink\" title=\"this.props.childern\"></a>this.props.childern</h4><p>children是个例外，不是跟组件的属性对应，表示组件的所有子节点。</p>\n<p>例子：定义一个列表组件，列表项中显示的内容，以及列表项的数量都由外部决定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ListComponent = React.createClass(&#123;</span><br><span class=\"line\">   render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (</span><br><span class=\"line\">         &lt;ul&gt;</span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                 <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                 *  列表项数量以及内容不确定，在创建模板时确定</span></span><br><span class=\"line\"><span class=\"comment\">                 *  利用this.props.children从父组件获取需要展示的内容</span></span><br><span class=\"line\"><span class=\"comment\">                 *</span></span><br><span class=\"line\"><span class=\"comment\">                 *  获取到列表内容后，需要遍历设置</span></span><br><span class=\"line\"><span class=\"comment\">                 *  使用this.props.map方法</span></span><br><span class=\"line\"><span class=\"comment\">                 *  返回值：数组对象。这里数组中的元素是&lt;li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">                 * */</span></span><br><span class=\"line\"></span><br><span class=\"line\">                 React.Children.map(<span class=\"keyword\">this</span>.props.children, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">child</span>) </span>&#123;</span><br><span class=\"line\">                     <span class=\"comment\">// child是遍历得到的父组件的子节点</span></span><br><span class=\"line\">                     <span class=\"keyword\">return</span> &lt;li&gt;&#123;child&#125;&lt;/li&gt;</span><br><span class=\"line\">                 &#125;)</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">       );</span></span><br><span class=\"line\"><span class=\"regexp\">   &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    (</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;ListComponent&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;h1&gt;淘宝&lt;/</span>h1&gt;</span><br><span class=\"line\">            &lt;a href=<span class=\"string\">\"https://www.taobao.com\"</span>&gt;taobao&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ListComponent&gt;</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"属性验证-propType\"><a href=\"#属性验证-propType\" class=\"headerlink\" title=\"属性验证 propType\"></a>属性验证 propType</h4><p>用于验证组件实例的属性是否符合要求.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ShowTitle = React.createClass(&#123;</span><br><span class=\"line\">    propTypes: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// title属性类型必须输字符串</span></span><br><span class=\"line\">        title: React.PropTypes.string.isRequired</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    &lt;ShowTitle title=<span class=\"number\">123</span> /&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"设置组件属性的默认值\"><a href=\"#设置组件属性的默认值\" class=\"headerlink\" title=\"设置组件属性的默认值\"></a>设置组件属性的默认值</h4><p>通过实现组件的getDefaultProps方法，对组件设置默认值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyTitel = React.createClass(&#123;</span><br><span class=\"line\">    getDefaultProps: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            title: <span class=\"string\">'O(∩_∩)O哈哈~'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    &lt;MyTitel/&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h4><p>例子： 定义一个组件，组件中包括一个button，给button绑定onClick事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyButton = React.createClass(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleClick: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      alert(<span class=\"string\">\"点击了\"</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;button onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;&#123;<span class=\"keyword\">this</span>.props.buttonTitle&#125;&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;MyButton buttonTitle=\"我是个按钮\"/</span>&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"state-状态\"><a href=\"#state-状态\" class=\"headerlink\" title=\"state 状态\"></a>state 状态</h4><p>例子1： 创建一个CheckButton组件，包含一个checkBox类型的输入框，复选框在选中和未选中两种状态下会显示不同的文字，即根据状态渲染。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CheckButton = React.createClass(&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 定义初始状态</span></span><br><span class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            isCheck: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 定义事件绑定的方法</span></span><br><span class=\"line\">    handleChange: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 修改状态值，通过this.state读取设置的状态</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">           isCheck: !<span class=\"keyword\">this</span>.state.isCheck</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据状态值，设置显示的文字</span></span><br><span class=\"line\">        <span class=\"comment\">// 在JSX语法中，不能直接使用if，使用三目运算符</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> text = <span class=\"keyword\">this</span>.state.isCheck ? <span class=\"string\">'已选中'</span> : <span class=\"string\">'未选中'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">              &lt;div&gt;</span><br><span class=\"line\">                  &lt;input type=<span class=\"string\">\"checkbox\"</span> onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; /&gt;</span><br><span class=\"line\">                  &#123;text&#125;</span><br><span class=\"line\">              &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;CheckButton/</span>&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>例子2：定义一个组件，将用户在输入框内输入的内容实时显示</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Input = React.createClass(&#123;</span><br><span class=\"line\">      getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">             value: <span class=\"string\">'请输入'</span></span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      handleChange:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 通过event.target.value读取用户输入的内容</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">              value: event.target.value</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> value = <span class=\"keyword\">this</span>.state.value;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> (</span><br><span class=\"line\">              &lt;div&gt;</span><br><span class=\"line\">                  &lt;input type=<span class=\"string\">\"text\"</span> value=&#123;value&#125; onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125;/&gt;</span><br><span class=\"line\">                  &lt;p&gt;&#123;value&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;/</span>div&gt;</span><br><span class=\"line\">          );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">      &lt;Input/&gt;,</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>)</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本章了解了JSX语法，学习了如何定义组件、设置组就按样式、创建符合组件，给组件设置属性等等，为之后学习ReactNative打基础。</p>\n"},{"title":"学习ReactNative基础（三）","date":"2017-03-26T09:44:11.000Z","_content":"\n## 前言\n上一篇文章学习了React的基础用法，这篇文章开始真正学习ReactNative的知识。\n\n## 组件生命周期\n\n在编程开发中，每个创建的对象都会有生命周期，对象创建后会占用内存，创建的越多可用内存越少，当对象的生命周期结束时，GC就会回收内存，所以了解生命周期对开发非常重要。\n\n组件生命周期有三个状态：\n1. Mounting：组件挂载，已插入真实 DOM\n2. Updating：组件更新，正在被重新渲染\n3. Unmounting：组件移除，已移出真实 DOM\n\n组件生命周期四个阶段：\n1. 创建\n2. 实例化\n3. 更新\n4. 销毁\n\n### Mounting/组件挂载相关 \n\n* componentWillMount：组件将要挂载。在render之前执行，但仅执行一次，即使多次重复渲染该组件，或者改变了组件的state\n* componentDidMount：组件以及挂载。在render之后执行，同一个组件重复渲染只执行一次\n\n### Updating/组件更新相关\n\n* componentWillReceiveProps(object nextProps)：已加载组件收到新的props之前调用，注意组件初始化渲染时则不会执行\n* shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用。当组件收到新的props或者新的state时，就会调用，根据返回值true/false决定是否重新渲染\n* componentWillUpdate(object nextProps, object nextState)：组件将要更新\n* componentDidUpdate(object prevProps, object prevState)：组件已经更新\n\n### Unmounting/组件移除相关\n\n* componentWillUnmount：在组件要被移除之前的时间点触发，可以利用它来处理清理组件的一些工作\n\n### 生命周期中与props和state相关\n\n* getDefaultProps 设置props属性默认值\n* getInitialState 升值state属性初始值\n\n### 例子\n\n\n```JavaScript\n\tvar Demo = React.createClass({\n       /*\n       *  一、创建阶段\n       *  流程：\n       *      只调用getDefaultProps方法\n       * */ \n       getDefaultProps: function () {\n\n           // 在创建类的时候被调用，设置this。props的默认值\n           console.log('getDefaultProps');\n           return {};\n       },\n       /*\n       *   二、实例化阶段\n       *   流程：\n       *       getInitialState\n       *       componentWillMount\n       *       render\n       *       componentDidMount\n       * \n       * */\n       getInitialState: function () {\n           // 设置this。state的默认值\n           console.log('getInitialState');\n           return null;\n       },\n       componentWillMount: function () {\n           // 在render之前调用\n           console.log('componentWillMount');\n       },\n       render: function () {\n           // 渲染并返回一个虚拟DOM\n           console.log('render');\n           return <div>Hello React</div>\n       },\n       componentDidMount: function () {\n           // 在render之后调用\n           // 在该方法中，React会使用render方法返回的虚拟DOM对象创建真实的DOM结构\n           // 可以在这个方法中读取DOM节点\n           console.log('componentDidMount');\n       },\n\n       /*\n       *   三、更新阶段\n       *   流程：\n       *   componentWillReceiveProps\n       *   shouldComponentUpdate 如果返回值是false，之后三个方法不执行\n       *   componentWillUpdate\n       *   render\n       *   componentDidUpdate\n       *\n       * */\n       componentWillReceiveProps: function () {\n           console.log('componentWillReceiveProps');\n       },\n       shouldComponentUpdate: function () {\n           // 是否需要更新\n           console.log('shouldComponentUpdate');\n           return true;\n       },\n       componentWillUpdate: function () {\n           console.log('componentWillUpdate');\n       },\n       componentDidUpdate: function () {\n           console.log('componentDidUpdate');\n       },\n\n       /*\n       *   四、销毁阶段\n       *   流程：\n       *       componentWillUnmount\n       *\n       * */\n\n       componentWillUnmount: function () {\n           console.log('componentWillUnmount');\n       }\n       \n   });\n\n   // 第一次创建并加载组件\n   ReactDOM.render(\n       <Demo />,\n       document.getElementById('container')\n   );\n\n   // 重新渲染组件\n   ReactDOM.render(\n           <Demo />,\n       document.getElementById('container')\n   );\n\n   // 移除组件\n   ReactDOM.unmountComponentAtNode(document.getElementById('container'));\n```\n\n## StyleSheet\n\nReactNative 中定义组件样式，是通过 `StyleSheet` 样式表定义的，有几个需要注意的地方：\n1. HTML5以;结尾，React以,结尾\n2. HTML5中的key、value都不加引号， React中属于JavaScript对象，key的名字不能出现‘-’，需要使用驼峰命名法，如果value是字符串要加引号\n3. HTML5中，value如果是数字，需要带单位，React中不需要单位\n\n盒子模型\n{% asset_img box-model.gif box-model %}\n\n例子：\n\n```\nconst styles = StyleSheet.create({\n  container: {\n    backgroundColor: 'red',\n    width: 300,\n    height: 400,\n    marginTop: 25,\n    marginLeft: 30,\n  },\n  top: {\n    backgroundColor: 'green',\n    width: 280,\n    height: 250,\n    margin: 10,\n  },\n  bottom: {\n    backgroundColor: 'yellow',\n    width: 280,\n    height: 110,\n    margin: 10,\n  },\n  boder: {\n    borderWidth: 3,\n    borderColor: 'black',\n  },\n});\n```\n\n## CSS3 弹性盒子(Flex Box)\n\n{% asset_img flexBox-model.jpg flexBox-model %}\n\n弹性盒模型，主要有两个轴，主轴和交叉轴，主轴并不一定是横向的，是根据Flex Item元素的排列方向来的，如果Item是横向排列，则主轴是横向的，如果Item是纵向的，主轴就是纵向的。\n\n弹性盒子有很多属性设置，可以参考[《CSS3 弹性盒子》](http://www.runoob.com/css3/css3-flexbox.html)设置。\n\n例子：\n\n```JavaScript\nexport default class LessonFlex extends Component {\n  render() {\n    return (\n      <View style={styles.container}>\n        <View style={styles.child1}></View>\n        <View style={styles.child2}></View>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    margin: 30,\n    width: 300,\n    height: 300,\n    backgroundColor: 'yellow',\n    // 默认主轴方向是column（竖向）\n    // 设置为横向排列\n    flexDirection: 'row',\n    // 主轴方向\n    justifyContent: 'center',\n    // 交叉轴\n    alignItems: 'center',\n  },\n  child1: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'green',\n  },\n  child2: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n  }\n});\n```\n\n### flex属性\n\nFlex Box里面一个重要的属性， `flex` 属性，可以给组件指定flex，flex的值是数字。\n* flex:1 表示组件可以撑满父组件所有的剩余空间\n* 同时存在多个并列的子组件，flex:1，均分\n* 如果这些并列的子组件的flex值不一样，谁的值越大，谁占的剩余空间比例就越大(即占据剩余空间的比等于并列组件间flex值的比)\n\n例子：\n\n```JavaScript\nconst styles = StyleSheet.create({\n  container: {\n    marginBottom: 30,\n    flex: 1,\n    backgroundColor: 'cyan',\n  },\n  child1: {\n    flex: 2,\n    backgroundColor: 'green',\n  },\n  child2: {\n    flex: 1,\n    backgroundColor: 'yellow',\n  }\n})\n```\n\n## View组件\n\n现在我们开始学习 ReactNative 的组件，先从[View组件](https://facebook.github.io/react-native/docs/view.html)开始。\n\n在Web开发中，div是最重要的一个元素，是页面布局的基础。\n在ReactNative开发中，View组件的作用类似于div。是最基础的组件，被看做是容器组件。\n\n例子：\n\n```JavaScript\nexport default class LessonView extends Component {\n  render() {\n    return (\n      <View style={[styles.container, styles.flex]}>\n        <View style={styles.item}>\n          <View style={[styles.flex, styles.center]}>\n            <Text>酒店</Text>\n          </View>\n          <View style={[styles.flex, styles.lineLeftRight]}>\n            <View style={[styles.flex, styles.center, styles.lineCenter]}>\n              <Text>海外酒店</Text>\n            </View>\n            <View style={[styles.flex, styles.center]}>\n              <Text>特价酒店</Text>\n            </View>\n          </View>\n          <View style={[styles.flex]}>\n            <View style={[styles.flex, styles.center, styles.lineCenter]}>\n              <Text>团购</Text>\n            </View>\n            <View style={[styles.flex, styles.center]}>\n              <Text>民宿.客栈</Text>\n            </View>\n          </View>\n        </View>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    marginTop: 64,\n    backgroundColor: '#F2F2F2',\n  },\n  flex: {\n    flex: 1\n  },\n  center: {\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  item: {\n    flexDirection: 'row',\n    backgroundColor: '#FF607C',\n    marginTop: 5,\n    marginLeft: 5,\n    marginRight: 5,\n    height: 80,\n    borderRadius: 5,\n  },\n  // 给中间的区域设置左右边线\n  lineLeftRight: {\n    borderLeftWidth: 1,\n    borderRightWidth: 1,\n    borderColor: 'white',\n  },\n  // 给上半区域设置下边线\n  lineCenter: {\n    borderColor: 'white',\n    borderBottomWidth: 1,\n  }\n});\n```\n\n## 总结\n\n本章学习了组件生命周期、了解了 StyleSheet 以及 Flex Box ，并且开始学习了第一个 ReactNative 组件 View。\n\n","source":"_posts/Learn-ReactNative-3.md","raw":"---\ntitle: 学习ReactNative基础（三）\ndate: 2017-03-26 17:44:11\ntags: RN\ncategory: ReactNative\n---\n\n## 前言\n上一篇文章学习了React的基础用法，这篇文章开始真正学习ReactNative的知识。\n\n## 组件生命周期\n\n在编程开发中，每个创建的对象都会有生命周期，对象创建后会占用内存，创建的越多可用内存越少，当对象的生命周期结束时，GC就会回收内存，所以了解生命周期对开发非常重要。\n\n组件生命周期有三个状态：\n1. Mounting：组件挂载，已插入真实 DOM\n2. Updating：组件更新，正在被重新渲染\n3. Unmounting：组件移除，已移出真实 DOM\n\n组件生命周期四个阶段：\n1. 创建\n2. 实例化\n3. 更新\n4. 销毁\n\n### Mounting/组件挂载相关 \n\n* componentWillMount：组件将要挂载。在render之前执行，但仅执行一次，即使多次重复渲染该组件，或者改变了组件的state\n* componentDidMount：组件以及挂载。在render之后执行，同一个组件重复渲染只执行一次\n\n### Updating/组件更新相关\n\n* componentWillReceiveProps(object nextProps)：已加载组件收到新的props之前调用，注意组件初始化渲染时则不会执行\n* shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用。当组件收到新的props或者新的state时，就会调用，根据返回值true/false决定是否重新渲染\n* componentWillUpdate(object nextProps, object nextState)：组件将要更新\n* componentDidUpdate(object prevProps, object prevState)：组件已经更新\n\n### Unmounting/组件移除相关\n\n* componentWillUnmount：在组件要被移除之前的时间点触发，可以利用它来处理清理组件的一些工作\n\n### 生命周期中与props和state相关\n\n* getDefaultProps 设置props属性默认值\n* getInitialState 升值state属性初始值\n\n### 例子\n\n\n```JavaScript\n\tvar Demo = React.createClass({\n       /*\n       *  一、创建阶段\n       *  流程：\n       *      只调用getDefaultProps方法\n       * */ \n       getDefaultProps: function () {\n\n           // 在创建类的时候被调用，设置this。props的默认值\n           console.log('getDefaultProps');\n           return {};\n       },\n       /*\n       *   二、实例化阶段\n       *   流程：\n       *       getInitialState\n       *       componentWillMount\n       *       render\n       *       componentDidMount\n       * \n       * */\n       getInitialState: function () {\n           // 设置this。state的默认值\n           console.log('getInitialState');\n           return null;\n       },\n       componentWillMount: function () {\n           // 在render之前调用\n           console.log('componentWillMount');\n       },\n       render: function () {\n           // 渲染并返回一个虚拟DOM\n           console.log('render');\n           return <div>Hello React</div>\n       },\n       componentDidMount: function () {\n           // 在render之后调用\n           // 在该方法中，React会使用render方法返回的虚拟DOM对象创建真实的DOM结构\n           // 可以在这个方法中读取DOM节点\n           console.log('componentDidMount');\n       },\n\n       /*\n       *   三、更新阶段\n       *   流程：\n       *   componentWillReceiveProps\n       *   shouldComponentUpdate 如果返回值是false，之后三个方法不执行\n       *   componentWillUpdate\n       *   render\n       *   componentDidUpdate\n       *\n       * */\n       componentWillReceiveProps: function () {\n           console.log('componentWillReceiveProps');\n       },\n       shouldComponentUpdate: function () {\n           // 是否需要更新\n           console.log('shouldComponentUpdate');\n           return true;\n       },\n       componentWillUpdate: function () {\n           console.log('componentWillUpdate');\n       },\n       componentDidUpdate: function () {\n           console.log('componentDidUpdate');\n       },\n\n       /*\n       *   四、销毁阶段\n       *   流程：\n       *       componentWillUnmount\n       *\n       * */\n\n       componentWillUnmount: function () {\n           console.log('componentWillUnmount');\n       }\n       \n   });\n\n   // 第一次创建并加载组件\n   ReactDOM.render(\n       <Demo />,\n       document.getElementById('container')\n   );\n\n   // 重新渲染组件\n   ReactDOM.render(\n           <Demo />,\n       document.getElementById('container')\n   );\n\n   // 移除组件\n   ReactDOM.unmountComponentAtNode(document.getElementById('container'));\n```\n\n## StyleSheet\n\nReactNative 中定义组件样式，是通过 `StyleSheet` 样式表定义的，有几个需要注意的地方：\n1. HTML5以;结尾，React以,结尾\n2. HTML5中的key、value都不加引号， React中属于JavaScript对象，key的名字不能出现‘-’，需要使用驼峰命名法，如果value是字符串要加引号\n3. HTML5中，value如果是数字，需要带单位，React中不需要单位\n\n盒子模型\n{% asset_img box-model.gif box-model %}\n\n例子：\n\n```\nconst styles = StyleSheet.create({\n  container: {\n    backgroundColor: 'red',\n    width: 300,\n    height: 400,\n    marginTop: 25,\n    marginLeft: 30,\n  },\n  top: {\n    backgroundColor: 'green',\n    width: 280,\n    height: 250,\n    margin: 10,\n  },\n  bottom: {\n    backgroundColor: 'yellow',\n    width: 280,\n    height: 110,\n    margin: 10,\n  },\n  boder: {\n    borderWidth: 3,\n    borderColor: 'black',\n  },\n});\n```\n\n## CSS3 弹性盒子(Flex Box)\n\n{% asset_img flexBox-model.jpg flexBox-model %}\n\n弹性盒模型，主要有两个轴，主轴和交叉轴，主轴并不一定是横向的，是根据Flex Item元素的排列方向来的，如果Item是横向排列，则主轴是横向的，如果Item是纵向的，主轴就是纵向的。\n\n弹性盒子有很多属性设置，可以参考[《CSS3 弹性盒子》](http://www.runoob.com/css3/css3-flexbox.html)设置。\n\n例子：\n\n```JavaScript\nexport default class LessonFlex extends Component {\n  render() {\n    return (\n      <View style={styles.container}>\n        <View style={styles.child1}></View>\n        <View style={styles.child2}></View>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    margin: 30,\n    width: 300,\n    height: 300,\n    backgroundColor: 'yellow',\n    // 默认主轴方向是column（竖向）\n    // 设置为横向排列\n    flexDirection: 'row',\n    // 主轴方向\n    justifyContent: 'center',\n    // 交叉轴\n    alignItems: 'center',\n  },\n  child1: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'green',\n  },\n  child2: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n  }\n});\n```\n\n### flex属性\n\nFlex Box里面一个重要的属性， `flex` 属性，可以给组件指定flex，flex的值是数字。\n* flex:1 表示组件可以撑满父组件所有的剩余空间\n* 同时存在多个并列的子组件，flex:1，均分\n* 如果这些并列的子组件的flex值不一样，谁的值越大，谁占的剩余空间比例就越大(即占据剩余空间的比等于并列组件间flex值的比)\n\n例子：\n\n```JavaScript\nconst styles = StyleSheet.create({\n  container: {\n    marginBottom: 30,\n    flex: 1,\n    backgroundColor: 'cyan',\n  },\n  child1: {\n    flex: 2,\n    backgroundColor: 'green',\n  },\n  child2: {\n    flex: 1,\n    backgroundColor: 'yellow',\n  }\n})\n```\n\n## View组件\n\n现在我们开始学习 ReactNative 的组件，先从[View组件](https://facebook.github.io/react-native/docs/view.html)开始。\n\n在Web开发中，div是最重要的一个元素，是页面布局的基础。\n在ReactNative开发中，View组件的作用类似于div。是最基础的组件，被看做是容器组件。\n\n例子：\n\n```JavaScript\nexport default class LessonView extends Component {\n  render() {\n    return (\n      <View style={[styles.container, styles.flex]}>\n        <View style={styles.item}>\n          <View style={[styles.flex, styles.center]}>\n            <Text>酒店</Text>\n          </View>\n          <View style={[styles.flex, styles.lineLeftRight]}>\n            <View style={[styles.flex, styles.center, styles.lineCenter]}>\n              <Text>海外酒店</Text>\n            </View>\n            <View style={[styles.flex, styles.center]}>\n              <Text>特价酒店</Text>\n            </View>\n          </View>\n          <View style={[styles.flex]}>\n            <View style={[styles.flex, styles.center, styles.lineCenter]}>\n              <Text>团购</Text>\n            </View>\n            <View style={[styles.flex, styles.center]}>\n              <Text>民宿.客栈</Text>\n            </View>\n          </View>\n        </View>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    marginTop: 64,\n    backgroundColor: '#F2F2F2',\n  },\n  flex: {\n    flex: 1\n  },\n  center: {\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  item: {\n    flexDirection: 'row',\n    backgroundColor: '#FF607C',\n    marginTop: 5,\n    marginLeft: 5,\n    marginRight: 5,\n    height: 80,\n    borderRadius: 5,\n  },\n  // 给中间的区域设置左右边线\n  lineLeftRight: {\n    borderLeftWidth: 1,\n    borderRightWidth: 1,\n    borderColor: 'white',\n  },\n  // 给上半区域设置下边线\n  lineCenter: {\n    borderColor: 'white',\n    borderBottomWidth: 1,\n  }\n});\n```\n\n## 总结\n\n本章学习了组件生命周期、了解了 StyleSheet 以及 Flex Box ，并且开始学习了第一个 ReactNative 组件 View。\n\n","slug":"Learn-ReactNative-3","published":1,"updated":"2017-05-01T03:37:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7ny00488jpb08azqm12","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇文章学习了React的基础用法，这篇文章开始真正学习ReactNative的知识。</p>\n<h2 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h2><p>在编程开发中，每个创建的对象都会有生命周期，对象创建后会占用内存，创建的越多可用内存越少，当对象的生命周期结束时，GC就会回收内存，所以了解生命周期对开发非常重要。</p>\n<p>组件生命周期有三个状态：</p>\n<ol>\n<li>Mounting：组件挂载，已插入真实 DOM</li>\n<li>Updating：组件更新，正在被重新渲染</li>\n<li>Unmounting：组件移除，已移出真实 DOM</li>\n</ol>\n<p>组件生命周期四个阶段：</p>\n<ol>\n<li>创建</li>\n<li>实例化</li>\n<li>更新</li>\n<li>销毁</li>\n</ol>\n<h3 id=\"Mounting-组件挂载相关\"><a href=\"#Mounting-组件挂载相关\" class=\"headerlink\" title=\"Mounting/组件挂载相关\"></a>Mounting/组件挂载相关</h3><ul>\n<li>componentWillMount：组件将要挂载。在render之前执行，但仅执行一次，即使多次重复渲染该组件，或者改变了组件的state</li>\n<li>componentDidMount：组件以及挂载。在render之后执行，同一个组件重复渲染只执行一次</li>\n</ul>\n<h3 id=\"Updating-组件更新相关\"><a href=\"#Updating-组件更新相关\" class=\"headerlink\" title=\"Updating/组件更新相关\"></a>Updating/组件更新相关</h3><ul>\n<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的props之前调用，注意组件初始化渲染时则不会执行</li>\n<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用。当组件收到新的props或者新的state时，就会调用，根据返回值true/false决定是否重新渲染</li>\n<li>componentWillUpdate(object nextProps, object nextState)：组件将要更新</li>\n<li>componentDidUpdate(object prevProps, object prevState)：组件已经更新</li>\n</ul>\n<h3 id=\"Unmounting-组件移除相关\"><a href=\"#Unmounting-组件移除相关\" class=\"headerlink\" title=\"Unmounting/组件移除相关\"></a>Unmounting/组件移除相关</h3><ul>\n<li>componentWillUnmount：在组件要被移除之前的时间点触发，可以利用它来处理清理组件的一些工作</li>\n</ul>\n<h3 id=\"生命周期中与props和state相关\"><a href=\"#生命周期中与props和state相关\" class=\"headerlink\" title=\"生命周期中与props和state相关\"></a>生命周期中与props和state相关</h3><ul>\n<li>getDefaultProps 设置props属性默认值</li>\n<li>getInitialState 升值state属性初始值</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Demo = React.createClass(&#123;</span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      *  一、创建阶段</span></span><br><span class=\"line\"><span class=\"comment\">      *  流程：</span></span><br><span class=\"line\"><span class=\"comment\">      *      只调用getDefaultProps方法</span></span><br><span class=\"line\"><span class=\"comment\">      * */</span> </span><br><span class=\"line\">      getDefaultProps: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 在创建类的时候被调用，设置this。props的默认值</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'getDefaultProps'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      *   二、实例化阶段</span></span><br><span class=\"line\"><span class=\"comment\">      *   流程：</span></span><br><span class=\"line\"><span class=\"comment\">      *       getInitialState</span></span><br><span class=\"line\"><span class=\"comment\">      *       componentWillMount</span></span><br><span class=\"line\"><span class=\"comment\">      *       render</span></span><br><span class=\"line\"><span class=\"comment\">      *       componentDidMount</span></span><br><span class=\"line\"><span class=\"comment\">      * </span></span><br><span class=\"line\"><span class=\"comment\">      * */</span></span><br><span class=\"line\">      getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 设置this。state的默认值</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'getInitialState'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      componentWillMount: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在render之前调用</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentWillMount'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 渲染并返回一个虚拟DOM</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'render'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> &lt;div&gt;Hello React&lt;/div&gt;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      componentDidMount: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在render之后调用</span></span><br><span class=\"line\">          <span class=\"comment\">// 在该方法中，React会使用render方法返回的虚拟DOM对象创建真实的DOM结构</span></span><br><span class=\"line\">          <span class=\"comment\">// 可以在这个方法中读取DOM节点</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentDidMount'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      *   三、更新阶段</span></span><br><span class=\"line\"><span class=\"comment\">      *   流程：</span></span><br><span class=\"line\"><span class=\"comment\">      *   componentWillReceiveProps</span></span><br><span class=\"line\"><span class=\"comment\">      *   shouldComponentUpdate 如果返回值是false，之后三个方法不执行</span></span><br><span class=\"line\"><span class=\"comment\">      *   componentWillUpdate</span></span><br><span class=\"line\"><span class=\"comment\">      *   render</span></span><br><span class=\"line\"><span class=\"comment\">      *   componentDidUpdate</span></span><br><span class=\"line\"><span class=\"comment\">      *</span></span><br><span class=\"line\"><span class=\"comment\">      * */</span></span><br><span class=\"line\">      componentWillReceiveProps: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentWillReceiveProps'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      shouldComponentUpdate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 是否需要更新</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'shouldComponentUpdate'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      componentWillUpdate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentWillUpdate'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      componentDidUpdate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentDidUpdate'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      *   四、销毁阶段</span></span><br><span class=\"line\"><span class=\"comment\">      *   流程：</span></span><br><span class=\"line\"><span class=\"comment\">      *       componentWillUnmount</span></span><br><span class=\"line\"><span class=\"comment\">      *</span></span><br><span class=\"line\"><span class=\"comment\">      * */</span></span><br><span class=\"line\"></span><br><span class=\"line\">      componentWillUnmount: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentWillUnmount'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 第一次创建并加载组件</span></span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">      &lt;Demo /&gt;,</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 重新渲染组件</span></span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">          &lt;Demo /&gt;,</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 移除组件</span></span><br><span class=\"line\">  ReactDOM.unmountComponentAtNode(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"StyleSheet\"><a href=\"#StyleSheet\" class=\"headerlink\" title=\"StyleSheet\"></a>StyleSheet</h2><p>ReactNative 中定义组件样式，是通过 <code>StyleSheet</code> 样式表定义的，有几个需要注意的地方：</p>\n<ol>\n<li>HTML5以;结尾，React以,结尾</li>\n<li>HTML5中的key、value都不加引号， React中属于JavaScript对象，key的名字不能出现‘-’，需要使用驼峰命名法，如果value是字符串要加引号</li>\n<li>HTML5中，value如果是数字，需要带单位，React中不需要单位</li>\n</ol>\n<p>盒子模型<br><img src=\"/2017/03/26/Learn-ReactNative-3/box-model.gif\" title=\"box-model\"></p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    backgroundColor: &apos;red&apos;,</span><br><span class=\"line\">    width: 300,</span><br><span class=\"line\">    height: 400,</span><br><span class=\"line\">    marginTop: 25,</span><br><span class=\"line\">    marginLeft: 30,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  top: &#123;</span><br><span class=\"line\">    backgroundColor: &apos;green&apos;,</span><br><span class=\"line\">    width: 280,</span><br><span class=\"line\">    height: 250,</span><br><span class=\"line\">    margin: 10,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  bottom: &#123;</span><br><span class=\"line\">    backgroundColor: &apos;yellow&apos;,</span><br><span class=\"line\">    width: 280,</span><br><span class=\"line\">    height: 110,</span><br><span class=\"line\">    margin: 10,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  boder: &#123;</span><br><span class=\"line\">    borderWidth: 3,</span><br><span class=\"line\">    borderColor: &apos;black&apos;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"CSS3-弹性盒子-Flex-Box\"><a href=\"#CSS3-弹性盒子-Flex-Box\" class=\"headerlink\" title=\"CSS3 弹性盒子(Flex Box)\"></a>CSS3 弹性盒子(Flex Box)</h2><img src=\"/2017/03/26/Learn-ReactNative-3/flexBox-model.jpg\" title=\"flexBox-model\">\n<p>弹性盒模型，主要有两个轴，主轴和交叉轴，主轴并不一定是横向的，是根据Flex Item元素的排列方向来的，如果Item是横向排列，则主轴是横向的，如果Item是纵向的，主轴就是纵向的。</p>\n<p>弹性盒子有很多属性设置，可以参考<a href=\"http://www.runoob.com/css3/css3-flexbox.html\" target=\"_blank\" rel=\"noopener\">《CSS3 弹性盒子》</a>设置。</p>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LessonFlex</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.child1&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.child2&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  container: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    margin: 30,</span></span><br><span class=\"line\"><span class=\"regexp\">    width: 300,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 300,</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'yellow',</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 默认主轴方向是column（竖向）</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 设置为横向排列</span></span><br><span class=\"line\"><span class=\"regexp\">    flexDirection: 'row',</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 主轴方向</span></span><br><span class=\"line\"><span class=\"regexp\">    justifyContent: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 交叉轴</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  child1: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    width: 100,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 100,</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'green',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  child2: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    width: 100,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 100,</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'blue',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"flex属性\"><a href=\"#flex属性\" class=\"headerlink\" title=\"flex属性\"></a>flex属性</h3><p>Flex Box里面一个重要的属性， <code>flex</code> 属性，可以给组件指定flex，flex的值是数字。</p>\n<ul>\n<li>flex:1 表示组件可以撑满父组件所有的剩余空间</li>\n<li>同时存在多个并列的子组件，flex:1，均分</li>\n<li>如果这些并列的子组件的flex值不一样，谁的值越大，谁占的剩余空间比例就越大(即占据剩余空间的比等于并列组件间flex值的比)</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    marginBottom: <span class=\"number\">30</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'cyan'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  child1: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">2</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'green'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  child2: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'yellow'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"View组件\"><a href=\"#View组件\" class=\"headerlink\" title=\"View组件\"></a>View组件</h2><p>现在我们开始学习 ReactNative 的组件，先从<a href=\"https://facebook.github.io/react-native/docs/view.html\" target=\"_blank\" rel=\"noopener\">View组件</a>开始。</p>\n<p>在Web开发中，div是最重要的一个元素，是页面布局的基础。<br>在ReactNative开发中，View组件的作用类似于div。是最基础的组件，被看做是容器组件。</p>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LessonView</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;[styles.container, styles.flex]&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.item&#125;&gt;</span><br><span class=\"line\">          &lt;View style=&#123;[styles.flex, styles.center]&#125;&gt;</span><br><span class=\"line\">            &lt;Text&gt;酒店&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>View&gt;</span><br><span class=\"line\">          &lt;View style=&#123;[styles.flex, styles.lineLeftRight]&#125;&gt;</span><br><span class=\"line\">            &lt;View style=&#123;[styles.flex, styles.center, styles.lineCenter]&#125;&gt;</span><br><span class=\"line\">              &lt;Text&gt;海外酒店&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>View&gt;</span><br><span class=\"line\">            &lt;View style=&#123;[styles.flex, styles.center]&#125;&gt;</span><br><span class=\"line\">              &lt;Text&gt;特价酒店&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>View&gt;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;View style=&#123;[styles.flex]&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;View style=&#123;[styles.flex, styles.center, styles.lineCenter]&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;Text&gt;团购&lt;/</span>Text&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;View style=&#123;[styles.flex, styles.center]&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;Text&gt;民宿.客栈&lt;/</span>Text&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>View&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    marginTop: <span class=\"number\">64</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F2F2F2'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  flex: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  center: &#123;</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  item: &#123;</span><br><span class=\"line\">    flexDirection: <span class=\"string\">'row'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#FF607C'</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">5</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    marginRight: <span class=\"number\">5</span>,</span><br><span class=\"line\">    height: <span class=\"number\">80</span>,</span><br><span class=\"line\">    borderRadius: <span class=\"number\">5</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 给中间的区域设置左右边线</span></span><br><span class=\"line\">  lineLeftRight: &#123;</span><br><span class=\"line\">    borderLeftWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    borderRightWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'white'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 给上半区域设置下边线</span></span><br><span class=\"line\">  lineCenter: &#123;</span><br><span class=\"line\">    borderColor: <span class=\"string\">'white'</span>,</span><br><span class=\"line\">    borderBottomWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本章学习了组件生命周期、了解了 StyleSheet 以及 Flex Box ，并且开始学习了第一个 ReactNative 组件 View。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇文章学习了React的基础用法，这篇文章开始真正学习ReactNative的知识。</p>\n<h2 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h2><p>在编程开发中，每个创建的对象都会有生命周期，对象创建后会占用内存，创建的越多可用内存越少，当对象的生命周期结束时，GC就会回收内存，所以了解生命周期对开发非常重要。</p>\n<p>组件生命周期有三个状态：</p>\n<ol>\n<li>Mounting：组件挂载，已插入真实 DOM</li>\n<li>Updating：组件更新，正在被重新渲染</li>\n<li>Unmounting：组件移除，已移出真实 DOM</li>\n</ol>\n<p>组件生命周期四个阶段：</p>\n<ol>\n<li>创建</li>\n<li>实例化</li>\n<li>更新</li>\n<li>销毁</li>\n</ol>\n<h3 id=\"Mounting-组件挂载相关\"><a href=\"#Mounting-组件挂载相关\" class=\"headerlink\" title=\"Mounting/组件挂载相关\"></a>Mounting/组件挂载相关</h3><ul>\n<li>componentWillMount：组件将要挂载。在render之前执行，但仅执行一次，即使多次重复渲染该组件，或者改变了组件的state</li>\n<li>componentDidMount：组件以及挂载。在render之后执行，同一个组件重复渲染只执行一次</li>\n</ul>\n<h3 id=\"Updating-组件更新相关\"><a href=\"#Updating-组件更新相关\" class=\"headerlink\" title=\"Updating/组件更新相关\"></a>Updating/组件更新相关</h3><ul>\n<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的props之前调用，注意组件初始化渲染时则不会执行</li>\n<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用。当组件收到新的props或者新的state时，就会调用，根据返回值true/false决定是否重新渲染</li>\n<li>componentWillUpdate(object nextProps, object nextState)：组件将要更新</li>\n<li>componentDidUpdate(object prevProps, object prevState)：组件已经更新</li>\n</ul>\n<h3 id=\"Unmounting-组件移除相关\"><a href=\"#Unmounting-组件移除相关\" class=\"headerlink\" title=\"Unmounting/组件移除相关\"></a>Unmounting/组件移除相关</h3><ul>\n<li>componentWillUnmount：在组件要被移除之前的时间点触发，可以利用它来处理清理组件的一些工作</li>\n</ul>\n<h3 id=\"生命周期中与props和state相关\"><a href=\"#生命周期中与props和state相关\" class=\"headerlink\" title=\"生命周期中与props和state相关\"></a>生命周期中与props和state相关</h3><ul>\n<li>getDefaultProps 设置props属性默认值</li>\n<li>getInitialState 升值state属性初始值</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Demo = React.createClass(&#123;</span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      *  一、创建阶段</span></span><br><span class=\"line\"><span class=\"comment\">      *  流程：</span></span><br><span class=\"line\"><span class=\"comment\">      *      只调用getDefaultProps方法</span></span><br><span class=\"line\"><span class=\"comment\">      * */</span> </span><br><span class=\"line\">      getDefaultProps: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 在创建类的时候被调用，设置this。props的默认值</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'getDefaultProps'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      *   二、实例化阶段</span></span><br><span class=\"line\"><span class=\"comment\">      *   流程：</span></span><br><span class=\"line\"><span class=\"comment\">      *       getInitialState</span></span><br><span class=\"line\"><span class=\"comment\">      *       componentWillMount</span></span><br><span class=\"line\"><span class=\"comment\">      *       render</span></span><br><span class=\"line\"><span class=\"comment\">      *       componentDidMount</span></span><br><span class=\"line\"><span class=\"comment\">      * </span></span><br><span class=\"line\"><span class=\"comment\">      * */</span></span><br><span class=\"line\">      getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 设置this。state的默认值</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'getInitialState'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      componentWillMount: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在render之前调用</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentWillMount'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 渲染并返回一个虚拟DOM</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'render'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> &lt;div&gt;Hello React&lt;/div&gt;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      componentDidMount: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在render之后调用</span></span><br><span class=\"line\">          <span class=\"comment\">// 在该方法中，React会使用render方法返回的虚拟DOM对象创建真实的DOM结构</span></span><br><span class=\"line\">          <span class=\"comment\">// 可以在这个方法中读取DOM节点</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentDidMount'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      *   三、更新阶段</span></span><br><span class=\"line\"><span class=\"comment\">      *   流程：</span></span><br><span class=\"line\"><span class=\"comment\">      *   componentWillReceiveProps</span></span><br><span class=\"line\"><span class=\"comment\">      *   shouldComponentUpdate 如果返回值是false，之后三个方法不执行</span></span><br><span class=\"line\"><span class=\"comment\">      *   componentWillUpdate</span></span><br><span class=\"line\"><span class=\"comment\">      *   render</span></span><br><span class=\"line\"><span class=\"comment\">      *   componentDidUpdate</span></span><br><span class=\"line\"><span class=\"comment\">      *</span></span><br><span class=\"line\"><span class=\"comment\">      * */</span></span><br><span class=\"line\">      componentWillReceiveProps: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentWillReceiveProps'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      shouldComponentUpdate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 是否需要更新</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'shouldComponentUpdate'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      componentWillUpdate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentWillUpdate'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      componentDidUpdate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentDidUpdate'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      *   四、销毁阶段</span></span><br><span class=\"line\"><span class=\"comment\">      *   流程：</span></span><br><span class=\"line\"><span class=\"comment\">      *       componentWillUnmount</span></span><br><span class=\"line\"><span class=\"comment\">      *</span></span><br><span class=\"line\"><span class=\"comment\">      * */</span></span><br><span class=\"line\"></span><br><span class=\"line\">      componentWillUnmount: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentWillUnmount'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 第一次创建并加载组件</span></span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">      &lt;Demo /&gt;,</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 重新渲染组件</span></span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">          &lt;Demo /&gt;,</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 移除组件</span></span><br><span class=\"line\">  ReactDOM.unmountComponentAtNode(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"StyleSheet\"><a href=\"#StyleSheet\" class=\"headerlink\" title=\"StyleSheet\"></a>StyleSheet</h2><p>ReactNative 中定义组件样式，是通过 <code>StyleSheet</code> 样式表定义的，有几个需要注意的地方：</p>\n<ol>\n<li>HTML5以;结尾，React以,结尾</li>\n<li>HTML5中的key、value都不加引号， React中属于JavaScript对象，key的名字不能出现‘-’，需要使用驼峰命名法，如果value是字符串要加引号</li>\n<li>HTML5中，value如果是数字，需要带单位，React中不需要单位</li>\n</ol>\n<p>盒子模型<br><img src=\"/2017/03/26/Learn-ReactNative-3/box-model.gif\" title=\"box-model\"></p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    backgroundColor: &apos;red&apos;,</span><br><span class=\"line\">    width: 300,</span><br><span class=\"line\">    height: 400,</span><br><span class=\"line\">    marginTop: 25,</span><br><span class=\"line\">    marginLeft: 30,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  top: &#123;</span><br><span class=\"line\">    backgroundColor: &apos;green&apos;,</span><br><span class=\"line\">    width: 280,</span><br><span class=\"line\">    height: 250,</span><br><span class=\"line\">    margin: 10,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  bottom: &#123;</span><br><span class=\"line\">    backgroundColor: &apos;yellow&apos;,</span><br><span class=\"line\">    width: 280,</span><br><span class=\"line\">    height: 110,</span><br><span class=\"line\">    margin: 10,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  boder: &#123;</span><br><span class=\"line\">    borderWidth: 3,</span><br><span class=\"line\">    borderColor: &apos;black&apos;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"CSS3-弹性盒子-Flex-Box\"><a href=\"#CSS3-弹性盒子-Flex-Box\" class=\"headerlink\" title=\"CSS3 弹性盒子(Flex Box)\"></a>CSS3 弹性盒子(Flex Box)</h2><img src=\"/2017/03/26/Learn-ReactNative-3/flexBox-model.jpg\" title=\"flexBox-model\">\n<p>弹性盒模型，主要有两个轴，主轴和交叉轴，主轴并不一定是横向的，是根据Flex Item元素的排列方向来的，如果Item是横向排列，则主轴是横向的，如果Item是纵向的，主轴就是纵向的。</p>\n<p>弹性盒子有很多属性设置，可以参考<a href=\"http://www.runoob.com/css3/css3-flexbox.html\" target=\"_blank\" rel=\"noopener\">《CSS3 弹性盒子》</a>设置。</p>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LessonFlex</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.child1&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.child2&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  container: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    margin: 30,</span></span><br><span class=\"line\"><span class=\"regexp\">    width: 300,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 300,</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'yellow',</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 默认主轴方向是column（竖向）</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 设置为横向排列</span></span><br><span class=\"line\"><span class=\"regexp\">    flexDirection: 'row',</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 主轴方向</span></span><br><span class=\"line\"><span class=\"regexp\">    justifyContent: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 交叉轴</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  child1: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    width: 100,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 100,</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'green',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  child2: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    width: 100,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 100,</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'blue',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"flex属性\"><a href=\"#flex属性\" class=\"headerlink\" title=\"flex属性\"></a>flex属性</h3><p>Flex Box里面一个重要的属性， <code>flex</code> 属性，可以给组件指定flex，flex的值是数字。</p>\n<ul>\n<li>flex:1 表示组件可以撑满父组件所有的剩余空间</li>\n<li>同时存在多个并列的子组件，flex:1，均分</li>\n<li>如果这些并列的子组件的flex值不一样，谁的值越大，谁占的剩余空间比例就越大(即占据剩余空间的比等于并列组件间flex值的比)</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    marginBottom: <span class=\"number\">30</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'cyan'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  child1: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">2</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'green'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  child2: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'yellow'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"View组件\"><a href=\"#View组件\" class=\"headerlink\" title=\"View组件\"></a>View组件</h2><p>现在我们开始学习 ReactNative 的组件，先从<a href=\"https://facebook.github.io/react-native/docs/view.html\" target=\"_blank\" rel=\"noopener\">View组件</a>开始。</p>\n<p>在Web开发中，div是最重要的一个元素，是页面布局的基础。<br>在ReactNative开发中，View组件的作用类似于div。是最基础的组件，被看做是容器组件。</p>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LessonView</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;[styles.container, styles.flex]&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.item&#125;&gt;</span><br><span class=\"line\">          &lt;View style=&#123;[styles.flex, styles.center]&#125;&gt;</span><br><span class=\"line\">            &lt;Text&gt;酒店&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>View&gt;</span><br><span class=\"line\">          &lt;View style=&#123;[styles.flex, styles.lineLeftRight]&#125;&gt;</span><br><span class=\"line\">            &lt;View style=&#123;[styles.flex, styles.center, styles.lineCenter]&#125;&gt;</span><br><span class=\"line\">              &lt;Text&gt;海外酒店&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>View&gt;</span><br><span class=\"line\">            &lt;View style=&#123;[styles.flex, styles.center]&#125;&gt;</span><br><span class=\"line\">              &lt;Text&gt;特价酒店&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>View&gt;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;View style=&#123;[styles.flex]&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;View style=&#123;[styles.flex, styles.center, styles.lineCenter]&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;Text&gt;团购&lt;/</span>Text&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;View style=&#123;[styles.flex, styles.center]&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;Text&gt;民宿.客栈&lt;/</span>Text&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>View&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    marginTop: <span class=\"number\">64</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F2F2F2'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  flex: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  center: &#123;</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  item: &#123;</span><br><span class=\"line\">    flexDirection: <span class=\"string\">'row'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#FF607C'</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">5</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    marginRight: <span class=\"number\">5</span>,</span><br><span class=\"line\">    height: <span class=\"number\">80</span>,</span><br><span class=\"line\">    borderRadius: <span class=\"number\">5</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 给中间的区域设置左右边线</span></span><br><span class=\"line\">  lineLeftRight: &#123;</span><br><span class=\"line\">    borderLeftWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    borderRightWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'white'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 给上半区域设置下边线</span></span><br><span class=\"line\">  lineCenter: &#123;</span><br><span class=\"line\">    borderColor: <span class=\"string\">'white'</span>,</span><br><span class=\"line\">    borderBottomWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本章学习了组件生命周期、了解了 StyleSheet 以及 Flex Box ，并且开始学习了第一个 ReactNative 组件 View。</p>\n"},{"title":"学习ReactNative基础（四）","date":"2017-04-03T03:33:54.000Z","_content":"\n## 前言\n\n本章，我们学习新的组件 Text 、 Touchable 、 TextInput 和 Image。\n\n## Text组件\n\nText组件是 ReactNative 中显示文本的组件，详细的内容可以参考[官方文档](https://facebook.github.io/react-native/docs/text.html)，这里只讲几个常用的属性。Text组件需要导入组件：\n\n```\n// onPress   手指触摸事件\n// numberOfLines 显示多少行\n\n// 可以设置字体颜色、大小、对齐方式等等\n\nimport {\n  AppRegistry,\n  StyleSheet,\n  Text,\n  View,\n  Text,\n} from 'react-native';\n```\n\n例子：做一个简单版的网易新闻web单页\n\n{% asset_img WX20170501-114928@2x.png neatnew-1 %}\n\n界面分析可以分成两部分：Header和新闻内容，整个界面是一个组件，由两个子组件组成。如果都写在index.ios.js文件中，代码比较乱，在单独一个文件中定义子组件，使用Module.exports将组件导出为独立的模块，可以在其他文件中引用。\n\nheader.js\n\n```JavaScript\n// 组件\nvar Header = React.createClass({\n  render: function () {\n    return (\n      <View style={styles.flex}>\n        <Text style={styles.font}>\n          <Text style={styles.font_1}>网易</Text>\n          <Text style={styles.font_2}>新闻</Text>\n          <Text>有态度</Text>\n        </Text>\n      </View>\n    );\n  }\n});\n\n// 样式\nvar styles = StyleSheet.create({\n  flex: {\n    marginTop: 25,\n    height: 40,\n    borderBottomWidth: 1,\n    borderBottomColor: '#EF2D26',\n    alignItems: 'center',\n  },\n  // 字体公共部分\n  font: {\n    fontSize: 25,\n    fontWeight: 'bold',\n    textAlign: 'center',\n  },\n  font_1: {\n    color: '#CD1D1C',\n  },\n  font_2: {\n    color: '#FFF',\n    backgroundColor: '#CD1D1C',\n  }\n});\n\n// 导出模块\nmodule.exports = Header;\n```\n\nnews.js\n\n```JavaScript\n// 组件\nvar News = React.createClass({\n  show: function(title) {\n    alert(title);\n  },\n  render: function () {\n    // 定义数组，用于存储设置好的Text组件\n    var newsComponents = [];\n    // 遍历存储信息的数组，从外部传入的\n    for (var i in this.props.news) {\n      var text = (\n        <Text\n          onPress={this.show.bind(this, this.props.news[i])}\n          style={styles.news_item}\n          numberOfLines={2}\n          key={i}>\n          {this.props.news[i]}\n        </Text>\n      );\n      // 将设置好的Text存入数组\n      newsComponents.push(text);\n    }\n\n    return (\n      <View style={styles.flex}>\n        <Text style={styles.news_title}>今日要闻</Text>\n        {newsComponents}\n      </View>\n    );\n  }\n});\n\n// 样式\nvar styles = StyleSheet.create({\n  flex: {\n    flex: 1,\n  },\n  // ‘今日要闻’标题\n  news_title: {\n    fontSize: 20,\n    fontWeight: 'bold',\n    color: '#CD1D1C',\n    marginLeft: 10,\n    marginTop: 15,\n  },\n  // 每条新闻\n  news_item: {\n    marginTop: 10,\n    marginLeft: 10,\n    marginRight: 10,\n    fontSize: 15,\n    lineHeight: 30,\n  }\n});\n\n// 导出模块\nmodule.exports = News;\n```\n\nindex.ios.js\n\n```JavaScript\n// 引入\nvar Header = require('./header');\nvar News = require('./news');\n\nexport default class LessonText extends Component {\n  render() {\n\n    // 定义数组存储新闻内容\n    var news = [\n      '1.回复看到撒后方可',\n      '2.发生的路口附近',\n      '3.附件是到付',\n      '4.房间号大搜罗咖啡就撒打开开发和四大，发神经的后来开飞机上大力开发接收到放假撒的路口附近',\n    ];\n\n    return (\n      <View style={styles.flex}>\n        {/* Header */}\n        <Header></Header>\n        {/* News */}\n        <News news={news}></News>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  flex: {\n    flex: 1,\n  },\n});\n```\n\n上面的代码通过 `module.exports` 导出模块，主入口通过 `require('./header');` 引入模块，达到了模块分离，精简了代码。\n\n## Touchable\n\nReactNative 中提供3个组件用于给其他没有触摸事件的组件绑定触摸事件（都需要导入组件），[官方文档](https://facebook.github.io/react-native/docs/touchableopacity.html)：\n\n```\nimport {\n  AppRegistry,\n  StyleSheet,\n  Text,\n  View,\n  TouchableOpacity,\n  TouchableHighlight,\n  TouchableWithoutFeedback,\n} from 'react-native';\n```\n\n\n* TouchableOpacity 透明触摸，点击时，组件会出现透明过度效果\n* TouchableHighlight 高亮触摸，点击时，组件会出现高亮效果\n* TouchableWithoutFeedback 无反馈性触摸，点击时，组件无视觉变化\n\n例子：\n\n```JavaScript\nvar LessonTouchable = React.createClass({\n  clickBtn: function () {\n    alert('按钮被点击');\n  },\n  render: function () {\n    return (\n      <View style={styles.container}>\n        <View style={styles.flex}>\n          <View style={styles.input}></View>\n        </View>\n        <TouchableHighlight style={styles.btn} onPress={this.clickBtn}>\n          <Text style={styles.search}>搜索</Text>\n        </TouchableHighlight>\n      </View>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flexDirection: 'row',\n    height: 45,\n    marginTop: 25,\n  },\n  flex: {\n    flex: 1,\n  },\n  input: {\n    height: 45,\n    borderWidth: 1,\n    marginLeft: 5,\n    paddingLeft: 5,\n    borderColor: '#CCC',\n    borderRadius: 4,\n  },\n  btn: {\n    width: 55,\n    marginLeft: 5,\n    marginRight: 5,\n    backgroundColor: '#23BEFF',\n    height: 45,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  search: {\n    color: '#FFF',\n    fontSize: 15,\n    fontWeight: 'bold',\n  }\n});\n```\n\n上面只提供了 `TouchableHighlight` 的示例，另外2个自己尝试效果。\n\n## TextInput\n\nTextInput是一个允许用户在应用中通过键盘输入文本的基本组件，本组件的属性提供了多种特性的配置，譬如自动完成、自动大小写、占位文字，以及多种不同的键盘类型（如纯数字键盘）等等，[官方文档](https://facebook.github.io/react-native/docs/textinput.html)，常用：\n    \n```\nplaceholder 占位符\nvalue 输入框的值\npassword 是否密文输入\neditable 输入框是否可编辑\nreturnKeyType 键盘return键类型\nonChange 当文本变化时调用\nonEndEditing 当结束编辑时调用\nonSubmitEditing 当结束编辑，点击提交按钮时调用\n```\n\n例子：\n\n```JavaScript\nvar LessonTextInput = React.createClass({\n  getInitialState: function() {\n    return {\n      inputText: '',\n    };\n  },\n  // 输入框的onChange实现\n  getContent: function(text) {\n    this.setState({\n      inputText: text\n    });\n  },\n  clickBtn: function() {\n    alert(this.state.inputText);\n  },\n  render: function() {\n    return (\n      <View style={styles.container}>\n        <View style={styles.flex}>\n          <TextInput\n            style={styles.input}\n            returnKeyType='search'\n            placeholder='请输入内容'\n            onChangeText={this.getContent}\n          />\n        </View>\n        <TouchableOpacity style={styles.btn} onPress={this.clickBtn}>\n          <Text style={styles.search}>搜索</Text>\n        </TouchableOpacity>\n      </View>\n\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flexDirection: 'row',\n    height: 45,\n    marginTop: 25,\n  },\n  flex: {\n    flex: 1,\n  },\n  input: {\n    height: 45,\n    borderWidth: 1,\n    marginLeft: 5,\n    paddingLeft: 5,\n    borderColor: '#CCC',\n    borderRadius: 4,\n  },\n  btn: {\n    width: 55,\n    marginLeft: 5,\n    marginRight: 5,\n    backgroundColor: '#23BEFF',\n    height: 45,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  search: {\n    color: '#FFF',\n    fontSize: 15,\n    fontWeight: 'bold',\n  }\n});\n```\n\n## Image\nImage 用于显示图片的组件，包括网络图片、静态资源等等，[官方文档](https://facebook.github.io/react-native/docs/image.html)，常用属性：\n\n```\nresizeMode  图片适应模式cover、contain、stretch\nsource 图片引用地址\niOS 支持的属性：onLoad、onLoadEnd、onLoadStart、onProgress\n```\n\n获取图片主要有两种方式：本地图片和网络图片，`Image` 都提供了获取的方式。\n\n* 获取本地图片，现在工程目录下创建图片文件夹，和 `index.ios.js` 同一级目录，然后通过 **source={require}** 属性获取\n* 获取网络图片，通过 **source={uri}** 获取\n\n\n例子：\n\n```JavaScript\nexport default class LessonImage extends Component {\n  render() {\n    return (\n      <View style={styles.container}>\n        <View style={styles.net}>\n          <Image\n            style={styles.netImage}\n            source={{uri:'http://reactnative.cn/static/docs/0.41/img/react-native-congratulations.png'}}\n            />\n        </View>\n        <View style={styles.local}>\n          <Image\n            style={styles.localImage}\n            source={require('./img/react-native-congratulations.png')}\n            />\n        </View>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    margin: 25,\n    alignItems: 'center',\n  },\n  net: {\n    marginTop: 38,\n    width: 300,\n    height: 240,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'cyan',\n  },\n  netImage: {\n    width: 280,\n    height: 200,\n    backgroundColor: 'gray',\n  },\n  local: {\n    marginTop: 30,\n    width: 300,\n    height: 200,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'cyan',\n  },\n  localImage: {\n    width: 180,\n    height: 180,\n    backgroundColor: 'gray',\n  },\n});\n```\n\n## 总结\n\n本篇文章非常简单的介绍了 ReactNative 的几个组件，并给出了示例，更加详细的用法请参考官方文档。\n    \n\n\n\n\n","source":"_posts/Learn-ReactNative-4.md","raw":"---\ntitle: 学习ReactNative基础（四）\ndate: 2017-04-03 11:33:54\ntags: RN\ncategory: ReactNative\n---\n\n## 前言\n\n本章，我们学习新的组件 Text 、 Touchable 、 TextInput 和 Image。\n\n## Text组件\n\nText组件是 ReactNative 中显示文本的组件，详细的内容可以参考[官方文档](https://facebook.github.io/react-native/docs/text.html)，这里只讲几个常用的属性。Text组件需要导入组件：\n\n```\n// onPress   手指触摸事件\n// numberOfLines 显示多少行\n\n// 可以设置字体颜色、大小、对齐方式等等\n\nimport {\n  AppRegistry,\n  StyleSheet,\n  Text,\n  View,\n  Text,\n} from 'react-native';\n```\n\n例子：做一个简单版的网易新闻web单页\n\n{% asset_img WX20170501-114928@2x.png neatnew-1 %}\n\n界面分析可以分成两部分：Header和新闻内容，整个界面是一个组件，由两个子组件组成。如果都写在index.ios.js文件中，代码比较乱，在单独一个文件中定义子组件，使用Module.exports将组件导出为独立的模块，可以在其他文件中引用。\n\nheader.js\n\n```JavaScript\n// 组件\nvar Header = React.createClass({\n  render: function () {\n    return (\n      <View style={styles.flex}>\n        <Text style={styles.font}>\n          <Text style={styles.font_1}>网易</Text>\n          <Text style={styles.font_2}>新闻</Text>\n          <Text>有态度</Text>\n        </Text>\n      </View>\n    );\n  }\n});\n\n// 样式\nvar styles = StyleSheet.create({\n  flex: {\n    marginTop: 25,\n    height: 40,\n    borderBottomWidth: 1,\n    borderBottomColor: '#EF2D26',\n    alignItems: 'center',\n  },\n  // 字体公共部分\n  font: {\n    fontSize: 25,\n    fontWeight: 'bold',\n    textAlign: 'center',\n  },\n  font_1: {\n    color: '#CD1D1C',\n  },\n  font_2: {\n    color: '#FFF',\n    backgroundColor: '#CD1D1C',\n  }\n});\n\n// 导出模块\nmodule.exports = Header;\n```\n\nnews.js\n\n```JavaScript\n// 组件\nvar News = React.createClass({\n  show: function(title) {\n    alert(title);\n  },\n  render: function () {\n    // 定义数组，用于存储设置好的Text组件\n    var newsComponents = [];\n    // 遍历存储信息的数组，从外部传入的\n    for (var i in this.props.news) {\n      var text = (\n        <Text\n          onPress={this.show.bind(this, this.props.news[i])}\n          style={styles.news_item}\n          numberOfLines={2}\n          key={i}>\n          {this.props.news[i]}\n        </Text>\n      );\n      // 将设置好的Text存入数组\n      newsComponents.push(text);\n    }\n\n    return (\n      <View style={styles.flex}>\n        <Text style={styles.news_title}>今日要闻</Text>\n        {newsComponents}\n      </View>\n    );\n  }\n});\n\n// 样式\nvar styles = StyleSheet.create({\n  flex: {\n    flex: 1,\n  },\n  // ‘今日要闻’标题\n  news_title: {\n    fontSize: 20,\n    fontWeight: 'bold',\n    color: '#CD1D1C',\n    marginLeft: 10,\n    marginTop: 15,\n  },\n  // 每条新闻\n  news_item: {\n    marginTop: 10,\n    marginLeft: 10,\n    marginRight: 10,\n    fontSize: 15,\n    lineHeight: 30,\n  }\n});\n\n// 导出模块\nmodule.exports = News;\n```\n\nindex.ios.js\n\n```JavaScript\n// 引入\nvar Header = require('./header');\nvar News = require('./news');\n\nexport default class LessonText extends Component {\n  render() {\n\n    // 定义数组存储新闻内容\n    var news = [\n      '1.回复看到撒后方可',\n      '2.发生的路口附近',\n      '3.附件是到付',\n      '4.房间号大搜罗咖啡就撒打开开发和四大，发神经的后来开飞机上大力开发接收到放假撒的路口附近',\n    ];\n\n    return (\n      <View style={styles.flex}>\n        {/* Header */}\n        <Header></Header>\n        {/* News */}\n        <News news={news}></News>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  flex: {\n    flex: 1,\n  },\n});\n```\n\n上面的代码通过 `module.exports` 导出模块，主入口通过 `require('./header');` 引入模块，达到了模块分离，精简了代码。\n\n## Touchable\n\nReactNative 中提供3个组件用于给其他没有触摸事件的组件绑定触摸事件（都需要导入组件），[官方文档](https://facebook.github.io/react-native/docs/touchableopacity.html)：\n\n```\nimport {\n  AppRegistry,\n  StyleSheet,\n  Text,\n  View,\n  TouchableOpacity,\n  TouchableHighlight,\n  TouchableWithoutFeedback,\n} from 'react-native';\n```\n\n\n* TouchableOpacity 透明触摸，点击时，组件会出现透明过度效果\n* TouchableHighlight 高亮触摸，点击时，组件会出现高亮效果\n* TouchableWithoutFeedback 无反馈性触摸，点击时，组件无视觉变化\n\n例子：\n\n```JavaScript\nvar LessonTouchable = React.createClass({\n  clickBtn: function () {\n    alert('按钮被点击');\n  },\n  render: function () {\n    return (\n      <View style={styles.container}>\n        <View style={styles.flex}>\n          <View style={styles.input}></View>\n        </View>\n        <TouchableHighlight style={styles.btn} onPress={this.clickBtn}>\n          <Text style={styles.search}>搜索</Text>\n        </TouchableHighlight>\n      </View>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flexDirection: 'row',\n    height: 45,\n    marginTop: 25,\n  },\n  flex: {\n    flex: 1,\n  },\n  input: {\n    height: 45,\n    borderWidth: 1,\n    marginLeft: 5,\n    paddingLeft: 5,\n    borderColor: '#CCC',\n    borderRadius: 4,\n  },\n  btn: {\n    width: 55,\n    marginLeft: 5,\n    marginRight: 5,\n    backgroundColor: '#23BEFF',\n    height: 45,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  search: {\n    color: '#FFF',\n    fontSize: 15,\n    fontWeight: 'bold',\n  }\n});\n```\n\n上面只提供了 `TouchableHighlight` 的示例，另外2个自己尝试效果。\n\n## TextInput\n\nTextInput是一个允许用户在应用中通过键盘输入文本的基本组件，本组件的属性提供了多种特性的配置，譬如自动完成、自动大小写、占位文字，以及多种不同的键盘类型（如纯数字键盘）等等，[官方文档](https://facebook.github.io/react-native/docs/textinput.html)，常用：\n    \n```\nplaceholder 占位符\nvalue 输入框的值\npassword 是否密文输入\neditable 输入框是否可编辑\nreturnKeyType 键盘return键类型\nonChange 当文本变化时调用\nonEndEditing 当结束编辑时调用\nonSubmitEditing 当结束编辑，点击提交按钮时调用\n```\n\n例子：\n\n```JavaScript\nvar LessonTextInput = React.createClass({\n  getInitialState: function() {\n    return {\n      inputText: '',\n    };\n  },\n  // 输入框的onChange实现\n  getContent: function(text) {\n    this.setState({\n      inputText: text\n    });\n  },\n  clickBtn: function() {\n    alert(this.state.inputText);\n  },\n  render: function() {\n    return (\n      <View style={styles.container}>\n        <View style={styles.flex}>\n          <TextInput\n            style={styles.input}\n            returnKeyType='search'\n            placeholder='请输入内容'\n            onChangeText={this.getContent}\n          />\n        </View>\n        <TouchableOpacity style={styles.btn} onPress={this.clickBtn}>\n          <Text style={styles.search}>搜索</Text>\n        </TouchableOpacity>\n      </View>\n\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flexDirection: 'row',\n    height: 45,\n    marginTop: 25,\n  },\n  flex: {\n    flex: 1,\n  },\n  input: {\n    height: 45,\n    borderWidth: 1,\n    marginLeft: 5,\n    paddingLeft: 5,\n    borderColor: '#CCC',\n    borderRadius: 4,\n  },\n  btn: {\n    width: 55,\n    marginLeft: 5,\n    marginRight: 5,\n    backgroundColor: '#23BEFF',\n    height: 45,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  search: {\n    color: '#FFF',\n    fontSize: 15,\n    fontWeight: 'bold',\n  }\n});\n```\n\n## Image\nImage 用于显示图片的组件，包括网络图片、静态资源等等，[官方文档](https://facebook.github.io/react-native/docs/image.html)，常用属性：\n\n```\nresizeMode  图片适应模式cover、contain、stretch\nsource 图片引用地址\niOS 支持的属性：onLoad、onLoadEnd、onLoadStart、onProgress\n```\n\n获取图片主要有两种方式：本地图片和网络图片，`Image` 都提供了获取的方式。\n\n* 获取本地图片，现在工程目录下创建图片文件夹，和 `index.ios.js` 同一级目录，然后通过 **source={require}** 属性获取\n* 获取网络图片，通过 **source={uri}** 获取\n\n\n例子：\n\n```JavaScript\nexport default class LessonImage extends Component {\n  render() {\n    return (\n      <View style={styles.container}>\n        <View style={styles.net}>\n          <Image\n            style={styles.netImage}\n            source={{uri:'http://reactnative.cn/static/docs/0.41/img/react-native-congratulations.png'}}\n            />\n        </View>\n        <View style={styles.local}>\n          <Image\n            style={styles.localImage}\n            source={require('./img/react-native-congratulations.png')}\n            />\n        </View>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    margin: 25,\n    alignItems: 'center',\n  },\n  net: {\n    marginTop: 38,\n    width: 300,\n    height: 240,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'cyan',\n  },\n  netImage: {\n    width: 280,\n    height: 200,\n    backgroundColor: 'gray',\n  },\n  local: {\n    marginTop: 30,\n    width: 300,\n    height: 200,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'cyan',\n  },\n  localImage: {\n    width: 180,\n    height: 180,\n    backgroundColor: 'gray',\n  },\n});\n```\n\n## 总结\n\n本篇文章非常简单的介绍了 ReactNative 的几个组件，并给出了示例，更加详细的用法请参考官方文档。\n    \n\n\n\n\n","slug":"Learn-ReactNative-4","published":1,"updated":"2017-05-01T04:42:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7nz004b8jpbuege6njy","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本章，我们学习新的组件 Text 、 Touchable 、 TextInput 和 Image。</p>\n<h2 id=\"Text组件\"><a href=\"#Text组件\" class=\"headerlink\" title=\"Text组件\"></a>Text组件</h2><p>Text组件是 ReactNative 中显示文本的组件，详细的内容可以参考<a href=\"https://facebook.github.io/react-native/docs/text.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>，这里只讲几个常用的属性。Text组件需要导入组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// onPress   手指触摸事件</span><br><span class=\"line\">// numberOfLines 显示多少行</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以设置字体颜色、大小、对齐方式等等</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  AppRegistry,</span><br><span class=\"line\">  StyleSheet,</span><br><span class=\"line\">  Text,</span><br><span class=\"line\">  View,</span><br><span class=\"line\">  Text,</span><br><span class=\"line\">&#125; from &apos;react-native&apos;;</span><br></pre></td></tr></table></figure>\n<p>例子：做一个简单版的网易新闻web单页</p>\n<img src=\"/2017/04/03/Learn-ReactNative-4/WX20170501-114928@2x.png\" title=\"neatnew-1\">\n<p>界面分析可以分成两部分：Header和新闻内容，整个界面是一个组件，由两个子组件组成。如果都写在index.ios.js文件中，代码比较乱，在单独一个文件中定义子组件，使用Module.exports将组件导出为独立的模块，可以在其他文件中引用。</p>\n<p>header.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Header = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.flex&#125;&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.font&#125;&gt;</span><br><span class=\"line\">          &lt;Text style=&#123;styles.font_1&#125;&gt;网易&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Text style=&#123;styles.font_2&#125;&gt;新闻&lt;/</span>Text&gt;</span><br><span class=\"line\">          &lt;Text&gt;有态度&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>Text&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 样式</span></span><br><span class=\"line\"><span class=\"regexp\">var styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  flex: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    marginTop: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 40,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderBottomWidth: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderBottomColor: '#EF2D26',</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ 字体公共部分</span></span><br><span class=\"line\"><span class=\"regexp\">  font: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    fontSize: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    fontWeight: 'bold',</span></span><br><span class=\"line\"><span class=\"regexp\">    textAlign: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  font_1: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    color: '#CD1D1C',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  font_2: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    color: '#FFF',</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: '#CD1D1C',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 导出模块</span></span><br><span class=\"line\"><span class=\"regexp\">module.exports = Header;</span></span><br></pre></td></tr></table></figure>\n<p>news.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> News = React.createClass(&#123;</span><br><span class=\"line\">  show: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">title</span>) </span>&#123;</span><br><span class=\"line\">    alert(title);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义数组，用于存储设置好的Text组件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> newsComponents = [];</span><br><span class=\"line\">    <span class=\"comment\">// 遍历存储信息的数组，从外部传入的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.props.news) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> text = (</span><br><span class=\"line\">        &lt;Text</span><br><span class=\"line\">          onPress=&#123;<span class=\"keyword\">this</span>.show.bind(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.props.news[i])&#125;</span><br><span class=\"line\">          style=&#123;styles.news_item&#125;</span><br><span class=\"line\">          numberOfLines=&#123;<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">          key=&#123;i&#125;&gt;</span><br><span class=\"line\">          &#123;<span class=\"keyword\">this</span>.props.news[i]&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      );</span></span><br><span class=\"line\"><span class=\"regexp\">      /</span><span class=\"regexp\">/ 将设置好的Text存入数组</span></span><br><span class=\"line\"><span class=\"regexp\">      newsComponents.push(text);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;View style=&#123;styles.flex&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Text style=&#123;styles.news_title&#125;&gt;今日要闻&lt;/</span>Text&gt;</span><br><span class=\"line\">        &#123;newsComponents&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 样式</span></span><br><span class=\"line\"><span class=\"regexp\">var styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  flex: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    flex: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ ‘今日要闻’标题</span></span><br><span class=\"line\"><span class=\"regexp\">  news_title: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    fontSize: 20,</span></span><br><span class=\"line\"><span class=\"regexp\">    fontWeight: 'bold',</span></span><br><span class=\"line\"><span class=\"regexp\">    color: '#CD1D1C',</span></span><br><span class=\"line\"><span class=\"regexp\">    marginLeft: 10,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginTop: 15,</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ 每条新闻</span></span><br><span class=\"line\"><span class=\"regexp\">  news_item: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    marginTop: 10,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginLeft: 10,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginRight: 10,</span></span><br><span class=\"line\"><span class=\"regexp\">    fontSize: 15,</span></span><br><span class=\"line\"><span class=\"regexp\">    lineHeight: 30,</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 导出模块</span></span><br><span class=\"line\"><span class=\"regexp\">module.exports = News;</span></span><br></pre></td></tr></table></figure>\n<p>index.ios.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Header = <span class=\"built_in\">require</span>(<span class=\"string\">'./header'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> News = <span class=\"built_in\">require</span>(<span class=\"string\">'./news'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LessonText</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义数组存储新闻内容</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> news = [</span><br><span class=\"line\">      <span class=\"string\">'1.回复看到撒后方可'</span>,</span><br><span class=\"line\">      <span class=\"string\">'2.发生的路口附近'</span>,</span><br><span class=\"line\">      <span class=\"string\">'3.附件是到付'</span>,</span><br><span class=\"line\">      <span class=\"string\">'4.房间号大搜罗咖啡就撒打开开发和四大，发神经的后来开飞机上大力开发接收到放假撒的路口附近'</span>,</span><br><span class=\"line\">    ];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.flex&#125;&gt;</span><br><span class=\"line\">        &#123;<span class=\"comment\">/* Header */</span>&#125;</span><br><span class=\"line\">        &lt;Header&gt;&lt;/Header&gt;</span><br><span class=\"line\">        &#123;<span class=\"comment\">/* News */</span>&#125;</span><br><span class=\"line\">        &lt;News news=&#123;news&#125;&gt;&lt;/News&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  flex: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    flex: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码通过 <code>module.exports</code> 导出模块，主入口通过 <code>require(&#39;./header&#39;);</code> 引入模块，达到了模块分离，精简了代码。</p>\n<h2 id=\"Touchable\"><a href=\"#Touchable\" class=\"headerlink\" title=\"Touchable\"></a>Touchable</h2><p>ReactNative 中提供3个组件用于给其他没有触摸事件的组件绑定触摸事件（都需要导入组件），<a href=\"https://facebook.github.io/react-native/docs/touchableopacity.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;</span><br><span class=\"line\">  AppRegistry,</span><br><span class=\"line\">  StyleSheet,</span><br><span class=\"line\">  Text,</span><br><span class=\"line\">  View,</span><br><span class=\"line\">  TouchableOpacity,</span><br><span class=\"line\">  TouchableHighlight,</span><br><span class=\"line\">  TouchableWithoutFeedback,</span><br><span class=\"line\">&#125; from &apos;react-native&apos;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>TouchableOpacity 透明触摸，点击时，组件会出现透明过度效果</li>\n<li>TouchableHighlight 高亮触摸，点击时，组件会出现高亮效果</li>\n<li>TouchableWithoutFeedback 无反馈性触摸，点击时，组件无视觉变化</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> LessonTouchable = React.createClass(&#123;</span><br><span class=\"line\">  clickBtn: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'按钮被点击'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.flex&#125;&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.input&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TouchableHighlight style=&#123;styles.btn&#125; onPress=&#123;this.clickBtn&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Text style=&#123;styles.search&#125;&gt;搜索&lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TouchableHighlight&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flexDirection: <span class=\"string\">'row'</span>,</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  flex: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  input: &#123;</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    borderWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    paddingLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'#CCC'</span>,</span><br><span class=\"line\">    borderRadius: <span class=\"number\">4</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  btn: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">55</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    marginRight: <span class=\"number\">5</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#23BEFF'</span>,</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  search: &#123;</span><br><span class=\"line\">    color: <span class=\"string\">'#FFF'</span>,</span><br><span class=\"line\">    fontSize: <span class=\"number\">15</span>,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面只提供了 <code>TouchableHighlight</code> 的示例，另外2个自己尝试效果。</p>\n<h2 id=\"TextInput\"><a href=\"#TextInput\" class=\"headerlink\" title=\"TextInput\"></a>TextInput</h2><p>TextInput是一个允许用户在应用中通过键盘输入文本的基本组件，本组件的属性提供了多种特性的配置，譬如自动完成、自动大小写、占位文字，以及多种不同的键盘类型（如纯数字键盘）等等，<a href=\"https://facebook.github.io/react-native/docs/textinput.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>，常用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">placeholder 占位符</span><br><span class=\"line\">value 输入框的值</span><br><span class=\"line\">password 是否密文输入</span><br><span class=\"line\">editable 输入框是否可编辑</span><br><span class=\"line\">returnKeyType 键盘return键类型</span><br><span class=\"line\">onChange 当文本变化时调用</span><br><span class=\"line\">onEndEditing 当结束编辑时调用</span><br><span class=\"line\">onSubmitEditing 当结束编辑，点击提交按钮时调用</span><br></pre></td></tr></table></figure>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> LessonTextInput = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      inputText: <span class=\"string\">''</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 输入框的onChange实现</span></span><br><span class=\"line\">  getContent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      inputText: text</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  clickBtn: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.state.inputText);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.flex&#125;&gt;</span><br><span class=\"line\">          &lt;TextInput</span><br><span class=\"line\">            style=&#123;styles.input&#125;</span><br><span class=\"line\">            returnKeyType=<span class=\"string\">'search'</span></span><br><span class=\"line\">            placeholder=<span class=\"string\">'请输入内容'</span></span><br><span class=\"line\">            onChangeText=&#123;<span class=\"keyword\">this</span>.getContent&#125;</span><br><span class=\"line\">          /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TouchableOpacity style=&#123;styles.btn&#125; onPress=&#123;this.clickBtn&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Text style=&#123;styles.search&#125;&gt;搜索&lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TouchableOpacity&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flexDirection: <span class=\"string\">'row'</span>,</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  flex: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  input: &#123;</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    borderWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    paddingLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'#CCC'</span>,</span><br><span class=\"line\">    borderRadius: <span class=\"number\">4</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  btn: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">55</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    marginRight: <span class=\"number\">5</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#23BEFF'</span>,</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  search: &#123;</span><br><span class=\"line\">    color: <span class=\"string\">'#FFF'</span>,</span><br><span class=\"line\">    fontSize: <span class=\"number\">15</span>,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h2><p>Image 用于显示图片的组件，包括网络图片、静态资源等等，<a href=\"https://facebook.github.io/react-native/docs/image.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>，常用属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resizeMode  图片适应模式cover、contain、stretch</span><br><span class=\"line\">source 图片引用地址</span><br><span class=\"line\">iOS 支持的属性：onLoad、onLoadEnd、onLoadStart、onProgress</span><br></pre></td></tr></table></figure>\n<p>获取图片主要有两种方式：本地图片和网络图片，<code>Image</code> 都提供了获取的方式。</p>\n<ul>\n<li>获取本地图片，现在工程目录下创建图片文件夹，和 <code>index.ios.js</code> 同一级目录，然后通过 <strong>source={require}</strong> 属性获取</li>\n<li>获取网络图片，通过 <strong>source={uri}</strong> 获取</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LessonImage</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.net&#125;&gt;</span><br><span class=\"line\">          &lt;Image</span><br><span class=\"line\">            style=&#123;styles.netImage&#125;</span><br><span class=\"line\">            source=&#123;&#123;<span class=\"attr\">uri</span>:<span class=\"string\">'http://reactnative.cn/static/docs/0.41/img/react-native-congratulations.png'</span>&#125;&#125;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;View style=&#123;styles.local&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Image</span></span><br><span class=\"line\"><span class=\"regexp\">            style=&#123;styles.localImage&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">            source=&#123;require('./img</span><span class=\"regexp\">/react-native-congratulations.png')&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">            /</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    margin: <span class=\"number\">25</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  net: &#123;</span><br><span class=\"line\">    marginTop: <span class=\"number\">38</span>,</span><br><span class=\"line\">    width: <span class=\"number\">300</span>,</span><br><span class=\"line\">    height: <span class=\"number\">240</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'cyan'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  netImage: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">280</span>,</span><br><span class=\"line\">    height: <span class=\"number\">200</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'gray'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  local: &#123;</span><br><span class=\"line\">    marginTop: <span class=\"number\">30</span>,</span><br><span class=\"line\">    width: <span class=\"number\">300</span>,</span><br><span class=\"line\">    height: <span class=\"number\">200</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'cyan'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  localImage: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">180</span>,</span><br><span class=\"line\">    height: <span class=\"number\">180</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'gray'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇文章非常简单的介绍了 ReactNative 的几个组件，并给出了示例，更加详细的用法请参考官方文档。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本章，我们学习新的组件 Text 、 Touchable 、 TextInput 和 Image。</p>\n<h2 id=\"Text组件\"><a href=\"#Text组件\" class=\"headerlink\" title=\"Text组件\"></a>Text组件</h2><p>Text组件是 ReactNative 中显示文本的组件，详细的内容可以参考<a href=\"https://facebook.github.io/react-native/docs/text.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>，这里只讲几个常用的属性。Text组件需要导入组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// onPress   手指触摸事件</span><br><span class=\"line\">// numberOfLines 显示多少行</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以设置字体颜色、大小、对齐方式等等</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  AppRegistry,</span><br><span class=\"line\">  StyleSheet,</span><br><span class=\"line\">  Text,</span><br><span class=\"line\">  View,</span><br><span class=\"line\">  Text,</span><br><span class=\"line\">&#125; from &apos;react-native&apos;;</span><br></pre></td></tr></table></figure>\n<p>例子：做一个简单版的网易新闻web单页</p>\n<img src=\"/2017/04/03/Learn-ReactNative-4/WX20170501-114928@2x.png\" title=\"neatnew-1\">\n<p>界面分析可以分成两部分：Header和新闻内容，整个界面是一个组件，由两个子组件组成。如果都写在index.ios.js文件中，代码比较乱，在单独一个文件中定义子组件，使用Module.exports将组件导出为独立的模块，可以在其他文件中引用。</p>\n<p>header.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Header = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.flex&#125;&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.font&#125;&gt;</span><br><span class=\"line\">          &lt;Text style=&#123;styles.font_1&#125;&gt;网易&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Text style=&#123;styles.font_2&#125;&gt;新闻&lt;/</span>Text&gt;</span><br><span class=\"line\">          &lt;Text&gt;有态度&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>Text&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 样式</span></span><br><span class=\"line\"><span class=\"regexp\">var styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  flex: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    marginTop: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 40,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderBottomWidth: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderBottomColor: '#EF2D26',</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ 字体公共部分</span></span><br><span class=\"line\"><span class=\"regexp\">  font: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    fontSize: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    fontWeight: 'bold',</span></span><br><span class=\"line\"><span class=\"regexp\">    textAlign: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  font_1: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    color: '#CD1D1C',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  font_2: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    color: '#FFF',</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: '#CD1D1C',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 导出模块</span></span><br><span class=\"line\"><span class=\"regexp\">module.exports = Header;</span></span><br></pre></td></tr></table></figure>\n<p>news.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> News = React.createClass(&#123;</span><br><span class=\"line\">  show: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">title</span>) </span>&#123;</span><br><span class=\"line\">    alert(title);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义数组，用于存储设置好的Text组件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> newsComponents = [];</span><br><span class=\"line\">    <span class=\"comment\">// 遍历存储信息的数组，从外部传入的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.props.news) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> text = (</span><br><span class=\"line\">        &lt;Text</span><br><span class=\"line\">          onPress=&#123;<span class=\"keyword\">this</span>.show.bind(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.props.news[i])&#125;</span><br><span class=\"line\">          style=&#123;styles.news_item&#125;</span><br><span class=\"line\">          numberOfLines=&#123;<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">          key=&#123;i&#125;&gt;</span><br><span class=\"line\">          &#123;<span class=\"keyword\">this</span>.props.news[i]&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      );</span></span><br><span class=\"line\"><span class=\"regexp\">      /</span><span class=\"regexp\">/ 将设置好的Text存入数组</span></span><br><span class=\"line\"><span class=\"regexp\">      newsComponents.push(text);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;View style=&#123;styles.flex&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Text style=&#123;styles.news_title&#125;&gt;今日要闻&lt;/</span>Text&gt;</span><br><span class=\"line\">        &#123;newsComponents&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 样式</span></span><br><span class=\"line\"><span class=\"regexp\">var styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  flex: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    flex: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ ‘今日要闻’标题</span></span><br><span class=\"line\"><span class=\"regexp\">  news_title: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    fontSize: 20,</span></span><br><span class=\"line\"><span class=\"regexp\">    fontWeight: 'bold',</span></span><br><span class=\"line\"><span class=\"regexp\">    color: '#CD1D1C',</span></span><br><span class=\"line\"><span class=\"regexp\">    marginLeft: 10,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginTop: 15,</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ 每条新闻</span></span><br><span class=\"line\"><span class=\"regexp\">  news_item: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    marginTop: 10,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginLeft: 10,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginRight: 10,</span></span><br><span class=\"line\"><span class=\"regexp\">    fontSize: 15,</span></span><br><span class=\"line\"><span class=\"regexp\">    lineHeight: 30,</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 导出模块</span></span><br><span class=\"line\"><span class=\"regexp\">module.exports = News;</span></span><br></pre></td></tr></table></figure>\n<p>index.ios.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Header = <span class=\"built_in\">require</span>(<span class=\"string\">'./header'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> News = <span class=\"built_in\">require</span>(<span class=\"string\">'./news'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LessonText</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义数组存储新闻内容</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> news = [</span><br><span class=\"line\">      <span class=\"string\">'1.回复看到撒后方可'</span>,</span><br><span class=\"line\">      <span class=\"string\">'2.发生的路口附近'</span>,</span><br><span class=\"line\">      <span class=\"string\">'3.附件是到付'</span>,</span><br><span class=\"line\">      <span class=\"string\">'4.房间号大搜罗咖啡就撒打开开发和四大，发神经的后来开飞机上大力开发接收到放假撒的路口附近'</span>,</span><br><span class=\"line\">    ];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.flex&#125;&gt;</span><br><span class=\"line\">        &#123;<span class=\"comment\">/* Header */</span>&#125;</span><br><span class=\"line\">        &lt;Header&gt;&lt;/Header&gt;</span><br><span class=\"line\">        &#123;<span class=\"comment\">/* News */</span>&#125;</span><br><span class=\"line\">        &lt;News news=&#123;news&#125;&gt;&lt;/News&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  flex: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    flex: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码通过 <code>module.exports</code> 导出模块，主入口通过 <code>require(&#39;./header&#39;);</code> 引入模块，达到了模块分离，精简了代码。</p>\n<h2 id=\"Touchable\"><a href=\"#Touchable\" class=\"headerlink\" title=\"Touchable\"></a>Touchable</h2><p>ReactNative 中提供3个组件用于给其他没有触摸事件的组件绑定触摸事件（都需要导入组件），<a href=\"https://facebook.github.io/react-native/docs/touchableopacity.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;</span><br><span class=\"line\">  AppRegistry,</span><br><span class=\"line\">  StyleSheet,</span><br><span class=\"line\">  Text,</span><br><span class=\"line\">  View,</span><br><span class=\"line\">  TouchableOpacity,</span><br><span class=\"line\">  TouchableHighlight,</span><br><span class=\"line\">  TouchableWithoutFeedback,</span><br><span class=\"line\">&#125; from &apos;react-native&apos;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>TouchableOpacity 透明触摸，点击时，组件会出现透明过度效果</li>\n<li>TouchableHighlight 高亮触摸，点击时，组件会出现高亮效果</li>\n<li>TouchableWithoutFeedback 无反馈性触摸，点击时，组件无视觉变化</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> LessonTouchable = React.createClass(&#123;</span><br><span class=\"line\">  clickBtn: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'按钮被点击'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.flex&#125;&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.input&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TouchableHighlight style=&#123;styles.btn&#125; onPress=&#123;this.clickBtn&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Text style=&#123;styles.search&#125;&gt;搜索&lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TouchableHighlight&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flexDirection: <span class=\"string\">'row'</span>,</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  flex: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  input: &#123;</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    borderWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    paddingLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'#CCC'</span>,</span><br><span class=\"line\">    borderRadius: <span class=\"number\">4</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  btn: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">55</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    marginRight: <span class=\"number\">5</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#23BEFF'</span>,</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  search: &#123;</span><br><span class=\"line\">    color: <span class=\"string\">'#FFF'</span>,</span><br><span class=\"line\">    fontSize: <span class=\"number\">15</span>,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面只提供了 <code>TouchableHighlight</code> 的示例，另外2个自己尝试效果。</p>\n<h2 id=\"TextInput\"><a href=\"#TextInput\" class=\"headerlink\" title=\"TextInput\"></a>TextInput</h2><p>TextInput是一个允许用户在应用中通过键盘输入文本的基本组件，本组件的属性提供了多种特性的配置，譬如自动完成、自动大小写、占位文字，以及多种不同的键盘类型（如纯数字键盘）等等，<a href=\"https://facebook.github.io/react-native/docs/textinput.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>，常用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">placeholder 占位符</span><br><span class=\"line\">value 输入框的值</span><br><span class=\"line\">password 是否密文输入</span><br><span class=\"line\">editable 输入框是否可编辑</span><br><span class=\"line\">returnKeyType 键盘return键类型</span><br><span class=\"line\">onChange 当文本变化时调用</span><br><span class=\"line\">onEndEditing 当结束编辑时调用</span><br><span class=\"line\">onSubmitEditing 当结束编辑，点击提交按钮时调用</span><br></pre></td></tr></table></figure>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> LessonTextInput = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      inputText: <span class=\"string\">''</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 输入框的onChange实现</span></span><br><span class=\"line\">  getContent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      inputText: text</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  clickBtn: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.state.inputText);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.flex&#125;&gt;</span><br><span class=\"line\">          &lt;TextInput</span><br><span class=\"line\">            style=&#123;styles.input&#125;</span><br><span class=\"line\">            returnKeyType=<span class=\"string\">'search'</span></span><br><span class=\"line\">            placeholder=<span class=\"string\">'请输入内容'</span></span><br><span class=\"line\">            onChangeText=&#123;<span class=\"keyword\">this</span>.getContent&#125;</span><br><span class=\"line\">          /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TouchableOpacity style=&#123;styles.btn&#125; onPress=&#123;this.clickBtn&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Text style=&#123;styles.search&#125;&gt;搜索&lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TouchableOpacity&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flexDirection: <span class=\"string\">'row'</span>,</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  flex: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  input: &#123;</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    borderWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    paddingLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'#CCC'</span>,</span><br><span class=\"line\">    borderRadius: <span class=\"number\">4</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  btn: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">55</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">5</span>,</span><br><span class=\"line\">    marginRight: <span class=\"number\">5</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#23BEFF'</span>,</span><br><span class=\"line\">    height: <span class=\"number\">45</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  search: &#123;</span><br><span class=\"line\">    color: <span class=\"string\">'#FFF'</span>,</span><br><span class=\"line\">    fontSize: <span class=\"number\">15</span>,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h2><p>Image 用于显示图片的组件，包括网络图片、静态资源等等，<a href=\"https://facebook.github.io/react-native/docs/image.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>，常用属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resizeMode  图片适应模式cover、contain、stretch</span><br><span class=\"line\">source 图片引用地址</span><br><span class=\"line\">iOS 支持的属性：onLoad、onLoadEnd、onLoadStart、onProgress</span><br></pre></td></tr></table></figure>\n<p>获取图片主要有两种方式：本地图片和网络图片，<code>Image</code> 都提供了获取的方式。</p>\n<ul>\n<li>获取本地图片，现在工程目录下创建图片文件夹，和 <code>index.ios.js</code> 同一级目录，然后通过 <strong>source={require}</strong> 属性获取</li>\n<li>获取网络图片，通过 <strong>source={uri}</strong> 获取</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LessonImage</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.net&#125;&gt;</span><br><span class=\"line\">          &lt;Image</span><br><span class=\"line\">            style=&#123;styles.netImage&#125;</span><br><span class=\"line\">            source=&#123;&#123;<span class=\"attr\">uri</span>:<span class=\"string\">'http://reactnative.cn/static/docs/0.41/img/react-native-congratulations.png'</span>&#125;&#125;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;View style=&#123;styles.local&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Image</span></span><br><span class=\"line\"><span class=\"regexp\">            style=&#123;styles.localImage&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">            source=&#123;require('./img</span><span class=\"regexp\">/react-native-congratulations.png')&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">            /</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    margin: <span class=\"number\">25</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  net: &#123;</span><br><span class=\"line\">    marginTop: <span class=\"number\">38</span>,</span><br><span class=\"line\">    width: <span class=\"number\">300</span>,</span><br><span class=\"line\">    height: <span class=\"number\">240</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'cyan'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  netImage: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">280</span>,</span><br><span class=\"line\">    height: <span class=\"number\">200</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'gray'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  local: &#123;</span><br><span class=\"line\">    marginTop: <span class=\"number\">30</span>,</span><br><span class=\"line\">    width: <span class=\"number\">300</span>,</span><br><span class=\"line\">    height: <span class=\"number\">200</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'cyan'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  localImage: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">180</span>,</span><br><span class=\"line\">    height: <span class=\"number\">180</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'gray'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇文章非常简单的介绍了 ReactNative 的几个组件，并给出了示例，更加详细的用法请参考官方文档。</p>\n"},{"title":"学习ReactNative基础（五）","date":"2017-04-22T04:42:00.000Z","_content":"\n## 前言\n\n本章继续学习 ReactNative 常用组件，ScrollView 和 ListView。有过移动开发经验的同学都知道 ScrollView 和 ListView 都是不可获取的组件，ListView 就是继承自 ScrollView。\n\n还有学习非常重要的 Navigator组件。\n\n## ScrollView\n\nScrollView 有很多回调方法，比如开始拖拽、结束拖拽、开始滑动、结束滑动等等，下面这个例子就是实现相关的回调，看看 ScrollView 的简单实现。\n\n例子1：ScrollView 的简单实现，实现监测拖拽、滑动的相关方法\n\n```JavaScript\nvar MyScrollView = React.createClass({\n  _onScrollBeginDrag: function() {\n    console.log('开始拖拽');\n  },\n  _onScrollEndDrag: function() {\n    console.log('结束拖拽');\n  },\n  _onMomentumScrollBegin: function() {\n    console.log('开始滑动');\n  },\n  _onMomentumScrollEnd: function() {\n    console.log('结束滑动');\n  },\n  _onRefresh: function() {\n    console.log('刷新');\n  },\n  render: function() {\n    return (\n      <View style={styles.container}>\n        <ScrollView\n          style={styles.scrollView}\n          showsVerticalScrollIndicator={true}\n          onScrollBeginDrag={this._onScrollBeginDrag}\n          onScrollEndDrag={this._onScrollEndDrag}\n          onMomentumScrollBegin={this._onMomentumScrollBegin}\n          onMomentumScrollEnd={this._onMomentumScrollEnd}\n          refreshControl={\n            <RefreshControl\n              refreshing={false}\n              tintColor='red'\n              title='正在刷新......'\n              onRefresh={this._onRefresh}\n            />\n          }>\n          <View style={styles.view_1}></View>\n          <View style={styles.view_2}></View>\n          <View style={styles.view_3}></View>\n        </ScrollView>\n      </View>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: 'cyan',\n  },\n  scrollView: {\n    marginTop: 25,\n    backgroundColor: '#CCCCCC',\n  },\n  view_1: {\n    margin: 15,\n    flex: 1,\n    height: 300,\n    backgroundColor: 'yellow',\n  },\n  view_2: {\n    margin: 15,\n    flex: 1,\n    height: 300,\n    backgroundColor: 'blue',\n  },\n  view_3: {\n    margin: 15,\n    flex: 1,\n    height: 300,\n    backgroundColor: 'green',\n  },\n});\n\nmodule.exports = MyScrollView;\n```\n\n下面这个例子是通过 ScrollView 实现电影列表，电影的数据是 RN 提供的[数据](// https://raw.githubusercontent.com/facebook/react-native/master/docs/MoviesExample.json)，因为还没有学习如何获取网络数据，我把数据拷贝下来，生成了个JSON文件，需要的时候本地加载。\n\n例子2：\n```JavaScript\n// 从文件中读取数据。执行JSON.Parse()方法，将JSON格式的字符串转换为JSON格式对象\nvar movieData = require('./data.json');\n\n// 获取所有movies数据\nvar movies = movieData.movies;\n\nvar MovieList = React.createClass({\n  render: function() {\n    // 创建电影列表组件，根据movie中元素的个数，创建对应的组件\n    // 遍历数组，每次创建一个movie对象\n    // 定义一个空数组，存储电影组件\n    var movieRows = [];\n    // 遍历数组\n    for (var i in movies) {\n      // 获取movie对象\n      var movie = movies[i];\n      // 创建组件，显示电影信息：\n      // 图像(movie.posters.thumbnail)\n      // 电影名称(movie.title)\n      // 上映时间(movie.year)\n      var row = (\n        <View key={i} style={styles.row}>\n          <Image\n            style={styles.thumbnail}\n            source={{uri:movie.posters.thumbnail}}/>\n          <View style={styles.rightContainer}>\n            <Text style={styles.title}>{movie.title}</Text>\n            <Text style={styles.year}>{movie.year}</Text>\n          </View>\n        </View>\n      );\n      movieRows.push(row);\n    }\n\n    return (\n      <View style={styles.container}>\n        <ScrollView style={styles.scrollView}>\n          {\n            // 数组(所有子组件)\n            movieRows\n          }\n        </ScrollView>\n      </View>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scrollView: {\n    flex: 1,\n    marginTop: 25,\n    backgroundColor: '#F5FCFF'\n  },\n  row: {\n    flexDirection: 'row',\n    padding: 5,\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF',\n  },\n  thumbnail: {\n    width: 53,\n    height: 81,\n    backgroundColor: 'gray',\n  },\n  rightContainer: {\n    marginLeft: 10,\n    flex: 1,\n  },\n  title: {\n    fontSize: 18,\n    marginTop: 3,\n    marginBottom: 3,\n    textAlign: 'center',\n  },\n  year: {\n    marginBottom: 3,\n    textAlign: 'center',\n  }\n});\n\nmodule.exports = MovieList;\n```\n\n## ListView\n\nListView 和 ScrollView 一样都可以滚动视图显示内容，但是它有一些高级特性：譬如给每段/组(section)数据添加一个带有粘性的头部（类似iPhone的通讯录，其首字母会在滑动过程中吸附在屏幕上方）；在列表头部和尾部增加单独的内容；在到达列表尾部的时候调用回调函数(onEndReached)，还有在视野内可见的数据变化时调用回调函数(onChangeVisibleRows)，以及一些性能方面的优化。\n\n特别是加载大数据时的性能优化，只需渲染显示在屏幕上的内容即可，超出屏幕的内容可以不渲染。\n[官方文档](https://facebook.github.io/react-native/docs/listview.html)\n\n例子1：简单的ListView列表\n\n```JavaScript\nvar contents = [\n  '312312',\n  'fsdfsad',\n  '312312444',\n  '4324231421',\n  '423142134213',\n];\n\nvar MyListView = React.createClass({\n  getInitialState: function() {\n    // 创建dataSource对象\n    var ds = new ListView.DataSource({\n      // 通过判断决定渲染哪些行组件，避免全部渲染，提高性能\n      rowHasChanged: (oldRow, newRow) => oldRow!==newRow\n    });\n\n    return {\n      // 设置dataSource时，不直接使用提供的原始数据，使用cloneWithRows对数据源进行复制\n      // 使用复制后的数据源实例化ListView。\n      // 优点：当原始数据源发生变化时，ListView组件的dataSource不会改变\n      dataSource: ds.cloneWithRows(contents)\n    };\n  },\n  // 渲染行组件，参数是每行要显示的数据对象\n  _renderRow: function(rowData:string) {\n    return (\n      <View style={styles.row}>\n        <Text style={styles.content}>{rowData}</Text>\n      </View>\n    );\n  },\n  render: function() {\n    return (\n      <ListView\n        style={styles.container}\n        dataSource={this.state.dataSource}\n        renderRow={this._renderRow}/>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    marginTop: 25,\n  },\n  row: {\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: 5,\n    height: 100,\n    borderBottomWidth: 1,\n    borderColor: '#CCCCCC',\n  },\n  content: {\n    flex: 1,\n    fontSize: 20,\n    color: 'blue',\n    lineHeight: 100,\n  }\n});\n\nmodule.exports = MyListView;\n```\n\n例子2：使用 ListView 改写 ScrollView 的电影列表\n\n```JavaScript\n// 从文件中读取数据\nvar movieData = require('./data.json');\n\n// 获取所有movies数据，属性movies是个数组\n// 原始数据\nvar movies = movieData.movies;\n\nvar MovieList = React.createClass({\n  getInitialState: function() {\n    var ds = new ListView.DataSource({\n      rowHasChanged: (oldRow, newRow) => oldRow!==newRow\n    });\n\n    return {\n      dataSource: ds.cloneWithRows(movies)\n    };\n  },\n  // 渲染行组件\n  _renderRow: function(movie) {\n    return (\n      <View style={styles.row}>\n        <Image\n          style={styles.thumbnail}\n          source={{uri:movie.posters.thumbnail}}/>\n        <View style={styles.rightContainer}>\n          <Text style={styles.title}>{movie.title}</Text>\n          <Text style={styles.year}>{movie.year}</Text>\n        </View>\n      </View>\n    );\n  },\n  // 渲染头部\n  _renderHeader: function() {\n    return (\n      <View style={styles.header}>\n        <Text style={styles.header_text}>Movies List</Text>\n        <View style={styles.separator}></View>\n      </View>\n    );\n  },\n  // 渲染分隔线\n  _renderSeparator: function(sectionID:number, rowID:number) {\n    return (\n      <View style={styles.separator} key={sectionID+rowID}></View>\n    );\n  },\n  render: function () {\n    return (\n      <ListView\n        style={styles.listView}\n        dataSource={this.state.dataSource}\n        renderRow={this._renderRow}\n        renderHeader={this._renderHeader}\n        renderSeparator={this._renderSeparator}\n        // 一开始渲染的行数\n        initialListSize={10}\n      />\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  // listView\n  listView: {\n    marginTop: 25,\n    flex: 1,\n    backgroundColor: '#F5FCFF',\n  },\n  row: {\n    flexDirection: 'row',\n    padding: 5,\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF'\n  },\n  thumbnail: {\n    width: 53,\n    height: 81,\n    backgroundColor: 'gray'\n  },\n  rightContainer: {\n    marginLeft: 10,\n    flex: 1,\n  },\n  title: {\n    fontSize: 10,\n    marginTop: 3,\n    marginBottom: 3,\n    textAlign: 'center'\n  },\n  year: {\n    marginBottom: 3,\n    textAlign: 'center',\n  },\n  // header\n  header: {\n    height: 44,\n    backgroundColor: '#F5FCFF',\n  },\n  header_text: {\n    flex: 1,\n    fontSize: 20,\n    fontWeight: 'bold',\n    textAlign: 'center',\n    lineHeight: 44,\n  },\n  // 分隔线\n  separator: {\n    height: 1,\n    backgroundColor: '#CCCCCC',\n  },\n});\n\nmodule.exports = MovieList;\n\n``` \n\n","source":"_posts/Learn-ReactNative-5.md","raw":"---\ntitle: 学习ReactNative基础（五）\ndate: 2017-04-22 12:42:00\ntags: RN\ncategory: ReactNative\n---\n\n## 前言\n\n本章继续学习 ReactNative 常用组件，ScrollView 和 ListView。有过移动开发经验的同学都知道 ScrollView 和 ListView 都是不可获取的组件，ListView 就是继承自 ScrollView。\n\n还有学习非常重要的 Navigator组件。\n\n## ScrollView\n\nScrollView 有很多回调方法，比如开始拖拽、结束拖拽、开始滑动、结束滑动等等，下面这个例子就是实现相关的回调，看看 ScrollView 的简单实现。\n\n例子1：ScrollView 的简单实现，实现监测拖拽、滑动的相关方法\n\n```JavaScript\nvar MyScrollView = React.createClass({\n  _onScrollBeginDrag: function() {\n    console.log('开始拖拽');\n  },\n  _onScrollEndDrag: function() {\n    console.log('结束拖拽');\n  },\n  _onMomentumScrollBegin: function() {\n    console.log('开始滑动');\n  },\n  _onMomentumScrollEnd: function() {\n    console.log('结束滑动');\n  },\n  _onRefresh: function() {\n    console.log('刷新');\n  },\n  render: function() {\n    return (\n      <View style={styles.container}>\n        <ScrollView\n          style={styles.scrollView}\n          showsVerticalScrollIndicator={true}\n          onScrollBeginDrag={this._onScrollBeginDrag}\n          onScrollEndDrag={this._onScrollEndDrag}\n          onMomentumScrollBegin={this._onMomentumScrollBegin}\n          onMomentumScrollEnd={this._onMomentumScrollEnd}\n          refreshControl={\n            <RefreshControl\n              refreshing={false}\n              tintColor='red'\n              title='正在刷新......'\n              onRefresh={this._onRefresh}\n            />\n          }>\n          <View style={styles.view_1}></View>\n          <View style={styles.view_2}></View>\n          <View style={styles.view_3}></View>\n        </ScrollView>\n      </View>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: 'cyan',\n  },\n  scrollView: {\n    marginTop: 25,\n    backgroundColor: '#CCCCCC',\n  },\n  view_1: {\n    margin: 15,\n    flex: 1,\n    height: 300,\n    backgroundColor: 'yellow',\n  },\n  view_2: {\n    margin: 15,\n    flex: 1,\n    height: 300,\n    backgroundColor: 'blue',\n  },\n  view_3: {\n    margin: 15,\n    flex: 1,\n    height: 300,\n    backgroundColor: 'green',\n  },\n});\n\nmodule.exports = MyScrollView;\n```\n\n下面这个例子是通过 ScrollView 实现电影列表，电影的数据是 RN 提供的[数据](// https://raw.githubusercontent.com/facebook/react-native/master/docs/MoviesExample.json)，因为还没有学习如何获取网络数据，我把数据拷贝下来，生成了个JSON文件，需要的时候本地加载。\n\n例子2：\n```JavaScript\n// 从文件中读取数据。执行JSON.Parse()方法，将JSON格式的字符串转换为JSON格式对象\nvar movieData = require('./data.json');\n\n// 获取所有movies数据\nvar movies = movieData.movies;\n\nvar MovieList = React.createClass({\n  render: function() {\n    // 创建电影列表组件，根据movie中元素的个数，创建对应的组件\n    // 遍历数组，每次创建一个movie对象\n    // 定义一个空数组，存储电影组件\n    var movieRows = [];\n    // 遍历数组\n    for (var i in movies) {\n      // 获取movie对象\n      var movie = movies[i];\n      // 创建组件，显示电影信息：\n      // 图像(movie.posters.thumbnail)\n      // 电影名称(movie.title)\n      // 上映时间(movie.year)\n      var row = (\n        <View key={i} style={styles.row}>\n          <Image\n            style={styles.thumbnail}\n            source={{uri:movie.posters.thumbnail}}/>\n          <View style={styles.rightContainer}>\n            <Text style={styles.title}>{movie.title}</Text>\n            <Text style={styles.year}>{movie.year}</Text>\n          </View>\n        </View>\n      );\n      movieRows.push(row);\n    }\n\n    return (\n      <View style={styles.container}>\n        <ScrollView style={styles.scrollView}>\n          {\n            // 数组(所有子组件)\n            movieRows\n          }\n        </ScrollView>\n      </View>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scrollView: {\n    flex: 1,\n    marginTop: 25,\n    backgroundColor: '#F5FCFF'\n  },\n  row: {\n    flexDirection: 'row',\n    padding: 5,\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF',\n  },\n  thumbnail: {\n    width: 53,\n    height: 81,\n    backgroundColor: 'gray',\n  },\n  rightContainer: {\n    marginLeft: 10,\n    flex: 1,\n  },\n  title: {\n    fontSize: 18,\n    marginTop: 3,\n    marginBottom: 3,\n    textAlign: 'center',\n  },\n  year: {\n    marginBottom: 3,\n    textAlign: 'center',\n  }\n});\n\nmodule.exports = MovieList;\n```\n\n## ListView\n\nListView 和 ScrollView 一样都可以滚动视图显示内容，但是它有一些高级特性：譬如给每段/组(section)数据添加一个带有粘性的头部（类似iPhone的通讯录，其首字母会在滑动过程中吸附在屏幕上方）；在列表头部和尾部增加单独的内容；在到达列表尾部的时候调用回调函数(onEndReached)，还有在视野内可见的数据变化时调用回调函数(onChangeVisibleRows)，以及一些性能方面的优化。\n\n特别是加载大数据时的性能优化，只需渲染显示在屏幕上的内容即可，超出屏幕的内容可以不渲染。\n[官方文档](https://facebook.github.io/react-native/docs/listview.html)\n\n例子1：简单的ListView列表\n\n```JavaScript\nvar contents = [\n  '312312',\n  'fsdfsad',\n  '312312444',\n  '4324231421',\n  '423142134213',\n];\n\nvar MyListView = React.createClass({\n  getInitialState: function() {\n    // 创建dataSource对象\n    var ds = new ListView.DataSource({\n      // 通过判断决定渲染哪些行组件，避免全部渲染，提高性能\n      rowHasChanged: (oldRow, newRow) => oldRow!==newRow\n    });\n\n    return {\n      // 设置dataSource时，不直接使用提供的原始数据，使用cloneWithRows对数据源进行复制\n      // 使用复制后的数据源实例化ListView。\n      // 优点：当原始数据源发生变化时，ListView组件的dataSource不会改变\n      dataSource: ds.cloneWithRows(contents)\n    };\n  },\n  // 渲染行组件，参数是每行要显示的数据对象\n  _renderRow: function(rowData:string) {\n    return (\n      <View style={styles.row}>\n        <Text style={styles.content}>{rowData}</Text>\n      </View>\n    );\n  },\n  render: function() {\n    return (\n      <ListView\n        style={styles.container}\n        dataSource={this.state.dataSource}\n        renderRow={this._renderRow}/>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    marginTop: 25,\n  },\n  row: {\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: 5,\n    height: 100,\n    borderBottomWidth: 1,\n    borderColor: '#CCCCCC',\n  },\n  content: {\n    flex: 1,\n    fontSize: 20,\n    color: 'blue',\n    lineHeight: 100,\n  }\n});\n\nmodule.exports = MyListView;\n```\n\n例子2：使用 ListView 改写 ScrollView 的电影列表\n\n```JavaScript\n// 从文件中读取数据\nvar movieData = require('./data.json');\n\n// 获取所有movies数据，属性movies是个数组\n// 原始数据\nvar movies = movieData.movies;\n\nvar MovieList = React.createClass({\n  getInitialState: function() {\n    var ds = new ListView.DataSource({\n      rowHasChanged: (oldRow, newRow) => oldRow!==newRow\n    });\n\n    return {\n      dataSource: ds.cloneWithRows(movies)\n    };\n  },\n  // 渲染行组件\n  _renderRow: function(movie) {\n    return (\n      <View style={styles.row}>\n        <Image\n          style={styles.thumbnail}\n          source={{uri:movie.posters.thumbnail}}/>\n        <View style={styles.rightContainer}>\n          <Text style={styles.title}>{movie.title}</Text>\n          <Text style={styles.year}>{movie.year}</Text>\n        </View>\n      </View>\n    );\n  },\n  // 渲染头部\n  _renderHeader: function() {\n    return (\n      <View style={styles.header}>\n        <Text style={styles.header_text}>Movies List</Text>\n        <View style={styles.separator}></View>\n      </View>\n    );\n  },\n  // 渲染分隔线\n  _renderSeparator: function(sectionID:number, rowID:number) {\n    return (\n      <View style={styles.separator} key={sectionID+rowID}></View>\n    );\n  },\n  render: function () {\n    return (\n      <ListView\n        style={styles.listView}\n        dataSource={this.state.dataSource}\n        renderRow={this._renderRow}\n        renderHeader={this._renderHeader}\n        renderSeparator={this._renderSeparator}\n        // 一开始渲染的行数\n        initialListSize={10}\n      />\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  // listView\n  listView: {\n    marginTop: 25,\n    flex: 1,\n    backgroundColor: '#F5FCFF',\n  },\n  row: {\n    flexDirection: 'row',\n    padding: 5,\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF'\n  },\n  thumbnail: {\n    width: 53,\n    height: 81,\n    backgroundColor: 'gray'\n  },\n  rightContainer: {\n    marginLeft: 10,\n    flex: 1,\n  },\n  title: {\n    fontSize: 10,\n    marginTop: 3,\n    marginBottom: 3,\n    textAlign: 'center'\n  },\n  year: {\n    marginBottom: 3,\n    textAlign: 'center',\n  },\n  // header\n  header: {\n    height: 44,\n    backgroundColor: '#F5FCFF',\n  },\n  header_text: {\n    flex: 1,\n    fontSize: 20,\n    fontWeight: 'bold',\n    textAlign: 'center',\n    lineHeight: 44,\n  },\n  // 分隔线\n  separator: {\n    height: 1,\n    backgroundColor: '#CCCCCC',\n  },\n});\n\nmodule.exports = MovieList;\n\n``` \n\n","slug":"Learn-ReactNative-5","published":1,"updated":"2017-05-01T06:18:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7o1004f8jpbwchvsjq7","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本章继续学习 ReactNative 常用组件，ScrollView 和 ListView。有过移动开发经验的同学都知道 ScrollView 和 ListView 都是不可获取的组件，ListView 就是继承自 ScrollView。</p>\n<p>还有学习非常重要的 Navigator组件。</p>\n<h2 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h2><p>ScrollView 有很多回调方法，比如开始拖拽、结束拖拽、开始滑动、结束滑动等等，下面这个例子就是实现相关的回调，看看 ScrollView 的简单实现。</p>\n<p>例子1：ScrollView 的简单实现，实现监测拖拽、滑动的相关方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyScrollView = React.createClass(&#123;</span><br><span class=\"line\">  _onScrollBeginDrag: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始拖拽'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  _onScrollEndDrag: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'结束拖拽'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  _onMomentumScrollBegin: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始滑动'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  _onMomentumScrollEnd: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'结束滑动'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  _onRefresh: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'刷新'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;ScrollView</span><br><span class=\"line\">          style=&#123;styles.scrollView&#125;</span><br><span class=\"line\">          showsVerticalScrollIndicator=&#123;<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">          onScrollBeginDrag=&#123;<span class=\"keyword\">this</span>._onScrollBeginDrag&#125;</span><br><span class=\"line\">          onScrollEndDrag=&#123;<span class=\"keyword\">this</span>._onScrollEndDrag&#125;</span><br><span class=\"line\">          onMomentumScrollBegin=&#123;<span class=\"keyword\">this</span>._onMomentumScrollBegin&#125;</span><br><span class=\"line\">          onMomentumScrollEnd=&#123;<span class=\"keyword\">this</span>._onMomentumScrollEnd&#125;</span><br><span class=\"line\">          refreshControl=&#123;</span><br><span class=\"line\">            &lt;RefreshControl</span><br><span class=\"line\">              refreshing=&#123;<span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">              tintColor=<span class=\"string\">'red'</span></span><br><span class=\"line\">              title=<span class=\"string\">'正在刷新......'</span></span><br><span class=\"line\">              onRefresh=&#123;<span class=\"keyword\">this</span>._onRefresh&#125;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">          &#125;&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.view_1&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.view_2&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.view_3&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ScrollView&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'cyan'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  scrollView: &#123;</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#CCCCCC'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  view_1: &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">15</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    height: <span class=\"number\">300</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'yellow'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  view_2: &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">15</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    height: <span class=\"number\">300</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'blue'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  view_3: &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">15</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    height: <span class=\"number\">300</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'green'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = MyScrollView;</span><br></pre></td></tr></table></figure>\n<p>下面这个例子是通过 ScrollView 实现电影列表，电影的数据是 RN 提供的<a href=\"// https://raw.githubusercontent.com/facebook/react-native/master/docs/MoviesExample.json\">数据</a>，因为还没有学习如何获取网络数据，我把数据拷贝下来，生成了个JSON文件，需要的时候本地加载。</p>\n<p>例子2：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从文件中读取数据。执行JSON.Parse()方法，将JSON格式的字符串转换为JSON格式对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> movieData = <span class=\"built_in\">require</span>(<span class=\"string\">'./data.json'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取所有movies数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> movies = movieData.movies;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> MovieList = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建电影列表组件，根据movie中元素的个数，创建对应的组件</span></span><br><span class=\"line\">    <span class=\"comment\">// 遍历数组，每次创建一个movie对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 定义一个空数组，存储电影组件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> movieRows = [];</span><br><span class=\"line\">    <span class=\"comment\">// 遍历数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> movies) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取movie对象</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> movie = movies[i];</span><br><span class=\"line\">      <span class=\"comment\">// 创建组件，显示电影信息：</span></span><br><span class=\"line\">      <span class=\"comment\">// 图像(movie.posters.thumbnail)</span></span><br><span class=\"line\">      <span class=\"comment\">// 电影名称(movie.title)</span></span><br><span class=\"line\">      <span class=\"comment\">// 上映时间(movie.year)</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> row = (</span><br><span class=\"line\">        &lt;View key=&#123;i&#125; style=&#123;styles.row&#125;&gt;</span><br><span class=\"line\">          &lt;Image</span><br><span class=\"line\">            style=&#123;styles.thumbnail&#125;</span><br><span class=\"line\">            source=&#123;&#123;<span class=\"attr\">uri</span>:movie.posters.thumbnail&#125;&#125;/&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.rightContainer&#125;&gt;</span><br><span class=\"line\">            &lt;Text style=&#123;styles.title&#125;&gt;&#123;movie.title&#125;&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;Text style=&#123;styles.year&#125;&gt;&#123;movie.year&#125;&lt;/</span>Text&gt;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>View&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">      movieRows.push(row);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;ScrollView style=&#123;styles.scrollView&#125;&gt;</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 数组(所有子组件)</span></span><br><span class=\"line\">            movieRows</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ScrollView&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  scrollView: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  row: &#123;</span><br><span class=\"line\">    flexDirection: <span class=\"string\">'row'</span>,</span><br><span class=\"line\">    padding: <span class=\"number\">5</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  thumbnail: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">53</span>,</span><br><span class=\"line\">    height: <span class=\"number\">81</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'gray'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  rightContainer: &#123;</span><br><span class=\"line\">    marginLeft: <span class=\"number\">10</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  title: &#123;</span><br><span class=\"line\">    fontSize: <span class=\"number\">18</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">3</span>,</span><br><span class=\"line\">    marginBottom: <span class=\"number\">3</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  year: &#123;</span><br><span class=\"line\">    marginBottom: <span class=\"number\">3</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = MovieList;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ListView\"><a href=\"#ListView\" class=\"headerlink\" title=\"ListView\"></a>ListView</h2><p>ListView 和 ScrollView 一样都可以滚动视图显示内容，但是它有一些高级特性：譬如给每段/组(section)数据添加一个带有粘性的头部（类似iPhone的通讯录，其首字母会在滑动过程中吸附在屏幕上方）；在列表头部和尾部增加单独的内容；在到达列表尾部的时候调用回调函数(onEndReached)，还有在视野内可见的数据变化时调用回调函数(onChangeVisibleRows)，以及一些性能方面的优化。</p>\n<p>特别是加载大数据时的性能优化，只需渲染显示在屏幕上的内容即可，超出屏幕的内容可以不渲染。<br><a href=\"https://facebook.github.io/react-native/docs/listview.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p>例子1：简单的ListView列表</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> contents = [</span><br><span class=\"line\">  <span class=\"string\">'312312'</span>,</span><br><span class=\"line\">  <span class=\"string\">'fsdfsad'</span>,</span><br><span class=\"line\">  <span class=\"string\">'312312444'</span>,</span><br><span class=\"line\">  <span class=\"string\">'4324231421'</span>,</span><br><span class=\"line\">  <span class=\"string\">'423142134213'</span>,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> MyListView = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建dataSource对象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ds = <span class=\"keyword\">new</span> ListView.DataSource(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 通过判断决定渲染哪些行组件，避免全部渲染，提高性能</span></span><br><span class=\"line\">      rowHasChanged: <span class=\"function\">(<span class=\"params\">oldRow, newRow</span>) =&gt;</span> oldRow!==newRow</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置dataSource时，不直接使用提供的原始数据，使用cloneWithRows对数据源进行复制</span></span><br><span class=\"line\">      <span class=\"comment\">// 使用复制后的数据源实例化ListView。</span></span><br><span class=\"line\">      <span class=\"comment\">// 优点：当原始数据源发生变化时，ListView组件的dataSource不会改变</span></span><br><span class=\"line\">      dataSource: ds.cloneWithRows(contents)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 渲染行组件，参数是每行要显示的数据对象</span></span><br><span class=\"line\">  _renderRow: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">rowData:string</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.row&#125;&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.content&#125;&gt;&#123;rowData&#125;&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ListView</span><br><span class=\"line\">        style=&#123;styles.container&#125;</span><br><span class=\"line\">        dataSource=&#123;<span class=\"keyword\">this</span>.state.dataSource&#125;</span><br><span class=\"line\">        renderRow=&#123;<span class=\"keyword\">this</span>._renderRow&#125;/&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  row: &#123;</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    padding: <span class=\"number\">5</span>,</span><br><span class=\"line\">    height: <span class=\"number\">100</span>,</span><br><span class=\"line\">    borderBottomWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'#CCCCCC'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  content: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    fontSize: <span class=\"number\">20</span>,</span><br><span class=\"line\">    color: <span class=\"string\">'blue'</span>,</span><br><span class=\"line\">    lineHeight: <span class=\"number\">100</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = MyListView;</span><br></pre></td></tr></table></figure>\n<p>例子2：使用 ListView 改写 ScrollView 的电影列表</p>\n<pre><code class=\"JavaScript\"><span class=\"comment\">// 从文件中读取数据</span>\n<span class=\"keyword\">var</span> movieData = <span class=\"built_in\">require</span>(<span class=\"string\">'./data.json'</span>);\n\n<span class=\"comment\">// 获取所有movies数据，属性movies是个数组</span>\n<span class=\"comment\">// 原始数据</span>\n<span class=\"keyword\">var</span> movies = movieData.movies;\n\n<span class=\"keyword\">var</span> MovieList = React.createClass({\n  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">var</span> ds = <span class=\"keyword\">new</span> ListView.DataSource({\n      rowHasChanged: <span class=\"function\">(<span class=\"params\">oldRow, newRow</span>) =&gt;</span> oldRow!==newRow\n    });\n\n    <span class=\"keyword\">return</span> {\n      dataSource: ds.cloneWithRows(movies)\n    };\n  },\n  <span class=\"comment\">// 渲染行组件</span>\n  _renderRow: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">movie</span>) </span>{\n    <span class=\"keyword\">return</span> (\n      &lt;View style={styles.row}&gt;\n        &lt;Image\n          style={styles.thumbnail}\n          source={{uri:movie.posters.thumbnail}}/&gt;\n        &lt;View style={styles.rightContainer}&gt;\n          &lt;Text style={styles.title}&gt;{movie.title}&lt;/Text&gt;\n          &lt;Text style={styles.year}&gt;{movie.year}&lt;/Text&gt;\n        &lt;/View&gt;\n      &lt;/View&gt;\n    );\n  },\n  <span class=\"comment\">// 渲染头部</span>\n  _renderHeader: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> (\n      &lt;View style={styles.header}&gt;\n        &lt;Text style={styles.header_text}&gt;Movies List&lt;<span class=\"regexp\">/Text&gt;</span>\n<span class=\"regexp\">        &lt;View style={styles.separator}&gt;&lt;/</span>View&gt;\n      &lt;<span class=\"regexp\">/View&gt;</span>\n<span class=\"regexp\">    );</span>\n<span class=\"regexp\">  },</span>\n<span class=\"regexp\">  /</span><span class=\"regexp\">/ 渲染分隔线</span>\n<span class=\"regexp\">  _renderSeparator: function(sectionID:number, rowID:number) {</span>\n<span class=\"regexp\">    return (</span>\n<span class=\"regexp\">      &lt;View style={styles.separator} key={sectionID+rowID}&gt;&lt;/</span>View&gt;\n    );\n  },\n  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> (\n      &lt;ListView\n        style={styles.listView}\n        dataSource={<span class=\"keyword\">this</span>.state.dataSource}\n        renderRow={<span class=\"keyword\">this</span>._renderRow}\n        renderHeader={<span class=\"keyword\">this</span>._renderHeader}\n        renderSeparator={<span class=\"keyword\">this</span>._renderSeparator}\n        <span class=\"comment\">// 一开始渲染的行数</span>\n        initialListSize={<span class=\"number\">10</span>}\n      /&gt;\n    );\n  }\n});\n\n<span class=\"keyword\">var</span> styles = StyleSheet.create({\n  <span class=\"comment\">// listView</span>\n  listView: {\n    marginTop: <span class=\"number\">25</span>,\n    flex: <span class=\"number\">1</span>,\n    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,\n  },\n  row: {\n    flexDirection: <span class=\"string\">'row'</span>,\n    padding: <span class=\"number\">5</span>,\n    alignItems: <span class=\"string\">'center'</span>,\n    backgroundColor: <span class=\"string\">'#F5FCFF'</span>\n  },\n  thumbnail: {\n    width: <span class=\"number\">53</span>,\n    height: <span class=\"number\">81</span>,\n    backgroundColor: <span class=\"string\">'gray'</span>\n  },\n  rightContainer: {\n    marginLeft: <span class=\"number\">10</span>,\n    flex: <span class=\"number\">1</span>,\n  },\n  title: {\n    fontSize: <span class=\"number\">10</span>,\n    marginTop: <span class=\"number\">3</span>,\n    marginBottom: <span class=\"number\">3</span>,\n    textAlign: <span class=\"string\">'center'</span>\n  },\n  year: {\n    marginBottom: <span class=\"number\">3</span>,\n    textAlign: <span class=\"string\">'center'</span>,\n  },\n  <span class=\"comment\">// header</span>\n  header: {\n    height: <span class=\"number\">44</span>,\n    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,\n  },\n  header_text: {\n    flex: <span class=\"number\">1</span>,\n    fontSize: <span class=\"number\">20</span>,\n    fontWeight: <span class=\"string\">'bold'</span>,\n    textAlign: <span class=\"string\">'center'</span>,\n    lineHeight: <span class=\"number\">44</span>,\n  },\n  <span class=\"comment\">// 分隔线</span>\n  separator: {\n    height: <span class=\"number\">1</span>,\n    backgroundColor: <span class=\"string\">'#CCCCCC'</span>,\n  },\n});\n\n<span class=\"built_in\">module</span>.exports = MovieList;\n\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本章继续学习 ReactNative 常用组件，ScrollView 和 ListView。有过移动开发经验的同学都知道 ScrollView 和 ListView 都是不可获取的组件，ListView 就是继承自 ScrollView。</p>\n<p>还有学习非常重要的 Navigator组件。</p>\n<h2 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h2><p>ScrollView 有很多回调方法，比如开始拖拽、结束拖拽、开始滑动、结束滑动等等，下面这个例子就是实现相关的回调，看看 ScrollView 的简单实现。</p>\n<p>例子1：ScrollView 的简单实现，实现监测拖拽、滑动的相关方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyScrollView = React.createClass(&#123;</span><br><span class=\"line\">  _onScrollBeginDrag: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始拖拽'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  _onScrollEndDrag: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'结束拖拽'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  _onMomentumScrollBegin: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始滑动'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  _onMomentumScrollEnd: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'结束滑动'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  _onRefresh: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'刷新'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;ScrollView</span><br><span class=\"line\">          style=&#123;styles.scrollView&#125;</span><br><span class=\"line\">          showsVerticalScrollIndicator=&#123;<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">          onScrollBeginDrag=&#123;<span class=\"keyword\">this</span>._onScrollBeginDrag&#125;</span><br><span class=\"line\">          onScrollEndDrag=&#123;<span class=\"keyword\">this</span>._onScrollEndDrag&#125;</span><br><span class=\"line\">          onMomentumScrollBegin=&#123;<span class=\"keyword\">this</span>._onMomentumScrollBegin&#125;</span><br><span class=\"line\">          onMomentumScrollEnd=&#123;<span class=\"keyword\">this</span>._onMomentumScrollEnd&#125;</span><br><span class=\"line\">          refreshControl=&#123;</span><br><span class=\"line\">            &lt;RefreshControl</span><br><span class=\"line\">              refreshing=&#123;<span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">              tintColor=<span class=\"string\">'red'</span></span><br><span class=\"line\">              title=<span class=\"string\">'正在刷新......'</span></span><br><span class=\"line\">              onRefresh=&#123;<span class=\"keyword\">this</span>._onRefresh&#125;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">          &#125;&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.view_1&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.view_2&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.view_3&#125;&gt;&lt;/View&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ScrollView&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'cyan'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  scrollView: &#123;</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#CCCCCC'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  view_1: &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">15</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    height: <span class=\"number\">300</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'yellow'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  view_2: &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">15</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    height: <span class=\"number\">300</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'blue'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  view_3: &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">15</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    height: <span class=\"number\">300</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'green'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = MyScrollView;</span><br></pre></td></tr></table></figure>\n<p>下面这个例子是通过 ScrollView 实现电影列表，电影的数据是 RN 提供的<a href=\"// https://raw.githubusercontent.com/facebook/react-native/master/docs/MoviesExample.json\">数据</a>，因为还没有学习如何获取网络数据，我把数据拷贝下来，生成了个JSON文件，需要的时候本地加载。</p>\n<p>例子2：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从文件中读取数据。执行JSON.Parse()方法，将JSON格式的字符串转换为JSON格式对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> movieData = <span class=\"built_in\">require</span>(<span class=\"string\">'./data.json'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取所有movies数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> movies = movieData.movies;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> MovieList = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建电影列表组件，根据movie中元素的个数，创建对应的组件</span></span><br><span class=\"line\">    <span class=\"comment\">// 遍历数组，每次创建一个movie对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 定义一个空数组，存储电影组件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> movieRows = [];</span><br><span class=\"line\">    <span class=\"comment\">// 遍历数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> movies) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取movie对象</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> movie = movies[i];</span><br><span class=\"line\">      <span class=\"comment\">// 创建组件，显示电影信息：</span></span><br><span class=\"line\">      <span class=\"comment\">// 图像(movie.posters.thumbnail)</span></span><br><span class=\"line\">      <span class=\"comment\">// 电影名称(movie.title)</span></span><br><span class=\"line\">      <span class=\"comment\">// 上映时间(movie.year)</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> row = (</span><br><span class=\"line\">        &lt;View key=&#123;i&#125; style=&#123;styles.row&#125;&gt;</span><br><span class=\"line\">          &lt;Image</span><br><span class=\"line\">            style=&#123;styles.thumbnail&#125;</span><br><span class=\"line\">            source=&#123;&#123;<span class=\"attr\">uri</span>:movie.posters.thumbnail&#125;&#125;/&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.rightContainer&#125;&gt;</span><br><span class=\"line\">            &lt;Text style=&#123;styles.title&#125;&gt;&#123;movie.title&#125;&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;Text style=&#123;styles.year&#125;&gt;&#123;movie.year&#125;&lt;/</span>Text&gt;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>View&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">      movieRows.push(row);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;ScrollView style=&#123;styles.scrollView&#125;&gt;</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 数组(所有子组件)</span></span><br><span class=\"line\">            movieRows</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ScrollView&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  scrollView: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  row: &#123;</span><br><span class=\"line\">    flexDirection: <span class=\"string\">'row'</span>,</span><br><span class=\"line\">    padding: <span class=\"number\">5</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  thumbnail: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">53</span>,</span><br><span class=\"line\">    height: <span class=\"number\">81</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'gray'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  rightContainer: &#123;</span><br><span class=\"line\">    marginLeft: <span class=\"number\">10</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  title: &#123;</span><br><span class=\"line\">    fontSize: <span class=\"number\">18</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">3</span>,</span><br><span class=\"line\">    marginBottom: <span class=\"number\">3</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  year: &#123;</span><br><span class=\"line\">    marginBottom: <span class=\"number\">3</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = MovieList;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ListView\"><a href=\"#ListView\" class=\"headerlink\" title=\"ListView\"></a>ListView</h2><p>ListView 和 ScrollView 一样都可以滚动视图显示内容，但是它有一些高级特性：譬如给每段/组(section)数据添加一个带有粘性的头部（类似iPhone的通讯录，其首字母会在滑动过程中吸附在屏幕上方）；在列表头部和尾部增加单独的内容；在到达列表尾部的时候调用回调函数(onEndReached)，还有在视野内可见的数据变化时调用回调函数(onChangeVisibleRows)，以及一些性能方面的优化。</p>\n<p>特别是加载大数据时的性能优化，只需渲染显示在屏幕上的内容即可，超出屏幕的内容可以不渲染。<br><a href=\"https://facebook.github.io/react-native/docs/listview.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p>例子1：简单的ListView列表</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> contents = [</span><br><span class=\"line\">  <span class=\"string\">'312312'</span>,</span><br><span class=\"line\">  <span class=\"string\">'fsdfsad'</span>,</span><br><span class=\"line\">  <span class=\"string\">'312312444'</span>,</span><br><span class=\"line\">  <span class=\"string\">'4324231421'</span>,</span><br><span class=\"line\">  <span class=\"string\">'423142134213'</span>,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> MyListView = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建dataSource对象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ds = <span class=\"keyword\">new</span> ListView.DataSource(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 通过判断决定渲染哪些行组件，避免全部渲染，提高性能</span></span><br><span class=\"line\">      rowHasChanged: <span class=\"function\">(<span class=\"params\">oldRow, newRow</span>) =&gt;</span> oldRow!==newRow</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置dataSource时，不直接使用提供的原始数据，使用cloneWithRows对数据源进行复制</span></span><br><span class=\"line\">      <span class=\"comment\">// 使用复制后的数据源实例化ListView。</span></span><br><span class=\"line\">      <span class=\"comment\">// 优点：当原始数据源发生变化时，ListView组件的dataSource不会改变</span></span><br><span class=\"line\">      dataSource: ds.cloneWithRows(contents)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 渲染行组件，参数是每行要显示的数据对象</span></span><br><span class=\"line\">  _renderRow: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">rowData:string</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.row&#125;&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.content&#125;&gt;&#123;rowData&#125;&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ListView</span><br><span class=\"line\">        style=&#123;styles.container&#125;</span><br><span class=\"line\">        dataSource=&#123;<span class=\"keyword\">this</span>.state.dataSource&#125;</span><br><span class=\"line\">        renderRow=&#123;<span class=\"keyword\">this</span>._renderRow&#125;/&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  container: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  row: &#123;</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    padding: <span class=\"number\">5</span>,</span><br><span class=\"line\">    height: <span class=\"number\">100</span>,</span><br><span class=\"line\">    borderBottomWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    borderColor: <span class=\"string\">'#CCCCCC'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  content: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    fontSize: <span class=\"number\">20</span>,</span><br><span class=\"line\">    color: <span class=\"string\">'blue'</span>,</span><br><span class=\"line\">    lineHeight: <span class=\"number\">100</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = MyListView;</span><br></pre></td></tr></table></figure>\n<p>例子2：使用 ListView 改写 ScrollView 的电影列表</p>\n<pre><code class=\"JavaScript\"><span class=\"comment\">// 从文件中读取数据</span>\n<span class=\"keyword\">var</span> movieData = <span class=\"built_in\">require</span>(<span class=\"string\">'./data.json'</span>);\n\n<span class=\"comment\">// 获取所有movies数据，属性movies是个数组</span>\n<span class=\"comment\">// 原始数据</span>\n<span class=\"keyword\">var</span> movies = movieData.movies;\n\n<span class=\"keyword\">var</span> MovieList = React.createClass({\n  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">var</span> ds = <span class=\"keyword\">new</span> ListView.DataSource({\n      rowHasChanged: <span class=\"function\">(<span class=\"params\">oldRow, newRow</span>) =&gt;</span> oldRow!==newRow\n    });\n\n    <span class=\"keyword\">return</span> {\n      dataSource: ds.cloneWithRows(movies)\n    };\n  },\n  <span class=\"comment\">// 渲染行组件</span>\n  _renderRow: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">movie</span>) </span>{\n    <span class=\"keyword\">return</span> (\n      &lt;View style={styles.row}&gt;\n        &lt;Image\n          style={styles.thumbnail}\n          source={{uri:movie.posters.thumbnail}}/&gt;\n        &lt;View style={styles.rightContainer}&gt;\n          &lt;Text style={styles.title}&gt;{movie.title}&lt;/Text&gt;\n          &lt;Text style={styles.year}&gt;{movie.year}&lt;/Text&gt;\n        &lt;/View&gt;\n      &lt;/View&gt;\n    );\n  },\n  <span class=\"comment\">// 渲染头部</span>\n  _renderHeader: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> (\n      &lt;View style={styles.header}&gt;\n        &lt;Text style={styles.header_text}&gt;Movies List&lt;<span class=\"regexp\">/Text&gt;</span>\n<span class=\"regexp\">        &lt;View style={styles.separator}&gt;&lt;/</span>View&gt;\n      &lt;<span class=\"regexp\">/View&gt;</span>\n<span class=\"regexp\">    );</span>\n<span class=\"regexp\">  },</span>\n<span class=\"regexp\">  /</span><span class=\"regexp\">/ 渲染分隔线</span>\n<span class=\"regexp\">  _renderSeparator: function(sectionID:number, rowID:number) {</span>\n<span class=\"regexp\">    return (</span>\n<span class=\"regexp\">      &lt;View style={styles.separator} key={sectionID+rowID}&gt;&lt;/</span>View&gt;\n    );\n  },\n  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> (\n      &lt;ListView\n        style={styles.listView}\n        dataSource={<span class=\"keyword\">this</span>.state.dataSource}\n        renderRow={<span class=\"keyword\">this</span>._renderRow}\n        renderHeader={<span class=\"keyword\">this</span>._renderHeader}\n        renderSeparator={<span class=\"keyword\">this</span>._renderSeparator}\n        <span class=\"comment\">// 一开始渲染的行数</span>\n        initialListSize={<span class=\"number\">10</span>}\n      /&gt;\n    );\n  }\n});\n\n<span class=\"keyword\">var</span> styles = StyleSheet.create({\n  <span class=\"comment\">// listView</span>\n  listView: {\n    marginTop: <span class=\"number\">25</span>,\n    flex: <span class=\"number\">1</span>,\n    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,\n  },\n  row: {\n    flexDirection: <span class=\"string\">'row'</span>,\n    padding: <span class=\"number\">5</span>,\n    alignItems: <span class=\"string\">'center'</span>,\n    backgroundColor: <span class=\"string\">'#F5FCFF'</span>\n  },\n  thumbnail: {\n    width: <span class=\"number\">53</span>,\n    height: <span class=\"number\">81</span>,\n    backgroundColor: <span class=\"string\">'gray'</span>\n  },\n  rightContainer: {\n    marginLeft: <span class=\"number\">10</span>,\n    flex: <span class=\"number\">1</span>,\n  },\n  title: {\n    fontSize: <span class=\"number\">10</span>,\n    marginTop: <span class=\"number\">3</span>,\n    marginBottom: <span class=\"number\">3</span>,\n    textAlign: <span class=\"string\">'center'</span>\n  },\n  year: {\n    marginBottom: <span class=\"number\">3</span>,\n    textAlign: <span class=\"string\">'center'</span>,\n  },\n  <span class=\"comment\">// header</span>\n  header: {\n    height: <span class=\"number\">44</span>,\n    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,\n  },\n  header_text: {\n    flex: <span class=\"number\">1</span>,\n    fontSize: <span class=\"number\">20</span>,\n    fontWeight: <span class=\"string\">'bold'</span>,\n    textAlign: <span class=\"string\">'center'</span>,\n    lineHeight: <span class=\"number\">44</span>,\n  },\n  <span class=\"comment\">// 分隔线</span>\n  separator: {\n    height: <span class=\"number\">1</span>,\n    backgroundColor: <span class=\"string\">'#CCCCCC'</span>,\n  },\n});\n\n<span class=\"built_in\">module</span>.exports = MovieList;\n\n</code></pre>\n"},{"title":"NSTimer（一）","date":"2016-11-19T04:42:49.000Z","_content":"\n## 前言\nNSTimer iOS中使用的计时器，定时去完成任务的东西。但是其中的坑点相当多：\n\n1. NSTimer 会 retain 你添加调用方法的对象，比如 self（最近被它坑到了）\n2. NSTimer 要添加到 runloop 才会执行\n3. NSTimer 并不是精确的按照指定的时间触发\n4. NSTimer 添加到 runloop 后，也不一定按照你想象的那样执行\n\n## 什么是NSTimer\n\nNSTimer 就是一个能在从现在开始的后面的某一个时刻或者周期性的执行我们指定的方法的对象。\n\n## NSTimer 与 Target\n\n从上面的解释来看，NSTimer 会在未来某个时刻执行一次或者多次我们指定的方法，那么它是怎么知道该方法那个时候是否还是有效的，如果该方法不存在了，消息分发会引发异常的。\n\n解决方法很简单，`就是把要指定给timer的“selector”的“target” retain 一份就搞定了，实际上系统也是这样做的`，不管是重复性的timer还是一次性的timer都会对它的方法的接收者进行retain，这两种timer的区别在于“**一次性的timer在完成调用以后会自动将自己invalidate，而重复的timer则将永生，直到你显示的invalidate它为止**”。\n\n举个例子：\n\n**JHTestTimerObject.h**\n```objc\n@interface JHTestTimerObject : NSObject\n/*\n * 公开方法，timer响应函数，用来做测试\n */\n- (void)timerAction:(NSTimer*)timer;\n\n@end\n```\n\n**JHTestTimerObject.m**\n```objc\n@implementation JHTestTimerObject\n- (id)init {\n    self = [super init];\n    if (self) {\n        NSLog(@\"instance %@ has been created!\", self);\n    }\n    \n    return self;\n}\n\n- (void)dealloc {\n    NSLog(@\"instance %@ has been dealloced!\", self);\n}\n\n- (void)timerAction:(NSTimer*)timer {\n    NSLog(@\"Hi, Timer Action for instance %@\", self);\n}\n@end\n```\n\n**调用**\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self testNonRepeatTimer];\n    //[self testRepeatTimer];\n}\n\n- (void)testNonRepeatTimer\n{\n    NSLog(@\"Test retatin target for non-repeat timer!\");\n    JHTestTimerObject *testObject = [[JHTestTimerObject alloc] init];\n    [NSTimer scheduledTimerWithTimeInterval:3 target:testObject selector:@selector(timerAction:) userInfo:nil repeats:NO];\n    NSLog(@\"Invoke release to testObject!\");\n}\n\n- (void)testRepeatTimer\n{\n    NSLog(@\"Test retain target for repeat Timer\");\n    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];\n    [NSTimer scheduledTimerWithTimeInterval:3 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES];\n    NSLog(@\"Invoke release to testObject2!\");\n}\n```\n\n## 分析\n\n上面这个例子，创建了一个测试对象 JHTestTimerObject ，在它的init，dealloc 和 timerAction 三个方法中分别打印了信息，并且在 ViewController 中 分别测试 单次执行timer 和 重复执行timer，由于在 ARC 环境下，testObject 超出**{}**的作用域范围就会被释放，`通过这点可以确认timer是否对“target”做了 retain 操作`。\n\n调用 **NonRepeatTimer** 打印结果：\n{% asset_img Snip20161126_2.png CALayer image %}\n根据打印结果，可以看出在**14:24:38**时，testObject 才执行了 dealloc 方法，系统等待 timer 执行结束后才释放 testObject 对象。这就证明了`单次执行timer也会 retain 它的“target”，直到它自己失效为止`。\n\n\n\n\n调用 **RepeatTimer** 打印结果：\n{% asset_img Snip20161126_3.png CALayer image %}\n据观察，timer一直在周期性的调用指定的方法，而且 testObject2 一直也没被释放。\n\n## 小结\n\n通过上面的例子，我们可以发现在timer对它的接收者进行retain，从而保证了timer调用时的正确性，但是又引入了接收者的内存管理问题。特别是对于重复性的timer，它所引用的对象将一直存在，将会造成内存泄露。\n\n解决办法， NSTimer 方法提供了一个销毁的方法 invalidate，我们可以用来解决这个问题。不管是一次性的还是重复性的timer，在执行完invalidate以后都会变成无效，因此对于重复性的timer我们一定要有对应的invalidate。\n\n## 强引用引发的”血案“\n\n相信不少人说我有调用 invalidate 销毁方法啊，但是并没有释放相关的对象，因为他们十有八九是在 dealloc 中调用的，犯了自欺欺人的错误。\n\n举个例子：\n\n**ViewController.m**\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    _button = [UIButton buttonWithType:UIButtonTypeSystem];\n    _button.frame = CGRectMake(100, 200, 50, 50);\n    [_button setTitle:@\"点一下\" forState:UIControlStateNormal];\n    [_button addTarget:self action:@selector(pushNextVC:) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:_button];\n}\n\n- (void)pushNextVC:(UIButton *)button {\n    JHTestTimerViewController *vc = [JHTestTimerViewController new];\n    [self.navigationController pushViewController:vc animated:YES];\n}\n```\n\n**JHTestTimerViewController.m**\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    _textLabel = [[UILabel alloc] initWithFrame:CGRectMake(100, 200, 40, 60)];\n    _textLabel.text = @\"这是第二个VC\";\n    [self.view addSubview:_textLabel];\n    \n    _timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(testTimer:) userInfo:nil repeats:YES];\n}\n\n- (void)dealloc {\n    // 自欺欺人的写法，永远都不会执行到，除非你在外部手动invalidate这个timer\n    [_timer invalidate];\n}\n\n- (void)testTimer:(NSTimer*)timer {\n    NSLog(@\"haha!\");\n}\n```\n按照常理 JHTestTimerViewController 会在点击导航栏的返回按钮后被销毁，然后触发 dealloc 方法，在 dealloc 方法中会销毁定时器，然而实际上并没有。\n\n原因是 _timer 会对“target”进行 retain ，只要强引用在，JHTestTimerViewController 就不会被销毁，就不会走 dealloc 方法，也就不会销毁 _timer ，_timer 不销毁就一直强引用 JHTestTimerViewController，这就造成了内存泄漏。\n\n## 小结2\ntimer 都会对它的 target 进行 retain，我们需要小心对待这个 target 的生命周期问题，尤其是重复性的timer。（NSTimer 初始化后，self 的 retainCount 加 1。 那么，我们需要在释放这个类之前，执行[timer invalidate];否则，不会执行该类的 dealloc 方法。）\n\n## 解决方法1\n既然知道了是强引用造成的原因，那么肯定有解决办法的。👇使用了一个简洁的方法来解决：\n\n```objc\n//\n//  NSTimer+EZ_Helper.m\n//  EZToolKit\n//\n//  Created by yangjun zhu on 15/5/20.\n//  Copyright (c) 2015年 Cactus. All rights reserved.\n//\n\n#import \"NSTimer+EZ_Helper.h\"\n\n@implementation NSTimer (EZ_Helper)\n+ (NSTimer *)ez_scheduledTimerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats\n{\n    void (^block)() = [inBlock copy];\n    NSTimer * timer = [self scheduledTimerWithTimeInterval:inTimeInterval target:self selector:@selector(__executeTimerBlock:) userInfo:block repeats:inRepeats];\n    return timer;\n}\n\n+ (NSTimer *)ez_timerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats\n{\n    void (^block)() = [inBlock copy];\n    NSTimer * timer = [self timerWithTimeInterval:inTimeInterval target:self selector:@selector(__executeTimerBlock:) userInfo:block repeats:inRepeats];\n    return timer;\n}\n\n+ (void)__executeTimerBlock:(NSTimer *)inTimer;\n{\n    if([inTimer userInfo])\n    {\n        void (^block)() = (void (^)())[inTimer userInfo];\n        block();\n    }\n}\n@end\n```\n给 NSTimer 写的一个category，在 category 中把一个”伪造“的 ”self“ 赋值给了 ”target“，这个 ”self“ 类似于一个中间的代理人，作用是接受 NSTimer 的强引用，这样 NSTimer 就不会持有原始的对象，原始对象就能正常调用 dealloc 方法，在 dealloc 中的 invalidate 方法就会销毁定 timer。（通过打断点可以看出 self 实际上是 NSTimer）\n\n## 解决方法2\n\n在 iOS10 中，我们发现 NSTimer 多了几个API：\n\n```objc\n+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:\n(BOOL)repeats block:(void (^)(NSTimer *timer))block\nAPI_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));\n\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:\n(BOOL)repeats block:(void (^)(NSTimer *timer))block\nAPI_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));\n``` \n\n这两个 API 是 iOS10 新添加的，前两个参数很好理解：**触发间隔** 和 **是否重复触发**。第三个参数是个 block ，有没有发觉和**解决方法1**非常相似，只是参数顺序不一样。\n\n看看第三个参数的注释：\n\n> block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references\n\n翻译过来是：block 是 timer 需要执行的内容；当 block 被执行时，timer 自己本身会被当做参数传递给 block ，避免循环引用。\n\n从注释就可以看出，新的API解决方式和**解决方法1**是一样的，避免持有相应的对象，这就是苹果给出了终极解决方案，但是缺点是要 iOS10 以上才能调用。\n\n\n## 总结\n本章主要讨论了 NSTimer 与 它的target 的关系，强引用 target 引发的问题，以及解决办法。下一章继续讨论其他坑点。\n\n> **注意：**无论是解决方法1还是解决方法2，在 block 中，一定要使用弱引用 weakself，否则还是会造成循环引用，内存泄漏。\n\n\n## 参考链接\n\n* [NSTimer](http://justsee.iteye.com/blog/1774722)\n* [iOS 中的 NSTimer](http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/)\n\n\n\n","source":"_posts/NSTimer-1.md","raw":"---\ntitle: NSTimer（一）\ndate: 2016-11-19 12:42:49\ntags: NSTimer\ncategory: 能工巧匠\n---\n\n## 前言\nNSTimer iOS中使用的计时器，定时去完成任务的东西。但是其中的坑点相当多：\n\n1. NSTimer 会 retain 你添加调用方法的对象，比如 self（最近被它坑到了）\n2. NSTimer 要添加到 runloop 才会执行\n3. NSTimer 并不是精确的按照指定的时间触发\n4. NSTimer 添加到 runloop 后，也不一定按照你想象的那样执行\n\n## 什么是NSTimer\n\nNSTimer 就是一个能在从现在开始的后面的某一个时刻或者周期性的执行我们指定的方法的对象。\n\n## NSTimer 与 Target\n\n从上面的解释来看，NSTimer 会在未来某个时刻执行一次或者多次我们指定的方法，那么它是怎么知道该方法那个时候是否还是有效的，如果该方法不存在了，消息分发会引发异常的。\n\n解决方法很简单，`就是把要指定给timer的“selector”的“target” retain 一份就搞定了，实际上系统也是这样做的`，不管是重复性的timer还是一次性的timer都会对它的方法的接收者进行retain，这两种timer的区别在于“**一次性的timer在完成调用以后会自动将自己invalidate，而重复的timer则将永生，直到你显示的invalidate它为止**”。\n\n举个例子：\n\n**JHTestTimerObject.h**\n```objc\n@interface JHTestTimerObject : NSObject\n/*\n * 公开方法，timer响应函数，用来做测试\n */\n- (void)timerAction:(NSTimer*)timer;\n\n@end\n```\n\n**JHTestTimerObject.m**\n```objc\n@implementation JHTestTimerObject\n- (id)init {\n    self = [super init];\n    if (self) {\n        NSLog(@\"instance %@ has been created!\", self);\n    }\n    \n    return self;\n}\n\n- (void)dealloc {\n    NSLog(@\"instance %@ has been dealloced!\", self);\n}\n\n- (void)timerAction:(NSTimer*)timer {\n    NSLog(@\"Hi, Timer Action for instance %@\", self);\n}\n@end\n```\n\n**调用**\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self testNonRepeatTimer];\n    //[self testRepeatTimer];\n}\n\n- (void)testNonRepeatTimer\n{\n    NSLog(@\"Test retatin target for non-repeat timer!\");\n    JHTestTimerObject *testObject = [[JHTestTimerObject alloc] init];\n    [NSTimer scheduledTimerWithTimeInterval:3 target:testObject selector:@selector(timerAction:) userInfo:nil repeats:NO];\n    NSLog(@\"Invoke release to testObject!\");\n}\n\n- (void)testRepeatTimer\n{\n    NSLog(@\"Test retain target for repeat Timer\");\n    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];\n    [NSTimer scheduledTimerWithTimeInterval:3 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES];\n    NSLog(@\"Invoke release to testObject2!\");\n}\n```\n\n## 分析\n\n上面这个例子，创建了一个测试对象 JHTestTimerObject ，在它的init，dealloc 和 timerAction 三个方法中分别打印了信息，并且在 ViewController 中 分别测试 单次执行timer 和 重复执行timer，由于在 ARC 环境下，testObject 超出**{}**的作用域范围就会被释放，`通过这点可以确认timer是否对“target”做了 retain 操作`。\n\n调用 **NonRepeatTimer** 打印结果：\n{% asset_img Snip20161126_2.png CALayer image %}\n根据打印结果，可以看出在**14:24:38**时，testObject 才执行了 dealloc 方法，系统等待 timer 执行结束后才释放 testObject 对象。这就证明了`单次执行timer也会 retain 它的“target”，直到它自己失效为止`。\n\n\n\n\n调用 **RepeatTimer** 打印结果：\n{% asset_img Snip20161126_3.png CALayer image %}\n据观察，timer一直在周期性的调用指定的方法，而且 testObject2 一直也没被释放。\n\n## 小结\n\n通过上面的例子，我们可以发现在timer对它的接收者进行retain，从而保证了timer调用时的正确性，但是又引入了接收者的内存管理问题。特别是对于重复性的timer，它所引用的对象将一直存在，将会造成内存泄露。\n\n解决办法， NSTimer 方法提供了一个销毁的方法 invalidate，我们可以用来解决这个问题。不管是一次性的还是重复性的timer，在执行完invalidate以后都会变成无效，因此对于重复性的timer我们一定要有对应的invalidate。\n\n## 强引用引发的”血案“\n\n相信不少人说我有调用 invalidate 销毁方法啊，但是并没有释放相关的对象，因为他们十有八九是在 dealloc 中调用的，犯了自欺欺人的错误。\n\n举个例子：\n\n**ViewController.m**\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    _button = [UIButton buttonWithType:UIButtonTypeSystem];\n    _button.frame = CGRectMake(100, 200, 50, 50);\n    [_button setTitle:@\"点一下\" forState:UIControlStateNormal];\n    [_button addTarget:self action:@selector(pushNextVC:) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:_button];\n}\n\n- (void)pushNextVC:(UIButton *)button {\n    JHTestTimerViewController *vc = [JHTestTimerViewController new];\n    [self.navigationController pushViewController:vc animated:YES];\n}\n```\n\n**JHTestTimerViewController.m**\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    _textLabel = [[UILabel alloc] initWithFrame:CGRectMake(100, 200, 40, 60)];\n    _textLabel.text = @\"这是第二个VC\";\n    [self.view addSubview:_textLabel];\n    \n    _timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(testTimer:) userInfo:nil repeats:YES];\n}\n\n- (void)dealloc {\n    // 自欺欺人的写法，永远都不会执行到，除非你在外部手动invalidate这个timer\n    [_timer invalidate];\n}\n\n- (void)testTimer:(NSTimer*)timer {\n    NSLog(@\"haha!\");\n}\n```\n按照常理 JHTestTimerViewController 会在点击导航栏的返回按钮后被销毁，然后触发 dealloc 方法，在 dealloc 方法中会销毁定时器，然而实际上并没有。\n\n原因是 _timer 会对“target”进行 retain ，只要强引用在，JHTestTimerViewController 就不会被销毁，就不会走 dealloc 方法，也就不会销毁 _timer ，_timer 不销毁就一直强引用 JHTestTimerViewController，这就造成了内存泄漏。\n\n## 小结2\ntimer 都会对它的 target 进行 retain，我们需要小心对待这个 target 的生命周期问题，尤其是重复性的timer。（NSTimer 初始化后，self 的 retainCount 加 1。 那么，我们需要在释放这个类之前，执行[timer invalidate];否则，不会执行该类的 dealloc 方法。）\n\n## 解决方法1\n既然知道了是强引用造成的原因，那么肯定有解决办法的。👇使用了一个简洁的方法来解决：\n\n```objc\n//\n//  NSTimer+EZ_Helper.m\n//  EZToolKit\n//\n//  Created by yangjun zhu on 15/5/20.\n//  Copyright (c) 2015年 Cactus. All rights reserved.\n//\n\n#import \"NSTimer+EZ_Helper.h\"\n\n@implementation NSTimer (EZ_Helper)\n+ (NSTimer *)ez_scheduledTimerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats\n{\n    void (^block)() = [inBlock copy];\n    NSTimer * timer = [self scheduledTimerWithTimeInterval:inTimeInterval target:self selector:@selector(__executeTimerBlock:) userInfo:block repeats:inRepeats];\n    return timer;\n}\n\n+ (NSTimer *)ez_timerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats\n{\n    void (^block)() = [inBlock copy];\n    NSTimer * timer = [self timerWithTimeInterval:inTimeInterval target:self selector:@selector(__executeTimerBlock:) userInfo:block repeats:inRepeats];\n    return timer;\n}\n\n+ (void)__executeTimerBlock:(NSTimer *)inTimer;\n{\n    if([inTimer userInfo])\n    {\n        void (^block)() = (void (^)())[inTimer userInfo];\n        block();\n    }\n}\n@end\n```\n给 NSTimer 写的一个category，在 category 中把一个”伪造“的 ”self“ 赋值给了 ”target“，这个 ”self“ 类似于一个中间的代理人，作用是接受 NSTimer 的强引用，这样 NSTimer 就不会持有原始的对象，原始对象就能正常调用 dealloc 方法，在 dealloc 中的 invalidate 方法就会销毁定 timer。（通过打断点可以看出 self 实际上是 NSTimer）\n\n## 解决方法2\n\n在 iOS10 中，我们发现 NSTimer 多了几个API：\n\n```objc\n+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:\n(BOOL)repeats block:(void (^)(NSTimer *timer))block\nAPI_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));\n\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:\n(BOOL)repeats block:(void (^)(NSTimer *timer))block\nAPI_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));\n``` \n\n这两个 API 是 iOS10 新添加的，前两个参数很好理解：**触发间隔** 和 **是否重复触发**。第三个参数是个 block ，有没有发觉和**解决方法1**非常相似，只是参数顺序不一样。\n\n看看第三个参数的注释：\n\n> block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references\n\n翻译过来是：block 是 timer 需要执行的内容；当 block 被执行时，timer 自己本身会被当做参数传递给 block ，避免循环引用。\n\n从注释就可以看出，新的API解决方式和**解决方法1**是一样的，避免持有相应的对象，这就是苹果给出了终极解决方案，但是缺点是要 iOS10 以上才能调用。\n\n\n## 总结\n本章主要讨论了 NSTimer 与 它的target 的关系，强引用 target 引发的问题，以及解决办法。下一章继续讨论其他坑点。\n\n> **注意：**无论是解决方法1还是解决方法2，在 block 中，一定要使用弱引用 weakself，否则还是会造成循环引用，内存泄漏。\n\n\n## 参考链接\n\n* [NSTimer](http://justsee.iteye.com/blog/1774722)\n* [iOS 中的 NSTimer](http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/)\n\n\n\n","slug":"NSTimer-1","published":1,"updated":"2016-11-27T06:55:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7o2004i8jpbxuwsekft","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>NSTimer iOS中使用的计时器，定时去完成任务的东西。但是其中的坑点相当多：</p>\n<ol>\n<li>NSTimer 会 retain 你添加调用方法的对象，比如 self（最近被它坑到了）</li>\n<li>NSTimer 要添加到 runloop 才会执行</li>\n<li>NSTimer 并不是精确的按照指定的时间触发</li>\n<li>NSTimer 添加到 runloop 后，也不一定按照你想象的那样执行</li>\n</ol>\n<h2 id=\"什么是NSTimer\"><a href=\"#什么是NSTimer\" class=\"headerlink\" title=\"什么是NSTimer\"></a>什么是NSTimer</h2><p>NSTimer 就是一个能在从现在开始的后面的某一个时刻或者周期性的执行我们指定的方法的对象。</p>\n<h2 id=\"NSTimer-与-Target\"><a href=\"#NSTimer-与-Target\" class=\"headerlink\" title=\"NSTimer 与 Target\"></a>NSTimer 与 Target</h2><p>从上面的解释来看，NSTimer 会在未来某个时刻执行一次或者多次我们指定的方法，那么它是怎么知道该方法那个时候是否还是有效的，如果该方法不存在了，消息分发会引发异常的。</p>\n<p>解决方法很简单，<code>就是把要指定给timer的“selector”的“target” retain 一份就搞定了，实际上系统也是这样做的</code>，不管是重复性的timer还是一次性的timer都会对它的方法的接收者进行retain，这两种timer的区别在于“<strong>一次性的timer在完成调用以后会自动将自己invalidate，而重复的timer则将永生，直到你显示的invalidate它为止</strong>”。</p>\n<p>举个例子：</p>\n<p><strong>JHTestTimerObject.h</strong><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">JHTestTimerObject</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 公开方法，timer响应函数，用来做测试</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)timerAction:(<span class=\"built_in\">NSTimer</span>*)timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>JHTestTimerObject.m</strong><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">JHTestTimerObject</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"instance %@ has been created!\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"instance %@ has been dealloced!\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)timerAction:(<span class=\"built_in\">NSTimer</span>*)timer &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hi, Timer Action for instance %@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>调用</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> testNonRepeatTimer];</span><br><span class=\"line\">    <span class=\"comment\">//[self testRepeatTimer];</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)testNonRepeatTimer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Test retatin target for non-repeat timer!\"</span>);</span><br><span class=\"line\">    JHTestTimerObject *testObject = [[JHTestTimerObject alloc] init];</span><br><span class=\"line\">    [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span> target:testObject selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Invoke release to testObject!\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)testRepeatTimer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Test retain target for repeat Timer\"</span>);</span><br><span class=\"line\">    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];</span><br><span class=\"line\">    [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span> target:testObject2 selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Invoke release to testObject2!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>上面这个例子，创建了一个测试对象 JHTestTimerObject ，在它的init，dealloc 和 timerAction 三个方法中分别打印了信息，并且在 ViewController 中 分别测试 单次执行timer 和 重复执行timer，由于在 ARC 环境下，testObject 超出<strong>{}</strong>的作用域范围就会被释放，<code>通过这点可以确认timer是否对“target”做了 retain 操作</code>。</p>\n<p>调用 <strong>NonRepeatTimer</strong> 打印结果：<br><img src=\"/2016/11/19/NSTimer-1/Snip20161126_2.png\" title=\"CALayer image\"><br>根据打印结果，可以看出在<strong>14:24:38</strong>时，testObject 才执行了 dealloc 方法，系统等待 timer 执行结束后才释放 testObject 对象。这就证明了<code>单次执行timer也会 retain 它的“target”，直到它自己失效为止</code>。</p>\n<p>调用 <strong>RepeatTimer</strong> 打印结果：<br><img src=\"/2016/11/19/NSTimer-1/Snip20161126_3.png\" title=\"CALayer image\"><br>据观察，timer一直在周期性的调用指定的方法，而且 testObject2 一直也没被释放。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>通过上面的例子，我们可以发现在timer对它的接收者进行retain，从而保证了timer调用时的正确性，但是又引入了接收者的内存管理问题。特别是对于重复性的timer，它所引用的对象将一直存在，将会造成内存泄露。</p>\n<p>解决办法， NSTimer 方法提供了一个销毁的方法 invalidate，我们可以用来解决这个问题。不管是一次性的还是重复性的timer，在执行完invalidate以后都会变成无效，因此对于重复性的timer我们一定要有对应的invalidate。</p>\n<h2 id=\"强引用引发的”血案“\"><a href=\"#强引用引发的”血案“\" class=\"headerlink\" title=\"强引用引发的”血案“\"></a>强引用引发的”血案“</h2><p>相信不少人说我有调用 invalidate 销毁方法啊，但是并没有释放相关的对象，因为他们十有八九是在 dealloc 中调用的，犯了自欺欺人的错误。</p>\n<p>举个例子：</p>\n<p><strong>ViewController.m</strong><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    _button = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeSystem</span>];</span><br><span class=\"line\">    _button.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">200</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">    [_button setTitle:<span class=\"string\">@\"点一下\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">    [_button addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(pushNextVC:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:_button];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)pushNextVC:(<span class=\"built_in\">UIButton</span> *)button &#123;</span><br><span class=\"line\">    JHTestTimerViewController *vc = [JHTestTimerViewController new];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.navigationController pushViewController:vc animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>JHTestTimerViewController.m</strong><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _textLabel = [[<span class=\"built_in\">UILabel</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">200</span>, <span class=\"number\">40</span>, <span class=\"number\">60</span>)];</span><br><span class=\"line\">    _textLabel.text = <span class=\"string\">@\"这是第二个VC\"</span>;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:_textLabel];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span>f target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(testTimer:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 自欺欺人的写法，永远都不会执行到，除非你在外部手动invalidate这个timer</span></span><br><span class=\"line\">    [_timer invalidate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)testTimer:(<span class=\"built_in\">NSTimer</span>*)timer &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按照常理 JHTestTimerViewController 会在点击导航栏的返回按钮后被销毁，然后触发 dealloc 方法，在 dealloc 方法中会销毁定时器，然而实际上并没有。</p>\n<p>原因是 _timer 会对“target”进行 retain ，只要强引用在，JHTestTimerViewController 就不会被销毁，就不会走 dealloc 方法，也就不会销毁 _timer ，_timer 不销毁就一直强引用 JHTestTimerViewController，这就造成了内存泄漏。</p>\n<h2 id=\"小结2\"><a href=\"#小结2\" class=\"headerlink\" title=\"小结2\"></a>小结2</h2><p>timer 都会对它的 target 进行 retain，我们需要小心对待这个 target 的生命周期问题，尤其是重复性的timer。（NSTimer 初始化后，self 的 retainCount 加 1。 那么，我们需要在释放这个类之前，执行[timer invalidate];否则，不会执行该类的 dealloc 方法。）</p>\n<h2 id=\"解决方法1\"><a href=\"#解决方法1\" class=\"headerlink\" title=\"解决方法1\"></a>解决方法1</h2><p>既然知道了是强引用造成的原因，那么肯定有解决办法的。👇使用了一个简洁的方法来解决：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  NSTimer+EZ_Helper.m</span></span><br><span class=\"line\"><span class=\"comment\">//  EZToolKit</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  Created by yangjun zhu on 15/5/20.</span></span><br><span class=\"line\"><span class=\"comment\">//  Copyright (c) 2015年 Cactus. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSTimer+EZ_Helper.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">EZ_Helper</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ez_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)inTimeInterval block:(<span class=\"keyword\">void</span> (^)())inBlock repeats:(<span class=\"built_in\">BOOL</span>)inRepeats</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = [inBlock <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> * timer = [<span class=\"keyword\">self</span> scheduledTimerWithTimeInterval:inTimeInterval target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(__executeTimerBlock:) userInfo:block repeats:inRepeats];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> timer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ez_timerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)inTimeInterval block:(<span class=\"keyword\">void</span> (^)())inBlock repeats:(<span class=\"built_in\">BOOL</span>)inRepeats</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = [inBlock <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> * timer = [<span class=\"keyword\">self</span> timerWithTimeInterval:inTimeInterval target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(__executeTimerBlock:) userInfo:block repeats:inRepeats];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> timer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)__executeTimerBlock:(<span class=\"built_in\">NSTimer</span> *)inTimer;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>([inTimer userInfo])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> (^block)() = (<span class=\"keyword\">void</span> (^)())[inTimer userInfo];</span><br><span class=\"line\">        block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>给 NSTimer 写的一个category，在 category 中把一个”伪造“的 ”self“ 赋值给了 ”target“，这个 ”self“ 类似于一个中间的代理人，作用是接受 NSTimer 的强引用，这样 NSTimer 就不会持有原始的对象，原始对象就能正常调用 dealloc 方法，在 dealloc 中的 invalidate 方法就会销毁定 timer。（通过打断点可以看出 self 实际上是 NSTimer）</p>\n<h2 id=\"解决方法2\"><a href=\"#解决方法2\" class=\"headerlink\" title=\"解决方法2\"></a>解决方法2</h2><p>在 iOS10 中，我们发现 NSTimer 多了几个API：</p>\n<pre><code class=\"objc\">+ (<span class=\"built_in\">NSTimer</span> *)timerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval repeats:\n(<span class=\"built_in\">BOOL</span>)repeats block:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSTimer</span> *timer))block\nAPI_AVAILABLE(macosx(<span class=\"number\">10.12</span>), ios(<span class=\"number\">10.0</span>), watchos(<span class=\"number\">3.0</span>), tvos(<span class=\"number\">10.0</span>));\n\n+ (<span class=\"built_in\">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval repeats:\n(<span class=\"built_in\">BOOL</span>)repeats block:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSTimer</span> *timer))block\nAPI_AVAILABLE(macosx(<span class=\"number\">10.12</span>), ios(<span class=\"number\">10.0</span>), watchos(<span class=\"number\">3.0</span>), tvos(<span class=\"number\">10.0</span>));\n</code></pre>\n<p>这两个 API 是 iOS10 新添加的，前两个参数很好理解：<strong>触发间隔</strong> 和 <strong>是否重复触发</strong>。第三个参数是个 block ，有没有发觉和<strong>解决方法1</strong>非常相似，只是参数顺序不一样。</p>\n<p>看看第三个参数的注释：</p>\n<blockquote>\n<p>block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</p>\n</blockquote>\n<p>翻译过来是：block 是 timer 需要执行的内容；当 block 被执行时，timer 自己本身会被当做参数传递给 block ，避免循环引用。</p>\n<p>从注释就可以看出，新的API解决方式和<strong>解决方法1</strong>是一样的，避免持有相应的对象，这就是苹果给出了终极解决方案，但是缺点是要 iOS10 以上才能调用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本章主要讨论了 NSTimer 与 它的target 的关系，强引用 target 引发的问题，以及解决办法。下一章继续讨论其他坑点。</p>\n<blockquote>\n<p><strong>注意：</strong>无论是解决方法1还是解决方法2，在 block 中，一定要使用弱引用 weakself，否则还是会造成循环引用，内存泄漏。</p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://justsee.iteye.com/blog/1774722\" target=\"_blank\" rel=\"noopener\">NSTimer</a></li>\n<li><a href=\"http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/\" target=\"_blank\" rel=\"noopener\">iOS 中的 NSTimer</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>NSTimer iOS中使用的计时器，定时去完成任务的东西。但是其中的坑点相当多：</p>\n<ol>\n<li>NSTimer 会 retain 你添加调用方法的对象，比如 self（最近被它坑到了）</li>\n<li>NSTimer 要添加到 runloop 才会执行</li>\n<li>NSTimer 并不是精确的按照指定的时间触发</li>\n<li>NSTimer 添加到 runloop 后，也不一定按照你想象的那样执行</li>\n</ol>\n<h2 id=\"什么是NSTimer\"><a href=\"#什么是NSTimer\" class=\"headerlink\" title=\"什么是NSTimer\"></a>什么是NSTimer</h2><p>NSTimer 就是一个能在从现在开始的后面的某一个时刻或者周期性的执行我们指定的方法的对象。</p>\n<h2 id=\"NSTimer-与-Target\"><a href=\"#NSTimer-与-Target\" class=\"headerlink\" title=\"NSTimer 与 Target\"></a>NSTimer 与 Target</h2><p>从上面的解释来看，NSTimer 会在未来某个时刻执行一次或者多次我们指定的方法，那么它是怎么知道该方法那个时候是否还是有效的，如果该方法不存在了，消息分发会引发异常的。</p>\n<p>解决方法很简单，<code>就是把要指定给timer的“selector”的“target” retain 一份就搞定了，实际上系统也是这样做的</code>，不管是重复性的timer还是一次性的timer都会对它的方法的接收者进行retain，这两种timer的区别在于“<strong>一次性的timer在完成调用以后会自动将自己invalidate，而重复的timer则将永生，直到你显示的invalidate它为止</strong>”。</p>\n<p>举个例子：</p>\n<p><strong>JHTestTimerObject.h</strong><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">JHTestTimerObject</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 公开方法，timer响应函数，用来做测试</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)timerAction:(<span class=\"built_in\">NSTimer</span>*)timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>JHTestTimerObject.m</strong><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">JHTestTimerObject</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"instance %@ has been created!\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"instance %@ has been dealloced!\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)timerAction:(<span class=\"built_in\">NSTimer</span>*)timer &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hi, Timer Action for instance %@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>调用</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> testNonRepeatTimer];</span><br><span class=\"line\">    <span class=\"comment\">//[self testRepeatTimer];</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)testNonRepeatTimer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Test retatin target for non-repeat timer!\"</span>);</span><br><span class=\"line\">    JHTestTimerObject *testObject = [[JHTestTimerObject alloc] init];</span><br><span class=\"line\">    [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span> target:testObject selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Invoke release to testObject!\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)testRepeatTimer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Test retain target for repeat Timer\"</span>);</span><br><span class=\"line\">    JHTestTimerObject *testObject2 = [[JHTestTimerObject alloc] init];</span><br><span class=\"line\">    [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span> target:testObject2 selector:<span class=\"keyword\">@selector</span>(timerAction:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Invoke release to testObject2!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>上面这个例子，创建了一个测试对象 JHTestTimerObject ，在它的init，dealloc 和 timerAction 三个方法中分别打印了信息，并且在 ViewController 中 分别测试 单次执行timer 和 重复执行timer，由于在 ARC 环境下，testObject 超出<strong>{}</strong>的作用域范围就会被释放，<code>通过这点可以确认timer是否对“target”做了 retain 操作</code>。</p>\n<p>调用 <strong>NonRepeatTimer</strong> 打印结果：<br><img src=\"/2016/11/19/NSTimer-1/Snip20161126_2.png\" title=\"CALayer image\"><br>根据打印结果，可以看出在<strong>14:24:38</strong>时，testObject 才执行了 dealloc 方法，系统等待 timer 执行结束后才释放 testObject 对象。这就证明了<code>单次执行timer也会 retain 它的“target”，直到它自己失效为止</code>。</p>\n<p>调用 <strong>RepeatTimer</strong> 打印结果：<br><img src=\"/2016/11/19/NSTimer-1/Snip20161126_3.png\" title=\"CALayer image\"><br>据观察，timer一直在周期性的调用指定的方法，而且 testObject2 一直也没被释放。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>通过上面的例子，我们可以发现在timer对它的接收者进行retain，从而保证了timer调用时的正确性，但是又引入了接收者的内存管理问题。特别是对于重复性的timer，它所引用的对象将一直存在，将会造成内存泄露。</p>\n<p>解决办法， NSTimer 方法提供了一个销毁的方法 invalidate，我们可以用来解决这个问题。不管是一次性的还是重复性的timer，在执行完invalidate以后都会变成无效，因此对于重复性的timer我们一定要有对应的invalidate。</p>\n<h2 id=\"强引用引发的”血案“\"><a href=\"#强引用引发的”血案“\" class=\"headerlink\" title=\"强引用引发的”血案“\"></a>强引用引发的”血案“</h2><p>相信不少人说我有调用 invalidate 销毁方法啊，但是并没有释放相关的对象，因为他们十有八九是在 dealloc 中调用的，犯了自欺欺人的错误。</p>\n<p>举个例子：</p>\n<p><strong>ViewController.m</strong><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    _button = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeSystem</span>];</span><br><span class=\"line\">    _button.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">200</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">    [_button setTitle:<span class=\"string\">@\"点一下\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">    [_button addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(pushNextVC:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:_button];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)pushNextVC:(<span class=\"built_in\">UIButton</span> *)button &#123;</span><br><span class=\"line\">    JHTestTimerViewController *vc = [JHTestTimerViewController new];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.navigationController pushViewController:vc animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>JHTestTimerViewController.m</strong><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _textLabel = [[<span class=\"built_in\">UILabel</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">200</span>, <span class=\"number\">40</span>, <span class=\"number\">60</span>)];</span><br><span class=\"line\">    _textLabel.text = <span class=\"string\">@\"这是第二个VC\"</span>;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:_textLabel];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span>f target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(testTimer:) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 自欺欺人的写法，永远都不会执行到，除非你在外部手动invalidate这个timer</span></span><br><span class=\"line\">    [_timer invalidate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)testTimer:(<span class=\"built_in\">NSTimer</span>*)timer &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按照常理 JHTestTimerViewController 会在点击导航栏的返回按钮后被销毁，然后触发 dealloc 方法，在 dealloc 方法中会销毁定时器，然而实际上并没有。</p>\n<p>原因是 _timer 会对“target”进行 retain ，只要强引用在，JHTestTimerViewController 就不会被销毁，就不会走 dealloc 方法，也就不会销毁 _timer ，_timer 不销毁就一直强引用 JHTestTimerViewController，这就造成了内存泄漏。</p>\n<h2 id=\"小结2\"><a href=\"#小结2\" class=\"headerlink\" title=\"小结2\"></a>小结2</h2><p>timer 都会对它的 target 进行 retain，我们需要小心对待这个 target 的生命周期问题，尤其是重复性的timer。（NSTimer 初始化后，self 的 retainCount 加 1。 那么，我们需要在释放这个类之前，执行[timer invalidate];否则，不会执行该类的 dealloc 方法。）</p>\n<h2 id=\"解决方法1\"><a href=\"#解决方法1\" class=\"headerlink\" title=\"解决方法1\"></a>解决方法1</h2><p>既然知道了是强引用造成的原因，那么肯定有解决办法的。👇使用了一个简洁的方法来解决：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  NSTimer+EZ_Helper.m</span></span><br><span class=\"line\"><span class=\"comment\">//  EZToolKit</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//  Created by yangjun zhu on 15/5/20.</span></span><br><span class=\"line\"><span class=\"comment\">//  Copyright (c) 2015年 Cactus. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSTimer+EZ_Helper.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">EZ_Helper</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ez_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)inTimeInterval block:(<span class=\"keyword\">void</span> (^)())inBlock repeats:(<span class=\"built_in\">BOOL</span>)inRepeats</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = [inBlock <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> * timer = [<span class=\"keyword\">self</span> scheduledTimerWithTimeInterval:inTimeInterval target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(__executeTimerBlock:) userInfo:block repeats:inRepeats];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> timer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ez_timerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)inTimeInterval block:(<span class=\"keyword\">void</span> (^)())inBlock repeats:(<span class=\"built_in\">BOOL</span>)inRepeats</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = [inBlock <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> * timer = [<span class=\"keyword\">self</span> timerWithTimeInterval:inTimeInterval target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(__executeTimerBlock:) userInfo:block repeats:inRepeats];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> timer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)__executeTimerBlock:(<span class=\"built_in\">NSTimer</span> *)inTimer;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>([inTimer userInfo])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> (^block)() = (<span class=\"keyword\">void</span> (^)())[inTimer userInfo];</span><br><span class=\"line\">        block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>给 NSTimer 写的一个category，在 category 中把一个”伪造“的 ”self“ 赋值给了 ”target“，这个 ”self“ 类似于一个中间的代理人，作用是接受 NSTimer 的强引用，这样 NSTimer 就不会持有原始的对象，原始对象就能正常调用 dealloc 方法，在 dealloc 中的 invalidate 方法就会销毁定 timer。（通过打断点可以看出 self 实际上是 NSTimer）</p>\n<h2 id=\"解决方法2\"><a href=\"#解决方法2\" class=\"headerlink\" title=\"解决方法2\"></a>解决方法2</h2><p>在 iOS10 中，我们发现 NSTimer 多了几个API：</p>\n<pre><code class=\"objc\">+ (<span class=\"built_in\">NSTimer</span> *)timerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval repeats:\n(<span class=\"built_in\">BOOL</span>)repeats block:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSTimer</span> *timer))block\nAPI_AVAILABLE(macosx(<span class=\"number\">10.12</span>), ios(<span class=\"number\">10.0</span>), watchos(<span class=\"number\">3.0</span>), tvos(<span class=\"number\">10.0</span>));\n\n+ (<span class=\"built_in\">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval repeats:\n(<span class=\"built_in\">BOOL</span>)repeats block:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSTimer</span> *timer))block\nAPI_AVAILABLE(macosx(<span class=\"number\">10.12</span>), ios(<span class=\"number\">10.0</span>), watchos(<span class=\"number\">3.0</span>), tvos(<span class=\"number\">10.0</span>));\n</code></pre>\n<p>这两个 API 是 iOS10 新添加的，前两个参数很好理解：<strong>触发间隔</strong> 和 <strong>是否重复触发</strong>。第三个参数是个 block ，有没有发觉和<strong>解决方法1</strong>非常相似，只是参数顺序不一样。</p>\n<p>看看第三个参数的注释：</p>\n<blockquote>\n<p>block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</p>\n</blockquote>\n<p>翻译过来是：block 是 timer 需要执行的内容；当 block 被执行时，timer 自己本身会被当做参数传递给 block ，避免循环引用。</p>\n<p>从注释就可以看出，新的API解决方式和<strong>解决方法1</strong>是一样的，避免持有相应的对象，这就是苹果给出了终极解决方案，但是缺点是要 iOS10 以上才能调用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本章主要讨论了 NSTimer 与 它的target 的关系，强引用 target 引发的问题，以及解决办法。下一章继续讨论其他坑点。</p>\n<blockquote>\n<p><strong>注意：</strong>无论是解决方法1还是解决方法2，在 block 中，一定要使用弱引用 weakself，否则还是会造成循环引用，内存泄漏。</p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://justsee.iteye.com/blog/1774722\" target=\"_blank\" rel=\"noopener\">NSTimer</a></li>\n<li><a href=\"http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/\" target=\"_blank\" rel=\"noopener\">iOS 中的 NSTimer</a></li>\n</ul>\n"},{"title":"使用GCD（一）","date":"2016-09-25T03:38:21.000Z","_content":"\n## 前言\nGCD的全称是Grand Central Dispatch，可译为“牛逼的中枢调度器”，属于系统级的的线程管理，会自动管理线程的生命周期（创建线程、调度任务、销毁线程），现在GCD这块已经开源了（[开源地址](http://libdispatch.macosforge.org)）。\n\n## GCD概要\n* GCD的队列可以分为2大类型：并发队列（Concurrent Dispatch Queue）和串行队列（Serial Dispatch Queue）\n* GCD会自动将队列的任务取出放到对应的形成中执行，遵循队列的FIFO原则：先进先出，后进后出\n* 有五中不同的队列：主队列main queue，运行在主线程，用于刷新UI。还有四个不同优先级的全局并发队列（High Priority Queue，Default Priority Queue，Low Priority Queue，Background Queue）\n\n## 几个容易混淆的术语\n\n同步和异步决定了要不要开启新的线程\n\n* 同步：在当前线程中执行任务，不具备开启新线程的能力\n* 异步：在新的线程中执行任务，具备开启新线程的能力\n\n并发和串行决定了任务的执行方式\n\n* 并发：多个任务并发（同时）执行\n* 串行：一个任务执行完毕后，再执行下一个任务\n\n## 基本概念\n\n* 系统标准的两个队列\n\n```objc\n// 主线程中的唯一队列，一种特殊的串行队列，放在主队列的任务，都会放到主线程中执行\ndispatch_get_main_queue\n// 包含四种不同优先级的并发队列，由系统创建，供整个应用使用。\ndispatch_get_global_queue\n```\n\n* 自定义队列\n\n```objc\n// 串行队列\ndispatch_queue_create(\"com.piglikeyoung.serialqueue\", DISPATCH_QUEUE_SERIAL)\n// 并行队列\ndispatch_queue_create(\"com.piglikeyoung.concurrentqueue\", DISPATCH_QUEUE_CONCURRENT)\n```\n\n* 同步异步线程创建\n\n```objc\n// 同步线程\ndispatch_sync(..., ^(block))\n// 异步线程\ndispatch_async(..., ^(block))\n```\n\n## 队列类型\n\n* Serial Dispatch Queue（串行队列）：要等待现在执行中的处理结束才执行下一个任务，同时只能执行1个任务。当创建多个Serial Queue时，它们各自是同步的，但Serial Queue之间是并发执行的。\n* Concurrent Dispatch Queue（并发队列）：不需要等待现在执行中的处理结束，并行多个处理，并行执行的处理数量取决于当前系统的状态。所谓“并行执行”，就是使用多个线程同时执行处理。\n\n\n```objc\n// 主队列\ndispatch_queue_t mainQueue = dispatch_get_main_queue();\n// 全局并发队列\ndispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); \n```\n\n## dispatch_queue_create\n通过 dispatch_queue_create 函数可以生成 Dispatch Queue，函数有两个参数，第一个是自定义队列名，第二个是队列类型，输入`NULL`或者`DISPATCH_QUEUE_SERIAL`表示**串行队列**，输入`DISPATCH_QUEUE_CONCURRENT`表示**并行队列**。\n\n```objc\ndispatch_queue_t queue = dispatch_queue_create(\"com.piglikeyoung.gcd.concurrentqueue\", DISPATCH_QUEUE_CONCURRENT);\n```\n\n第二个参数还有第三种传值方式，参考下面说到的`dipatch_queue_attr_make_with_qos_class`\n\n## dispatch_set_target_queue\ndispatch_queue_create 函数生成的 Dispatch Queue 不管是 Serial Dispatch Queue 还是 Concurrent Dispatch Queue ，都是使用与默认优先级 Global Dispatch Queue 相同执行优先级的线程。而变更生成的 Dispatch Queue 的执行优先级需要使用 `dispatch_set_target_queue` 函数。\n\n```objc\n- (void)setTargetQueue {\n    dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create(\"com.piglikeyoung.gcd.MySerialDispatchQueue\", NULL);\n    dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);\n    dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);\n}\n```\n\n指定要变更执行优先级的 Dispatch Queue 为 dispatch_set_target_queue 函数的第一个参数，指定与要使用的执行优先级相同优先级的 Global Dispatch Queue 为第二个参数（目标）。第一个参数如果指定系统提供的 Main Dispatch Queue 和 Global Dispatch Queue 则不知道会出现什么状况，因此这些均不可指定。\n\n\ndispatch_set_target_queue 不仅可以变更 Dispatch Queue 的执行优先级，还可以作成 Dispatch Queue 的执行阶层。如果在多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某个 Serial Dispatch Queue ，那么原先本应并行执行的多个 Serial Dispatch Queue ，在目标 Serial Dispatch Queue 上只能同时执行一个处理。\n\n```objc\n- (void)dispatchSetTargetQueueDemo {\n    dispatch_queue_t serialQueue = dispatch_queue_create(\"com.piglikeyoung.gcd.serialqueue\", DISPATCH_QUEUE_SERIAL);\n    dispatch_queue_t firstQueue = dispatch_queue_create(\"com.piglikeyoung.gcd.firstqueue\", DISPATCH_QUEUE_SERIAL);\n    dispatch_queue_t secondQueue = dispatch_queue_create(\"com.piglikeyoung.gcd.secondqueue\", DISPATCH_QUEUE_CONCURRENT);\n    \n    dispatch_set_target_queue(firstQueue, serialQueue);\n    dispatch_set_target_queue(secondQueue, serialQueue);\n    \n    dispatch_async(firstQueue, ^{\n        NSLog(@\"1\");\n        sleep(3);\n    });\n    dispatch_async(secondQueue, ^{\n        NSLog(@\"2\");\n        sleep(2);\n    });\n    dispatch_async(secondQueue, ^{\n        NSLog(@\"3\");\n        sleep(1);\n    });\n}\n```\n\n## dipatch_queue_attr_make_with_qos_class\niOS8之后苹果框架概念基础中将不再过分强调线程这个概念。新的 qualityOfService 属性替换了 ThreadPriority。\n\nqualityOfService 主要用于 dispatch_queue_create函数。适用于OSX v10.10及以后或iOS v8.0及以后的版本。\n\n自定义队列通过 dipatch_queue_attr_make_with_qos_class 来指定队列的执行优先级：\n\n```objc\n- (void)attrMakeWithQosClass{\n\t// 自定义属性\n\tdispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, -1);\n\tdispatch_queue_t queue = dispatch_queue_create(\"com.piglikeyoung.gcd.qosqueue\", attr);\n}\n```\n\ndispatch_queue_attr_make_with_qos_class 参数有三个：\n\n* 第一个参数**attr**：传入**DISPATCH_QUEUE_SERIAL**、**NULL**或者**DISPATCH_QUEUE_CONCURRENT**，表示串行或者并行\n* 第二个参数**qos_class**：传入qos_class枚举，表示优先级级别\n* 带三个参数**relative_priority**：相对于qos_class的相对优先级，qos_class用于区分大的优先级级别，relative_priority表示大级别下的小级别。`relative_priority必须大于QOS_MIN_RELATIVE_PRIORITY并且小于0，否则将返回NULL`。从GCD源码中可以查到QOS_MIN_RELATIVE_PRIORITY等于-15。\n\nqos_class枚举定义了以下值：\n\n* **QOS_CLASS_USER_INTERACTIVE**：最高优先级，交互级别。使用这个优先级会占用几乎所有的系统CUP和I/O带宽，仅限用于交互的UI操作，比如处理点击事件，绘制图像到屏幕上，动画等\n* **QOS_CLASS_USER_INITIATED**：次高优先级，user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。例如，如果用户打开email app马上查看邮件。\n* **QOS_CLASS_DEFAULT**：默认优先级，当没有设置优先级的时候，线程默认优先级。一般情况下用的都是这个优先级。\n* **QOS_CLASS_UTILITY**：普通优先级，utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。例如，电子邮件应用程序可以被配置为每隔5分钟自动检查邮件。如果系统是非常有限的资源，而电子邮件检查被推迟几分钟这也是被允许的。\n* **QOS_CLASS_BACKGROUND**：后台优先级，background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。比如email app可能使用它来执行索引搜索。\n* **QOS_CLASS_UNSPECIFIED**：未知优先级，表示服务质量信息缺失。\n\n和 ThreadPriority 的对比表格：\n\n| Global queue | Corresponding QoS class | 说明 |\n| :------------ | :--------------- | :----- |\n| Main thread | NSQualityOfServiceUserInteractive | UI相关，交互等 |\n| DISPATCH_QUEUE_PRIORITY_HIGH | QOS_CLASS_USER_INITIATED | 用于执行类似初始化等需要立即返回的事件 |\n| DISPATCH_QUEUE_PRIORITY_DEFAULT | QOS_CLASS_DEFAULT | 当没有设置优先级的时候，线程默认优先级。一般情况下用的都是这个优先级 |\n| DISPATCH_QUEUE_PRIORITY_LOW | QOS_CLASS_UTILITY | 主要用于不需要立即返回的任务，花费时间稍多比如下载，需要几秒或几分钟的 |\n| DISPATCH_QUEUE_PRIORITY_BACKGROUND | QOS_CLASS_BACKGROUND | 用于用户几乎不感知的任务，在后台的操作可能需要好几分钟甚至几小时的 |\n\n\n```objc\n// 两种使用方式等价\ndispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0), ^{\n   // do Something\n});\n    \ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   // do Something\n});\n```\n\n## 参考资料\n* [官方文档](https://developer.apple.com/reference/dispatch)\n* Objective-C 高级编程 iOS与OS X多线程和内存管理\n* [细说GCD（Grand Central Dispatch）如何用](https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8)\n* [那些开发者应该知道但又略显模糊的iOS 8 API](http://www.cocoachina.com/ios/20140630/8984.html)\n* [小笨狼漫谈多线程：GCD(一)](http://www.jianshu.com/users/1f93e3b1f3da/latest_articles)\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Using-Grand-Central-Dispatch-1.md","raw":"---\ntitle: 使用GCD（一）\ndate: 2016-09-25 11:38:21\ntags: GCD\ncategory: 能工巧匠\n---\n\n## 前言\nGCD的全称是Grand Central Dispatch，可译为“牛逼的中枢调度器”，属于系统级的的线程管理，会自动管理线程的生命周期（创建线程、调度任务、销毁线程），现在GCD这块已经开源了（[开源地址](http://libdispatch.macosforge.org)）。\n\n## GCD概要\n* GCD的队列可以分为2大类型：并发队列（Concurrent Dispatch Queue）和串行队列（Serial Dispatch Queue）\n* GCD会自动将队列的任务取出放到对应的形成中执行，遵循队列的FIFO原则：先进先出，后进后出\n* 有五中不同的队列：主队列main queue，运行在主线程，用于刷新UI。还有四个不同优先级的全局并发队列（High Priority Queue，Default Priority Queue，Low Priority Queue，Background Queue）\n\n## 几个容易混淆的术语\n\n同步和异步决定了要不要开启新的线程\n\n* 同步：在当前线程中执行任务，不具备开启新线程的能力\n* 异步：在新的线程中执行任务，具备开启新线程的能力\n\n并发和串行决定了任务的执行方式\n\n* 并发：多个任务并发（同时）执行\n* 串行：一个任务执行完毕后，再执行下一个任务\n\n## 基本概念\n\n* 系统标准的两个队列\n\n```objc\n// 主线程中的唯一队列，一种特殊的串行队列，放在主队列的任务，都会放到主线程中执行\ndispatch_get_main_queue\n// 包含四种不同优先级的并发队列，由系统创建，供整个应用使用。\ndispatch_get_global_queue\n```\n\n* 自定义队列\n\n```objc\n// 串行队列\ndispatch_queue_create(\"com.piglikeyoung.serialqueue\", DISPATCH_QUEUE_SERIAL)\n// 并行队列\ndispatch_queue_create(\"com.piglikeyoung.concurrentqueue\", DISPATCH_QUEUE_CONCURRENT)\n```\n\n* 同步异步线程创建\n\n```objc\n// 同步线程\ndispatch_sync(..., ^(block))\n// 异步线程\ndispatch_async(..., ^(block))\n```\n\n## 队列类型\n\n* Serial Dispatch Queue（串行队列）：要等待现在执行中的处理结束才执行下一个任务，同时只能执行1个任务。当创建多个Serial Queue时，它们各自是同步的，但Serial Queue之间是并发执行的。\n* Concurrent Dispatch Queue（并发队列）：不需要等待现在执行中的处理结束，并行多个处理，并行执行的处理数量取决于当前系统的状态。所谓“并行执行”，就是使用多个线程同时执行处理。\n\n\n```objc\n// 主队列\ndispatch_queue_t mainQueue = dispatch_get_main_queue();\n// 全局并发队列\ndispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); \n```\n\n## dispatch_queue_create\n通过 dispatch_queue_create 函数可以生成 Dispatch Queue，函数有两个参数，第一个是自定义队列名，第二个是队列类型，输入`NULL`或者`DISPATCH_QUEUE_SERIAL`表示**串行队列**，输入`DISPATCH_QUEUE_CONCURRENT`表示**并行队列**。\n\n```objc\ndispatch_queue_t queue = dispatch_queue_create(\"com.piglikeyoung.gcd.concurrentqueue\", DISPATCH_QUEUE_CONCURRENT);\n```\n\n第二个参数还有第三种传值方式，参考下面说到的`dipatch_queue_attr_make_with_qos_class`\n\n## dispatch_set_target_queue\ndispatch_queue_create 函数生成的 Dispatch Queue 不管是 Serial Dispatch Queue 还是 Concurrent Dispatch Queue ，都是使用与默认优先级 Global Dispatch Queue 相同执行优先级的线程。而变更生成的 Dispatch Queue 的执行优先级需要使用 `dispatch_set_target_queue` 函数。\n\n```objc\n- (void)setTargetQueue {\n    dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create(\"com.piglikeyoung.gcd.MySerialDispatchQueue\", NULL);\n    dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);\n    dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);\n}\n```\n\n指定要变更执行优先级的 Dispatch Queue 为 dispatch_set_target_queue 函数的第一个参数，指定与要使用的执行优先级相同优先级的 Global Dispatch Queue 为第二个参数（目标）。第一个参数如果指定系统提供的 Main Dispatch Queue 和 Global Dispatch Queue 则不知道会出现什么状况，因此这些均不可指定。\n\n\ndispatch_set_target_queue 不仅可以变更 Dispatch Queue 的执行优先级，还可以作成 Dispatch Queue 的执行阶层。如果在多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某个 Serial Dispatch Queue ，那么原先本应并行执行的多个 Serial Dispatch Queue ，在目标 Serial Dispatch Queue 上只能同时执行一个处理。\n\n```objc\n- (void)dispatchSetTargetQueueDemo {\n    dispatch_queue_t serialQueue = dispatch_queue_create(\"com.piglikeyoung.gcd.serialqueue\", DISPATCH_QUEUE_SERIAL);\n    dispatch_queue_t firstQueue = dispatch_queue_create(\"com.piglikeyoung.gcd.firstqueue\", DISPATCH_QUEUE_SERIAL);\n    dispatch_queue_t secondQueue = dispatch_queue_create(\"com.piglikeyoung.gcd.secondqueue\", DISPATCH_QUEUE_CONCURRENT);\n    \n    dispatch_set_target_queue(firstQueue, serialQueue);\n    dispatch_set_target_queue(secondQueue, serialQueue);\n    \n    dispatch_async(firstQueue, ^{\n        NSLog(@\"1\");\n        sleep(3);\n    });\n    dispatch_async(secondQueue, ^{\n        NSLog(@\"2\");\n        sleep(2);\n    });\n    dispatch_async(secondQueue, ^{\n        NSLog(@\"3\");\n        sleep(1);\n    });\n}\n```\n\n## dipatch_queue_attr_make_with_qos_class\niOS8之后苹果框架概念基础中将不再过分强调线程这个概念。新的 qualityOfService 属性替换了 ThreadPriority。\n\nqualityOfService 主要用于 dispatch_queue_create函数。适用于OSX v10.10及以后或iOS v8.0及以后的版本。\n\n自定义队列通过 dipatch_queue_attr_make_with_qos_class 来指定队列的执行优先级：\n\n```objc\n- (void)attrMakeWithQosClass{\n\t// 自定义属性\n\tdispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, -1);\n\tdispatch_queue_t queue = dispatch_queue_create(\"com.piglikeyoung.gcd.qosqueue\", attr);\n}\n```\n\ndispatch_queue_attr_make_with_qos_class 参数有三个：\n\n* 第一个参数**attr**：传入**DISPATCH_QUEUE_SERIAL**、**NULL**或者**DISPATCH_QUEUE_CONCURRENT**，表示串行或者并行\n* 第二个参数**qos_class**：传入qos_class枚举，表示优先级级别\n* 带三个参数**relative_priority**：相对于qos_class的相对优先级，qos_class用于区分大的优先级级别，relative_priority表示大级别下的小级别。`relative_priority必须大于QOS_MIN_RELATIVE_PRIORITY并且小于0，否则将返回NULL`。从GCD源码中可以查到QOS_MIN_RELATIVE_PRIORITY等于-15。\n\nqos_class枚举定义了以下值：\n\n* **QOS_CLASS_USER_INTERACTIVE**：最高优先级，交互级别。使用这个优先级会占用几乎所有的系统CUP和I/O带宽，仅限用于交互的UI操作，比如处理点击事件，绘制图像到屏幕上，动画等\n* **QOS_CLASS_USER_INITIATED**：次高优先级，user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。例如，如果用户打开email app马上查看邮件。\n* **QOS_CLASS_DEFAULT**：默认优先级，当没有设置优先级的时候，线程默认优先级。一般情况下用的都是这个优先级。\n* **QOS_CLASS_UTILITY**：普通优先级，utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。例如，电子邮件应用程序可以被配置为每隔5分钟自动检查邮件。如果系统是非常有限的资源，而电子邮件检查被推迟几分钟这也是被允许的。\n* **QOS_CLASS_BACKGROUND**：后台优先级，background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。比如email app可能使用它来执行索引搜索。\n* **QOS_CLASS_UNSPECIFIED**：未知优先级，表示服务质量信息缺失。\n\n和 ThreadPriority 的对比表格：\n\n| Global queue | Corresponding QoS class | 说明 |\n| :------------ | :--------------- | :----- |\n| Main thread | NSQualityOfServiceUserInteractive | UI相关，交互等 |\n| DISPATCH_QUEUE_PRIORITY_HIGH | QOS_CLASS_USER_INITIATED | 用于执行类似初始化等需要立即返回的事件 |\n| DISPATCH_QUEUE_PRIORITY_DEFAULT | QOS_CLASS_DEFAULT | 当没有设置优先级的时候，线程默认优先级。一般情况下用的都是这个优先级 |\n| DISPATCH_QUEUE_PRIORITY_LOW | QOS_CLASS_UTILITY | 主要用于不需要立即返回的任务，花费时间稍多比如下载，需要几秒或几分钟的 |\n| DISPATCH_QUEUE_PRIORITY_BACKGROUND | QOS_CLASS_BACKGROUND | 用于用户几乎不感知的任务，在后台的操作可能需要好几分钟甚至几小时的 |\n\n\n```objc\n// 两种使用方式等价\ndispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0), ^{\n   // do Something\n});\n    \ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   // do Something\n});\n```\n\n## 参考资料\n* [官方文档](https://developer.apple.com/reference/dispatch)\n* Objective-C 高级编程 iOS与OS X多线程和内存管理\n* [细说GCD（Grand Central Dispatch）如何用](https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8)\n* [那些开发者应该知道但又略显模糊的iOS 8 API](http://www.cocoachina.com/ios/20140630/8984.html)\n* [小笨狼漫谈多线程：GCD(一)](http://www.jianshu.com/users/1f93e3b1f3da/latest_articles)\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Using-Grand-Central-Dispatch-1","published":1,"updated":"2016-09-25T08:49:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7o3004l8jpbovohxgn0","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>GCD的全称是Grand Central Dispatch，可译为“牛逼的中枢调度器”，属于系统级的的线程管理，会自动管理线程的生命周期（创建线程、调度任务、销毁线程），现在GCD这块已经开源了（<a href=\"http://libdispatch.macosforge.org\" target=\"_blank\" rel=\"noopener\">开源地址</a>）。</p>\n<h2 id=\"GCD概要\"><a href=\"#GCD概要\" class=\"headerlink\" title=\"GCD概要\"></a>GCD概要</h2><ul>\n<li>GCD的队列可以分为2大类型：并发队列（Concurrent Dispatch Queue）和串行队列（Serial Dispatch Queue）</li>\n<li>GCD会自动将队列的任务取出放到对应的形成中执行，遵循队列的FIFO原则：先进先出，后进后出</li>\n<li>有五中不同的队列：主队列main queue，运行在主线程，用于刷新UI。还有四个不同优先级的全局并发队列（High Priority Queue，Default Priority Queue，Low Priority Queue，Background Queue）</li>\n</ul>\n<h2 id=\"几个容易混淆的术语\"><a href=\"#几个容易混淆的术语\" class=\"headerlink\" title=\"几个容易混淆的术语\"></a>几个容易混淆的术语</h2><p>同步和异步决定了要不要开启新的线程</p>\n<ul>\n<li>同步：在当前线程中执行任务，不具备开启新线程的能力</li>\n<li>异步：在新的线程中执行任务，具备开启新线程的能力</li>\n</ul>\n<p>并发和串行决定了任务的执行方式</p>\n<ul>\n<li>并发：多个任务并发（同时）执行</li>\n<li>串行：一个任务执行完毕后，再执行下一个任务</li>\n</ul>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li>系统标准的两个队列</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程中的唯一队列，一种特殊的串行队列，放在主队列的任务，都会放到主线程中执行</span></span><br><span class=\"line\">dispatch_get_main_queue</span><br><span class=\"line\"><span class=\"comment\">// 包含四种不同优先级的并发队列，由系统创建，供整个应用使用。</span></span><br><span class=\"line\">dispatch_get_global_queue</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自定义队列</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 串行队列</span></span><br><span class=\"line\">dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.serialqueue\"</span>, DISPATCH_QUEUE_SERIAL)</span><br><span class=\"line\"><span class=\"comment\">// 并行队列</span></span><br><span class=\"line\">dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.concurrentqueue\"</span>, DISPATCH_QUEUE_CONCURRENT)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>同步异步线程创建</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同步线程</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(..., ^(block))</span><br><span class=\"line\"><span class=\"comment\">// 异步线程</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(..., ^(block))</span><br></pre></td></tr></table></figure>\n<h2 id=\"队列类型\"><a href=\"#队列类型\" class=\"headerlink\" title=\"队列类型\"></a>队列类型</h2><ul>\n<li>Serial Dispatch Queue（串行队列）：要等待现在执行中的处理结束才执行下一个任务，同时只能执行1个任务。当创建多个Serial Queue时，它们各自是同步的，但Serial Queue之间是并发执行的。</li>\n<li>Concurrent Dispatch Queue（并发队列）：不需要等待现在执行中的处理结束，并行多个处理，并行执行的处理数量取决于当前系统的状态。所谓“并行执行”，就是使用多个线程同时执行处理。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主队列</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class=\"line\"><span class=\"comment\">// 全局并发队列</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"dispatch-queue-create\"><a href=\"#dispatch-queue-create\" class=\"headerlink\" title=\"dispatch_queue_create\"></a>dispatch_queue_create</h2><p>通过 dispatch_queue_create 函数可以生成 Dispatch Queue，函数有两个参数，第一个是自定义队列名，第二个是队列类型，输入<code>NULL</code>或者<code>DISPATCH_QUEUE_SERIAL</code>表示<strong>串行队列</strong>，输入<code>DISPATCH_QUEUE_CONCURRENT</code>表示<strong>并行队列</strong>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.concurrentqueue\"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>\n<p>第二个参数还有第三种传值方式，参考下面说到的<code>dipatch_queue_attr_make_with_qos_class</code></p>\n<h2 id=\"dispatch-set-target-queue\"><a href=\"#dispatch-set-target-queue\" class=\"headerlink\" title=\"dispatch_set_target_queue\"></a>dispatch_set_target_queue</h2><p>dispatch_queue_create 函数生成的 Dispatch Queue 不管是 Serial Dispatch Queue 还是 Concurrent Dispatch Queue ，都是使用与默认优先级 Global Dispatch Queue 相同执行优先级的线程。而变更生成的 Dispatch Queue 的执行优先级需要使用 <code>dispatch_set_target_queue</code> 函数。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setTargetQueue &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> mySerialDispatchQueue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.MySerialDispatchQueue\"</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class=\"number\">0</span>);</span><br><span class=\"line\">    dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>指定要变更执行优先级的 Dispatch Queue 为 dispatch_set_target_queue 函数的第一个参数，指定与要使用的执行优先级相同优先级的 Global Dispatch Queue 为第二个参数（目标）。第一个参数如果指定系统提供的 Main Dispatch Queue 和 Global Dispatch Queue 则不知道会出现什么状况，因此这些均不可指定。</p>\n<p>dispatch_set_target_queue 不仅可以变更 Dispatch Queue 的执行优先级，还可以作成 Dispatch Queue 的执行阶层。如果在多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某个 Serial Dispatch Queue ，那么原先本应并行执行的多个 Serial Dispatch Queue ，在目标 Serial Dispatch Queue 上只能同时执行一个处理。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchSetTargetQueueDemo &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.serialqueue\"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> firstQueue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.firstqueue\"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> secondQueue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.secondqueue\"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_set_target_queue(firstQueue, serialQueue);</span><br><span class=\"line\">    dispatch_set_target_queue(secondQueue, serialQueue);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(firstQueue, ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(secondQueue, ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(secondQueue, ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"dipatch-queue-attr-make-with-qos-class\"><a href=\"#dipatch-queue-attr-make-with-qos-class\" class=\"headerlink\" title=\"dipatch_queue_attr_make_with_qos_class\"></a>dipatch_queue_attr_make_with_qos_class</h2><p>iOS8之后苹果框架概念基础中将不再过分强调线程这个概念。新的 qualityOfService 属性替换了 ThreadPriority。</p>\n<p>qualityOfService 主要用于 dispatch_queue_create函数。适用于OSX v10.10及以后或iOS v8.0及以后的版本。</p>\n<p>自定义队列通过 dipatch_queue_attr_make_with_qos_class 来指定队列的执行优先级：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)attrMakeWithQosClass&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 自定义属性</span></span><br><span class=\"line\">\tdispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.qosqueue\"</span>, attr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>dispatch_queue_attr_make_with_qos_class 参数有三个：</p>\n<ul>\n<li>第一个参数<strong>attr</strong>：传入<strong>DISPATCH_QUEUE_SERIAL</strong>、<strong>NULL</strong>或者<strong>DISPATCH_QUEUE_CONCURRENT</strong>，表示串行或者并行</li>\n<li>第二个参数<strong>qos_class</strong>：传入qos_class枚举，表示优先级级别</li>\n<li>带三个参数<strong>relative_priority</strong>：相对于qos_class的相对优先级，qos_class用于区分大的优先级级别，relative_priority表示大级别下的小级别。<code>relative_priority必须大于QOS_MIN_RELATIVE_PRIORITY并且小于0，否则将返回NULL</code>。从GCD源码中可以查到QOS_MIN_RELATIVE_PRIORITY等于-15。</li>\n</ul>\n<p>qos_class枚举定义了以下值：</p>\n<ul>\n<li><strong>QOS_CLASS_USER_INTERACTIVE</strong>：最高优先级，交互级别。使用这个优先级会占用几乎所有的系统CUP和I/O带宽，仅限用于交互的UI操作，比如处理点击事件，绘制图像到屏幕上，动画等</li>\n<li><strong>QOS_CLASS_USER_INITIATED</strong>：次高优先级，user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。例如，如果用户打开email app马上查看邮件。</li>\n<li><strong>QOS_CLASS_DEFAULT</strong>：默认优先级，当没有设置优先级的时候，线程默认优先级。一般情况下用的都是这个优先级。</li>\n<li><strong>QOS_CLASS_UTILITY</strong>：普通优先级，utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。例如，电子邮件应用程序可以被配置为每隔5分钟自动检查邮件。如果系统是非常有限的资源，而电子邮件检查被推迟几分钟这也是被允许的。</li>\n<li><strong>QOS_CLASS_BACKGROUND</strong>：后台优先级，background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。比如email app可能使用它来执行索引搜索。</li>\n<li><strong>QOS_CLASS_UNSPECIFIED</strong>：未知优先级，表示服务质量信息缺失。</li>\n</ul>\n<p>和 ThreadPriority 的对比表格：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Global queue</th>\n<th style=\"text-align:left\">Corresponding QoS class</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Main thread</td>\n<td style=\"text-align:left\">NSQualityOfServiceUserInteractive</td>\n<td style=\"text-align:left\">UI相关，交互等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DISPATCH_QUEUE_PRIORITY_HIGH</td>\n<td style=\"text-align:left\">QOS_CLASS_USER_INITIATED</td>\n<td style=\"text-align:left\">用于执行类似初始化等需要立即返回的事件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DISPATCH_QUEUE_PRIORITY_DEFAULT</td>\n<td style=\"text-align:left\">QOS_CLASS_DEFAULT</td>\n<td style=\"text-align:left\">当没有设置优先级的时候，线程默认优先级。一般情况下用的都是这个优先级</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DISPATCH_QUEUE_PRIORITY_LOW</td>\n<td style=\"text-align:left\">QOS_CLASS_UTILITY</td>\n<td style=\"text-align:left\">主要用于不需要立即返回的任务，花费时间稍多比如下载，需要几秒或几分钟的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DISPATCH_QUEUE_PRIORITY_BACKGROUND</td>\n<td style=\"text-align:left\">QOS_CLASS_BACKGROUND</td>\n<td style=\"text-align:left\">用于用户几乎不感知的任务，在后台的操作可能需要好几分钟甚至几小时的</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 两种使用方式等价</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do Something</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do Something</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://developer.apple.com/reference/dispatch\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>Objective-C 高级编程 iOS与OS X多线程和内存管理</li>\n<li><a href=\"https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8\" target=\"_blank\" rel=\"noopener\">细说GCD（Grand Central Dispatch）如何用</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20140630/8984.html\" target=\"_blank\" rel=\"noopener\">那些开发者应该知道但又略显模糊的iOS 8 API</a></li>\n<li><a href=\"http://www.jianshu.com/users/1f93e3b1f3da/latest_articles\" target=\"_blank\" rel=\"noopener\">小笨狼漫谈多线程：GCD(一)</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>GCD的全称是Grand Central Dispatch，可译为“牛逼的中枢调度器”，属于系统级的的线程管理，会自动管理线程的生命周期（创建线程、调度任务、销毁线程），现在GCD这块已经开源了（<a href=\"http://libdispatch.macosforge.org\" target=\"_blank\" rel=\"noopener\">开源地址</a>）。</p>\n<h2 id=\"GCD概要\"><a href=\"#GCD概要\" class=\"headerlink\" title=\"GCD概要\"></a>GCD概要</h2><ul>\n<li>GCD的队列可以分为2大类型：并发队列（Concurrent Dispatch Queue）和串行队列（Serial Dispatch Queue）</li>\n<li>GCD会自动将队列的任务取出放到对应的形成中执行，遵循队列的FIFO原则：先进先出，后进后出</li>\n<li>有五中不同的队列：主队列main queue，运行在主线程，用于刷新UI。还有四个不同优先级的全局并发队列（High Priority Queue，Default Priority Queue，Low Priority Queue，Background Queue）</li>\n</ul>\n<h2 id=\"几个容易混淆的术语\"><a href=\"#几个容易混淆的术语\" class=\"headerlink\" title=\"几个容易混淆的术语\"></a>几个容易混淆的术语</h2><p>同步和异步决定了要不要开启新的线程</p>\n<ul>\n<li>同步：在当前线程中执行任务，不具备开启新线程的能力</li>\n<li>异步：在新的线程中执行任务，具备开启新线程的能力</li>\n</ul>\n<p>并发和串行决定了任务的执行方式</p>\n<ul>\n<li>并发：多个任务并发（同时）执行</li>\n<li>串行：一个任务执行完毕后，再执行下一个任务</li>\n</ul>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li>系统标准的两个队列</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程中的唯一队列，一种特殊的串行队列，放在主队列的任务，都会放到主线程中执行</span></span><br><span class=\"line\">dispatch_get_main_queue</span><br><span class=\"line\"><span class=\"comment\">// 包含四种不同优先级的并发队列，由系统创建，供整个应用使用。</span></span><br><span class=\"line\">dispatch_get_global_queue</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自定义队列</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 串行队列</span></span><br><span class=\"line\">dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.serialqueue\"</span>, DISPATCH_QUEUE_SERIAL)</span><br><span class=\"line\"><span class=\"comment\">// 并行队列</span></span><br><span class=\"line\">dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.concurrentqueue\"</span>, DISPATCH_QUEUE_CONCURRENT)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>同步异步线程创建</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同步线程</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(..., ^(block))</span><br><span class=\"line\"><span class=\"comment\">// 异步线程</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(..., ^(block))</span><br></pre></td></tr></table></figure>\n<h2 id=\"队列类型\"><a href=\"#队列类型\" class=\"headerlink\" title=\"队列类型\"></a>队列类型</h2><ul>\n<li>Serial Dispatch Queue（串行队列）：要等待现在执行中的处理结束才执行下一个任务，同时只能执行1个任务。当创建多个Serial Queue时，它们各自是同步的，但Serial Queue之间是并发执行的。</li>\n<li>Concurrent Dispatch Queue（并发队列）：不需要等待现在执行中的处理结束，并行多个处理，并行执行的处理数量取决于当前系统的状态。所谓“并行执行”，就是使用多个线程同时执行处理。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主队列</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class=\"line\"><span class=\"comment\">// 全局并发队列</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"dispatch-queue-create\"><a href=\"#dispatch-queue-create\" class=\"headerlink\" title=\"dispatch_queue_create\"></a>dispatch_queue_create</h2><p>通过 dispatch_queue_create 函数可以生成 Dispatch Queue，函数有两个参数，第一个是自定义队列名，第二个是队列类型，输入<code>NULL</code>或者<code>DISPATCH_QUEUE_SERIAL</code>表示<strong>串行队列</strong>，输入<code>DISPATCH_QUEUE_CONCURRENT</code>表示<strong>并行队列</strong>。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.concurrentqueue\"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>\n<p>第二个参数还有第三种传值方式，参考下面说到的<code>dipatch_queue_attr_make_with_qos_class</code></p>\n<h2 id=\"dispatch-set-target-queue\"><a href=\"#dispatch-set-target-queue\" class=\"headerlink\" title=\"dispatch_set_target_queue\"></a>dispatch_set_target_queue</h2><p>dispatch_queue_create 函数生成的 Dispatch Queue 不管是 Serial Dispatch Queue 还是 Concurrent Dispatch Queue ，都是使用与默认优先级 Global Dispatch Queue 相同执行优先级的线程。而变更生成的 Dispatch Queue 的执行优先级需要使用 <code>dispatch_set_target_queue</code> 函数。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setTargetQueue &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> mySerialDispatchQueue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.MySerialDispatchQueue\"</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class=\"number\">0</span>);</span><br><span class=\"line\">    dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>指定要变更执行优先级的 Dispatch Queue 为 dispatch_set_target_queue 函数的第一个参数，指定与要使用的执行优先级相同优先级的 Global Dispatch Queue 为第二个参数（目标）。第一个参数如果指定系统提供的 Main Dispatch Queue 和 Global Dispatch Queue 则不知道会出现什么状况，因此这些均不可指定。</p>\n<p>dispatch_set_target_queue 不仅可以变更 Dispatch Queue 的执行优先级，还可以作成 Dispatch Queue 的执行阶层。如果在多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某个 Serial Dispatch Queue ，那么原先本应并行执行的多个 Serial Dispatch Queue ，在目标 Serial Dispatch Queue 上只能同时执行一个处理。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchSetTargetQueueDemo &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.serialqueue\"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> firstQueue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.firstqueue\"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> secondQueue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.secondqueue\"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_set_target_queue(firstQueue, serialQueue);</span><br><span class=\"line\">    dispatch_set_target_queue(secondQueue, serialQueue);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(firstQueue, ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(secondQueue, ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(secondQueue, ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"dipatch-queue-attr-make-with-qos-class\"><a href=\"#dipatch-queue-attr-make-with-qos-class\" class=\"headerlink\" title=\"dipatch_queue_attr_make_with_qos_class\"></a>dipatch_queue_attr_make_with_qos_class</h2><p>iOS8之后苹果框架概念基础中将不再过分强调线程这个概念。新的 qualityOfService 属性替换了 ThreadPriority。</p>\n<p>qualityOfService 主要用于 dispatch_queue_create函数。适用于OSX v10.10及以后或iOS v8.0及以后的版本。</p>\n<p>自定义队列通过 dipatch_queue_attr_make_with_qos_class 来指定队列的执行优先级：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)attrMakeWithQosClass&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 自定义属性</span></span><br><span class=\"line\">\tdispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.qosqueue\"</span>, attr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>dispatch_queue_attr_make_with_qos_class 参数有三个：</p>\n<ul>\n<li>第一个参数<strong>attr</strong>：传入<strong>DISPATCH_QUEUE_SERIAL</strong>、<strong>NULL</strong>或者<strong>DISPATCH_QUEUE_CONCURRENT</strong>，表示串行或者并行</li>\n<li>第二个参数<strong>qos_class</strong>：传入qos_class枚举，表示优先级级别</li>\n<li>带三个参数<strong>relative_priority</strong>：相对于qos_class的相对优先级，qos_class用于区分大的优先级级别，relative_priority表示大级别下的小级别。<code>relative_priority必须大于QOS_MIN_RELATIVE_PRIORITY并且小于0，否则将返回NULL</code>。从GCD源码中可以查到QOS_MIN_RELATIVE_PRIORITY等于-15。</li>\n</ul>\n<p>qos_class枚举定义了以下值：</p>\n<ul>\n<li><strong>QOS_CLASS_USER_INTERACTIVE</strong>：最高优先级，交互级别。使用这个优先级会占用几乎所有的系统CUP和I/O带宽，仅限用于交互的UI操作，比如处理点击事件，绘制图像到屏幕上，动画等</li>\n<li><strong>QOS_CLASS_USER_INITIATED</strong>：次高优先级，user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。例如，如果用户打开email app马上查看邮件。</li>\n<li><strong>QOS_CLASS_DEFAULT</strong>：默认优先级，当没有设置优先级的时候，线程默认优先级。一般情况下用的都是这个优先级。</li>\n<li><strong>QOS_CLASS_UTILITY</strong>：普通优先级，utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。例如，电子邮件应用程序可以被配置为每隔5分钟自动检查邮件。如果系统是非常有限的资源，而电子邮件检查被推迟几分钟这也是被允许的。</li>\n<li><strong>QOS_CLASS_BACKGROUND</strong>：后台优先级，background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。比如email app可能使用它来执行索引搜索。</li>\n<li><strong>QOS_CLASS_UNSPECIFIED</strong>：未知优先级，表示服务质量信息缺失。</li>\n</ul>\n<p>和 ThreadPriority 的对比表格：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Global queue</th>\n<th style=\"text-align:left\">Corresponding QoS class</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Main thread</td>\n<td style=\"text-align:left\">NSQualityOfServiceUserInteractive</td>\n<td style=\"text-align:left\">UI相关，交互等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DISPATCH_QUEUE_PRIORITY_HIGH</td>\n<td style=\"text-align:left\">QOS_CLASS_USER_INITIATED</td>\n<td style=\"text-align:left\">用于执行类似初始化等需要立即返回的事件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DISPATCH_QUEUE_PRIORITY_DEFAULT</td>\n<td style=\"text-align:left\">QOS_CLASS_DEFAULT</td>\n<td style=\"text-align:left\">当没有设置优先级的时候，线程默认优先级。一般情况下用的都是这个优先级</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DISPATCH_QUEUE_PRIORITY_LOW</td>\n<td style=\"text-align:left\">QOS_CLASS_UTILITY</td>\n<td style=\"text-align:left\">主要用于不需要立即返回的任务，花费时间稍多比如下载，需要几秒或几分钟的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DISPATCH_QUEUE_PRIORITY_BACKGROUND</td>\n<td style=\"text-align:left\">QOS_CLASS_BACKGROUND</td>\n<td style=\"text-align:left\">用于用户几乎不感知的任务，在后台的操作可能需要好几分钟甚至几小时的</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 两种使用方式等价</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do Something</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do Something</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://developer.apple.com/reference/dispatch\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>Objective-C 高级编程 iOS与OS X多线程和内存管理</li>\n<li><a href=\"https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8\" target=\"_blank\" rel=\"noopener\">细说GCD（Grand Central Dispatch）如何用</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20140630/8984.html\" target=\"_blank\" rel=\"noopener\">那些开发者应该知道但又略显模糊的iOS 8 API</a></li>\n<li><a href=\"http://www.jianshu.com/users/1f93e3b1f3da/latest_articles\" target=\"_blank\" rel=\"noopener\">小笨狼漫谈多线程：GCD(一)</a></li>\n</ul>\n"},{"title":"使用GCD（二）","date":"2016-10-01T10:32:11.000Z","_content":"\n## 前言\n前一篇文章（[链接](http://piglikeyoung.com/2016/09/25/Using-Grand-Central-Dispatch-1/)）已经简单的介绍GCD的简单使用，这篇文章继续使用GCD。\n\n## dispatch_async\nGCD中有2个异步的API：\n\n```objc\nvoid dispatch_async(dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work);\n```\n\n这两个API都是将一个任务提交到queue中，提交之后立刻返回，不等待任务执行完成。系统会对queue做retain操作，任务执行完成后，queue才被release。两者的区别在于`dispatch_async`接受block作为参数，`dispatch_async_f`接受函数。\n\n`dispatch_async_f`中，**context**作为第一个参数传给**work**函数。如果**work**不需要参数，**context**可以传入**NULL**。**work**参数不能传入**NULL**，否则会发生不可预料的事。\n\n> 使用GCD的时候，block会被copy，block会在执行完之后release，而且block是被系统持有的，所以不用担心循环引用的问题，**block里面的self不需要weak**。\n\n`async`是异步的意思，至于怎么异步，看下面的例子：\n```objc\n- (void)dispatchAsync {\n    NSLog(@\"1\");\n    dispatch_async(dispatch_get_main_queue(), ^{\n        // do Something\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");// 1，3，2\n}\n```\n因为block是异步的，打印不是按照1，2，3的顺序打印的，简单点说，就是block里面的任务添加到队列后，GCD立刻返回，不阻塞线程，不需要等待任务执行完成。\n\n就像上面的例子，先打印 ”1“ ，block添加主队列里，添加完成立刻返回，然后打印 ”3“，等主队列里面前面的任务执行完成再打印 ”2“。\n\n\n## dispatch_sync\n\n和异步一样，GCD同步也有两个API：\n\n```objc\nvoid dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work);\n```\n参数内容和`dispatch_async`一样，不同的是任务加入queue之后不会立刻返回，阻塞线程，等待任务执行完成后再返回。\n\n\n```objc\n- (void)dispatchSync {\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0), ^{\n        // do Something\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");// 1，2，3\n}\n```\n\n从打印可以看出，打印是按照顺序来的\n1. 先打印 ”1“ \n2. 然后dispatch_sync会将block提交到global queue中，等待block的执行\n3. 全局队列中block前面的任务执行完成后，block执行\n4. block执行完成后，dispatch_sync返回\n5. dispatch_sync之后的代码执行，打印 ”3“\n\n从示例代码中可以看出我在全局队列做同步操作的，没有在主队列里面做，是因为dispatch_sync需要等待block被执行，非常容易发生死锁，特别是在串行队列里面，而且主队列就是串行队列。\n\n\n```objc\n- (void)dispatchSyncDeadLock {\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_main_queue(), ^{ // Dead Lock\n        // do Something\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n```\n\n分析一下死锁怎么发生的：\n1. 任务是放到主队列（串行队列）里面，串行队列任务是一个一个执行的\n2. dispatch_sync需要等待block执行完成发返回，block需要等待前面的任务执行完成，也就是dispatch_sync执行完成。两者相互等待，永远不会执行完成，造成了死锁。\n\n从中看出死锁是：`使用了dispatch_sync将任务加入串行队列`\n\n如果是并行队列，则不会造成死锁。\n\n## dispatch_after\n在开发中经常需要到延迟几秒再执行的代码的情况，GCD也有这样的API:\n\n```objc\nvoid dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work);\n```\nwhen表示时间，如果传入 `DISPATCH_TIME_NOW` 会等同于 `dispatch_async` ，另外不允许传入 `DISPATCH_TIME_FOREVER` ，这会永远阻塞线程。\n\n```objc\n- (void)dispatchAfter {\n    NSLog(@\"1\");\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n```\n需要注意的是，dispatch_after 函数并不是在指定时间后执行处理，而只是在指定时间追加处理到 Dispatch Queue。此源代码与在3秒后用 dispatch_async 函数追加 Block 到 Main Dispatch Queue 相同。\n\n因为 Main Dispatch Queue 在主线程的 RunLoop 中执行，所以在比如每隔1/60秒执行的 RunLoop 中，Block 最快在3秒后执行，最慢在3秒+1/60秒后执行，并且在 Main Dispatch Queue 有大量处理追加或者主线程的处理本身有延迟时，这个时间会更长。\n\n虽然在有严格时间的要求下使用时会出现问题，但在想大致延迟处理时，该函数是非常有效的。\n\n例子中 `dispatch_time` 参数原型是这样的\n\n```objc\ndispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta );\n```\n第一个参数用 `DISPATCH_TIME_NOW`表示当前。第二个参数delta表示纳秒，1秒=1000000000纳秒，系统用一些宏来简化\n\n```objc\n #define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒\n #define USEC_PER_SEC 1000000ull    //每毫秒有多少纳秒\n #define NSEC_PER_USEC 1000ull      //每秒有多少毫秒\n```\n\n这样1秒可以这样写：\n\n```objc\ndispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);\ndispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC);\ndispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC);\n```\n\n## dispatch_once\nGCD中还有保证在应用程序中只执行一次指定处理的API。\n\n```objc\n- (void)dispatchOne {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        // do Something\n    });\n}\n```\n通常通过这种方式生成单例对象。\n\n## dispatch_groups\n\n在追加到 Dispatch Queue 中的多个处理全部结束后想执行结束处理，这种情况会经常出现。如果使用一个 Serial Dispatch Queue  时，只要将想执行的处理全部追加到该 Serial Dispatch Queue 中并在最后追加结束处理，即可实现。但是在使用 Concurrent Dispatch Queue 时或同时使用多个Dispatch Queue 时，代码将会变得复杂。\n\n这是 Dispatch Group 将派上用场了。\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\n    \ndispatch_group_async(group, queue, ^{\n   NSLog(@\"1\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"2\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"3\");\n});\n    \ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n   NSLog(@\"done\");\n});\n```\n例子中追加了3个 Block 到 Global Dispatch Queue，这些 Block 执行完成完毕后，执行 Main Dispatch Queue 中的结束处理。\n\n在监听多个异步任务的时候，用到了`dispatch_group_notify`函数，它是异步执行，不会阻塞线程，第一个参数指定为要监视的 Dispatch Group。在追加到该 Dispatch Group 的全部处理执行结束时，将第三个参数的 Block 追加到的第二个参数的 Dispatch Queue 中。在 dispatch_group_notify 函数中不管指定什么样的 Dispatch Queue，属于 Dispatch Group 的全部处理在追加指定的 Block 时都已执行结束。\n\n在 GCD API 中还有一个监听多个异步任务的函数 `dispatch_group_wait` 会阻塞当前线程，等待所有任务都完成或等待超时。这里的等待是指一旦调用 dispatch_group_wait 函数，该函数就处于调用状态而不返回。即执行 dispatch_group_wait 函数的当前线程停止。在经过 dispatch_group_wait 函数中指定的时间或属于指定 Dispatch Group 的处理全部执行结束之前，执行该函数的线程停止。\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\n    \ndispatch_group_async(group, queue, ^{\n   NSLog(@\"1\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"2\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"3\");\n});\n    \ndispatch_group_wait(group, DISPATCH_TIME_FOREVER);\n```\n\ndispatch_group_wait 函数的第二个参数指定为等待的时间（超时）。它是 dispatch_time_t 类型的值。例子中用了 **DISPATCH_TIME_FOREVER** ，意思是永久等待。只要属于 Dispatch Group 的处理 尚未执行结束，就会一直等待，中途不能取消。\n\n如果指定等待间隔为1秒是应做如下处理：\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\n    \ndispatch_group_async(group, queue, ^{\n   NSLog(@\"1\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"2\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"3\");\n});\n    \ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);\nNSInteger result = dispatch_group_wait(group, time);\nif (result == 0) {\n   // 属于 Dispatch Group 的全部处理执行结束\n} else {\n   // 属于 Dispatch Group 的某个处理还在执行中\n}\n```\n如果 dispatch_group_wait 函数的返回值不为 0 ，就意味着虽然经过了指定的时间，但属于 Dispatch Group 的某个处理还在执行中。如果返回值为 0 ，那么全部处理执行结束。如果使用 **DISPATCH_TIME_FOREVER** ，属于 Dispatch Group 的全部处理必定全部执行结束，因此返回值恒为 0 。\n\n如果使用 **DISPATCH_TIME_NOW** ，则不用任何等待即可判定属于 Dispatch Group 的处理是否执行结束。\n\n## dispatch_barrier_async\n在访问数据库或文件时，如果使用 Serial Dispatch Queue 可以避免数据竞争的问题。\n写入操作不能和其他的写入操作以及包含读取处理的其他某些处理并行执行。如果只是读取操作和读取操作并行执行，那么多个并行执行不会发生问题。\n\nGCD 为我们提供非常简便的解决方法 `dispatch_barrier_async` 函数。\n\n首先 dispatch_queue_create 函数生成 Concurrent Dispatch Queue，在 dispatch_async 中追加读取操作：\n\n```objc\ndispatch_queue_t queue = dispatch_queue_create(\"com.piglikeyoung.gcd.concurrentqueue\", DISPATCH_QUEUE_CONCURRENT);\n\ndispatch_async(queue, blk0_for_reading);\ndispatch_async(queue, blk1_for_reading);\ndispatch_async(queue, blk2_for_reading);\ndispatch_async(queue, blk3_for_reading);\ndispatch_async(queue, blk4_for_reading);\ndispatch_async(queue, blk5_for_reading);\ndispatch_async(queue, blk6_for_reading);\n```\n在 blk3_for_reading 处理和 blk4_for_reading 处理之间执行写入操作，并将写入的内容在 blk4_for_reading 处理以及之后的处理中获取。\n\n```objc\ndispatch_async(queue, blk0_for_reading);\ndispatch_async(queue, blk1_for_reading);\ndispatch_async(queue, blk2_for_reading);\ndispatch_async(queue, blk3_for_reading);\ndispatch_async(queue, blk_for_writing);\ndispatch_async(queue, blk4_for_reading);\ndispatch_async(queue, blk5_for_reading);\ndispatch_async(queue, blk6_for_reading);\n```\n如果是简单把写入操作加入 Concurrent Dispatch Queue，那么读取到的数据有可能和预期不符，如果是多个读取和多个写入混合并发，有可能引起数据竞争的问题。\n\n这时候使用 `dispatch_barrier_async` 函数，**dispatch_barrier_async** 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束后，再将指定的处理追加到该 Concurrent Dispatch Queue 中。然后在由 dispatch_barrier_async 函数追加的处理执行完毕后，Concurrent Dispatch Queue 才恢复一般的动作，追加到该 Concurrent Dispatch Queue 的处理又开始并行执行。\n\n```objc\ndispatch_async(queue, blk0_for_reading);\ndispatch_async(queue, blk1_for_reading);\ndispatch_async(queue, blk2_for_reading);\ndispatch_async(queue, blk3_for_reading);\ndispatch_barrier_async(queue, blk_for_writing);\ndispatch_async(queue, blk4_for_reading);\ndispatch_async(queue, blk5_for_reading);\ndispatch_async(queue, blk6_for_reading);\n```\ndispatch_barrier_async 处理流程图如下：\n{% asset_img Snip20161005_1.png DNS %}\n\n\n> 注意：dispatch_barrier_async 只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和 dispatch_sync 一样\n\n\n## dispatch_apply\ndispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联 API。该函数按指定的次数将指定的 Block 追加到指定的 Dispatch Queue 中，并等待全部处理执行结束。\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\ndispatch_apply(10, queue, ^(size_t index) {\n   NSLog(@\"%zd\", index);\n});\nNSLog(@\"done\");\n```\n\n因为是在全局并发队列中执行处理，所以打印的顺序不定。但输出结果中最后的 done 肯定是在最后。因为 dispatch_apply 函数会等待全部处理执行结束。\n\n第一个参数是重复次数，第二个参数是追加对象的 Dispatch Queue ，第三个参数是追加的处理。不同的是第三个参数是带参数的block，这是为了按第一个参数重复追加 Block 并区分各个 Block 而使用。\n\n由于 dispatch_apply 函数也和 dispatch_sync 函数相同，会等待处理执行结束，**因此推荐在 dispatch_async 函数中非同步地执行  dispatch_apply 函数**，而且能够避免线程爆炸，因为GCD会管理并发。\n\n## 参考资料\n* [官方文档](https://developer.apple.com/reference/dispatch)\n* Objective-C 高级编程 iOS与OS X多线程和内存管理\n\n\n","source":"_posts/Using-Grand-Central-Dispatch-2.md","raw":"---\ntitle: 使用GCD（二）\ndate: 2016-10-01 18:32:11\ntags: GCD\ncategory: 能工巧匠\n---\n\n## 前言\n前一篇文章（[链接](http://piglikeyoung.com/2016/09/25/Using-Grand-Central-Dispatch-1/)）已经简单的介绍GCD的简单使用，这篇文章继续使用GCD。\n\n## dispatch_async\nGCD中有2个异步的API：\n\n```objc\nvoid dispatch_async(dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work);\n```\n\n这两个API都是将一个任务提交到queue中，提交之后立刻返回，不等待任务执行完成。系统会对queue做retain操作，任务执行完成后，queue才被release。两者的区别在于`dispatch_async`接受block作为参数，`dispatch_async_f`接受函数。\n\n`dispatch_async_f`中，**context**作为第一个参数传给**work**函数。如果**work**不需要参数，**context**可以传入**NULL**。**work**参数不能传入**NULL**，否则会发生不可预料的事。\n\n> 使用GCD的时候，block会被copy，block会在执行完之后release，而且block是被系统持有的，所以不用担心循环引用的问题，**block里面的self不需要weak**。\n\n`async`是异步的意思，至于怎么异步，看下面的例子：\n```objc\n- (void)dispatchAsync {\n    NSLog(@\"1\");\n    dispatch_async(dispatch_get_main_queue(), ^{\n        // do Something\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");// 1，3，2\n}\n```\n因为block是异步的，打印不是按照1，2，3的顺序打印的，简单点说，就是block里面的任务添加到队列后，GCD立刻返回，不阻塞线程，不需要等待任务执行完成。\n\n就像上面的例子，先打印 ”1“ ，block添加主队列里，添加完成立刻返回，然后打印 ”3“，等主队列里面前面的任务执行完成再打印 ”2“。\n\n\n## dispatch_sync\n\n和异步一样，GCD同步也有两个API：\n\n```objc\nvoid dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work);\n```\n参数内容和`dispatch_async`一样，不同的是任务加入queue之后不会立刻返回，阻塞线程，等待任务执行完成后再返回。\n\n\n```objc\n- (void)dispatchSync {\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0), ^{\n        // do Something\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");// 1，2，3\n}\n```\n\n从打印可以看出，打印是按照顺序来的\n1. 先打印 ”1“ \n2. 然后dispatch_sync会将block提交到global queue中，等待block的执行\n3. 全局队列中block前面的任务执行完成后，block执行\n4. block执行完成后，dispatch_sync返回\n5. dispatch_sync之后的代码执行，打印 ”3“\n\n从示例代码中可以看出我在全局队列做同步操作的，没有在主队列里面做，是因为dispatch_sync需要等待block被执行，非常容易发生死锁，特别是在串行队列里面，而且主队列就是串行队列。\n\n\n```objc\n- (void)dispatchSyncDeadLock {\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_main_queue(), ^{ // Dead Lock\n        // do Something\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n```\n\n分析一下死锁怎么发生的：\n1. 任务是放到主队列（串行队列）里面，串行队列任务是一个一个执行的\n2. dispatch_sync需要等待block执行完成发返回，block需要等待前面的任务执行完成，也就是dispatch_sync执行完成。两者相互等待，永远不会执行完成，造成了死锁。\n\n从中看出死锁是：`使用了dispatch_sync将任务加入串行队列`\n\n如果是并行队列，则不会造成死锁。\n\n## dispatch_after\n在开发中经常需要到延迟几秒再执行的代码的情况，GCD也有这样的API:\n\n```objc\nvoid dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work);\n```\nwhen表示时间，如果传入 `DISPATCH_TIME_NOW` 会等同于 `dispatch_async` ，另外不允许传入 `DISPATCH_TIME_FOREVER` ，这会永远阻塞线程。\n\n```objc\n- (void)dispatchAfter {\n    NSLog(@\"1\");\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n```\n需要注意的是，dispatch_after 函数并不是在指定时间后执行处理，而只是在指定时间追加处理到 Dispatch Queue。此源代码与在3秒后用 dispatch_async 函数追加 Block 到 Main Dispatch Queue 相同。\n\n因为 Main Dispatch Queue 在主线程的 RunLoop 中执行，所以在比如每隔1/60秒执行的 RunLoop 中，Block 最快在3秒后执行，最慢在3秒+1/60秒后执行，并且在 Main Dispatch Queue 有大量处理追加或者主线程的处理本身有延迟时，这个时间会更长。\n\n虽然在有严格时间的要求下使用时会出现问题，但在想大致延迟处理时，该函数是非常有效的。\n\n例子中 `dispatch_time` 参数原型是这样的\n\n```objc\ndispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta );\n```\n第一个参数用 `DISPATCH_TIME_NOW`表示当前。第二个参数delta表示纳秒，1秒=1000000000纳秒，系统用一些宏来简化\n\n```objc\n #define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒\n #define USEC_PER_SEC 1000000ull    //每毫秒有多少纳秒\n #define NSEC_PER_USEC 1000ull      //每秒有多少毫秒\n```\n\n这样1秒可以这样写：\n\n```objc\ndispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);\ndispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC);\ndispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC);\n```\n\n## dispatch_once\nGCD中还有保证在应用程序中只执行一次指定处理的API。\n\n```objc\n- (void)dispatchOne {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        // do Something\n    });\n}\n```\n通常通过这种方式生成单例对象。\n\n## dispatch_groups\n\n在追加到 Dispatch Queue 中的多个处理全部结束后想执行结束处理，这种情况会经常出现。如果使用一个 Serial Dispatch Queue  时，只要将想执行的处理全部追加到该 Serial Dispatch Queue 中并在最后追加结束处理，即可实现。但是在使用 Concurrent Dispatch Queue 时或同时使用多个Dispatch Queue 时，代码将会变得复杂。\n\n这是 Dispatch Group 将派上用场了。\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\n    \ndispatch_group_async(group, queue, ^{\n   NSLog(@\"1\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"2\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"3\");\n});\n    \ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n   NSLog(@\"done\");\n});\n```\n例子中追加了3个 Block 到 Global Dispatch Queue，这些 Block 执行完成完毕后，执行 Main Dispatch Queue 中的结束处理。\n\n在监听多个异步任务的时候，用到了`dispatch_group_notify`函数，它是异步执行，不会阻塞线程，第一个参数指定为要监视的 Dispatch Group。在追加到该 Dispatch Group 的全部处理执行结束时，将第三个参数的 Block 追加到的第二个参数的 Dispatch Queue 中。在 dispatch_group_notify 函数中不管指定什么样的 Dispatch Queue，属于 Dispatch Group 的全部处理在追加指定的 Block 时都已执行结束。\n\n在 GCD API 中还有一个监听多个异步任务的函数 `dispatch_group_wait` 会阻塞当前线程，等待所有任务都完成或等待超时。这里的等待是指一旦调用 dispatch_group_wait 函数，该函数就处于调用状态而不返回。即执行 dispatch_group_wait 函数的当前线程停止。在经过 dispatch_group_wait 函数中指定的时间或属于指定 Dispatch Group 的处理全部执行结束之前，执行该函数的线程停止。\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\n    \ndispatch_group_async(group, queue, ^{\n   NSLog(@\"1\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"2\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"3\");\n});\n    \ndispatch_group_wait(group, DISPATCH_TIME_FOREVER);\n```\n\ndispatch_group_wait 函数的第二个参数指定为等待的时间（超时）。它是 dispatch_time_t 类型的值。例子中用了 **DISPATCH_TIME_FOREVER** ，意思是永久等待。只要属于 Dispatch Group 的处理 尚未执行结束，就会一直等待，中途不能取消。\n\n如果指定等待间隔为1秒是应做如下处理：\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\n    \ndispatch_group_async(group, queue, ^{\n   NSLog(@\"1\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"2\");\n});\ndispatch_group_async(group, queue, ^{\n   NSLog(@\"3\");\n});\n    \ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);\nNSInteger result = dispatch_group_wait(group, time);\nif (result == 0) {\n   // 属于 Dispatch Group 的全部处理执行结束\n} else {\n   // 属于 Dispatch Group 的某个处理还在执行中\n}\n```\n如果 dispatch_group_wait 函数的返回值不为 0 ，就意味着虽然经过了指定的时间，但属于 Dispatch Group 的某个处理还在执行中。如果返回值为 0 ，那么全部处理执行结束。如果使用 **DISPATCH_TIME_FOREVER** ，属于 Dispatch Group 的全部处理必定全部执行结束，因此返回值恒为 0 。\n\n如果使用 **DISPATCH_TIME_NOW** ，则不用任何等待即可判定属于 Dispatch Group 的处理是否执行结束。\n\n## dispatch_barrier_async\n在访问数据库或文件时，如果使用 Serial Dispatch Queue 可以避免数据竞争的问题。\n写入操作不能和其他的写入操作以及包含读取处理的其他某些处理并行执行。如果只是读取操作和读取操作并行执行，那么多个并行执行不会发生问题。\n\nGCD 为我们提供非常简便的解决方法 `dispatch_barrier_async` 函数。\n\n首先 dispatch_queue_create 函数生成 Concurrent Dispatch Queue，在 dispatch_async 中追加读取操作：\n\n```objc\ndispatch_queue_t queue = dispatch_queue_create(\"com.piglikeyoung.gcd.concurrentqueue\", DISPATCH_QUEUE_CONCURRENT);\n\ndispatch_async(queue, blk0_for_reading);\ndispatch_async(queue, blk1_for_reading);\ndispatch_async(queue, blk2_for_reading);\ndispatch_async(queue, blk3_for_reading);\ndispatch_async(queue, blk4_for_reading);\ndispatch_async(queue, blk5_for_reading);\ndispatch_async(queue, blk6_for_reading);\n```\n在 blk3_for_reading 处理和 blk4_for_reading 处理之间执行写入操作，并将写入的内容在 blk4_for_reading 处理以及之后的处理中获取。\n\n```objc\ndispatch_async(queue, blk0_for_reading);\ndispatch_async(queue, blk1_for_reading);\ndispatch_async(queue, blk2_for_reading);\ndispatch_async(queue, blk3_for_reading);\ndispatch_async(queue, blk_for_writing);\ndispatch_async(queue, blk4_for_reading);\ndispatch_async(queue, blk5_for_reading);\ndispatch_async(queue, blk6_for_reading);\n```\n如果是简单把写入操作加入 Concurrent Dispatch Queue，那么读取到的数据有可能和预期不符，如果是多个读取和多个写入混合并发，有可能引起数据竞争的问题。\n\n这时候使用 `dispatch_barrier_async` 函数，**dispatch_barrier_async** 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束后，再将指定的处理追加到该 Concurrent Dispatch Queue 中。然后在由 dispatch_barrier_async 函数追加的处理执行完毕后，Concurrent Dispatch Queue 才恢复一般的动作，追加到该 Concurrent Dispatch Queue 的处理又开始并行执行。\n\n```objc\ndispatch_async(queue, blk0_for_reading);\ndispatch_async(queue, blk1_for_reading);\ndispatch_async(queue, blk2_for_reading);\ndispatch_async(queue, blk3_for_reading);\ndispatch_barrier_async(queue, blk_for_writing);\ndispatch_async(queue, blk4_for_reading);\ndispatch_async(queue, blk5_for_reading);\ndispatch_async(queue, blk6_for_reading);\n```\ndispatch_barrier_async 处理流程图如下：\n{% asset_img Snip20161005_1.png DNS %}\n\n\n> 注意：dispatch_barrier_async 只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和 dispatch_sync 一样\n\n\n## dispatch_apply\ndispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联 API。该函数按指定的次数将指定的 Block 追加到指定的 Dispatch Queue 中，并等待全部处理执行结束。\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);\ndispatch_apply(10, queue, ^(size_t index) {\n   NSLog(@\"%zd\", index);\n});\nNSLog(@\"done\");\n```\n\n因为是在全局并发队列中执行处理，所以打印的顺序不定。但输出结果中最后的 done 肯定是在最后。因为 dispatch_apply 函数会等待全部处理执行结束。\n\n第一个参数是重复次数，第二个参数是追加对象的 Dispatch Queue ，第三个参数是追加的处理。不同的是第三个参数是带参数的block，这是为了按第一个参数重复追加 Block 并区分各个 Block 而使用。\n\n由于 dispatch_apply 函数也和 dispatch_sync 函数相同，会等待处理执行结束，**因此推荐在 dispatch_async 函数中非同步地执行  dispatch_apply 函数**，而且能够避免线程爆炸，因为GCD会管理并发。\n\n## 参考资料\n* [官方文档](https://developer.apple.com/reference/dispatch)\n* Objective-C 高级编程 iOS与OS X多线程和内存管理\n\n\n","slug":"Using-Grand-Central-Dispatch-2","published":1,"updated":"2016-10-05T08:11:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7o5004o8jpbtq6bcp6m","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前一篇文章（<a href=\"http://piglikeyoung.com/2016/09/25/Using-Grand-Central-Dispatch-1/\">链接</a>）已经简单的介绍GCD的简单使用，这篇文章继续使用GCD。</p>\n<h2 id=\"dispatch-async\"><a href=\"#dispatch-async\" class=\"headerlink\" title=\"dispatch_async\"></a>dispatch_async</h2><p>GCD中有2个异步的API：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">dispatch_async</span>(<span class=\"built_in\">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class=\"line\"><span class=\"keyword\">void</span> dispatch_async_f(<span class=\"built_in\">dispatch_queue_t</span> queue, <span class=\"keyword\">void</span> *context, dispatch_function_t work);</span><br></pre></td></tr></table></figure>\n<p>这两个API都是将一个任务提交到queue中，提交之后立刻返回，不等待任务执行完成。系统会对queue做retain操作，任务执行完成后，queue才被release。两者的区别在于<code>dispatch_async</code>接受block作为参数，<code>dispatch_async_f</code>接受函数。</p>\n<p><code>dispatch_async_f</code>中，<strong>context</strong>作为第一个参数传给<strong>work</strong>函数。如果<strong>work</strong>不需要参数，<strong>context</strong>可以传入<strong>NULL</strong>。<strong>work</strong>参数不能传入<strong>NULL</strong>，否则会发生不可预料的事。</p>\n<blockquote>\n<p>使用GCD的时候，block会被copy，block会在执行完之后release，而且block是被系统持有的，所以不用担心循环引用的问题，<strong>block里面的self不需要weak</strong>。</p>\n</blockquote>\n<p><code>async</code>是异步的意思，至于怎么异步，看下面的例子：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchAsync &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do Something</span></span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);<span class=\"comment\">// 1，3，2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为block是异步的，打印不是按照1，2，3的顺序打印的，简单点说，就是block里面的任务添加到队列后，GCD立刻返回，不阻塞线程，不需要等待任务执行完成。</p>\n<p>就像上面的例子，先打印 ”1“ ，block添加主队列里，添加完成立刻返回，然后打印 ”3“，等主队列里面前面的任务执行完成再打印 ”2“。</p>\n<h2 id=\"dispatch-sync\"><a href=\"#dispatch-sync\" class=\"headerlink\" title=\"dispatch_sync\"></a>dispatch_sync</h2><p>和异步一样，GCD同步也有两个API：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">dispatch_sync</span>(<span class=\"built_in\">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class=\"line\"><span class=\"keyword\">void</span> dispatch_sync_f(<span class=\"built_in\">dispatch_queue_t</span> queue, <span class=\"keyword\">void</span> *context, dispatch_function_t work);</span><br></pre></td></tr></table></figure>\n<p>参数内容和<code>dispatch_async</code>一样，不同的是任务加入queue之后不会立刻返回，阻塞线程，等待任务执行完成后再返回。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchSync &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do Something</span></span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);<span class=\"comment\">// 1，2，3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从打印可以看出，打印是按照顺序来的</p>\n<ol>\n<li>先打印 ”1“ </li>\n<li>然后dispatch_sync会将block提交到global queue中，等待block的执行</li>\n<li>全局队列中block前面的任务执行完成后，block执行</li>\n<li>block执行完成后，dispatch_sync返回</li>\n<li>dispatch_sync之后的代码执行，打印 ”3“</li>\n</ol>\n<p>从示例代码中可以看出我在全局队列做同步操作的，没有在主队列里面做，是因为dispatch_sync需要等待block被执行，非常容易发生死锁，特别是在串行队列里面，而且主队列就是串行队列。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchSyncDeadLock &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123; <span class=\"comment\">// Dead Lock</span></span><br><span class=\"line\">        <span class=\"comment\">// do Something</span></span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析一下死锁怎么发生的：</p>\n<ol>\n<li>任务是放到主队列（串行队列）里面，串行队列任务是一个一个执行的</li>\n<li>dispatch_sync需要等待block执行完成发返回，block需要等待前面的任务执行完成，也就是dispatch_sync执行完成。两者相互等待，永远不会执行完成，造成了死锁。</li>\n</ol>\n<p>从中看出死锁是：<code>使用了dispatch_sync将任务加入串行队列</code></p>\n<p>如果是并行队列，则不会造成死锁。</p>\n<h2 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h2><p>在开发中经常需要到延迟几秒再执行的代码的情况，GCD也有这样的API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> dispatch_after(dispatch_time_t when, <span class=\"built_in\">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class=\"line\"><span class=\"keyword\">void</span> dispatch_after_f(dispatch_time_t when, <span class=\"built_in\">dispatch_queue_t</span> queue, <span class=\"keyword\">void</span> *context, dispatch_function_t work);</span><br></pre></td></tr></table></figure>\n<p>when表示时间，如果传入 <code>DISPATCH_TIME_NOW</code> 会等同于 <code>dispatch_async</code> ，另外不允许传入 <code>DISPATCH_TIME_FOREVER</code> ，这会永远阻塞线程。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchAfter &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">3</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，dispatch_after 函数并不是在指定时间后执行处理，而只是在指定时间追加处理到 Dispatch Queue。此源代码与在3秒后用 dispatch_async 函数追加 Block 到 Main Dispatch Queue 相同。</p>\n<p>因为 Main Dispatch Queue 在主线程的 RunLoop 中执行，所以在比如每隔1/60秒执行的 RunLoop 中，Block 最快在3秒后执行，最慢在3秒+1/60秒后执行，并且在 Main Dispatch Queue 有大量处理追加或者主线程的处理本身有延迟时，这个时间会更长。</p>\n<p>虽然在有严格时间的要求下使用时会出现问题，但在想大致延迟处理时，该函数是非常有效的。</p>\n<p>例子中 <code>dispatch_time</code> 参数原型是这样的</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta );</span><br></pre></td></tr></table></figure>\n<p>第一个参数用 <code>DISPATCH_TIME_NOW</code>表示当前。第二个参数delta表示纳秒，1秒=1000000000纳秒，系统用一些宏来简化</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒</span></span><br><span class=\"line\"><span class=\"meta\">#define USEC_PER_SEC 1000000ull    //每毫秒有多少纳秒</span></span><br><span class=\"line\"><span class=\"meta\">#define NSEC_PER_USEC 1000ull      //每秒有多少毫秒</span></span><br></pre></td></tr></table></figure>\n<p>这样1秒可以这样写：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_time(DISPATCH_TIME_NOW, <span class=\"number\">1</span> * <span class=\"built_in\">NSEC_PER_SEC</span>);</span><br><span class=\"line\">dispatch_time(DISPATCH_TIME_NOW, <span class=\"number\">1000</span> * USEC_PER_SEC);</span><br><span class=\"line\">dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * <span class=\"built_in\">NSEC_PER_USEC</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h2><p>GCD中还有保证在应用程序中只执行一次指定处理的API。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchOne &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do Something</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通常通过这种方式生成单例对象。</p>\n<h2 id=\"dispatch-groups\"><a href=\"#dispatch-groups\" class=\"headerlink\" title=\"dispatch_groups\"></a>dispatch_groups</h2><p>在追加到 Dispatch Queue 中的多个处理全部结束后想执行结束处理，这种情况会经常出现。如果使用一个 Serial Dispatch Queue  时，只要将想执行的处理全部追加到该 Serial Dispatch Queue 中并在最后追加结束处理，即可实现。但是在使用 Concurrent Dispatch Queue 时或同时使用多个Dispatch Queue 时，代码将会变得复杂。</p>\n<p>这是 Dispatch Group 将派上用场了。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"done\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>例子中追加了3个 Block 到 Global Dispatch Queue，这些 Block 执行完成完毕后，执行 Main Dispatch Queue 中的结束处理。</p>\n<p>在监听多个异步任务的时候，用到了<code>dispatch_group_notify</code>函数，它是异步执行，不会阻塞线程，第一个参数指定为要监视的 Dispatch Group。在追加到该 Dispatch Group 的全部处理执行结束时，将第三个参数的 Block 追加到的第二个参数的 Dispatch Queue 中。在 dispatch_group_notify 函数中不管指定什么样的 Dispatch Queue，属于 Dispatch Group 的全部处理在追加指定的 Block 时都已执行结束。</p>\n<p>在 GCD API 中还有一个监听多个异步任务的函数 <code>dispatch_group_wait</code> 会阻塞当前线程，等待所有任务都完成或等待超时。这里的等待是指一旦调用 dispatch_group_wait 函数，该函数就处于调用状态而不返回。即执行 dispatch_group_wait 函数的当前线程停止。在经过 dispatch_group_wait 函数中指定的时间或属于指定 Dispatch Group 的处理全部执行结束之前，执行该函数的线程停止。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>\n<p>dispatch_group_wait 函数的第二个参数指定为等待的时间（超时）。它是 dispatch_time_t 类型的值。例子中用了 <strong>DISPATCH_TIME_FOREVER</strong> ，意思是永久等待。只要属于 Dispatch Group 的处理 尚未执行结束，就会一直等待，中途不能取消。</p>\n<p>如果指定等待间隔为1秒是应做如下处理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class=\"number\">1</span> * <span class=\"built_in\">NSEC_PER_SEC</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSInteger</span> result = dispatch_group_wait(group, time);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 属于 Dispatch Group 的全部处理执行结束</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 属于 Dispatch Group 的某个处理还在执行中</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果 dispatch_group_wait 函数的返回值不为 0 ，就意味着虽然经过了指定的时间，但属于 Dispatch Group 的某个处理还在执行中。如果返回值为 0 ，那么全部处理执行结束。如果使用 <strong>DISPATCH_TIME_FOREVER</strong> ，属于 Dispatch Group 的全部处理必定全部执行结束，因此返回值恒为 0 。</p>\n<p>如果使用 <strong>DISPATCH_TIME_NOW</strong> ，则不用任何等待即可判定属于 Dispatch Group 的处理是否执行结束。</p>\n<h2 id=\"dispatch-barrier-async\"><a href=\"#dispatch-barrier-async\" class=\"headerlink\" title=\"dispatch_barrier_async\"></a>dispatch_barrier_async</h2><p>在访问数据库或文件时，如果使用 Serial Dispatch Queue 可以避免数据竞争的问题。<br>写入操作不能和其他的写入操作以及包含读取处理的其他某些处理并行执行。如果只是读取操作和读取操作并行执行，那么多个并行执行不会发生问题。</p>\n<p>GCD 为我们提供非常简便的解决方法 <code>dispatch_barrier_async</code> 函数。</p>\n<p>首先 dispatch_queue_create 函数生成 Concurrent Dispatch Queue，在 dispatch_async 中追加读取操作：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.concurrentqueue\"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk0_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk1_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk2_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk3_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk4_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk5_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk6_for_reading);</span><br></pre></td></tr></table></figure>\n<p>在 blk3_for_reading 处理和 blk4_for_reading 处理之间执行写入操作，并将写入的内容在 blk4_for_reading 处理以及之后的处理中获取。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk0_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk1_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk2_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk3_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk_for_writing);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk4_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk5_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk6_for_reading);</span><br></pre></td></tr></table></figure>\n<p>如果是简单把写入操作加入 Concurrent Dispatch Queue，那么读取到的数据有可能和预期不符，如果是多个读取和多个写入混合并发，有可能引起数据竞争的问题。</p>\n<p>这时候使用 <code>dispatch_barrier_async</code> 函数，<strong>dispatch_barrier_async</strong> 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束后，再将指定的处理追加到该 Concurrent Dispatch Queue 中。然后在由 dispatch_barrier_async 函数追加的处理执行完毕后，Concurrent Dispatch Queue 才恢复一般的动作，追加到该 Concurrent Dispatch Queue 的处理又开始并行执行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk0_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk1_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk2_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk3_for_reading);</span><br><span class=\"line\">dispatch_barrier_async(queue, blk_for_writing);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk4_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk5_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk6_for_reading);</span><br></pre></td></tr></table></figure>\n<p>dispatch_barrier_async 处理流程图如下：<br><img src=\"/2016/10/01/Using-Grand-Central-Dispatch-2/Snip20161005_1.png\" title=\"DNS\"></p>\n<blockquote>\n<p>注意：dispatch_barrier_async 只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和 dispatch_sync 一样</p>\n</blockquote>\n<h2 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h2><p>dispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联 API。该函数按指定的次数将指定的 Block 追加到指定的 Dispatch Queue 中，并等待全部处理执行结束。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\">dispatch_apply(<span class=\"number\">10</span>, queue, ^(size_t index) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%zd\"</span>, index);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"done\"</span>);</span><br></pre></td></tr></table></figure>\n<p>因为是在全局并发队列中执行处理，所以打印的顺序不定。但输出结果中最后的 done 肯定是在最后。因为 dispatch_apply 函数会等待全部处理执行结束。</p>\n<p>第一个参数是重复次数，第二个参数是追加对象的 Dispatch Queue ，第三个参数是追加的处理。不同的是第三个参数是带参数的block，这是为了按第一个参数重复追加 Block 并区分各个 Block 而使用。</p>\n<p>由于 dispatch_apply 函数也和 dispatch_sync 函数相同，会等待处理执行结束，<strong>因此推荐在 dispatch_async 函数中非同步地执行  dispatch_apply 函数</strong>，而且能够避免线程爆炸，因为GCD会管理并发。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://developer.apple.com/reference/dispatch\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>Objective-C 高级编程 iOS与OS X多线程和内存管理</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前一篇文章（<a href=\"http://piglikeyoung.com/2016/09/25/Using-Grand-Central-Dispatch-1/\">链接</a>）已经简单的介绍GCD的简单使用，这篇文章继续使用GCD。</p>\n<h2 id=\"dispatch-async\"><a href=\"#dispatch-async\" class=\"headerlink\" title=\"dispatch_async\"></a>dispatch_async</h2><p>GCD中有2个异步的API：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">dispatch_async</span>(<span class=\"built_in\">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class=\"line\"><span class=\"keyword\">void</span> dispatch_async_f(<span class=\"built_in\">dispatch_queue_t</span> queue, <span class=\"keyword\">void</span> *context, dispatch_function_t work);</span><br></pre></td></tr></table></figure>\n<p>这两个API都是将一个任务提交到queue中，提交之后立刻返回，不等待任务执行完成。系统会对queue做retain操作，任务执行完成后，queue才被release。两者的区别在于<code>dispatch_async</code>接受block作为参数，<code>dispatch_async_f</code>接受函数。</p>\n<p><code>dispatch_async_f</code>中，<strong>context</strong>作为第一个参数传给<strong>work</strong>函数。如果<strong>work</strong>不需要参数，<strong>context</strong>可以传入<strong>NULL</strong>。<strong>work</strong>参数不能传入<strong>NULL</strong>，否则会发生不可预料的事。</p>\n<blockquote>\n<p>使用GCD的时候，block会被copy，block会在执行完之后release，而且block是被系统持有的，所以不用担心循环引用的问题，<strong>block里面的self不需要weak</strong>。</p>\n</blockquote>\n<p><code>async</code>是异步的意思，至于怎么异步，看下面的例子：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchAsync &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do Something</span></span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);<span class=\"comment\">// 1，3，2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为block是异步的，打印不是按照1，2，3的顺序打印的，简单点说，就是block里面的任务添加到队列后，GCD立刻返回，不阻塞线程，不需要等待任务执行完成。</p>\n<p>就像上面的例子，先打印 ”1“ ，block添加主队列里，添加完成立刻返回，然后打印 ”3“，等主队列里面前面的任务执行完成再打印 ”2“。</p>\n<h2 id=\"dispatch-sync\"><a href=\"#dispatch-sync\" class=\"headerlink\" title=\"dispatch_sync\"></a>dispatch_sync</h2><p>和异步一样，GCD同步也有两个API：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">dispatch_sync</span>(<span class=\"built_in\">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class=\"line\"><span class=\"keyword\">void</span> dispatch_sync_f(<span class=\"built_in\">dispatch_queue_t</span> queue, <span class=\"keyword\">void</span> *context, dispatch_function_t work);</span><br></pre></td></tr></table></figure>\n<p>参数内容和<code>dispatch_async</code>一样，不同的是任务加入queue之后不会立刻返回，阻塞线程，等待任务执行完成后再返回。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchSync &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do Something</span></span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);<span class=\"comment\">// 1，2，3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从打印可以看出，打印是按照顺序来的</p>\n<ol>\n<li>先打印 ”1“ </li>\n<li>然后dispatch_sync会将block提交到global queue中，等待block的执行</li>\n<li>全局队列中block前面的任务执行完成后，block执行</li>\n<li>block执行完成后，dispatch_sync返回</li>\n<li>dispatch_sync之后的代码执行，打印 ”3“</li>\n</ol>\n<p>从示例代码中可以看出我在全局队列做同步操作的，没有在主队列里面做，是因为dispatch_sync需要等待block被执行，非常容易发生死锁，特别是在串行队列里面，而且主队列就是串行队列。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchSyncDeadLock &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123; <span class=\"comment\">// Dead Lock</span></span><br><span class=\"line\">        <span class=\"comment\">// do Something</span></span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析一下死锁怎么发生的：</p>\n<ol>\n<li>任务是放到主队列（串行队列）里面，串行队列任务是一个一个执行的</li>\n<li>dispatch_sync需要等待block执行完成发返回，block需要等待前面的任务执行完成，也就是dispatch_sync执行完成。两者相互等待，永远不会执行完成，造成了死锁。</li>\n</ol>\n<p>从中看出死锁是：<code>使用了dispatch_sync将任务加入串行队列</code></p>\n<p>如果是并行队列，则不会造成死锁。</p>\n<h2 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h2><p>在开发中经常需要到延迟几秒再执行的代码的情况，GCD也有这样的API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> dispatch_after(dispatch_time_t when, <span class=\"built_in\">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class=\"line\"><span class=\"keyword\">void</span> dispatch_after_f(dispatch_time_t when, <span class=\"built_in\">dispatch_queue_t</span> queue, <span class=\"keyword\">void</span> *context, dispatch_function_t work);</span><br></pre></td></tr></table></figure>\n<p>when表示时间，如果传入 <code>DISPATCH_TIME_NOW</code> 会等同于 <code>dispatch_async</code> ，另外不允许传入 <code>DISPATCH_TIME_FOREVER</code> ，这会永远阻塞线程。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchAfter &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">3</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，dispatch_after 函数并不是在指定时间后执行处理，而只是在指定时间追加处理到 Dispatch Queue。此源代码与在3秒后用 dispatch_async 函数追加 Block 到 Main Dispatch Queue 相同。</p>\n<p>因为 Main Dispatch Queue 在主线程的 RunLoop 中执行，所以在比如每隔1/60秒执行的 RunLoop 中，Block 最快在3秒后执行，最慢在3秒+1/60秒后执行，并且在 Main Dispatch Queue 有大量处理追加或者主线程的处理本身有延迟时，这个时间会更长。</p>\n<p>虽然在有严格时间的要求下使用时会出现问题，但在想大致延迟处理时，该函数是非常有效的。</p>\n<p>例子中 <code>dispatch_time</code> 参数原型是这样的</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta );</span><br></pre></td></tr></table></figure>\n<p>第一个参数用 <code>DISPATCH_TIME_NOW</code>表示当前。第二个参数delta表示纳秒，1秒=1000000000纳秒，系统用一些宏来简化</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒</span></span><br><span class=\"line\"><span class=\"meta\">#define USEC_PER_SEC 1000000ull    //每毫秒有多少纳秒</span></span><br><span class=\"line\"><span class=\"meta\">#define NSEC_PER_USEC 1000ull      //每秒有多少毫秒</span></span><br></pre></td></tr></table></figure>\n<p>这样1秒可以这样写：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_time(DISPATCH_TIME_NOW, <span class=\"number\">1</span> * <span class=\"built_in\">NSEC_PER_SEC</span>);</span><br><span class=\"line\">dispatch_time(DISPATCH_TIME_NOW, <span class=\"number\">1000</span> * USEC_PER_SEC);</span><br><span class=\"line\">dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * <span class=\"built_in\">NSEC_PER_USEC</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h2><p>GCD中还有保证在应用程序中只执行一次指定处理的API。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dispatchOne &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do Something</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通常通过这种方式生成单例对象。</p>\n<h2 id=\"dispatch-groups\"><a href=\"#dispatch-groups\" class=\"headerlink\" title=\"dispatch_groups\"></a>dispatch_groups</h2><p>在追加到 Dispatch Queue 中的多个处理全部结束后想执行结束处理，这种情况会经常出现。如果使用一个 Serial Dispatch Queue  时，只要将想执行的处理全部追加到该 Serial Dispatch Queue 中并在最后追加结束处理，即可实现。但是在使用 Concurrent Dispatch Queue 时或同时使用多个Dispatch Queue 时，代码将会变得复杂。</p>\n<p>这是 Dispatch Group 将派上用场了。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"done\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>例子中追加了3个 Block 到 Global Dispatch Queue，这些 Block 执行完成完毕后，执行 Main Dispatch Queue 中的结束处理。</p>\n<p>在监听多个异步任务的时候，用到了<code>dispatch_group_notify</code>函数，它是异步执行，不会阻塞线程，第一个参数指定为要监视的 Dispatch Group。在追加到该 Dispatch Group 的全部处理执行结束时，将第三个参数的 Block 追加到的第二个参数的 Dispatch Queue 中。在 dispatch_group_notify 函数中不管指定什么样的 Dispatch Queue，属于 Dispatch Group 的全部处理在追加指定的 Block 时都已执行结束。</p>\n<p>在 GCD API 中还有一个监听多个异步任务的函数 <code>dispatch_group_wait</code> 会阻塞当前线程，等待所有任务都完成或等待超时。这里的等待是指一旦调用 dispatch_group_wait 函数，该函数就处于调用状态而不返回。即执行 dispatch_group_wait 函数的当前线程停止。在经过 dispatch_group_wait 函数中指定的时间或属于指定 Dispatch Group 的处理全部执行结束之前，执行该函数的线程停止。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>\n<p>dispatch_group_wait 函数的第二个参数指定为等待的时间（超时）。它是 dispatch_time_t 类型的值。例子中用了 <strong>DISPATCH_TIME_FOREVER</strong> ，意思是永久等待。只要属于 Dispatch Group 的处理 尚未执行结束，就会一直等待，中途不能取消。</p>\n<p>如果指定等待间隔为1秒是应做如下处理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"3\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class=\"number\">1</span> * <span class=\"built_in\">NSEC_PER_SEC</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSInteger</span> result = dispatch_group_wait(group, time);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 属于 Dispatch Group 的全部处理执行结束</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 属于 Dispatch Group 的某个处理还在执行中</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果 dispatch_group_wait 函数的返回值不为 0 ，就意味着虽然经过了指定的时间，但属于 Dispatch Group 的某个处理还在执行中。如果返回值为 0 ，那么全部处理执行结束。如果使用 <strong>DISPATCH_TIME_FOREVER</strong> ，属于 Dispatch Group 的全部处理必定全部执行结束，因此返回值恒为 0 。</p>\n<p>如果使用 <strong>DISPATCH_TIME_NOW</strong> ，则不用任何等待即可判定属于 Dispatch Group 的处理是否执行结束。</p>\n<h2 id=\"dispatch-barrier-async\"><a href=\"#dispatch-barrier-async\" class=\"headerlink\" title=\"dispatch_barrier_async\"></a>dispatch_barrier_async</h2><p>在访问数据库或文件时，如果使用 Serial Dispatch Queue 可以避免数据竞争的问题。<br>写入操作不能和其他的写入操作以及包含读取处理的其他某些处理并行执行。如果只是读取操作和读取操作并行执行，那么多个并行执行不会发生问题。</p>\n<p>GCD 为我们提供非常简便的解决方法 <code>dispatch_barrier_async</code> 函数。</p>\n<p>首先 dispatch_queue_create 函数生成 Concurrent Dispatch Queue，在 dispatch_async 中追加读取操作：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(<span class=\"string\">\"com.piglikeyoung.gcd.concurrentqueue\"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk0_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk1_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk2_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk3_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk4_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk5_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk6_for_reading);</span><br></pre></td></tr></table></figure>\n<p>在 blk3_for_reading 处理和 blk4_for_reading 处理之间执行写入操作，并将写入的内容在 blk4_for_reading 处理以及之后的处理中获取。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk0_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk1_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk2_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk3_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk_for_writing);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk4_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk5_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk6_for_reading);</span><br></pre></td></tr></table></figure>\n<p>如果是简单把写入操作加入 Concurrent Dispatch Queue，那么读取到的数据有可能和预期不符，如果是多个读取和多个写入混合并发，有可能引起数据竞争的问题。</p>\n<p>这时候使用 <code>dispatch_barrier_async</code> 函数，<strong>dispatch_barrier_async</strong> 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束后，再将指定的处理追加到该 Concurrent Dispatch Queue 中。然后在由 dispatch_barrier_async 函数追加的处理执行完毕后，Concurrent Dispatch Queue 才恢复一般的动作，追加到该 Concurrent Dispatch Queue 的处理又开始并行执行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk0_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk1_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk2_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk3_for_reading);</span><br><span class=\"line\">dispatch_barrier_async(queue, blk_for_writing);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk4_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk5_for_reading);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, blk6_for_reading);</span><br></pre></td></tr></table></figure>\n<p>dispatch_barrier_async 处理流程图如下：<br><img src=\"/2016/10/01/Using-Grand-Central-Dispatch-2/Snip20161005_1.png\" title=\"DNS\"></p>\n<blockquote>\n<p>注意：dispatch_barrier_async 只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和 dispatch_sync 一样</p>\n</blockquote>\n<h2 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h2><p>dispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联 API。该函数按指定的次数将指定的 Block 追加到指定的 Dispatch Queue 中，并等待全部处理执行结束。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\">dispatch_apply(<span class=\"number\">10</span>, queue, ^(size_t index) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%zd\"</span>, index);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"done\"</span>);</span><br></pre></td></tr></table></figure>\n<p>因为是在全局并发队列中执行处理，所以打印的顺序不定。但输出结果中最后的 done 肯定是在最后。因为 dispatch_apply 函数会等待全部处理执行结束。</p>\n<p>第一个参数是重复次数，第二个参数是追加对象的 Dispatch Queue ，第三个参数是追加的处理。不同的是第三个参数是带参数的block，这是为了按第一个参数重复追加 Block 并区分各个 Block 而使用。</p>\n<p>由于 dispatch_apply 函数也和 dispatch_sync 函数相同，会等待处理执行结束，<strong>因此推荐在 dispatch_async 函数中非同步地执行  dispatch_apply 函数</strong>，而且能够避免线程爆炸，因为GCD会管理并发。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://developer.apple.com/reference/dispatch\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>Objective-C 高级编程 iOS与OS X多线程和内存管理</li>\n</ul>\n"},{"title":"学习CALayer（一）","date":"2016-10-15T08:43:40.000Z","_content":"\n## 前言\n我们都知道在iOS中每一个你看到的东西都是由View组成的，比如按钮视图，table视图等等。但是你可能不知道每个View背后都有一个叫做CALayer的类。本系列文章着重学习使用CALayer，CALayer和View的区别请参考：\n* [详解CALayer 和 UIView的区别和联系](http://www.jianshu.com/p/079e5cf0f014)\n* [View-Layer 协作](https://objccn.io/issue-12-4/)\n\n本章的内容大部分是从[CALayer Tutorial: Getting Started](http://www.raywenderlich.com/90488/calayer-in-ios-with-swift-10-examples)学习得来。\n\n## CALayer\nCALayer是接下来要学习到的Layers的基类，包含了很多基础属性，比如\n* **contents**：表示Layer呈现的内容，一般会设置为CGImage的对象\n* **contentsGravity**：表示内容对齐和填充方式\n* **cornerRadius**：表示Layer圆角半径，默认zero\n* **masksToBounds**：是否进行bounds的切割，设置圆角属性是会设置为YES\n\nLayer还有很多属性和View相似，比如**frame**，**bounds**等等用于设置Layer的位置。\n\nCALayer还有几个知识点：\n* Layers有subLayer，就像Views有subViews\n* Layer的properties能够产生隐式动画。当你改变Layer的property，它会默认产生隐式动画。你也可以使用自定义动画。\n* Layer比Views更轻量级，更能节约性能。\n* Layers有大量有用的properties。\n\n看下面这段代码：\n```objc\n// 1\n_layer = [CALayer new];\n_layer.frame = CGRectMake(0, 0, 200, 200);\n\n// 2\n_layer.contents = (__bridge id _Nullable)([[UIImage imageNamed:@\"star\"] CGImage]);\n_layer.contentsGravity = kCAGravityCenter;\n\n// 3\n_layer.magnificationFilter = kCAFilterLinear;\n_layer.geometryFlipped = NO;\n\n// 4\n_layer.backgroundColor = [kDefaultBackgroundColor CGColor];\n\n// 5\n_layer.cornerRadius = 100.0;\n_layer.borderWidth = 12.0;\n_layer.borderColor = [[UIColor whiteColor] CGColor];\n\n// 6\n_layer.shadowOpacity = 0.75;\n_layer.shadowOffset = CGSizeMake(0, 3);\n_layer.shadowRadius = 3.0;\n```\n\n分析：\n1. 创建了一个CALayer对象，设置它的frame\n2. 把layer的内容设置为一张图片，图片的格式是Quartz image data（CGImage）\n3. 设置内容对齐和填充方式\n4. 设置layer的背景色\n5. 设置layer的圆角弧度为自己宽度的一半（它就会变成圆形），设置它的边框宽度和颜色\n6. 设置layer的阴影透明度，阴影偏移量，阴影圆角半径\n\n最终效果：\n{% asset_img Snip20161029_1.png CALayer image %}\n\n**CALayer有附加属性能够提高性能**：\n* **shouldRasterize**：光栅化，设置为YES后CALayer会被光栅化为bitmap，layer的阴影等效果也会被保存到bitmap中，`缓存起来后不需要多次渲染提高了性能`，而对于经常变动的内容，这个时候不要开启，否则会造成性能的浪费。\n* **drawsAsynchronously**：异步渲染，这个和shouldRasterize正好相反，默认也是NO，设置为YES能够提高`需要反复渲染`layer内容的性能，比如之后会学习到的**emitter layer**连续渲染颗粒动画。\n\n> 提醒：在设置**shouldrasterize**或**drawsasynchronously**时，应该反复比较设置前后的性能，正确使用时，能够提高性能，误用时，性能可能会急转直下。\n\n> 注意：Layer不属于响应链条的一部分，它无法和View一样直接响应点击和手势。\n\n\n## CAScrollLayer\nCAScrollLayer是CALayer的子类，用于显示Layer的一部分，不能直接响应用户的触摸甚至检查滚动范围。CAScrollLayer的可滚动区域的范围是由它的子层布局来确定的。 CAScrollLayer不提供键盘或鼠标事件处理，也没有提供可见滚动条。 \n\nUIScrollView并没有用CAScrollLayer，事实上，就是简单的通过直接操作图层边界来实现滑动。\n\nCAScrollLayer可以设置它的滚动方向，还可以滚动到特定的点或者区域。\n\n```objc\n#import \"ScrollView.h\"\n@implementation ScrollView\n// 1\n+ (Class)layerClass\n{\n    return [CAScrollLayer class];\n}\n\n- (void)setUp\n{\n    //enable clipping\n    self.layer.masksToBounds = YES;\n\n    //attach pan gesture recognizer\n    UIPanGestureRecognizer *recognizer = nil;\n    recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];\n    [self addGestureRecognizer:recognizer];\n}\n\n- (id)initWithFrame:(CGRect)frame\n{\n    //this is called when view is created in code\n    if ((self = [super initWithFrame:frame])) {\n        [self setUp];\n    }\n    return self;\n}\n\n- (void)awakeFromNib {\n    //this is called when view is created from a nib\n    [self setUp];\n}\n\n- (void)pan:(UIPanGestureRecognizer *)recognizer\n{\n    //get the offset by subtracting the pan gesture\n    //translation from the current bounds origin\n    CGPoint offset = self.bounds.origin;\n    offset.x -= [recognizer translationInView:self].x;\n    offset.y -= [recognizer translationInView:self].y;\n\n    //scroll the layer\n    [(CAScrollLayer *)self.layer scrollToPoint:offset];\n\n    //reset the pan gesture translation\n    [recognizer setTranslation:CGPointZero inView:self];\n    \n    // 结束恢复原点\n//    if (sender.state == UIGestureRecognizerStateEnded) {\n//        [UIView animateWithDuration:0.3 animations:^{\n//            [self.scrollingViewLayer scrollToPoint:CGPointZero];\n//        }];\n//    }\n\n}\n@end\n```\n分析：\n1. 创建一个View的子类，重写**layerClass**方法，返回**CAScrollLayer**。这里修改了创建的Layer类，并添加它作为sublayer。\n2. 在手势响应方法中，它会滚到触摸点。注意：**scrollToPoint** 和 **scrollToRect**方法没有隐式动画，需要使用 UIView 动画才会有滚动动画。\n\n这里有一些经验规则时使用（或不使用）CAScrollLayer：\n* 如果你想使用轻量级的，只需要通过代码的方式滚动：考虑使用CAScrollLayer\n* 如果你想用户能够通过屏幕滚动：最好使用UIScrollView，了解更多可以点击[链接](https://videos.raywenderlich.com/courses/scroll-view-school/lessons/1)\n* 如果你要滚动非常巨大的图片：考虑使用CATiledLayer（接下来会学到）\n\n## CATextLayer\nCATextLayer能够简单而快速绘制普通文本或者富文本，和UILabel不一样，CATextLayer没有UIFont属性，只有 CTFontRef 或者 CGFontRef。\n\n\n```objc\n- (void)setUpTextLayer {\n\t// 1\n\tCFStringRef fontName = (__bridge CFStringRef)@\"Noteworthy-Light\";\n\tself.noteworthyLightFont = CTFontCreateWithName(fontName, baseFontSize, nil);\n\tfontName = (__bridge CFStringRef)@\"Helvetica\";\n\tself.helveticaFont = CTFontCreateWithName(fontName, baseFontSize, nil);\n\t\n\t// 2\n\tNSMutableString *string =[NSMutableString string];\n\tfor (NSInteger i = 0; i <= 20; i++) {\n\t\t[string appendFormat:@\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce auctor arcu quis velit congue dictum. \"];\n\t}\n\t// 3\n\tself.textLayer = ({\n\t   CATextLayer *layer = [CATextLayer layer];\n\t   layer.frame = self.viewForTextLayer.bounds;\n\t   layer.string = string;\n\t   layer.font = self.helveticaFont;\n\t   layer.foregroundColor = [[UIColor darkGrayColor] CGColor];\n\t   layer.wrapped = YES;\n\t   layer.alignmentMode = kCAAlignmentLeft;\n\t   layer.truncationMode = kCATruncationEnd;\n\t   layer.contentsScale = [[UIScreen mainScreen] scale];\n\t   layer;\n\t});\n}\n```\n分析：\n1. 创建给Layer赋值的字体\n2. 创建显示文本\n3. 创建CATextLayer并设置属性，contentsScale匹配当前屏幕的发大倍数\n\n不仅仅是CATextLayer，所有的Layer类，默认的放大系数**contentsScale**都是 1。当关联上Views时，layer会自动设置**contentsScale**与当前屏幕的放大系数一致。你手动创建的Layer时，需要设置**contentsScale**，否则它的放大系数和Retina不匹配。\n\n\n\n\n## 参考链接\n* [详解CALayer 和 UIView的区别和联系](http://www.jianshu.com/p/079e5cf0f014)\n* [View-Layer 协作](https://objccn.io/issue-12-4/)\n* [CALyer.h阅读笔记](http://www.360doc.com/content/16/0318/10/31697881_543270664.shtml)\n* [iOS-Core-Animation-Advanced-Techniques(七)](http://www.cocoachina.com/ios/20150106/10840.html)\n* [WWDC心得与延伸:iOS图形性能](http://www.cocoachina.com/ios/20150429/11712.html)\n* [iOS-Core-Animation-Advanced-Techniques](https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques)\n\n\n\n\n","source":"_posts/learn-CALayer-1.md","raw":"---\ntitle: 学习CALayer（一）\ndate: 2016-10-15 16:43:40\ntags: CALayer\ncategory: 能工巧匠\n---\n\n## 前言\n我们都知道在iOS中每一个你看到的东西都是由View组成的，比如按钮视图，table视图等等。但是你可能不知道每个View背后都有一个叫做CALayer的类。本系列文章着重学习使用CALayer，CALayer和View的区别请参考：\n* [详解CALayer 和 UIView的区别和联系](http://www.jianshu.com/p/079e5cf0f014)\n* [View-Layer 协作](https://objccn.io/issue-12-4/)\n\n本章的内容大部分是从[CALayer Tutorial: Getting Started](http://www.raywenderlich.com/90488/calayer-in-ios-with-swift-10-examples)学习得来。\n\n## CALayer\nCALayer是接下来要学习到的Layers的基类，包含了很多基础属性，比如\n* **contents**：表示Layer呈现的内容，一般会设置为CGImage的对象\n* **contentsGravity**：表示内容对齐和填充方式\n* **cornerRadius**：表示Layer圆角半径，默认zero\n* **masksToBounds**：是否进行bounds的切割，设置圆角属性是会设置为YES\n\nLayer还有很多属性和View相似，比如**frame**，**bounds**等等用于设置Layer的位置。\n\nCALayer还有几个知识点：\n* Layers有subLayer，就像Views有subViews\n* Layer的properties能够产生隐式动画。当你改变Layer的property，它会默认产生隐式动画。你也可以使用自定义动画。\n* Layer比Views更轻量级，更能节约性能。\n* Layers有大量有用的properties。\n\n看下面这段代码：\n```objc\n// 1\n_layer = [CALayer new];\n_layer.frame = CGRectMake(0, 0, 200, 200);\n\n// 2\n_layer.contents = (__bridge id _Nullable)([[UIImage imageNamed:@\"star\"] CGImage]);\n_layer.contentsGravity = kCAGravityCenter;\n\n// 3\n_layer.magnificationFilter = kCAFilterLinear;\n_layer.geometryFlipped = NO;\n\n// 4\n_layer.backgroundColor = [kDefaultBackgroundColor CGColor];\n\n// 5\n_layer.cornerRadius = 100.0;\n_layer.borderWidth = 12.0;\n_layer.borderColor = [[UIColor whiteColor] CGColor];\n\n// 6\n_layer.shadowOpacity = 0.75;\n_layer.shadowOffset = CGSizeMake(0, 3);\n_layer.shadowRadius = 3.0;\n```\n\n分析：\n1. 创建了一个CALayer对象，设置它的frame\n2. 把layer的内容设置为一张图片，图片的格式是Quartz image data（CGImage）\n3. 设置内容对齐和填充方式\n4. 设置layer的背景色\n5. 设置layer的圆角弧度为自己宽度的一半（它就会变成圆形），设置它的边框宽度和颜色\n6. 设置layer的阴影透明度，阴影偏移量，阴影圆角半径\n\n最终效果：\n{% asset_img Snip20161029_1.png CALayer image %}\n\n**CALayer有附加属性能够提高性能**：\n* **shouldRasterize**：光栅化，设置为YES后CALayer会被光栅化为bitmap，layer的阴影等效果也会被保存到bitmap中，`缓存起来后不需要多次渲染提高了性能`，而对于经常变动的内容，这个时候不要开启，否则会造成性能的浪费。\n* **drawsAsynchronously**：异步渲染，这个和shouldRasterize正好相反，默认也是NO，设置为YES能够提高`需要反复渲染`layer内容的性能，比如之后会学习到的**emitter layer**连续渲染颗粒动画。\n\n> 提醒：在设置**shouldrasterize**或**drawsasynchronously**时，应该反复比较设置前后的性能，正确使用时，能够提高性能，误用时，性能可能会急转直下。\n\n> 注意：Layer不属于响应链条的一部分，它无法和View一样直接响应点击和手势。\n\n\n## CAScrollLayer\nCAScrollLayer是CALayer的子类，用于显示Layer的一部分，不能直接响应用户的触摸甚至检查滚动范围。CAScrollLayer的可滚动区域的范围是由它的子层布局来确定的。 CAScrollLayer不提供键盘或鼠标事件处理，也没有提供可见滚动条。 \n\nUIScrollView并没有用CAScrollLayer，事实上，就是简单的通过直接操作图层边界来实现滑动。\n\nCAScrollLayer可以设置它的滚动方向，还可以滚动到特定的点或者区域。\n\n```objc\n#import \"ScrollView.h\"\n@implementation ScrollView\n// 1\n+ (Class)layerClass\n{\n    return [CAScrollLayer class];\n}\n\n- (void)setUp\n{\n    //enable clipping\n    self.layer.masksToBounds = YES;\n\n    //attach pan gesture recognizer\n    UIPanGestureRecognizer *recognizer = nil;\n    recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];\n    [self addGestureRecognizer:recognizer];\n}\n\n- (id)initWithFrame:(CGRect)frame\n{\n    //this is called when view is created in code\n    if ((self = [super initWithFrame:frame])) {\n        [self setUp];\n    }\n    return self;\n}\n\n- (void)awakeFromNib {\n    //this is called when view is created from a nib\n    [self setUp];\n}\n\n- (void)pan:(UIPanGestureRecognizer *)recognizer\n{\n    //get the offset by subtracting the pan gesture\n    //translation from the current bounds origin\n    CGPoint offset = self.bounds.origin;\n    offset.x -= [recognizer translationInView:self].x;\n    offset.y -= [recognizer translationInView:self].y;\n\n    //scroll the layer\n    [(CAScrollLayer *)self.layer scrollToPoint:offset];\n\n    //reset the pan gesture translation\n    [recognizer setTranslation:CGPointZero inView:self];\n    \n    // 结束恢复原点\n//    if (sender.state == UIGestureRecognizerStateEnded) {\n//        [UIView animateWithDuration:0.3 animations:^{\n//            [self.scrollingViewLayer scrollToPoint:CGPointZero];\n//        }];\n//    }\n\n}\n@end\n```\n分析：\n1. 创建一个View的子类，重写**layerClass**方法，返回**CAScrollLayer**。这里修改了创建的Layer类，并添加它作为sublayer。\n2. 在手势响应方法中，它会滚到触摸点。注意：**scrollToPoint** 和 **scrollToRect**方法没有隐式动画，需要使用 UIView 动画才会有滚动动画。\n\n这里有一些经验规则时使用（或不使用）CAScrollLayer：\n* 如果你想使用轻量级的，只需要通过代码的方式滚动：考虑使用CAScrollLayer\n* 如果你想用户能够通过屏幕滚动：最好使用UIScrollView，了解更多可以点击[链接](https://videos.raywenderlich.com/courses/scroll-view-school/lessons/1)\n* 如果你要滚动非常巨大的图片：考虑使用CATiledLayer（接下来会学到）\n\n## CATextLayer\nCATextLayer能够简单而快速绘制普通文本或者富文本，和UILabel不一样，CATextLayer没有UIFont属性，只有 CTFontRef 或者 CGFontRef。\n\n\n```objc\n- (void)setUpTextLayer {\n\t// 1\n\tCFStringRef fontName = (__bridge CFStringRef)@\"Noteworthy-Light\";\n\tself.noteworthyLightFont = CTFontCreateWithName(fontName, baseFontSize, nil);\n\tfontName = (__bridge CFStringRef)@\"Helvetica\";\n\tself.helveticaFont = CTFontCreateWithName(fontName, baseFontSize, nil);\n\t\n\t// 2\n\tNSMutableString *string =[NSMutableString string];\n\tfor (NSInteger i = 0; i <= 20; i++) {\n\t\t[string appendFormat:@\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce auctor arcu quis velit congue dictum. \"];\n\t}\n\t// 3\n\tself.textLayer = ({\n\t   CATextLayer *layer = [CATextLayer layer];\n\t   layer.frame = self.viewForTextLayer.bounds;\n\t   layer.string = string;\n\t   layer.font = self.helveticaFont;\n\t   layer.foregroundColor = [[UIColor darkGrayColor] CGColor];\n\t   layer.wrapped = YES;\n\t   layer.alignmentMode = kCAAlignmentLeft;\n\t   layer.truncationMode = kCATruncationEnd;\n\t   layer.contentsScale = [[UIScreen mainScreen] scale];\n\t   layer;\n\t});\n}\n```\n分析：\n1. 创建给Layer赋值的字体\n2. 创建显示文本\n3. 创建CATextLayer并设置属性，contentsScale匹配当前屏幕的发大倍数\n\n不仅仅是CATextLayer，所有的Layer类，默认的放大系数**contentsScale**都是 1。当关联上Views时，layer会自动设置**contentsScale**与当前屏幕的放大系数一致。你手动创建的Layer时，需要设置**contentsScale**，否则它的放大系数和Retina不匹配。\n\n\n\n\n## 参考链接\n* [详解CALayer 和 UIView的区别和联系](http://www.jianshu.com/p/079e5cf0f014)\n* [View-Layer 协作](https://objccn.io/issue-12-4/)\n* [CALyer.h阅读笔记](http://www.360doc.com/content/16/0318/10/31697881_543270664.shtml)\n* [iOS-Core-Animation-Advanced-Techniques(七)](http://www.cocoachina.com/ios/20150106/10840.html)\n* [WWDC心得与延伸:iOS图形性能](http://www.cocoachina.com/ios/20150429/11712.html)\n* [iOS-Core-Animation-Advanced-Techniques](https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques)\n\n\n\n\n","slug":"learn-CALayer-1","published":1,"updated":"2016-10-29T11:57:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7od004r8jpbvtrwsx2d","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我们都知道在iOS中每一个你看到的东西都是由View组成的，比如按钮视图，table视图等等。但是你可能不知道每个View背后都有一个叫做CALayer的类。本系列文章着重学习使用CALayer，CALayer和View的区别请参考：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/079e5cf0f014\" target=\"_blank\" rel=\"noopener\">详解CALayer 和 UIView的区别和联系</a></li>\n<li><a href=\"https://objccn.io/issue-12-4/\" target=\"_blank\" rel=\"noopener\">View-Layer 协作</a></li>\n</ul>\n<p>本章的内容大部分是从<a href=\"http://www.raywenderlich.com/90488/calayer-in-ios-with-swift-10-examples\" target=\"_blank\" rel=\"noopener\">CALayer Tutorial: Getting Started</a>学习得来。</p>\n<h2 id=\"CALayer\"><a href=\"#CALayer\" class=\"headerlink\" title=\"CALayer\"></a>CALayer</h2><p>CALayer是接下来要学习到的Layers的基类，包含了很多基础属性，比如</p>\n<ul>\n<li><strong>contents</strong>：表示Layer呈现的内容，一般会设置为CGImage的对象</li>\n<li><strong>contentsGravity</strong>：表示内容对齐和填充方式</li>\n<li><strong>cornerRadius</strong>：表示Layer圆角半径，默认zero</li>\n<li><strong>masksToBounds</strong>：是否进行bounds的切割，设置圆角属性是会设置为YES</li>\n</ul>\n<p>Layer还有很多属性和View相似，比如<strong>frame</strong>，<strong>bounds</strong>等等用于设置Layer的位置。</p>\n<p>CALayer还有几个知识点：</p>\n<ul>\n<li>Layers有subLayer，就像Views有subViews</li>\n<li>Layer的properties能够产生隐式动画。当你改变Layer的property，它会默认产生隐式动画。你也可以使用自定义动画。</li>\n<li>Layer比Views更轻量级，更能节约性能。</li>\n<li>Layers有大量有用的properties。</li>\n</ul>\n<p>看下面这段代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\">_layer = [<span class=\"built_in\">CALayer</span> new];</span><br><span class=\"line\">_layer.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">200</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\">_layer.contents = (__bridge <span class=\"keyword\">id</span> _Nullable)([[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"star\"</span>] <span class=\"built_in\">CGImage</span>]);</span><br><span class=\"line\">_layer.contentsGravity = kCAGravityCenter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\">_layer.magnificationFilter = kCAFilterLinear;</span><br><span class=\"line\">_layer.geometryFlipped = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\">_layer.backgroundColor = [kDefaultBackgroundColor <span class=\"built_in\">CGColor</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br><span class=\"line\">_layer.cornerRadius = <span class=\"number\">100.0</span>;</span><br><span class=\"line\">_layer.borderWidth = <span class=\"number\">12.0</span>;</span><br><span class=\"line\">_layer.borderColor = [[<span class=\"built_in\">UIColor</span> whiteColor] <span class=\"built_in\">CGColor</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\">_layer.shadowOpacity = <span class=\"number\">0.75</span>;</span><br><span class=\"line\">_layer.shadowOffset = <span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">_layer.shadowRadius = <span class=\"number\">3.0</span>;</span><br></pre></td></tr></table></figure></p>\n<p>分析：</p>\n<ol>\n<li>创建了一个CALayer对象，设置它的frame</li>\n<li>把layer的内容设置为一张图片，图片的格式是Quartz image data（CGImage）</li>\n<li>设置内容对齐和填充方式</li>\n<li>设置layer的背景色</li>\n<li>设置layer的圆角弧度为自己宽度的一半（它就会变成圆形），设置它的边框宽度和颜色</li>\n<li>设置layer的阴影透明度，阴影偏移量，阴影圆角半径</li>\n</ol>\n<p>最终效果：<br><img src=\"/2016/10/15/learn-CALayer-1/Snip20161029_1.png\" title=\"CALayer image\"></p>\n<p><strong>CALayer有附加属性能够提高性能</strong>：</p>\n<ul>\n<li><strong>shouldRasterize</strong>：光栅化，设置为YES后CALayer会被光栅化为bitmap，layer的阴影等效果也会被保存到bitmap中，<code>缓存起来后不需要多次渲染提高了性能</code>，而对于经常变动的内容，这个时候不要开启，否则会造成性能的浪费。</li>\n<li><strong>drawsAsynchronously</strong>：异步渲染，这个和shouldRasterize正好相反，默认也是NO，设置为YES能够提高<code>需要反复渲染</code>layer内容的性能，比如之后会学习到的<strong>emitter layer</strong>连续渲染颗粒动画。</li>\n</ul>\n<blockquote>\n<p>提醒：在设置<strong>shouldrasterize</strong>或<strong>drawsasynchronously</strong>时，应该反复比较设置前后的性能，正确使用时，能够提高性能，误用时，性能可能会急转直下。</p>\n</blockquote>\n<blockquote>\n<p>注意：Layer不属于响应链条的一部分，它无法和View一样直接响应点击和手势。</p>\n</blockquote>\n<h2 id=\"CAScrollLayer\"><a href=\"#CAScrollLayer\" class=\"headerlink\" title=\"CAScrollLayer\"></a>CAScrollLayer</h2><p>CAScrollLayer是CALayer的子类，用于显示Layer的一部分，不能直接响应用户的触摸甚至检查滚动范围。CAScrollLayer的可滚动区域的范围是由它的子层布局来确定的。 CAScrollLayer不提供键盘或鼠标事件处理，也没有提供可见滚动条。 </p>\n<p>UIScrollView并没有用CAScrollLayer，事实上，就是简单的通过直接操作图层边界来实现滑动。</p>\n<p>CAScrollLayer可以设置它的滚动方向，还可以滚动到特定的点或者区域。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"ScrollView.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ScrollView</span></span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\">+ (Class)layerClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">CAScrollLayer</span> <span class=\"keyword\">class</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUp</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//enable clipping</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.layer.masksToBounds = <span class=\"literal\">YES</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//attach pan gesture recognizer</span></span><br><span class=\"line\">    <span class=\"built_in\">UIPanGestureRecognizer</span> *recognizer = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    recognizer = [[<span class=\"built_in\">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(pan:)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addGestureRecognizer:recognizer];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithFrame:(<span class=\"built_in\">CGRect</span>)frame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//this is called when view is created in code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithFrame:frame])) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setUp];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)awakeFromNib &#123;</span><br><span class=\"line\">    <span class=\"comment\">//this is called when view is created from a nib</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUp];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)pan:(<span class=\"built_in\">UIPanGestureRecognizer</span> *)recognizer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//get the offset by subtracting the pan gesture</span></span><br><span class=\"line\">    <span class=\"comment\">//translation from the current bounds origin</span></span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> offset = <span class=\"keyword\">self</span>.bounds.origin;</span><br><span class=\"line\">    offset.x -= [recognizer translationInView:<span class=\"keyword\">self</span>].x;</span><br><span class=\"line\">    offset.y -= [recognizer translationInView:<span class=\"keyword\">self</span>].y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//scroll the layer</span></span><br><span class=\"line\">    [(<span class=\"built_in\">CAScrollLayer</span> *)<span class=\"keyword\">self</span>.layer scrollToPoint:offset];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//reset the pan gesture translation</span></span><br><span class=\"line\">    [recognizer setTranslation:<span class=\"built_in\">CGPointZero</span> inView:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 结束恢复原点</span></span><br><span class=\"line\"><span class=\"comment\">//    if (sender.state == UIGestureRecognizerStateEnded) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        [UIView animateWithDuration:0.3 animations:^&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            [self.scrollingViewLayer scrollToPoint:CGPointZero];</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;];</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>创建一个View的子类，重写<strong>layerClass</strong>方法，返回<strong>CAScrollLayer</strong>。这里修改了创建的Layer类，并添加它作为sublayer。</li>\n<li>在手势响应方法中，它会滚到触摸点。注意：<strong>scrollToPoint</strong> 和 <strong>scrollToRect</strong>方法没有隐式动画，需要使用 UIView 动画才会有滚动动画。</li>\n</ol>\n<p>这里有一些经验规则时使用（或不使用）CAScrollLayer：</p>\n<ul>\n<li>如果你想使用轻量级的，只需要通过代码的方式滚动：考虑使用CAScrollLayer</li>\n<li>如果你想用户能够通过屏幕滚动：最好使用UIScrollView，了解更多可以点击<a href=\"https://videos.raywenderlich.com/courses/scroll-view-school/lessons/1\" target=\"_blank\" rel=\"noopener\">链接</a></li>\n<li>如果你要滚动非常巨大的图片：考虑使用CATiledLayer（接下来会学到）</li>\n</ul>\n<h2 id=\"CATextLayer\"><a href=\"#CATextLayer\" class=\"headerlink\" title=\"CATextLayer\"></a>CATextLayer</h2><p>CATextLayer能够简单而快速绘制普通文本或者富文本，和UILabel不一样，CATextLayer没有UIFont属性，只有 CTFontRef 或者 CGFontRef。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpTextLayer &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 1</span></span><br><span class=\"line\">\t<span class=\"built_in\">CFStringRef</span> fontName = (__bridge <span class=\"built_in\">CFStringRef</span>)<span class=\"string\">@\"Noteworthy-Light\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.noteworthyLightFont = <span class=\"built_in\">CTFontCreateWithName</span>(fontName, baseFontSize, <span class=\"literal\">nil</span>);</span><br><span class=\"line\">\tfontName = (__bridge <span class=\"built_in\">CFStringRef</span>)<span class=\"string\">@\"Helvetica\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.helveticaFont = <span class=\"built_in\">CTFontCreateWithName</span>(fontName, baseFontSize, <span class=\"literal\">nil</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 2</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> *string =[<span class=\"built_in\">NSMutableString</span> string];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">\t\t[string appendFormat:<span class=\"string\">@\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce auctor arcu quis velit congue dictum. \"</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 3</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.textLayer = (&#123;</span><br><span class=\"line\">\t   <span class=\"built_in\">CATextLayer</span> *layer = [<span class=\"built_in\">CATextLayer</span> layer];</span><br><span class=\"line\">\t   layer.frame = <span class=\"keyword\">self</span>.viewForTextLayer.bounds;</span><br><span class=\"line\">\t   layer.string = string;</span><br><span class=\"line\">\t   layer.font = <span class=\"keyword\">self</span>.helveticaFont;</span><br><span class=\"line\">\t   layer.foregroundColor = [[<span class=\"built_in\">UIColor</span> darkGrayColor] <span class=\"built_in\">CGColor</span>];</span><br><span class=\"line\">\t   layer.wrapped = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">\t   layer.alignmentMode = kCAAlignmentLeft;</span><br><span class=\"line\">\t   layer.truncationMode = kCATruncationEnd;</span><br><span class=\"line\">\t   layer.contentsScale = [[<span class=\"built_in\">UIScreen</span> mainScreen] scale];</span><br><span class=\"line\">\t   layer;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>创建给Layer赋值的字体</li>\n<li>创建显示文本</li>\n<li>创建CATextLayer并设置属性，contentsScale匹配当前屏幕的发大倍数</li>\n</ol>\n<p>不仅仅是CATextLayer，所有的Layer类，默认的放大系数<strong>contentsScale</strong>都是 1。当关联上Views时，layer会自动设置<strong>contentsScale</strong>与当前屏幕的放大系数一致。你手动创建的Layer时，需要设置<strong>contentsScale</strong>，否则它的放大系数和Retina不匹配。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://www.jianshu.com/p/079e5cf0f014\" target=\"_blank\" rel=\"noopener\">详解CALayer 和 UIView的区别和联系</a></li>\n<li><a href=\"https://objccn.io/issue-12-4/\" target=\"_blank\" rel=\"noopener\">View-Layer 协作</a></li>\n<li><a href=\"http://www.360doc.com/content/16/0318/10/31697881_543270664.shtml\" target=\"_blank\" rel=\"noopener\">CALyer.h阅读笔记</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150106/10840.html\" target=\"_blank\" rel=\"noopener\">iOS-Core-Animation-Advanced-Techniques(七)</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150429/11712.html\" target=\"_blank\" rel=\"noopener\">WWDC心得与延伸:iOS图形性能</a></li>\n<li><a href=\"https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques\" target=\"_blank\" rel=\"noopener\">iOS-Core-Animation-Advanced-Techniques</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我们都知道在iOS中每一个你看到的东西都是由View组成的，比如按钮视图，table视图等等。但是你可能不知道每个View背后都有一个叫做CALayer的类。本系列文章着重学习使用CALayer，CALayer和View的区别请参考：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/079e5cf0f014\" target=\"_blank\" rel=\"noopener\">详解CALayer 和 UIView的区别和联系</a></li>\n<li><a href=\"https://objccn.io/issue-12-4/\" target=\"_blank\" rel=\"noopener\">View-Layer 协作</a></li>\n</ul>\n<p>本章的内容大部分是从<a href=\"http://www.raywenderlich.com/90488/calayer-in-ios-with-swift-10-examples\" target=\"_blank\" rel=\"noopener\">CALayer Tutorial: Getting Started</a>学习得来。</p>\n<h2 id=\"CALayer\"><a href=\"#CALayer\" class=\"headerlink\" title=\"CALayer\"></a>CALayer</h2><p>CALayer是接下来要学习到的Layers的基类，包含了很多基础属性，比如</p>\n<ul>\n<li><strong>contents</strong>：表示Layer呈现的内容，一般会设置为CGImage的对象</li>\n<li><strong>contentsGravity</strong>：表示内容对齐和填充方式</li>\n<li><strong>cornerRadius</strong>：表示Layer圆角半径，默认zero</li>\n<li><strong>masksToBounds</strong>：是否进行bounds的切割，设置圆角属性是会设置为YES</li>\n</ul>\n<p>Layer还有很多属性和View相似，比如<strong>frame</strong>，<strong>bounds</strong>等等用于设置Layer的位置。</p>\n<p>CALayer还有几个知识点：</p>\n<ul>\n<li>Layers有subLayer，就像Views有subViews</li>\n<li>Layer的properties能够产生隐式动画。当你改变Layer的property，它会默认产生隐式动画。你也可以使用自定义动画。</li>\n<li>Layer比Views更轻量级，更能节约性能。</li>\n<li>Layers有大量有用的properties。</li>\n</ul>\n<p>看下面这段代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\">_layer = [<span class=\"built_in\">CALayer</span> new];</span><br><span class=\"line\">_layer.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">200</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\">_layer.contents = (__bridge <span class=\"keyword\">id</span> _Nullable)([[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"star\"</span>] <span class=\"built_in\">CGImage</span>]);</span><br><span class=\"line\">_layer.contentsGravity = kCAGravityCenter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\">_layer.magnificationFilter = kCAFilterLinear;</span><br><span class=\"line\">_layer.geometryFlipped = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\">_layer.backgroundColor = [kDefaultBackgroundColor <span class=\"built_in\">CGColor</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br><span class=\"line\">_layer.cornerRadius = <span class=\"number\">100.0</span>;</span><br><span class=\"line\">_layer.borderWidth = <span class=\"number\">12.0</span>;</span><br><span class=\"line\">_layer.borderColor = [[<span class=\"built_in\">UIColor</span> whiteColor] <span class=\"built_in\">CGColor</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\">_layer.shadowOpacity = <span class=\"number\">0.75</span>;</span><br><span class=\"line\">_layer.shadowOffset = <span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">_layer.shadowRadius = <span class=\"number\">3.0</span>;</span><br></pre></td></tr></table></figure></p>\n<p>分析：</p>\n<ol>\n<li>创建了一个CALayer对象，设置它的frame</li>\n<li>把layer的内容设置为一张图片，图片的格式是Quartz image data（CGImage）</li>\n<li>设置内容对齐和填充方式</li>\n<li>设置layer的背景色</li>\n<li>设置layer的圆角弧度为自己宽度的一半（它就会变成圆形），设置它的边框宽度和颜色</li>\n<li>设置layer的阴影透明度，阴影偏移量，阴影圆角半径</li>\n</ol>\n<p>最终效果：<br><img src=\"/2016/10/15/learn-CALayer-1/Snip20161029_1.png\" title=\"CALayer image\"></p>\n<p><strong>CALayer有附加属性能够提高性能</strong>：</p>\n<ul>\n<li><strong>shouldRasterize</strong>：光栅化，设置为YES后CALayer会被光栅化为bitmap，layer的阴影等效果也会被保存到bitmap中，<code>缓存起来后不需要多次渲染提高了性能</code>，而对于经常变动的内容，这个时候不要开启，否则会造成性能的浪费。</li>\n<li><strong>drawsAsynchronously</strong>：异步渲染，这个和shouldRasterize正好相反，默认也是NO，设置为YES能够提高<code>需要反复渲染</code>layer内容的性能，比如之后会学习到的<strong>emitter layer</strong>连续渲染颗粒动画。</li>\n</ul>\n<blockquote>\n<p>提醒：在设置<strong>shouldrasterize</strong>或<strong>drawsasynchronously</strong>时，应该反复比较设置前后的性能，正确使用时，能够提高性能，误用时，性能可能会急转直下。</p>\n</blockquote>\n<blockquote>\n<p>注意：Layer不属于响应链条的一部分，它无法和View一样直接响应点击和手势。</p>\n</blockquote>\n<h2 id=\"CAScrollLayer\"><a href=\"#CAScrollLayer\" class=\"headerlink\" title=\"CAScrollLayer\"></a>CAScrollLayer</h2><p>CAScrollLayer是CALayer的子类，用于显示Layer的一部分，不能直接响应用户的触摸甚至检查滚动范围。CAScrollLayer的可滚动区域的范围是由它的子层布局来确定的。 CAScrollLayer不提供键盘或鼠标事件处理，也没有提供可见滚动条。 </p>\n<p>UIScrollView并没有用CAScrollLayer，事实上，就是简单的通过直接操作图层边界来实现滑动。</p>\n<p>CAScrollLayer可以设置它的滚动方向，还可以滚动到特定的点或者区域。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"ScrollView.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ScrollView</span></span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\">+ (Class)layerClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">CAScrollLayer</span> <span class=\"keyword\">class</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUp</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//enable clipping</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.layer.masksToBounds = <span class=\"literal\">YES</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//attach pan gesture recognizer</span></span><br><span class=\"line\">    <span class=\"built_in\">UIPanGestureRecognizer</span> *recognizer = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    recognizer = [[<span class=\"built_in\">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(pan:)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addGestureRecognizer:recognizer];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithFrame:(<span class=\"built_in\">CGRect</span>)frame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//this is called when view is created in code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithFrame:frame])) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setUp];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)awakeFromNib &#123;</span><br><span class=\"line\">    <span class=\"comment\">//this is called when view is created from a nib</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUp];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)pan:(<span class=\"built_in\">UIPanGestureRecognizer</span> *)recognizer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//get the offset by subtracting the pan gesture</span></span><br><span class=\"line\">    <span class=\"comment\">//translation from the current bounds origin</span></span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> offset = <span class=\"keyword\">self</span>.bounds.origin;</span><br><span class=\"line\">    offset.x -= [recognizer translationInView:<span class=\"keyword\">self</span>].x;</span><br><span class=\"line\">    offset.y -= [recognizer translationInView:<span class=\"keyword\">self</span>].y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//scroll the layer</span></span><br><span class=\"line\">    [(<span class=\"built_in\">CAScrollLayer</span> *)<span class=\"keyword\">self</span>.layer scrollToPoint:offset];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//reset the pan gesture translation</span></span><br><span class=\"line\">    [recognizer setTranslation:<span class=\"built_in\">CGPointZero</span> inView:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 结束恢复原点</span></span><br><span class=\"line\"><span class=\"comment\">//    if (sender.state == UIGestureRecognizerStateEnded) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        [UIView animateWithDuration:0.3 animations:^&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            [self.scrollingViewLayer scrollToPoint:CGPointZero];</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;];</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>创建一个View的子类，重写<strong>layerClass</strong>方法，返回<strong>CAScrollLayer</strong>。这里修改了创建的Layer类，并添加它作为sublayer。</li>\n<li>在手势响应方法中，它会滚到触摸点。注意：<strong>scrollToPoint</strong> 和 <strong>scrollToRect</strong>方法没有隐式动画，需要使用 UIView 动画才会有滚动动画。</li>\n</ol>\n<p>这里有一些经验规则时使用（或不使用）CAScrollLayer：</p>\n<ul>\n<li>如果你想使用轻量级的，只需要通过代码的方式滚动：考虑使用CAScrollLayer</li>\n<li>如果你想用户能够通过屏幕滚动：最好使用UIScrollView，了解更多可以点击<a href=\"https://videos.raywenderlich.com/courses/scroll-view-school/lessons/1\" target=\"_blank\" rel=\"noopener\">链接</a></li>\n<li>如果你要滚动非常巨大的图片：考虑使用CATiledLayer（接下来会学到）</li>\n</ul>\n<h2 id=\"CATextLayer\"><a href=\"#CATextLayer\" class=\"headerlink\" title=\"CATextLayer\"></a>CATextLayer</h2><p>CATextLayer能够简单而快速绘制普通文本或者富文本，和UILabel不一样，CATextLayer没有UIFont属性，只有 CTFontRef 或者 CGFontRef。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpTextLayer &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 1</span></span><br><span class=\"line\">\t<span class=\"built_in\">CFStringRef</span> fontName = (__bridge <span class=\"built_in\">CFStringRef</span>)<span class=\"string\">@\"Noteworthy-Light\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.noteworthyLightFont = <span class=\"built_in\">CTFontCreateWithName</span>(fontName, baseFontSize, <span class=\"literal\">nil</span>);</span><br><span class=\"line\">\tfontName = (__bridge <span class=\"built_in\">CFStringRef</span>)<span class=\"string\">@\"Helvetica\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.helveticaFont = <span class=\"built_in\">CTFontCreateWithName</span>(fontName, baseFontSize, <span class=\"literal\">nil</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 2</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> *string =[<span class=\"built_in\">NSMutableString</span> string];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">\t\t[string appendFormat:<span class=\"string\">@\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce auctor arcu quis velit congue dictum. \"</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 3</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.textLayer = (&#123;</span><br><span class=\"line\">\t   <span class=\"built_in\">CATextLayer</span> *layer = [<span class=\"built_in\">CATextLayer</span> layer];</span><br><span class=\"line\">\t   layer.frame = <span class=\"keyword\">self</span>.viewForTextLayer.bounds;</span><br><span class=\"line\">\t   layer.string = string;</span><br><span class=\"line\">\t   layer.font = <span class=\"keyword\">self</span>.helveticaFont;</span><br><span class=\"line\">\t   layer.foregroundColor = [[<span class=\"built_in\">UIColor</span> darkGrayColor] <span class=\"built_in\">CGColor</span>];</span><br><span class=\"line\">\t   layer.wrapped = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">\t   layer.alignmentMode = kCAAlignmentLeft;</span><br><span class=\"line\">\t   layer.truncationMode = kCATruncationEnd;</span><br><span class=\"line\">\t   layer.contentsScale = [[<span class=\"built_in\">UIScreen</span> mainScreen] scale];</span><br><span class=\"line\">\t   layer;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>创建给Layer赋值的字体</li>\n<li>创建显示文本</li>\n<li>创建CATextLayer并设置属性，contentsScale匹配当前屏幕的发大倍数</li>\n</ol>\n<p>不仅仅是CATextLayer，所有的Layer类，默认的放大系数<strong>contentsScale</strong>都是 1。当关联上Views时，layer会自动设置<strong>contentsScale</strong>与当前屏幕的放大系数一致。你手动创建的Layer时，需要设置<strong>contentsScale</strong>，否则它的放大系数和Retina不匹配。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://www.jianshu.com/p/079e5cf0f014\" target=\"_blank\" rel=\"noopener\">详解CALayer 和 UIView的区别和联系</a></li>\n<li><a href=\"https://objccn.io/issue-12-4/\" target=\"_blank\" rel=\"noopener\">View-Layer 协作</a></li>\n<li><a href=\"http://www.360doc.com/content/16/0318/10/31697881_543270664.shtml\" target=\"_blank\" rel=\"noopener\">CALyer.h阅读笔记</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150106/10840.html\" target=\"_blank\" rel=\"noopener\">iOS-Core-Animation-Advanced-Techniques(七)</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150429/11712.html\" target=\"_blank\" rel=\"noopener\">WWDC心得与延伸:iOS图形性能</a></li>\n<li><a href=\"https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques\" target=\"_blank\" rel=\"noopener\">iOS-Core-Animation-Advanced-Techniques</a></li>\n</ul>\n"},{"title":"学习CALayer（二）","date":"2016-10-22T12:07:08.000Z","_content":"\n## 前言\n上一篇文章学习了**CALayer**和它的两个子类**CAScrollLayer**和**CATextLayer**。本章继续学习别的Layer。\n\n## AVPlayerLayer\nAVPlayerLayer是AVFoundation的一个Layer，它有个AVPlayer来播放 AV media 文件（AVPlayerItems）。\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self setUpPlayerLayer];\n    \n    // 3\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playerDidReachEndNotificationHandler:) name:AVPlayerItemDidPlayToEndTimeNotification object:nil];\n}\n\n- (void)setUpPlayerLayer {\n    // 1\n    NSURL *url = [[NSBundle mainBundle] URLForResource:@\"colorfulStreak\" withExtension:@\"m4v\"];\n    AVPlayer *player = [AVPlayer playerWithURL:url];\n    player.actionAtItemEnd = AVPlayerActionAtItemEndNone;\n    // 2\n    self.playerLayer = [AVPlayerLayer layer];\n    self.playerLayer.frame = CGRectMake(0, 0, 300, 180);\n    self.playerLayer.player = player;\n    [self.viewForPlayerLayer.layer addSublayer:self.playerLayer];\n}\n\n- (void)playerDidReachEndNotificationHandler:(NSNotification *)notification {\n    AVPlayerItem *playerItem = self.playerLayer.player.currentItem;\n    if (playerItem) {\n        [playerItem seekToTime:kCMTimeZero];\n    }\n}\n```\n\n分析：\n1. 根据播放文件路径创建 player ，告诉player播放完成后什么也不做\n2. 创建 playerLayer\n3. 注册 AVPlayer 的播放一个文件结束时的通知。（记得在controller销毁时移除监听）\n\n`AVPlayerLayer` 有两个属性：\n* **videoGravity**：设置视频的显示方式\n* **readyForDisplay**：是否视频加载完成就立刻播放\n\n`AVPlayer` 有几个特别的属性和方法：\n* **rate**：表示0到1的播放速率，0表示暂停，1表示正常速度播放（1X）。换句话说，调用 **pause** 方法等同于 设置 Rate 为 0；调用 **play** 方法等同于 设置 rate 为 1。\n\n那么设置快进，慢动作或者反向播放，可以直接 rate 的值来实现，设置超过 1 的值，就是要求视频快进播放，比如设置为 2，就是两倍的速度播放。设置为负数时，就是反向播放。\n\n在设置 rate 的时候，应该先验证视频能否按照想要设置速率来播放，在 `AVPlayerItem` 中提供了检验的方法：\n* **canPlayFastForward** rate 大于 1\n* **canPlaySlowForward** rate 在 0 和 1 之间\n* **canPlayReverse** rate 是 -1\n* **canPlaySlowReverse** rate 在 -1 和 0 之间\n* **canPlayFastReverse** rate 小于 -1\n\n## CAGradientLayer\n当你使用2种以上颜色时，CAGradientLayer 能够让它很容易应用到背景上，你需要配置一组从 **startPoint** 到 **endPoint** 对应的CGColors。\n\n**startPoint** 和 **endPoint** 不是明确的点，它们是坐标系的边界反映。x的值是1，意味着该点位于layer的右边缘，y的值是1，意味着该点在layer的底部边缘。\n\nCAGradientLayer 有个 **type** 属性，只有**kCAGradientLayerAxial** 一个选项，表示线性过渡颜色数组的值。\n\n如下图所示，线A从 **startPoint** 到 **endPoint** 是渐变方向，垂直于线A的线B，沿着线B的颜色都是一样的。\n{% asset_img AxialGradientLayerType.gif AxialGradientLayerType image %}\n\n另外，你还可以通过 **locations** 属性来控制颜色数组的显示，分配给每个颜色的显示范围。如果没有设置 **locations** 这个值，每个颜色都是平均显示，均匀分布。如果设置了，它的数量必须和颜色的数量对应，否则会发生错误。\n\n```objc\n- (void)setUpGradientLayer {\n    self.gradientLayer = [CAGradientLayer layer];\n    self.gradientLayer.frame = CGRectMake(0, 0, 200, 200);\n    // colors 接收 CGColorRef 的对象数组，用于定义每个 gradient 的结束位置\n    self.gradientLayer.colors = self.colors;\n    // gradient 渐变的起始锚点\n    self.gradientLayer.startPoint = CGPointMake(0.5f, 0.0f);\n    // gradient 渐变的结束锚点\n    self.gradientLayer.endPoint = CGPointMake(0.5f, 1.0f);\n    // 渐变的结束位置，与colors一一对应\n    self.gradientLayer.locations = self.locations;\n    \n    [self.viewForGradientLayer.layer addSublayer:self.gradientLayer];\n}\n```\n\n显示效果如下图：\n{% asset_img CAGradientLayer-500x500.png CAGradientLayer image %}\n\n\n## CAReplicatorLayer\nCAReplicatorLayer 可以将自己的sublayers复制指定的次数。\n每个复制的layer都可以拥有自己的颜色和属性，CAReplicatorLayer可以延迟sublayers的动画效果显示，还支持 Depth（景深）效果产生3D效果。 \n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 创建CAReplicatorLayer，它是个容器层，你添加内容到它上面，它会复制添加的内容。\n    _replicatorLayer = [CAReplicatorLayer layer];\n    [self setUpReplicatorLayer];\n    [_viewForReplicatorLayer.layer addSublayer:_replicatorLayer];\n    \n    // 需要被复制的layer\n    _instanceLayer = [CALayer layer];\n    [self setUpInstanceLayer];\n    [_replicatorLayer addSublayer:_instanceLayer];\n    \n    [self setUpLayerFadeAnimation];\n    [self instanceDelaySliderChanged:_instanceDelaySlider];\n    [self updateLayerSizeSliderValueLabel];\n    [self updateInstanceCountSliderValueLabel];\n    [self updateInstanceDelaySliderValueLabel];\n}\n\n- (void)setUpReplicatorLayer {\n    _replicatorLayer.frame = CGRectMake(0, 0, 250, 250);\n    CGFloat count = self.instanceCountSlider.value;\n    // 复制多少份\n    _replicatorLayer.instanceCount = count;\n    // 是否开启三维空间效果\n    _replicatorLayer.preservesDepth = NO;\n    _replicatorLayer.instanceColor = [[UIColor whiteColor] CGColor];\n    // 颜色值递减\n    _replicatorLayer.instanceRedOffset = [self offsetValueForSwitch:_offsetRedSwitch];\n    _replicatorLayer.instanceGreenOffset = [self offsetValueForSwitch:_offsetGreenSwitch];\n    _replicatorLayer.instanceBlueOffset = [self offsetValueForSwitch:_offsetBlueSwitch];\n    _replicatorLayer.instanceAlphaOffset = [self offsetValueForSwitch:_offsetAlphaSwitch];\n    CGFloat angle = (M_PI * 2.0) / count;\n    // 复制图层在被创建时产生的和上一个复制图层的位移(位移的锚点时CAReplicatorlayer的中心点)\n    _replicatorLayer.instanceTransform = CATransform3DMakeRotation(angle, 0.0, 0.0, 1.0);\n}\n```\n\n分析：\n1. 创建 CAReplicatorLayer 对象，设置它的frame\n2. 设置 replicator layer 复制sublayers个数和延迟渲染时间，设置为2D效果，(preservesDepth = false) ，背景色为白色\n3. 添加 RGBA渐变到每个成功复制的实例上，RGB默认都是0。在本例子中，默认颜色是白色，意味这个RGB都已经设置为1.0\n4. 设置渐变路径是围成个圆\n\n更多详情看Demo的代码\n\n最终效果：\n{% asset_img CAReplicatorLayer.gif CAReplicatorLayer image %}\n\n使用 CAReplicatorLayer 可以创建很多 cool 的动画，可以参考：\n* [使用CAReplicatorLayer创建动画](http://www.ios-animations-by-emails.com/posts/2015-march#tutorial)\n* [CALayer-CAReplicatorLayer(复制图层)](http://www.jianshu.com/p/84455b674f55)\n\n\n## CATiledLayer\n有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。\n\nCATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。\n\n[详细实践](https://zsisme.gitbooks.io/ios-/content/chapter6/catiledLayer.html)\n\nCATiledLayer 有两个properties：（[详细解释](http://www.cocoachina.com/bbs/read.php?tid-31201.html)）\n* **levelsOfDetail** ：表示一共有多少个drawLayer的位置\n* **levelsOfDetailBias**：表示比1大的位置里有多少个drawLayer的位置（包括1）\n\n## 参考链接\n* [iOS-Core-Animation-Advanced-Techniques(七)](http://www.cocoachina.com/ios/20150106/10840.html)\n* [WWDC心得与延伸:iOS图形性能](http://www.cocoachina.com/ios/20150429/11712.html)\n* [iOS-Core-Animation-Advanced-Techniques](https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques)\n\n\n\n","source":"_posts/learn-CALayer-2.md","raw":"---\ntitle: 学习CALayer（二）\ndate: 2016-10-22 20:07:08\ntags: CALayer\ncategory: 能工巧匠\n---\n\n## 前言\n上一篇文章学习了**CALayer**和它的两个子类**CAScrollLayer**和**CATextLayer**。本章继续学习别的Layer。\n\n## AVPlayerLayer\nAVPlayerLayer是AVFoundation的一个Layer，它有个AVPlayer来播放 AV media 文件（AVPlayerItems）。\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self setUpPlayerLayer];\n    \n    // 3\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playerDidReachEndNotificationHandler:) name:AVPlayerItemDidPlayToEndTimeNotification object:nil];\n}\n\n- (void)setUpPlayerLayer {\n    // 1\n    NSURL *url = [[NSBundle mainBundle] URLForResource:@\"colorfulStreak\" withExtension:@\"m4v\"];\n    AVPlayer *player = [AVPlayer playerWithURL:url];\n    player.actionAtItemEnd = AVPlayerActionAtItemEndNone;\n    // 2\n    self.playerLayer = [AVPlayerLayer layer];\n    self.playerLayer.frame = CGRectMake(0, 0, 300, 180);\n    self.playerLayer.player = player;\n    [self.viewForPlayerLayer.layer addSublayer:self.playerLayer];\n}\n\n- (void)playerDidReachEndNotificationHandler:(NSNotification *)notification {\n    AVPlayerItem *playerItem = self.playerLayer.player.currentItem;\n    if (playerItem) {\n        [playerItem seekToTime:kCMTimeZero];\n    }\n}\n```\n\n分析：\n1. 根据播放文件路径创建 player ，告诉player播放完成后什么也不做\n2. 创建 playerLayer\n3. 注册 AVPlayer 的播放一个文件结束时的通知。（记得在controller销毁时移除监听）\n\n`AVPlayerLayer` 有两个属性：\n* **videoGravity**：设置视频的显示方式\n* **readyForDisplay**：是否视频加载完成就立刻播放\n\n`AVPlayer` 有几个特别的属性和方法：\n* **rate**：表示0到1的播放速率，0表示暂停，1表示正常速度播放（1X）。换句话说，调用 **pause** 方法等同于 设置 Rate 为 0；调用 **play** 方法等同于 设置 rate 为 1。\n\n那么设置快进，慢动作或者反向播放，可以直接 rate 的值来实现，设置超过 1 的值，就是要求视频快进播放，比如设置为 2，就是两倍的速度播放。设置为负数时，就是反向播放。\n\n在设置 rate 的时候，应该先验证视频能否按照想要设置速率来播放，在 `AVPlayerItem` 中提供了检验的方法：\n* **canPlayFastForward** rate 大于 1\n* **canPlaySlowForward** rate 在 0 和 1 之间\n* **canPlayReverse** rate 是 -1\n* **canPlaySlowReverse** rate 在 -1 和 0 之间\n* **canPlayFastReverse** rate 小于 -1\n\n## CAGradientLayer\n当你使用2种以上颜色时，CAGradientLayer 能够让它很容易应用到背景上，你需要配置一组从 **startPoint** 到 **endPoint** 对应的CGColors。\n\n**startPoint** 和 **endPoint** 不是明确的点，它们是坐标系的边界反映。x的值是1，意味着该点位于layer的右边缘，y的值是1，意味着该点在layer的底部边缘。\n\nCAGradientLayer 有个 **type** 属性，只有**kCAGradientLayerAxial** 一个选项，表示线性过渡颜色数组的值。\n\n如下图所示，线A从 **startPoint** 到 **endPoint** 是渐变方向，垂直于线A的线B，沿着线B的颜色都是一样的。\n{% asset_img AxialGradientLayerType.gif AxialGradientLayerType image %}\n\n另外，你还可以通过 **locations** 属性来控制颜色数组的显示，分配给每个颜色的显示范围。如果没有设置 **locations** 这个值，每个颜色都是平均显示，均匀分布。如果设置了，它的数量必须和颜色的数量对应，否则会发生错误。\n\n```objc\n- (void)setUpGradientLayer {\n    self.gradientLayer = [CAGradientLayer layer];\n    self.gradientLayer.frame = CGRectMake(0, 0, 200, 200);\n    // colors 接收 CGColorRef 的对象数组，用于定义每个 gradient 的结束位置\n    self.gradientLayer.colors = self.colors;\n    // gradient 渐变的起始锚点\n    self.gradientLayer.startPoint = CGPointMake(0.5f, 0.0f);\n    // gradient 渐变的结束锚点\n    self.gradientLayer.endPoint = CGPointMake(0.5f, 1.0f);\n    // 渐变的结束位置，与colors一一对应\n    self.gradientLayer.locations = self.locations;\n    \n    [self.viewForGradientLayer.layer addSublayer:self.gradientLayer];\n}\n```\n\n显示效果如下图：\n{% asset_img CAGradientLayer-500x500.png CAGradientLayer image %}\n\n\n## CAReplicatorLayer\nCAReplicatorLayer 可以将自己的sublayers复制指定的次数。\n每个复制的layer都可以拥有自己的颜色和属性，CAReplicatorLayer可以延迟sublayers的动画效果显示，还支持 Depth（景深）效果产生3D效果。 \n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 创建CAReplicatorLayer，它是个容器层，你添加内容到它上面，它会复制添加的内容。\n    _replicatorLayer = [CAReplicatorLayer layer];\n    [self setUpReplicatorLayer];\n    [_viewForReplicatorLayer.layer addSublayer:_replicatorLayer];\n    \n    // 需要被复制的layer\n    _instanceLayer = [CALayer layer];\n    [self setUpInstanceLayer];\n    [_replicatorLayer addSublayer:_instanceLayer];\n    \n    [self setUpLayerFadeAnimation];\n    [self instanceDelaySliderChanged:_instanceDelaySlider];\n    [self updateLayerSizeSliderValueLabel];\n    [self updateInstanceCountSliderValueLabel];\n    [self updateInstanceDelaySliderValueLabel];\n}\n\n- (void)setUpReplicatorLayer {\n    _replicatorLayer.frame = CGRectMake(0, 0, 250, 250);\n    CGFloat count = self.instanceCountSlider.value;\n    // 复制多少份\n    _replicatorLayer.instanceCount = count;\n    // 是否开启三维空间效果\n    _replicatorLayer.preservesDepth = NO;\n    _replicatorLayer.instanceColor = [[UIColor whiteColor] CGColor];\n    // 颜色值递减\n    _replicatorLayer.instanceRedOffset = [self offsetValueForSwitch:_offsetRedSwitch];\n    _replicatorLayer.instanceGreenOffset = [self offsetValueForSwitch:_offsetGreenSwitch];\n    _replicatorLayer.instanceBlueOffset = [self offsetValueForSwitch:_offsetBlueSwitch];\n    _replicatorLayer.instanceAlphaOffset = [self offsetValueForSwitch:_offsetAlphaSwitch];\n    CGFloat angle = (M_PI * 2.0) / count;\n    // 复制图层在被创建时产生的和上一个复制图层的位移(位移的锚点时CAReplicatorlayer的中心点)\n    _replicatorLayer.instanceTransform = CATransform3DMakeRotation(angle, 0.0, 0.0, 1.0);\n}\n```\n\n分析：\n1. 创建 CAReplicatorLayer 对象，设置它的frame\n2. 设置 replicator layer 复制sublayers个数和延迟渲染时间，设置为2D效果，(preservesDepth = false) ，背景色为白色\n3. 添加 RGBA渐变到每个成功复制的实例上，RGB默认都是0。在本例子中，默认颜色是白色，意味这个RGB都已经设置为1.0\n4. 设置渐变路径是围成个圆\n\n更多详情看Demo的代码\n\n最终效果：\n{% asset_img CAReplicatorLayer.gif CAReplicatorLayer image %}\n\n使用 CAReplicatorLayer 可以创建很多 cool 的动画，可以参考：\n* [使用CAReplicatorLayer创建动画](http://www.ios-animations-by-emails.com/posts/2015-march#tutorial)\n* [CALayer-CAReplicatorLayer(复制图层)](http://www.jianshu.com/p/84455b674f55)\n\n\n## CATiledLayer\n有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。\n\nCATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。\n\n[详细实践](https://zsisme.gitbooks.io/ios-/content/chapter6/catiledLayer.html)\n\nCATiledLayer 有两个properties：（[详细解释](http://www.cocoachina.com/bbs/read.php?tid-31201.html)）\n* **levelsOfDetail** ：表示一共有多少个drawLayer的位置\n* **levelsOfDetailBias**：表示比1大的位置里有多少个drawLayer的位置（包括1）\n\n## 参考链接\n* [iOS-Core-Animation-Advanced-Techniques(七)](http://www.cocoachina.com/ios/20150106/10840.html)\n* [WWDC心得与延伸:iOS图形性能](http://www.cocoachina.com/ios/20150429/11712.html)\n* [iOS-Core-Animation-Advanced-Techniques](https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques)\n\n\n\n","slug":"learn-CALayer-2","published":1,"updated":"2016-10-29T14:56:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7of004u8jpbdivgqwx8","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇文章学习了<strong>CALayer</strong>和它的两个子类<strong>CAScrollLayer</strong>和<strong>CATextLayer</strong>。本章继续学习别的Layer。</p>\n<h2 id=\"AVPlayerLayer\"><a href=\"#AVPlayerLayer\" class=\"headerlink\" title=\"AVPlayerLayer\"></a>AVPlayerLayer</h2><p>AVPlayerLayer是AVFoundation的一个Layer，它有个AVPlayer来播放 AV media 文件（AVPlayerItems）。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpPlayerLayer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 3</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] addObserver:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(playerDidReachEndNotificationHandler:) name:<span class=\"built_in\">AVPlayerItemDidPlayToEndTimeNotification</span> object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpPlayerLayer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"colorfulStreak\"</span> withExtension:<span class=\"string\">@\"m4v\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">AVPlayer</span> *player = [<span class=\"built_in\">AVPlayer</span> playerWithURL:url];</span><br><span class=\"line\">    player.actionAtItemEnd = <span class=\"built_in\">AVPlayerActionAtItemEndNone</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.playerLayer = [<span class=\"built_in\">AVPlayerLayer</span> layer];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.playerLayer.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">300</span>, <span class=\"number\">180</span>);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.playerLayer.player = player;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.viewForPlayerLayer.layer addSublayer:<span class=\"keyword\">self</span>.playerLayer];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)playerDidReachEndNotificationHandler:(<span class=\"built_in\">NSNotification</span> *)notification &#123;</span><br><span class=\"line\">    <span class=\"built_in\">AVPlayerItem</span> *playerItem = <span class=\"keyword\">self</span>.playerLayer.player.currentItem;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (playerItem) &#123;</span><br><span class=\"line\">        [playerItem seekToTime:kCMTimeZero];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>根据播放文件路径创建 player ，告诉player播放完成后什么也不做</li>\n<li>创建 playerLayer</li>\n<li>注册 AVPlayer 的播放一个文件结束时的通知。（记得在controller销毁时移除监听）</li>\n</ol>\n<p><code>AVPlayerLayer</code> 有两个属性：</p>\n<ul>\n<li><strong>videoGravity</strong>：设置视频的显示方式</li>\n<li><strong>readyForDisplay</strong>：是否视频加载完成就立刻播放</li>\n</ul>\n<p><code>AVPlayer</code> 有几个特别的属性和方法：</p>\n<ul>\n<li><strong>rate</strong>：表示0到1的播放速率，0表示暂停，1表示正常速度播放（1X）。换句话说，调用 <strong>pause</strong> 方法等同于 设置 Rate 为 0；调用 <strong>play</strong> 方法等同于 设置 rate 为 1。</li>\n</ul>\n<p>那么设置快进，慢动作或者反向播放，可以直接 rate 的值来实现，设置超过 1 的值，就是要求视频快进播放，比如设置为 2，就是两倍的速度播放。设置为负数时，就是反向播放。</p>\n<p>在设置 rate 的时候，应该先验证视频能否按照想要设置速率来播放，在 <code>AVPlayerItem</code> 中提供了检验的方法：</p>\n<ul>\n<li><strong>canPlayFastForward</strong> rate 大于 1</li>\n<li><strong>canPlaySlowForward</strong> rate 在 0 和 1 之间</li>\n<li><strong>canPlayReverse</strong> rate 是 -1</li>\n<li><strong>canPlaySlowReverse</strong> rate 在 -1 和 0 之间</li>\n<li><strong>canPlayFastReverse</strong> rate 小于 -1</li>\n</ul>\n<h2 id=\"CAGradientLayer\"><a href=\"#CAGradientLayer\" class=\"headerlink\" title=\"CAGradientLayer\"></a>CAGradientLayer</h2><p>当你使用2种以上颜色时，CAGradientLayer 能够让它很容易应用到背景上，你需要配置一组从 <strong>startPoint</strong> 到 <strong>endPoint</strong> 对应的CGColors。</p>\n<p><strong>startPoint</strong> 和 <strong>endPoint</strong> 不是明确的点，它们是坐标系的边界反映。x的值是1，意味着该点位于layer的右边缘，y的值是1，意味着该点在layer的底部边缘。</p>\n<p>CAGradientLayer 有个 <strong>type</strong> 属性，只有<strong>kCAGradientLayerAxial</strong> 一个选项，表示线性过渡颜色数组的值。</p>\n<p>如下图所示，线A从 <strong>startPoint</strong> 到 <strong>endPoint</strong> 是渐变方向，垂直于线A的线B，沿着线B的颜色都是一样的。<br><img src=\"/2016/10/22/learn-CALayer-2/AxialGradientLayerType.gif\" title=\"AxialGradientLayerType image\"></p>\n<p>另外，你还可以通过 <strong>locations</strong> 属性来控制颜色数组的显示，分配给每个颜色的显示范围。如果没有设置 <strong>locations</strong> 这个值，每个颜色都是平均显示，均匀分布。如果设置了，它的数量必须和颜色的数量对应，否则会发生错误。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpGradientLayer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer = [<span class=\"built_in\">CAGradientLayer</span> layer];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">200</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\">    <span class=\"comment\">// colors 接收 CGColorRef 的对象数组，用于定义每个 gradient 的结束位置</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer.colors = <span class=\"keyword\">self</span>.colors;</span><br><span class=\"line\">    <span class=\"comment\">// gradient 渐变的起始锚点</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer.startPoint = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">    <span class=\"comment\">// gradient 渐变的结束锚点</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer.endPoint = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0.5</span>f, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">    <span class=\"comment\">// 渐变的结束位置，与colors一一对应</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer.locations = <span class=\"keyword\">self</span>.locations;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.viewForGradientLayer.layer addSublayer:<span class=\"keyword\">self</span>.gradientLayer];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显示效果如下图：<br><img src=\"/2016/10/22/learn-CALayer-2/CAGradientLayer-500x500.png\" title=\"CAGradientLayer image\"></p>\n<h2 id=\"CAReplicatorLayer\"><a href=\"#CAReplicatorLayer\" class=\"headerlink\" title=\"CAReplicatorLayer\"></a>CAReplicatorLayer</h2><p>CAReplicatorLayer 可以将自己的sublayers复制指定的次数。<br>每个复制的layer都可以拥有自己的颜色和属性，CAReplicatorLayer可以延迟sublayers的动画效果显示，还支持 Depth（景深）效果产生3D效果。 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建CAReplicatorLayer，它是个容器层，你添加内容到它上面，它会复制添加的内容。</span></span><br><span class=\"line\">    _replicatorLayer = [<span class=\"built_in\">CAReplicatorLayer</span> layer];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpReplicatorLayer];</span><br><span class=\"line\">    [_viewForReplicatorLayer.layer addSublayer:_replicatorLayer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 需要被复制的layer</span></span><br><span class=\"line\">    _instanceLayer = [<span class=\"built_in\">CALayer</span> layer];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpInstanceLayer];</span><br><span class=\"line\">    [_replicatorLayer addSublayer:_instanceLayer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpLayerFadeAnimation];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> instanceDelaySliderChanged:_instanceDelaySlider];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateLayerSizeSliderValueLabel];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateInstanceCountSliderValueLabel];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateInstanceDelaySliderValueLabel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpReplicatorLayer &#123;</span><br><span class=\"line\">    _replicatorLayer.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">250</span>, <span class=\"number\">250</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> count = <span class=\"keyword\">self</span>.instanceCountSlider.value;</span><br><span class=\"line\">    <span class=\"comment\">// 复制多少份</span></span><br><span class=\"line\">    _replicatorLayer.instanceCount = count;</span><br><span class=\"line\">    <span class=\"comment\">// 是否开启三维空间效果</span></span><br><span class=\"line\">    _replicatorLayer.preservesDepth = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    _replicatorLayer.instanceColor = [[<span class=\"built_in\">UIColor</span> whiteColor] <span class=\"built_in\">CGColor</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 颜色值递减</span></span><br><span class=\"line\">    _replicatorLayer.instanceRedOffset = [<span class=\"keyword\">self</span> offsetValueForSwitch:_offsetRedSwitch];</span><br><span class=\"line\">    _replicatorLayer.instanceGreenOffset = [<span class=\"keyword\">self</span> offsetValueForSwitch:_offsetGreenSwitch];</span><br><span class=\"line\">    _replicatorLayer.instanceBlueOffset = [<span class=\"keyword\">self</span> offsetValueForSwitch:_offsetBlueSwitch];</span><br><span class=\"line\">    _replicatorLayer.instanceAlphaOffset = [<span class=\"keyword\">self</span> offsetValueForSwitch:_offsetAlphaSwitch];</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> angle = (M_PI * <span class=\"number\">2.0</span>) / count;</span><br><span class=\"line\">    <span class=\"comment\">// 复制图层在被创建时产生的和上一个复制图层的位移(位移的锚点时CAReplicatorlayer的中心点)</span></span><br><span class=\"line\">    _replicatorLayer.instanceTransform = <span class=\"built_in\">CATransform3DMakeRotation</span>(angle, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>创建 CAReplicatorLayer 对象，设置它的frame</li>\n<li>设置 replicator layer 复制sublayers个数和延迟渲染时间，设置为2D效果，(preservesDepth = false) ，背景色为白色</li>\n<li>添加 RGBA渐变到每个成功复制的实例上，RGB默认都是0。在本例子中，默认颜色是白色，意味这个RGB都已经设置为1.0</li>\n<li>设置渐变路径是围成个圆</li>\n</ol>\n<p>更多详情看Demo的代码</p>\n<p>最终效果：<br><img src=\"/2016/10/22/learn-CALayer-2/CAReplicatorLayer.gif\" title=\"CAReplicatorLayer image\"></p>\n<p>使用 CAReplicatorLayer 可以创建很多 cool 的动画，可以参考：</p>\n<ul>\n<li><a href=\"http://www.ios-animations-by-emails.com/posts/2015-march#tutorial\" target=\"_blank\" rel=\"noopener\">使用CAReplicatorLayer创建动画</a></li>\n<li><a href=\"http://www.jianshu.com/p/84455b674f55\" target=\"_blank\" rel=\"noopener\">CALayer-CAReplicatorLayer(复制图层)</a></li>\n</ul>\n<h2 id=\"CATiledLayer\"><a href=\"#CATiledLayer\" class=\"headerlink\" title=\"CATiledLayer\"></a>CATiledLayer</h2><p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。</p>\n<p>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。</p>\n<p><a href=\"https://zsisme.gitbooks.io/ios-/content/chapter6/catiledLayer.html\" target=\"_blank\" rel=\"noopener\">详细实践</a></p>\n<p>CATiledLayer 有两个properties：（<a href=\"http://www.cocoachina.com/bbs/read.php?tid-31201.html\" target=\"_blank\" rel=\"noopener\">详细解释</a>）</p>\n<ul>\n<li><strong>levelsOfDetail</strong> ：表示一共有多少个drawLayer的位置</li>\n<li><strong>levelsOfDetailBias</strong>：表示比1大的位置里有多少个drawLayer的位置（包括1）</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://www.cocoachina.com/ios/20150106/10840.html\" target=\"_blank\" rel=\"noopener\">iOS-Core-Animation-Advanced-Techniques(七)</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150429/11712.html\" target=\"_blank\" rel=\"noopener\">WWDC心得与延伸:iOS图形性能</a></li>\n<li><a href=\"https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques\" target=\"_blank\" rel=\"noopener\">iOS-Core-Animation-Advanced-Techniques</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇文章学习了<strong>CALayer</strong>和它的两个子类<strong>CAScrollLayer</strong>和<strong>CATextLayer</strong>。本章继续学习别的Layer。</p>\n<h2 id=\"AVPlayerLayer\"><a href=\"#AVPlayerLayer\" class=\"headerlink\" title=\"AVPlayerLayer\"></a>AVPlayerLayer</h2><p>AVPlayerLayer是AVFoundation的一个Layer，它有个AVPlayer来播放 AV media 文件（AVPlayerItems）。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpPlayerLayer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 3</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] addObserver:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(playerDidReachEndNotificationHandler:) name:<span class=\"built_in\">AVPlayerItemDidPlayToEndTimeNotification</span> object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpPlayerLayer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"colorfulStreak\"</span> withExtension:<span class=\"string\">@\"m4v\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">AVPlayer</span> *player = [<span class=\"built_in\">AVPlayer</span> playerWithURL:url];</span><br><span class=\"line\">    player.actionAtItemEnd = <span class=\"built_in\">AVPlayerActionAtItemEndNone</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.playerLayer = [<span class=\"built_in\">AVPlayerLayer</span> layer];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.playerLayer.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">300</span>, <span class=\"number\">180</span>);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.playerLayer.player = player;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.viewForPlayerLayer.layer addSublayer:<span class=\"keyword\">self</span>.playerLayer];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)playerDidReachEndNotificationHandler:(<span class=\"built_in\">NSNotification</span> *)notification &#123;</span><br><span class=\"line\">    <span class=\"built_in\">AVPlayerItem</span> *playerItem = <span class=\"keyword\">self</span>.playerLayer.player.currentItem;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (playerItem) &#123;</span><br><span class=\"line\">        [playerItem seekToTime:kCMTimeZero];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>根据播放文件路径创建 player ，告诉player播放完成后什么也不做</li>\n<li>创建 playerLayer</li>\n<li>注册 AVPlayer 的播放一个文件结束时的通知。（记得在controller销毁时移除监听）</li>\n</ol>\n<p><code>AVPlayerLayer</code> 有两个属性：</p>\n<ul>\n<li><strong>videoGravity</strong>：设置视频的显示方式</li>\n<li><strong>readyForDisplay</strong>：是否视频加载完成就立刻播放</li>\n</ul>\n<p><code>AVPlayer</code> 有几个特别的属性和方法：</p>\n<ul>\n<li><strong>rate</strong>：表示0到1的播放速率，0表示暂停，1表示正常速度播放（1X）。换句话说，调用 <strong>pause</strong> 方法等同于 设置 Rate 为 0；调用 <strong>play</strong> 方法等同于 设置 rate 为 1。</li>\n</ul>\n<p>那么设置快进，慢动作或者反向播放，可以直接 rate 的值来实现，设置超过 1 的值，就是要求视频快进播放，比如设置为 2，就是两倍的速度播放。设置为负数时，就是反向播放。</p>\n<p>在设置 rate 的时候，应该先验证视频能否按照想要设置速率来播放，在 <code>AVPlayerItem</code> 中提供了检验的方法：</p>\n<ul>\n<li><strong>canPlayFastForward</strong> rate 大于 1</li>\n<li><strong>canPlaySlowForward</strong> rate 在 0 和 1 之间</li>\n<li><strong>canPlayReverse</strong> rate 是 -1</li>\n<li><strong>canPlaySlowReverse</strong> rate 在 -1 和 0 之间</li>\n<li><strong>canPlayFastReverse</strong> rate 小于 -1</li>\n</ul>\n<h2 id=\"CAGradientLayer\"><a href=\"#CAGradientLayer\" class=\"headerlink\" title=\"CAGradientLayer\"></a>CAGradientLayer</h2><p>当你使用2种以上颜色时，CAGradientLayer 能够让它很容易应用到背景上，你需要配置一组从 <strong>startPoint</strong> 到 <strong>endPoint</strong> 对应的CGColors。</p>\n<p><strong>startPoint</strong> 和 <strong>endPoint</strong> 不是明确的点，它们是坐标系的边界反映。x的值是1，意味着该点位于layer的右边缘，y的值是1，意味着该点在layer的底部边缘。</p>\n<p>CAGradientLayer 有个 <strong>type</strong> 属性，只有<strong>kCAGradientLayerAxial</strong> 一个选项，表示线性过渡颜色数组的值。</p>\n<p>如下图所示，线A从 <strong>startPoint</strong> 到 <strong>endPoint</strong> 是渐变方向，垂直于线A的线B，沿着线B的颜色都是一样的。<br><img src=\"/2016/10/22/learn-CALayer-2/AxialGradientLayerType.gif\" title=\"AxialGradientLayerType image\"></p>\n<p>另外，你还可以通过 <strong>locations</strong> 属性来控制颜色数组的显示，分配给每个颜色的显示范围。如果没有设置 <strong>locations</strong> 这个值，每个颜色都是平均显示，均匀分布。如果设置了，它的数量必须和颜色的数量对应，否则会发生错误。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpGradientLayer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer = [<span class=\"built_in\">CAGradientLayer</span> layer];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">200</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\">    <span class=\"comment\">// colors 接收 CGColorRef 的对象数组，用于定义每个 gradient 的结束位置</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer.colors = <span class=\"keyword\">self</span>.colors;</span><br><span class=\"line\">    <span class=\"comment\">// gradient 渐变的起始锚点</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer.startPoint = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\">    <span class=\"comment\">// gradient 渐变的结束锚点</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer.endPoint = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0.5</span>f, <span class=\"number\">1.0</span>f);</span><br><span class=\"line\">    <span class=\"comment\">// 渐变的结束位置，与colors一一对应</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gradientLayer.locations = <span class=\"keyword\">self</span>.locations;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.viewForGradientLayer.layer addSublayer:<span class=\"keyword\">self</span>.gradientLayer];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显示效果如下图：<br><img src=\"/2016/10/22/learn-CALayer-2/CAGradientLayer-500x500.png\" title=\"CAGradientLayer image\"></p>\n<h2 id=\"CAReplicatorLayer\"><a href=\"#CAReplicatorLayer\" class=\"headerlink\" title=\"CAReplicatorLayer\"></a>CAReplicatorLayer</h2><p>CAReplicatorLayer 可以将自己的sublayers复制指定的次数。<br>每个复制的layer都可以拥有自己的颜色和属性，CAReplicatorLayer可以延迟sublayers的动画效果显示，还支持 Depth（景深）效果产生3D效果。 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建CAReplicatorLayer，它是个容器层，你添加内容到它上面，它会复制添加的内容。</span></span><br><span class=\"line\">    _replicatorLayer = [<span class=\"built_in\">CAReplicatorLayer</span> layer];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpReplicatorLayer];</span><br><span class=\"line\">    [_viewForReplicatorLayer.layer addSublayer:_replicatorLayer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 需要被复制的layer</span></span><br><span class=\"line\">    _instanceLayer = [<span class=\"built_in\">CALayer</span> layer];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpInstanceLayer];</span><br><span class=\"line\">    [_replicatorLayer addSublayer:_instanceLayer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpLayerFadeAnimation];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> instanceDelaySliderChanged:_instanceDelaySlider];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateLayerSizeSliderValueLabel];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateInstanceCountSliderValueLabel];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateInstanceDelaySliderValueLabel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpReplicatorLayer &#123;</span><br><span class=\"line\">    _replicatorLayer.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">250</span>, <span class=\"number\">250</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> count = <span class=\"keyword\">self</span>.instanceCountSlider.value;</span><br><span class=\"line\">    <span class=\"comment\">// 复制多少份</span></span><br><span class=\"line\">    _replicatorLayer.instanceCount = count;</span><br><span class=\"line\">    <span class=\"comment\">// 是否开启三维空间效果</span></span><br><span class=\"line\">    _replicatorLayer.preservesDepth = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    _replicatorLayer.instanceColor = [[<span class=\"built_in\">UIColor</span> whiteColor] <span class=\"built_in\">CGColor</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 颜色值递减</span></span><br><span class=\"line\">    _replicatorLayer.instanceRedOffset = [<span class=\"keyword\">self</span> offsetValueForSwitch:_offsetRedSwitch];</span><br><span class=\"line\">    _replicatorLayer.instanceGreenOffset = [<span class=\"keyword\">self</span> offsetValueForSwitch:_offsetGreenSwitch];</span><br><span class=\"line\">    _replicatorLayer.instanceBlueOffset = [<span class=\"keyword\">self</span> offsetValueForSwitch:_offsetBlueSwitch];</span><br><span class=\"line\">    _replicatorLayer.instanceAlphaOffset = [<span class=\"keyword\">self</span> offsetValueForSwitch:_offsetAlphaSwitch];</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> angle = (M_PI * <span class=\"number\">2.0</span>) / count;</span><br><span class=\"line\">    <span class=\"comment\">// 复制图层在被创建时产生的和上一个复制图层的位移(位移的锚点时CAReplicatorlayer的中心点)</span></span><br><span class=\"line\">    _replicatorLayer.instanceTransform = <span class=\"built_in\">CATransform3DMakeRotation</span>(angle, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>创建 CAReplicatorLayer 对象，设置它的frame</li>\n<li>设置 replicator layer 复制sublayers个数和延迟渲染时间，设置为2D效果，(preservesDepth = false) ，背景色为白色</li>\n<li>添加 RGBA渐变到每个成功复制的实例上，RGB默认都是0。在本例子中，默认颜色是白色，意味这个RGB都已经设置为1.0</li>\n<li>设置渐变路径是围成个圆</li>\n</ol>\n<p>更多详情看Demo的代码</p>\n<p>最终效果：<br><img src=\"/2016/10/22/learn-CALayer-2/CAReplicatorLayer.gif\" title=\"CAReplicatorLayer image\"></p>\n<p>使用 CAReplicatorLayer 可以创建很多 cool 的动画，可以参考：</p>\n<ul>\n<li><a href=\"http://www.ios-animations-by-emails.com/posts/2015-march#tutorial\" target=\"_blank\" rel=\"noopener\">使用CAReplicatorLayer创建动画</a></li>\n<li><a href=\"http://www.jianshu.com/p/84455b674f55\" target=\"_blank\" rel=\"noopener\">CALayer-CAReplicatorLayer(复制图层)</a></li>\n</ul>\n<h2 id=\"CATiledLayer\"><a href=\"#CATiledLayer\" class=\"headerlink\" title=\"CATiledLayer\"></a>CATiledLayer</h2><p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。</p>\n<p>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。</p>\n<p><a href=\"https://zsisme.gitbooks.io/ios-/content/chapter6/catiledLayer.html\" target=\"_blank\" rel=\"noopener\">详细实践</a></p>\n<p>CATiledLayer 有两个properties：（<a href=\"http://www.cocoachina.com/bbs/read.php?tid-31201.html\" target=\"_blank\" rel=\"noopener\">详细解释</a>）</p>\n<ul>\n<li><strong>levelsOfDetail</strong> ：表示一共有多少个drawLayer的位置</li>\n<li><strong>levelsOfDetailBias</strong>：表示比1大的位置里有多少个drawLayer的位置（包括1）</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"http://www.cocoachina.com/ios/20150106/10840.html\" target=\"_blank\" rel=\"noopener\">iOS-Core-Animation-Advanced-Techniques(七)</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150429/11712.html\" target=\"_blank\" rel=\"noopener\">WWDC心得与延伸:iOS图形性能</a></li>\n<li><a href=\"https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques\" target=\"_blank\" rel=\"noopener\">iOS-Core-Animation-Advanced-Techniques</a></li>\n</ul>\n"},{"title":"学习CALayer（三）","date":"2016-10-29T08:43:40.000Z","_content":"\n## 前言\n前两篇介绍CALayer和它的部分子类，本章继续学习其他的子类。\n\n## CAShapeLayer\nCAShapeLayer 可以通过设置矢量路径来绘制图片，它使用起来比使用图片快得多。另一个优势是你不再需要提供常规的@2x和@3x尺寸的图片了。\n\n此外，你可以使用各种属性来自定义线条粗细，颜色，划线，连线路径。如果线条相交形成一个封闭的区域，可以设置填充该区域的颜色。\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 1\n    self.color = [UIColor colorWithRed:248/255.0 green:96/255.0 blue:47/255.0 alpha:1.0];\n    [self setUpOpenPath];\n    [self setUpClosedPath];\n    [self setUpShapeLayer];\n}\n\n- (void)setUpShapeLayer {\n    // 3\n    self.shapeLayer = ({\n        CAShapeLayer *layer = [CAShapeLayer layer];\n        layer.path = self.openPath.CGPath;\n        layer.fillColor = nil;\n        layer.fillRule = kCAFillRuleNonZero;\n        layer.lineCap = kCALineCapButt;\n        layer.lineDashPattern = nil;\n        layer.lineDashPhase = 0.0;\n        layer.lineJoin = kCALineJoinMiter;\n        layer.lineWidth = _lineWidthSlider.value;\n        layer.miterLimit = 4.0;\n        layer.strokeColor = self.color.CGColor;\n        [_viewForShapeLayer.layer addSublayer:layer];\n        layer;\n    });\n    \n}\n\n- (void)setUpOpenPath {\n\t// 2\n    self.openPath = [UIBezierPath bezierPath];\n    [self.openPath moveToPoint:CGPointMake(30, 196)];\n    [self.openPath addCurveToPoint:CGPointMake(112.0, 12.5) controlPoint1:CGPointMake(110.56, 13.79) controlPoint2:CGPointMake(112.07, 13.01)];\n    [self.openPath addCurveToPoint:CGPointMake(194, 196) controlPoint1:CGPointMake(111.9, 11.81) controlPoint2:CGPointMake(194, 196)];\n    [self.openPath addLineToPoint:CGPointMake(30.0, 85.68)];\n    [self.openPath addLineToPoint:CGPointMake(194.0, 48.91)];\n    [self.openPath addLineToPoint:CGPointMake(30.0, 196)];\n}\n\n- (void)setUpClosedPath {\n    self.closedPath = [UIBezierPath bezierPath];\n    self.closedPath.CGPath = self.openPath.CGPath;\n    [self.closedPath closePath];\n}\n```\n\n分析：\n1. 创建 color，path 和 shapeLayer\n2. 绘制 shapeLayer 路径。如果你不想这个写绘图代码，你可以使用 PaintCode 软件，导入矢量图（SVG）或者 photoshop（PSD）文件来生成你的代码。\n3. 设置 shapeLayer 的属性\n\n**CAShapeLayer** 属性\n* **fillRule**：填充规则，有两个选择 **kCAFillRuleNonZero** 和 **kCAFillRuleEvenOdd**\n\n**nonzero**字面意思是“非零”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右穿过射线则计数加1，从右向左穿过射线则计数减1。得出计数结果后，如果结果是0，则认为点在图形外部，否则认为在内部。下图演示了nonzero规则:\n{% asset_img nonzero.png nonzero image %}\n\n**evenodd**字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部。下图演示了evenodd 规则\n{% asset_img evenodd.png evenodd image %}\n\n* **lineCap**：线端点类型\n{% asset_img lineCap.png lineCap image %}\n\n* **lineJoin**：线连接类型\n{% asset_img lineJoin.png lineJoin image %}\n\n* **lineDashPattern**：线型模板\n这是一个NSNumber的数组，索引从1开始记，奇数位数值表示实线长度，偶数位数值表示空白长度\n\n* **lineDashPhase**：线型模板的起始位置\n默认是0，可以理解为第一个空格起始位置 = 实线长度 - lineDashPhase。假设设置为5绘制 5空格，设置lineDashPhase为2，那么第一段绘制为5-2，然后空5绘制5\n\n\n## CATransformLayer\nCATransformLayer 和别的平面的Layer不一样，它可以绘制3D结构。它实际上是其sublayers的容器，每个子图层可以有自己的transforms和opacity变换，但是，它不会渲染自己的属性，比如背景色，边框，只渲染sublayers。\n\n你不能直接点击一个transform layer，因为它没有一个2D坐标空间来映射一个接触点，但是能够点击单个sublayers。\n\n```objc\n@interface ViewController ()  \n{  \n    CGPoint startPoint;  \n  \n    CATransformLayer *s_Cube;  \n  \n    float pix, piy;  \n}  \n  \n@property (nonatomic, weak) IBOutlet UIView *containerView;  \n  \n@end  \n  \n@implementation ViewController  \n  \n- (CALayer *)faceWithTransform:(CATransform3D)transform  \n{  \n    //create cube face layer  \n    CALayer *face = [CALayer layer];  \n    face.frame = CGRectMake(-50, -50, 100, 100);  \n      \n    //apply a random color  \n    CGFloat red = (rand() / (double)INT_MAX);  \n    CGFloat green = (rand() / (double)INT_MAX);  \n    CGFloat blue = (rand() / (double)INT_MAX);  \n    face.backgroundColor = [UIColor colorWithRed:red  \n                                           green:green  \n                                            blue:blue  \n                                           alpha:1.0].CGColor;  \n  \n    //apply the transform and return  \n    face.transform = transform;  \n    return face;  \n}  \n  \n- (CALayer *)cubeWithTransform:(CATransform3D)transform  \n{  \n    //create cube layer  \n    CATransformLayer *cube = [CATransformLayer layer];  \n      \n    //add cube face 1  \n    CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //add cube face 2  \n    ct = CATransform3DMakeTranslation(50, 0, 0);  \n    ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //add cube face 3  \n    ct = CATransform3DMakeTranslation(0, -50, 0);  \n    ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //add cube face 4  \n    ct = CATransform3DMakeTranslation(0, 50, 0);  \n    ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //add cube face 5  \n    ct = CATransform3DMakeTranslation(-50, 0, 0);  \n    ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //add cube face 6  \n    ct = CATransform3DMakeTranslation(0, 0, -50);  \n    ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //center the cube layer within the container  \n    CGSize containerSize = self.containerView.bounds.size;  \n    cube.position = CGPointMake(containerSize.width / 2.0,  \n                                containerSize.height / 2.0);  \n      \n    //apply the transform and return  \n    cube.transform = transform;  \n    return cube;  \n}  \n  \n- (void)viewDidLoad  \n{  \n    [super viewDidLoad];  \n      \n    //set up the perspective transform  \n    CATransform3D pt = CATransform3DIdentity;  \n    pt.m34 = -1.0 / 500.0;  \n    self.containerView.layer.sublayerTransform = pt;  \n      \n    //set up the transform for cube 1 and add it  \n    CATransform3D c1t = CATransform3DIdentity;  \n    c1t = CATransform3DTranslate(c1t, -100, 0, 0);  \n    CALayer *cube1 = [self cubeWithTransform:c1t];  \n    s_Cube = (CATransformLayer *)cube1;  \n    [self.containerView.layer addSublayer:cube1];  \n      \n    //set up the transform for cube 2 and add it  \n    CATransform3D c2t = CATransform3DIdentity;  \n    c2t = CATransform3DTranslate(c2t, 100, 0, 0);  \n    c2t = CATransform3DRotate(c2t, -M_PI_4, 1, 0, 0);  \n    c2t = CATransform3DRotate(c2t, -M_PI_4, 0, 1, 0);  \n    CALayer *cube2 = [self cubeWithTransform:c2t];  \n    [self.containerView.layer addSublayer:cube2];  \n}  \n  \n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event  \n{  \n    UITouch *touch = [touches anyObject];  \n  \n    startPoint = [touch locationInView:self.view];  \n}  \n  \n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event  \n{  \n    UITouch *touch = [touches anyObject];  \n  \n    CGPoint currentPosition = [touch locationInView:self.view];  \n  \n    CGFloat deltaX = startPoint.x - currentPosition.x;  \n  \n    CGFloat deltaY = startPoint.y - currentPosition.y;  \n  \n    CATransform3D c1t = CATransform3DIdentity;  \n    c1t = CATransform3DTranslate(c1t, -100, 0, 0);  \n    c1t = CATransform3DRotate(c1t, pix+M_PI_2*deltaY/100, 1, 0, 0);  \n    c1t = CATransform3DRotate(c1t, piy-M_PI_2*deltaX/100, 0, 1, 0);  \n  \n    s_Cube.transform = c1t;  \n}  \n  \n- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event  \n{  \n    UITouch *touch = [touches anyObject];  \n  \n    CGPoint currentPosition = [touch locationInView:self.view];  \n  \n    CGFloat deltaX = startPoint.x - currentPosition.x;  \n  \n    CGFloat deltaY = startPoint.y - currentPosition.y;  \n  \n    pix = M_PI_2*deltaY/100;  \n    piy = -M_PI_2*deltaX/100;  \n}  \n  \n@end  \n```\n\n分析：\n1. 给立方体创建每个面，设置不一样的颜色，并添加到同一个transform layer\n2. 给每个面设置不一样的Z轴的值已经旋转角度，增加层次感\n3. 每次旋转都是基于x轴和y轴的偏移。注意，代码里是给 **sublayerTransform** 设置 **transform** 值，它可以应用到transform layer的每个sublayers\n\n\n## CAEmitterLayer\nCAEmitterLayer 渲染粒子动画，每个粒子都是一个 CAEmitterCell 对象。通过设置 CAEmitterLayer 和 CAEmitterCell 的属性，可以改变粒子的速率，大小，形状，颜色，加速度，生命周期等等。\n\n```objc\n@interface JHCAEmitterLayerViewController ()\n@property (weak, nonatomic) IBOutlet UIView *viewForEmitterLayer;\n@end\n\n@implementation JHCAEmitterLayerViewController\n- (CAEmitterLayer *)emitterLayer {\n    if (!_emitterLayer) {\n        _emitterLayer = ({\n            CAEmitterLayer *layer = [CAEmitterLayer layer];\n            layer.frame=  CGRectMake(0, 0, kScreenWidth, kScreenHeight * 0.5);\n            layer.seed = [[NSDate date] timeIntervalSince1970];\n            layer.emitterPosition = CGPointMake(kScreenWidth * 0.5, kScreenHeight * 0.25);\n            [_viewForEmitterLayer.layer addSublayer:layer];\n            layer;\n        });\n    }\n    return _emitterLayer;\n}\n\n- (CAEmitterCell *)emitterCell {\n    if (!_emitterCell) {\n        _emitterCell = ({\n            CAEmitterCell *emitterCell = [CAEmitterCell emitterCell];\n            emitterCell.enabled = YES;\n            emitterCell.name = @\"yjh\";\n            emitterCell.contents = (__bridge id _Nullable)([UIImage imageNamed:@\"smallStar\"].CGImage);\n            emitterCell.contentsRect = CGRectMake(0, 0, 1, 1);\n            emitterCell.color = [UIColor colorWithRed:0 green:0 blue:0 alpha:1.0].CGColor;\n            emitterCell.redRange = 1.0;\n            emitterCell.greenRange = 1.0;\n            emitterCell.blueRange = 1.0;\n            emitterCell.alphaRange = 0.0;\n            emitterCell.redSpeed = 0.0;\n            emitterCell.greenSpeed = 0.0;\n            emitterCell.blueSpeed = 0.0;\n            emitterCell.alphaSpeed = -0.5;\n            emitterCell.scale = 1.0;\n            emitterCell.scaleRange = 0.0;\n            emitterCell.scaleSpeed = 0.1;\n            \n            CGFloat zeroDegreesInRadians = [self degreesToRadians:0.0];\n            emitterCell.spin = [self degreesToRadians:130.0];\n            emitterCell.spinRange = zeroDegreesInRadians;\n            emitterCell.emissionLatitude = zeroDegreesInRadians;\n            emitterCell.emissionLongitude = zeroDegreesInRadians;\n            emitterCell.emissionRange = [self degreesToRadians:360.0];\n            \n            emitterCell.lifetime = 1.0;\n            emitterCell.lifetimeRange = 0.0;\n            emitterCell.birthRate = 250.0;\n            emitterCell.velocity = 50.0;\n            emitterCell.velocityRange = 500.0;\n            emitterCell.xAcceleration = -750.0;\n            emitterCell.yAcceleration = 0.0;\n            \n            emitterCell;\n        });\n    }\n    return _emitterCell;\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self resetEmitterCells];\n}\n```\n\n分析：\n1. 创建 emitter layer 和 emitter cell\n2. 设置 emitter cells 的渲染模式 renderMode\n3. 将异步渲染 drawsAsynchronously 设置为YES，这可以提高性能，因为发射器层必须持续地重绘其发射器单元。\n4. 设置 emitterCell 时，有很多属性需要赋值。contents 设置粒子的内容，然后设置初始速度和最大方差（velocityRange），emitter layer 使用 初始值+/-方差 区间内的随机数来初始化粒子，很多 emitterCell 的属性都有方差设置。\n5. 设置 cell 的生命周期是1秒，默认是0，所以如果你没明确设置，cell 永远不会出现，birthRate（每秒产生数量） 也一样，默认是0，必须设置为正整数才能显示 cell\n6. 设置 x 和 y轴的加速度，它会影响粒子的运动轨迹\n\n\n## 参考资料\n* [IOS Core Animation Advanced Techniques的学习笔记(五)](http://blog.csdn.net/iunion/article/details/26221213)\n* [关于贝塞尔曲线](http://blog.csdn.net/shidongdong2012/article/details/22478463)\n\n","source":"_posts/learn-CALayer-3.md","raw":"---\ntitle: 学习CALayer（三）\ndate: 2016-10-29 16:43:40\ntags: CALayer\ncategory: 能工巧匠\n---\n\n## 前言\n前两篇介绍CALayer和它的部分子类，本章继续学习其他的子类。\n\n## CAShapeLayer\nCAShapeLayer 可以通过设置矢量路径来绘制图片，它使用起来比使用图片快得多。另一个优势是你不再需要提供常规的@2x和@3x尺寸的图片了。\n\n此外，你可以使用各种属性来自定义线条粗细，颜色，划线，连线路径。如果线条相交形成一个封闭的区域，可以设置填充该区域的颜色。\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 1\n    self.color = [UIColor colorWithRed:248/255.0 green:96/255.0 blue:47/255.0 alpha:1.0];\n    [self setUpOpenPath];\n    [self setUpClosedPath];\n    [self setUpShapeLayer];\n}\n\n- (void)setUpShapeLayer {\n    // 3\n    self.shapeLayer = ({\n        CAShapeLayer *layer = [CAShapeLayer layer];\n        layer.path = self.openPath.CGPath;\n        layer.fillColor = nil;\n        layer.fillRule = kCAFillRuleNonZero;\n        layer.lineCap = kCALineCapButt;\n        layer.lineDashPattern = nil;\n        layer.lineDashPhase = 0.0;\n        layer.lineJoin = kCALineJoinMiter;\n        layer.lineWidth = _lineWidthSlider.value;\n        layer.miterLimit = 4.0;\n        layer.strokeColor = self.color.CGColor;\n        [_viewForShapeLayer.layer addSublayer:layer];\n        layer;\n    });\n    \n}\n\n- (void)setUpOpenPath {\n\t// 2\n    self.openPath = [UIBezierPath bezierPath];\n    [self.openPath moveToPoint:CGPointMake(30, 196)];\n    [self.openPath addCurveToPoint:CGPointMake(112.0, 12.5) controlPoint1:CGPointMake(110.56, 13.79) controlPoint2:CGPointMake(112.07, 13.01)];\n    [self.openPath addCurveToPoint:CGPointMake(194, 196) controlPoint1:CGPointMake(111.9, 11.81) controlPoint2:CGPointMake(194, 196)];\n    [self.openPath addLineToPoint:CGPointMake(30.0, 85.68)];\n    [self.openPath addLineToPoint:CGPointMake(194.0, 48.91)];\n    [self.openPath addLineToPoint:CGPointMake(30.0, 196)];\n}\n\n- (void)setUpClosedPath {\n    self.closedPath = [UIBezierPath bezierPath];\n    self.closedPath.CGPath = self.openPath.CGPath;\n    [self.closedPath closePath];\n}\n```\n\n分析：\n1. 创建 color，path 和 shapeLayer\n2. 绘制 shapeLayer 路径。如果你不想这个写绘图代码，你可以使用 PaintCode 软件，导入矢量图（SVG）或者 photoshop（PSD）文件来生成你的代码。\n3. 设置 shapeLayer 的属性\n\n**CAShapeLayer** 属性\n* **fillRule**：填充规则，有两个选择 **kCAFillRuleNonZero** 和 **kCAFillRuleEvenOdd**\n\n**nonzero**字面意思是“非零”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右穿过射线则计数加1，从右向左穿过射线则计数减1。得出计数结果后，如果结果是0，则认为点在图形外部，否则认为在内部。下图演示了nonzero规则:\n{% asset_img nonzero.png nonzero image %}\n\n**evenodd**字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部。下图演示了evenodd 规则\n{% asset_img evenodd.png evenodd image %}\n\n* **lineCap**：线端点类型\n{% asset_img lineCap.png lineCap image %}\n\n* **lineJoin**：线连接类型\n{% asset_img lineJoin.png lineJoin image %}\n\n* **lineDashPattern**：线型模板\n这是一个NSNumber的数组，索引从1开始记，奇数位数值表示实线长度，偶数位数值表示空白长度\n\n* **lineDashPhase**：线型模板的起始位置\n默认是0，可以理解为第一个空格起始位置 = 实线长度 - lineDashPhase。假设设置为5绘制 5空格，设置lineDashPhase为2，那么第一段绘制为5-2，然后空5绘制5\n\n\n## CATransformLayer\nCATransformLayer 和别的平面的Layer不一样，它可以绘制3D结构。它实际上是其sublayers的容器，每个子图层可以有自己的transforms和opacity变换，但是，它不会渲染自己的属性，比如背景色，边框，只渲染sublayers。\n\n你不能直接点击一个transform layer，因为它没有一个2D坐标空间来映射一个接触点，但是能够点击单个sublayers。\n\n```objc\n@interface ViewController ()  \n{  \n    CGPoint startPoint;  \n  \n    CATransformLayer *s_Cube;  \n  \n    float pix, piy;  \n}  \n  \n@property (nonatomic, weak) IBOutlet UIView *containerView;  \n  \n@end  \n  \n@implementation ViewController  \n  \n- (CALayer *)faceWithTransform:(CATransform3D)transform  \n{  \n    //create cube face layer  \n    CALayer *face = [CALayer layer];  \n    face.frame = CGRectMake(-50, -50, 100, 100);  \n      \n    //apply a random color  \n    CGFloat red = (rand() / (double)INT_MAX);  \n    CGFloat green = (rand() / (double)INT_MAX);  \n    CGFloat blue = (rand() / (double)INT_MAX);  \n    face.backgroundColor = [UIColor colorWithRed:red  \n                                           green:green  \n                                            blue:blue  \n                                           alpha:1.0].CGColor;  \n  \n    //apply the transform and return  \n    face.transform = transform;  \n    return face;  \n}  \n  \n- (CALayer *)cubeWithTransform:(CATransform3D)transform  \n{  \n    //create cube layer  \n    CATransformLayer *cube = [CATransformLayer layer];  \n      \n    //add cube face 1  \n    CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //add cube face 2  \n    ct = CATransform3DMakeTranslation(50, 0, 0);  \n    ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //add cube face 3  \n    ct = CATransform3DMakeTranslation(0, -50, 0);  \n    ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //add cube face 4  \n    ct = CATransform3DMakeTranslation(0, 50, 0);  \n    ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //add cube face 5  \n    ct = CATransform3DMakeTranslation(-50, 0, 0);  \n    ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //add cube face 6  \n    ct = CATransform3DMakeTranslation(0, 0, -50);  \n    ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);  \n    [cube addSublayer:[self faceWithTransform:ct]];  \n      \n    //center the cube layer within the container  \n    CGSize containerSize = self.containerView.bounds.size;  \n    cube.position = CGPointMake(containerSize.width / 2.0,  \n                                containerSize.height / 2.0);  \n      \n    //apply the transform and return  \n    cube.transform = transform;  \n    return cube;  \n}  \n  \n- (void)viewDidLoad  \n{  \n    [super viewDidLoad];  \n      \n    //set up the perspective transform  \n    CATransform3D pt = CATransform3DIdentity;  \n    pt.m34 = -1.0 / 500.0;  \n    self.containerView.layer.sublayerTransform = pt;  \n      \n    //set up the transform for cube 1 and add it  \n    CATransform3D c1t = CATransform3DIdentity;  \n    c1t = CATransform3DTranslate(c1t, -100, 0, 0);  \n    CALayer *cube1 = [self cubeWithTransform:c1t];  \n    s_Cube = (CATransformLayer *)cube1;  \n    [self.containerView.layer addSublayer:cube1];  \n      \n    //set up the transform for cube 2 and add it  \n    CATransform3D c2t = CATransform3DIdentity;  \n    c2t = CATransform3DTranslate(c2t, 100, 0, 0);  \n    c2t = CATransform3DRotate(c2t, -M_PI_4, 1, 0, 0);  \n    c2t = CATransform3DRotate(c2t, -M_PI_4, 0, 1, 0);  \n    CALayer *cube2 = [self cubeWithTransform:c2t];  \n    [self.containerView.layer addSublayer:cube2];  \n}  \n  \n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event  \n{  \n    UITouch *touch = [touches anyObject];  \n  \n    startPoint = [touch locationInView:self.view];  \n}  \n  \n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event  \n{  \n    UITouch *touch = [touches anyObject];  \n  \n    CGPoint currentPosition = [touch locationInView:self.view];  \n  \n    CGFloat deltaX = startPoint.x - currentPosition.x;  \n  \n    CGFloat deltaY = startPoint.y - currentPosition.y;  \n  \n    CATransform3D c1t = CATransform3DIdentity;  \n    c1t = CATransform3DTranslate(c1t, -100, 0, 0);  \n    c1t = CATransform3DRotate(c1t, pix+M_PI_2*deltaY/100, 1, 0, 0);  \n    c1t = CATransform3DRotate(c1t, piy-M_PI_2*deltaX/100, 0, 1, 0);  \n  \n    s_Cube.transform = c1t;  \n}  \n  \n- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event  \n{  \n    UITouch *touch = [touches anyObject];  \n  \n    CGPoint currentPosition = [touch locationInView:self.view];  \n  \n    CGFloat deltaX = startPoint.x - currentPosition.x;  \n  \n    CGFloat deltaY = startPoint.y - currentPosition.y;  \n  \n    pix = M_PI_2*deltaY/100;  \n    piy = -M_PI_2*deltaX/100;  \n}  \n  \n@end  \n```\n\n分析：\n1. 给立方体创建每个面，设置不一样的颜色，并添加到同一个transform layer\n2. 给每个面设置不一样的Z轴的值已经旋转角度，增加层次感\n3. 每次旋转都是基于x轴和y轴的偏移。注意，代码里是给 **sublayerTransform** 设置 **transform** 值，它可以应用到transform layer的每个sublayers\n\n\n## CAEmitterLayer\nCAEmitterLayer 渲染粒子动画，每个粒子都是一个 CAEmitterCell 对象。通过设置 CAEmitterLayer 和 CAEmitterCell 的属性，可以改变粒子的速率，大小，形状，颜色，加速度，生命周期等等。\n\n```objc\n@interface JHCAEmitterLayerViewController ()\n@property (weak, nonatomic) IBOutlet UIView *viewForEmitterLayer;\n@end\n\n@implementation JHCAEmitterLayerViewController\n- (CAEmitterLayer *)emitterLayer {\n    if (!_emitterLayer) {\n        _emitterLayer = ({\n            CAEmitterLayer *layer = [CAEmitterLayer layer];\n            layer.frame=  CGRectMake(0, 0, kScreenWidth, kScreenHeight * 0.5);\n            layer.seed = [[NSDate date] timeIntervalSince1970];\n            layer.emitterPosition = CGPointMake(kScreenWidth * 0.5, kScreenHeight * 0.25);\n            [_viewForEmitterLayer.layer addSublayer:layer];\n            layer;\n        });\n    }\n    return _emitterLayer;\n}\n\n- (CAEmitterCell *)emitterCell {\n    if (!_emitterCell) {\n        _emitterCell = ({\n            CAEmitterCell *emitterCell = [CAEmitterCell emitterCell];\n            emitterCell.enabled = YES;\n            emitterCell.name = @\"yjh\";\n            emitterCell.contents = (__bridge id _Nullable)([UIImage imageNamed:@\"smallStar\"].CGImage);\n            emitterCell.contentsRect = CGRectMake(0, 0, 1, 1);\n            emitterCell.color = [UIColor colorWithRed:0 green:0 blue:0 alpha:1.0].CGColor;\n            emitterCell.redRange = 1.0;\n            emitterCell.greenRange = 1.0;\n            emitterCell.blueRange = 1.0;\n            emitterCell.alphaRange = 0.0;\n            emitterCell.redSpeed = 0.0;\n            emitterCell.greenSpeed = 0.0;\n            emitterCell.blueSpeed = 0.0;\n            emitterCell.alphaSpeed = -0.5;\n            emitterCell.scale = 1.0;\n            emitterCell.scaleRange = 0.0;\n            emitterCell.scaleSpeed = 0.1;\n            \n            CGFloat zeroDegreesInRadians = [self degreesToRadians:0.0];\n            emitterCell.spin = [self degreesToRadians:130.0];\n            emitterCell.spinRange = zeroDegreesInRadians;\n            emitterCell.emissionLatitude = zeroDegreesInRadians;\n            emitterCell.emissionLongitude = zeroDegreesInRadians;\n            emitterCell.emissionRange = [self degreesToRadians:360.0];\n            \n            emitterCell.lifetime = 1.0;\n            emitterCell.lifetimeRange = 0.0;\n            emitterCell.birthRate = 250.0;\n            emitterCell.velocity = 50.0;\n            emitterCell.velocityRange = 500.0;\n            emitterCell.xAcceleration = -750.0;\n            emitterCell.yAcceleration = 0.0;\n            \n            emitterCell;\n        });\n    }\n    return _emitterCell;\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self resetEmitterCells];\n}\n```\n\n分析：\n1. 创建 emitter layer 和 emitter cell\n2. 设置 emitter cells 的渲染模式 renderMode\n3. 将异步渲染 drawsAsynchronously 设置为YES，这可以提高性能，因为发射器层必须持续地重绘其发射器单元。\n4. 设置 emitterCell 时，有很多属性需要赋值。contents 设置粒子的内容，然后设置初始速度和最大方差（velocityRange），emitter layer 使用 初始值+/-方差 区间内的随机数来初始化粒子，很多 emitterCell 的属性都有方差设置。\n5. 设置 cell 的生命周期是1秒，默认是0，所以如果你没明确设置，cell 永远不会出现，birthRate（每秒产生数量） 也一样，默认是0，必须设置为正整数才能显示 cell\n6. 设置 x 和 y轴的加速度，它会影响粒子的运动轨迹\n\n\n## 参考资料\n* [IOS Core Animation Advanced Techniques的学习笔记(五)](http://blog.csdn.net/iunion/article/details/26221213)\n* [关于贝塞尔曲线](http://blog.csdn.net/shidongdong2012/article/details/22478463)\n\n","slug":"learn-CALayer-3","published":1,"updated":"2016-10-30T07:50:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7og004y8jpbmzo2d79z","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前两篇介绍CALayer和它的部分子类，本章继续学习其他的子类。</p>\n<h2 id=\"CAShapeLayer\"><a href=\"#CAShapeLayer\" class=\"headerlink\" title=\"CAShapeLayer\"></a>CAShapeLayer</h2><p>CAShapeLayer 可以通过设置矢量路径来绘制图片，它使用起来比使用图片快得多。另一个优势是你不再需要提供常规的@2x和@3x尺寸的图片了。</p>\n<p>此外，你可以使用各种属性来自定义线条粗细，颜色，划线，连线路径。如果线条相交形成一个封闭的区域，可以设置填充该区域的颜色。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.color = [<span class=\"built_in\">UIColor</span> colorWithRed:<span class=\"number\">248</span>/<span class=\"number\">255.0</span> green:<span class=\"number\">96</span>/<span class=\"number\">255.0</span> blue:<span class=\"number\">47</span>/<span class=\"number\">255.0</span> alpha:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpOpenPath];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpClosedPath];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpShapeLayer];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpShapeLayer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 3</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.shapeLayer = (&#123;</span><br><span class=\"line\">        <span class=\"built_in\">CAShapeLayer</span> *layer = [<span class=\"built_in\">CAShapeLayer</span> layer];</span><br><span class=\"line\">        layer.path = <span class=\"keyword\">self</span>.openPath.CGPath;</span><br><span class=\"line\">        layer.fillColor = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        layer.fillRule = kCAFillRuleNonZero;</span><br><span class=\"line\">        layer.lineCap = kCALineCapButt;</span><br><span class=\"line\">        layer.lineDashPattern = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        layer.lineDashPhase = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">        layer.lineJoin = kCALineJoinMiter;</span><br><span class=\"line\">        layer.lineWidth = _lineWidthSlider.value;</span><br><span class=\"line\">        layer.miterLimit = <span class=\"number\">4.0</span>;</span><br><span class=\"line\">        layer.strokeColor = <span class=\"keyword\">self</span>.color.CGColor;</span><br><span class=\"line\">        [_viewForShapeLayer.layer addSublayer:layer];</span><br><span class=\"line\">        layer;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpOpenPath &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.openPath = [<span class=\"built_in\">UIBezierPath</span> bezierPath];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath moveToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">30</span>, <span class=\"number\">196</span>)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath addCurveToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">112.0</span>, <span class=\"number\">12.5</span>) controlPoint1:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">110.56</span>, <span class=\"number\">13.79</span>) controlPoint2:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">112.07</span>, <span class=\"number\">13.01</span>)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath addCurveToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">194</span>, <span class=\"number\">196</span>) controlPoint1:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">111.9</span>, <span class=\"number\">11.81</span>) controlPoint2:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">194</span>, <span class=\"number\">196</span>)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">30.0</span>, <span class=\"number\">85.68</span>)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">194.0</span>, <span class=\"number\">48.91</span>)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">30.0</span>, <span class=\"number\">196</span>)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpClosedPath &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.closedPath = [<span class=\"built_in\">UIBezierPath</span> bezierPath];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.closedPath.CGPath = <span class=\"keyword\">self</span>.openPath.CGPath;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.closedPath closePath];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>创建 color，path 和 shapeLayer</li>\n<li>绘制 shapeLayer 路径。如果你不想这个写绘图代码，你可以使用 PaintCode 软件，导入矢量图（SVG）或者 photoshop（PSD）文件来生成你的代码。</li>\n<li>设置 shapeLayer 的属性</li>\n</ol>\n<p><strong>CAShapeLayer</strong> 属性</p>\n<ul>\n<li><strong>fillRule</strong>：填充规则，有两个选择 <strong>kCAFillRuleNonZero</strong> 和 <strong>kCAFillRuleEvenOdd</strong></li>\n</ul>\n<p><strong>nonzero</strong>字面意思是“非零”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右穿过射线则计数加1，从右向左穿过射线则计数减1。得出计数结果后，如果结果是0，则认为点在图形外部，否则认为在内部。下图演示了nonzero规则:<br><img src=\"/2016/10/29/learn-CALayer-3/nonzero.png\" title=\"nonzero image\"></p>\n<p><strong>evenodd</strong>字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部。下图演示了evenodd 规则<br><img src=\"/2016/10/29/learn-CALayer-3/evenodd.png\" title=\"evenodd image\"></p>\n<ul>\n<li><p><strong>lineCap</strong>：线端点类型</p>\n<img src=\"/2016/10/29/learn-CALayer-3/lineCap.png\" title=\"lineCap image\">\n</li>\n<li><p><strong>lineJoin</strong>：线连接类型</p>\n<img src=\"/2016/10/29/learn-CALayer-3/lineJoin.png\" title=\"lineJoin image\">\n</li>\n<li><p><strong>lineDashPattern</strong>：线型模板<br>这是一个NSNumber的数组，索引从1开始记，奇数位数值表示实线长度，偶数位数值表示空白长度</p>\n</li>\n<li><p><strong>lineDashPhase</strong>：线型模板的起始位置<br>默认是0，可以理解为第一个空格起始位置 = 实线长度 - lineDashPhase。假设设置为5绘制 5空格，设置lineDashPhase为2，那么第一段绘制为5-2，然后空5绘制5</p>\n</li>\n</ul>\n<h2 id=\"CATransformLayer\"><a href=\"#CATransformLayer\" class=\"headerlink\" title=\"CATransformLayer\"></a>CATransformLayer</h2><p>CATransformLayer 和别的平面的Layer不一样，它可以绘制3D结构。它实际上是其sublayers的容器，每个子图层可以有自己的transforms和opacity变换，但是，它不会渲染自己的属性，比如背景色，边框，只渲染sublayers。</p>\n<p>你不能直接点击一个transform layer，因为它没有一个2D坐标空间来映射一个接触点，但是能够点击单个sublayers。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()  </span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> startPoint;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CATransformLayer</span> *s_Cube;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">float</span> pix, piy;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *containerView;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">@end</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"built_in\">CALayer</span> *)faceWithTransform:(<span class=\"built_in\">CATransform3D</span>)transform  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//create cube face layer  </span></span><br><span class=\"line\">    <span class=\"built_in\">CALayer</span> *face = [<span class=\"built_in\">CALayer</span> layer];  </span><br><span class=\"line\">    face.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">-50</span>, <span class=\"number\">-50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//apply a random color  </span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> red = (rand() / (<span class=\"keyword\">double</span>)INT_MAX);  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> green = (rand() / (<span class=\"keyword\">double</span>)INT_MAX);  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> blue = (rand() / (<span class=\"keyword\">double</span>)INT_MAX);  </span><br><span class=\"line\">    face.backgroundColor = [<span class=\"built_in\">UIColor</span> colorWithRed:red  </span><br><span class=\"line\">                                           green:green  </span><br><span class=\"line\">                                            blue:blue  </span><br><span class=\"line\">                                           alpha:<span class=\"number\">1.0</span>].CGColor;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//apply the transform and return  </span></span><br><span class=\"line\">    face.transform = transform;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> face;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"built_in\">CALayer</span> *)cubeWithTransform:(<span class=\"built_in\">CATransform3D</span>)transform  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//create cube layer  </span></span><br><span class=\"line\">    <span class=\"built_in\">CATransformLayer</span> *cube = [<span class=\"built_in\">CATransformLayer</span> layer];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 1  </span></span><br><span class=\"line\">    <span class=\"built_in\">CATransform3D</span> ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 2  </span></span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DRotate</span>(ct, M_PI_2, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 3  </span></span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">-50</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DRotate</span>(ct, M_PI_2, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 4  </span></span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DRotate</span>(ct, -M_PI_2, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 5  </span></span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">-50</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DRotate</span>(ct, -M_PI_2, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 6  </span></span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-50</span>);  </span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DRotate</span>(ct, M_PI, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//center the cube layer within the container  </span></span><br><span class=\"line\">    <span class=\"built_in\">CGSize</span> containerSize = <span class=\"keyword\">self</span>.containerView.bounds.size;  </span><br><span class=\"line\">    cube.position = <span class=\"built_in\">CGPointMake</span>(containerSize.width / <span class=\"number\">2.0</span>,  </span><br><span class=\"line\">                                containerSize.height / <span class=\"number\">2.0</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//apply the transform and return  </span></span><br><span class=\"line\">    cube.transform = transform;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> cube;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//set up the perspective transform  </span></span><br><span class=\"line\">    <span class=\"built_in\">CATransform3D</span> pt = <span class=\"built_in\">CATransform3DIdentity</span>;  </span><br><span class=\"line\">    pt.m34 = <span class=\"number\">-1.0</span> / <span class=\"number\">500.0</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.containerView.layer.sublayerTransform = pt;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//set up the transform for cube 1 and add it  </span></span><br><span class=\"line\">    <span class=\"built_in\">CATransform3D</span> c1t = <span class=\"built_in\">CATransform3DIdentity</span>;  </span><br><span class=\"line\">    c1t = <span class=\"built_in\">CATransform3DTranslate</span>(c1t, <span class=\"number\">-100</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    <span class=\"built_in\">CALayer</span> *cube1 = [<span class=\"keyword\">self</span> cubeWithTransform:c1t];  </span><br><span class=\"line\">    s_Cube = (<span class=\"built_in\">CATransformLayer</span> *)cube1;  </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.containerView.layer addSublayer:cube1];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//set up the transform for cube 2 and add it  </span></span><br><span class=\"line\">    <span class=\"built_in\">CATransform3D</span> c2t = <span class=\"built_in\">CATransform3DIdentity</span>;  </span><br><span class=\"line\">    c2t = <span class=\"built_in\">CATransform3DTranslate</span>(c2t, <span class=\"number\">100</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    c2t = <span class=\"built_in\">CATransform3DRotate</span>(c2t, -M_PI_4, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    c2t = <span class=\"built_in\">CATransform3DRotate</span>(c2t, -M_PI_4, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    <span class=\"built_in\">CALayer</span> *cube2 = [<span class=\"keyword\">self</span> cubeWithTransform:c2t];  </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.containerView.layer addSublayer:cube2];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    startPoint = [touch locationInView:<span class=\"keyword\">self</span>.view];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> currentPosition = [touch locationInView:<span class=\"keyword\">self</span>.view];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> deltaX = startPoint.x - currentPosition.x;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> deltaY = startPoint.y - currentPosition.y;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CATransform3D</span> c1t = <span class=\"built_in\">CATransform3DIdentity</span>;  </span><br><span class=\"line\">    c1t = <span class=\"built_in\">CATransform3DTranslate</span>(c1t, <span class=\"number\">-100</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    c1t = <span class=\"built_in\">CATransform3DRotate</span>(c1t, pix+M_PI_2*deltaY/<span class=\"number\">100</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    c1t = <span class=\"built_in\">CATransform3DRotate</span>(c1t, piy-M_PI_2*deltaX/<span class=\"number\">100</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    s_Cube.transform = c1t;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)touchesEnded:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> currentPosition = [touch locationInView:<span class=\"keyword\">self</span>.view];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> deltaX = startPoint.x - currentPosition.x;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> deltaY = startPoint.y - currentPosition.y;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    pix = M_PI_2*deltaY/<span class=\"number\">100</span>;  </span><br><span class=\"line\">    piy = -M_PI_2*deltaX/<span class=\"number\">100</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>给立方体创建每个面，设置不一样的颜色，并添加到同一个transform layer</li>\n<li>给每个面设置不一样的Z轴的值已经旋转角度，增加层次感</li>\n<li>每次旋转都是基于x轴和y轴的偏移。注意，代码里是给 <strong>sublayerTransform</strong> 设置 <strong>transform</strong> 值，它可以应用到transform layer的每个sublayers</li>\n</ol>\n<h2 id=\"CAEmitterLayer\"><a href=\"#CAEmitterLayer\" class=\"headerlink\" title=\"CAEmitterLayer\"></a>CAEmitterLayer</h2><p>CAEmitterLayer 渲染粒子动画，每个粒子都是一个 CAEmitterCell 对象。通过设置 CAEmitterLayer 和 CAEmitterCell 的属性，可以改变粒子的速率，大小，形状，颜色，加速度，生命周期等等。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">JHCAEmitterLayerViewController</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *viewForEmitterLayer;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">JHCAEmitterLayerViewController</span></span></span><br><span class=\"line\">- (<span class=\"built_in\">CAEmitterLayer</span> *)emitterLayer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!_emitterLayer) &#123;</span><br><span class=\"line\">        _emitterLayer = (&#123;</span><br><span class=\"line\">            <span class=\"built_in\">CAEmitterLayer</span> *layer = [<span class=\"built_in\">CAEmitterLayer</span> layer];</span><br><span class=\"line\">            layer.frame=  <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, kScreenWidth, kScreenHeight * <span class=\"number\">0.5</span>);</span><br><span class=\"line\">            layer.seed = [[<span class=\"built_in\">NSDate</span> date] timeIntervalSince1970];</span><br><span class=\"line\">            layer.emitterPosition = <span class=\"built_in\">CGPointMake</span>(kScreenWidth * <span class=\"number\">0.5</span>, kScreenHeight * <span class=\"number\">0.25</span>);</span><br><span class=\"line\">            [_viewForEmitterLayer.layer addSublayer:layer];</span><br><span class=\"line\">            layer;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _emitterLayer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CAEmitterCell</span> *)emitterCell &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!_emitterCell) &#123;</span><br><span class=\"line\">        _emitterCell = (&#123;</span><br><span class=\"line\">            <span class=\"built_in\">CAEmitterCell</span> *emitterCell = [<span class=\"built_in\">CAEmitterCell</span> emitterCell];</span><br><span class=\"line\">            emitterCell.enabled = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">            emitterCell.name = <span class=\"string\">@\"yjh\"</span>;</span><br><span class=\"line\">            emitterCell.contents = (__bridge <span class=\"keyword\">id</span> _Nullable)([<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"smallStar\"</span>].CGImage);</span><br><span class=\"line\">            emitterCell.contentsRect = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            emitterCell.color = [<span class=\"built_in\">UIColor</span> colorWithRed:<span class=\"number\">0</span> green:<span class=\"number\">0</span> blue:<span class=\"number\">0</span> alpha:<span class=\"number\">1.0</span>].CGColor;</span><br><span class=\"line\">            emitterCell.redRange = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            emitterCell.greenRange = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            emitterCell.blueRange = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            emitterCell.alphaRange = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.redSpeed = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.greenSpeed = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.blueSpeed = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.alphaSpeed = <span class=\"number\">-0.5</span>;</span><br><span class=\"line\">            emitterCell.scale = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            emitterCell.scaleRange = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.scaleSpeed = <span class=\"number\">0.1</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">CGFloat</span> zeroDegreesInRadians = [<span class=\"keyword\">self</span> degreesToRadians:<span class=\"number\">0.0</span>];</span><br><span class=\"line\">            emitterCell.spin = [<span class=\"keyword\">self</span> degreesToRadians:<span class=\"number\">130.0</span>];</span><br><span class=\"line\">            emitterCell.spinRange = zeroDegreesInRadians;</span><br><span class=\"line\">            emitterCell.emissionLatitude = zeroDegreesInRadians;</span><br><span class=\"line\">            emitterCell.emissionLongitude = zeroDegreesInRadians;</span><br><span class=\"line\">            emitterCell.emissionRange = [<span class=\"keyword\">self</span> degreesToRadians:<span class=\"number\">360.0</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            emitterCell.lifetime = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            emitterCell.lifetimeRange = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.birthRate = <span class=\"number\">250.0</span>;</span><br><span class=\"line\">            emitterCell.velocity = <span class=\"number\">50.0</span>;</span><br><span class=\"line\">            emitterCell.velocityRange = <span class=\"number\">500.0</span>;</span><br><span class=\"line\">            emitterCell.xAcceleration = <span class=\"number\">-750.0</span>;</span><br><span class=\"line\">            emitterCell.yAcceleration = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            emitterCell;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _emitterCell;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> resetEmitterCells];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>创建 emitter layer 和 emitter cell</li>\n<li>设置 emitter cells 的渲染模式 renderMode</li>\n<li>将异步渲染 drawsAsynchronously 设置为YES，这可以提高性能，因为发射器层必须持续地重绘其发射器单元。</li>\n<li>设置 emitterCell 时，有很多属性需要赋值。contents 设置粒子的内容，然后设置初始速度和最大方差（velocityRange），emitter layer 使用 初始值+/-方差 区间内的随机数来初始化粒子，很多 emitterCell 的属性都有方差设置。</li>\n<li>设置 cell 的生命周期是1秒，默认是0，所以如果你没明确设置，cell 永远不会出现，birthRate（每秒产生数量） 也一样，默认是0，必须设置为正整数才能显示 cell</li>\n<li>设置 x 和 y轴的加速度，它会影响粒子的运动轨迹</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://blog.csdn.net/iunion/article/details/26221213\" target=\"_blank\" rel=\"noopener\">IOS Core Animation Advanced Techniques的学习笔记(五)</a></li>\n<li><a href=\"http://blog.csdn.net/shidongdong2012/article/details/22478463\" target=\"_blank\" rel=\"noopener\">关于贝塞尔曲线</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前两篇介绍CALayer和它的部分子类，本章继续学习其他的子类。</p>\n<h2 id=\"CAShapeLayer\"><a href=\"#CAShapeLayer\" class=\"headerlink\" title=\"CAShapeLayer\"></a>CAShapeLayer</h2><p>CAShapeLayer 可以通过设置矢量路径来绘制图片，它使用起来比使用图片快得多。另一个优势是你不再需要提供常规的@2x和@3x尺寸的图片了。</p>\n<p>此外，你可以使用各种属性来自定义线条粗细，颜色，划线，连线路径。如果线条相交形成一个封闭的区域，可以设置填充该区域的颜色。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.color = [<span class=\"built_in\">UIColor</span> colorWithRed:<span class=\"number\">248</span>/<span class=\"number\">255.0</span> green:<span class=\"number\">96</span>/<span class=\"number\">255.0</span> blue:<span class=\"number\">47</span>/<span class=\"number\">255.0</span> alpha:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpOpenPath];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpClosedPath];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setUpShapeLayer];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpShapeLayer &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 3</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.shapeLayer = (&#123;</span><br><span class=\"line\">        <span class=\"built_in\">CAShapeLayer</span> *layer = [<span class=\"built_in\">CAShapeLayer</span> layer];</span><br><span class=\"line\">        layer.path = <span class=\"keyword\">self</span>.openPath.CGPath;</span><br><span class=\"line\">        layer.fillColor = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        layer.fillRule = kCAFillRuleNonZero;</span><br><span class=\"line\">        layer.lineCap = kCALineCapButt;</span><br><span class=\"line\">        layer.lineDashPattern = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        layer.lineDashPhase = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">        layer.lineJoin = kCALineJoinMiter;</span><br><span class=\"line\">        layer.lineWidth = _lineWidthSlider.value;</span><br><span class=\"line\">        layer.miterLimit = <span class=\"number\">4.0</span>;</span><br><span class=\"line\">        layer.strokeColor = <span class=\"keyword\">self</span>.color.CGColor;</span><br><span class=\"line\">        [_viewForShapeLayer.layer addSublayer:layer];</span><br><span class=\"line\">        layer;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpOpenPath &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.openPath = [<span class=\"built_in\">UIBezierPath</span> bezierPath];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath moveToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">30</span>, <span class=\"number\">196</span>)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath addCurveToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">112.0</span>, <span class=\"number\">12.5</span>) controlPoint1:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">110.56</span>, <span class=\"number\">13.79</span>) controlPoint2:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">112.07</span>, <span class=\"number\">13.01</span>)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath addCurveToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">194</span>, <span class=\"number\">196</span>) controlPoint1:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">111.9</span>, <span class=\"number\">11.81</span>) controlPoint2:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">194</span>, <span class=\"number\">196</span>)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">30.0</span>, <span class=\"number\">85.68</span>)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">194.0</span>, <span class=\"number\">48.91</span>)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.openPath addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">30.0</span>, <span class=\"number\">196</span>)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setUpClosedPath &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.closedPath = [<span class=\"built_in\">UIBezierPath</span> bezierPath];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.closedPath.CGPath = <span class=\"keyword\">self</span>.openPath.CGPath;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.closedPath closePath];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>创建 color，path 和 shapeLayer</li>\n<li>绘制 shapeLayer 路径。如果你不想这个写绘图代码，你可以使用 PaintCode 软件，导入矢量图（SVG）或者 photoshop（PSD）文件来生成你的代码。</li>\n<li>设置 shapeLayer 的属性</li>\n</ol>\n<p><strong>CAShapeLayer</strong> 属性</p>\n<ul>\n<li><strong>fillRule</strong>：填充规则，有两个选择 <strong>kCAFillRuleNonZero</strong> 和 <strong>kCAFillRuleEvenOdd</strong></li>\n</ul>\n<p><strong>nonzero</strong>字面意思是“非零”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右穿过射线则计数加1，从右向左穿过射线则计数减1。得出计数结果后，如果结果是0，则认为点在图形外部，否则认为在内部。下图演示了nonzero规则:<br><img src=\"/2016/10/29/learn-CALayer-3/nonzero.png\" title=\"nonzero image\"></p>\n<p><strong>evenodd</strong>字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部。下图演示了evenodd 规则<br><img src=\"/2016/10/29/learn-CALayer-3/evenodd.png\" title=\"evenodd image\"></p>\n<ul>\n<li><p><strong>lineCap</strong>：线端点类型</p>\n<img src=\"/2016/10/29/learn-CALayer-3/lineCap.png\" title=\"lineCap image\">\n</li>\n<li><p><strong>lineJoin</strong>：线连接类型</p>\n<img src=\"/2016/10/29/learn-CALayer-3/lineJoin.png\" title=\"lineJoin image\">\n</li>\n<li><p><strong>lineDashPattern</strong>：线型模板<br>这是一个NSNumber的数组，索引从1开始记，奇数位数值表示实线长度，偶数位数值表示空白长度</p>\n</li>\n<li><p><strong>lineDashPhase</strong>：线型模板的起始位置<br>默认是0，可以理解为第一个空格起始位置 = 实线长度 - lineDashPhase。假设设置为5绘制 5空格，设置lineDashPhase为2，那么第一段绘制为5-2，然后空5绘制5</p>\n</li>\n</ul>\n<h2 id=\"CATransformLayer\"><a href=\"#CATransformLayer\" class=\"headerlink\" title=\"CATransformLayer\"></a>CATransformLayer</h2><p>CATransformLayer 和别的平面的Layer不一样，它可以绘制3D结构。它实际上是其sublayers的容器，每个子图层可以有自己的transforms和opacity变换，但是，它不会渲染自己的属性，比如背景色，边框，只渲染sublayers。</p>\n<p>你不能直接点击一个transform layer，因为它没有一个2D坐标空间来映射一个接触点，但是能够点击单个sublayers。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()  </span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> startPoint;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CATransformLayer</span> *s_Cube;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">float</span> pix, piy;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *containerView;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">@end</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"built_in\">CALayer</span> *)faceWithTransform:(<span class=\"built_in\">CATransform3D</span>)transform  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//create cube face layer  </span></span><br><span class=\"line\">    <span class=\"built_in\">CALayer</span> *face = [<span class=\"built_in\">CALayer</span> layer];  </span><br><span class=\"line\">    face.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">-50</span>, <span class=\"number\">-50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//apply a random color  </span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> red = (rand() / (<span class=\"keyword\">double</span>)INT_MAX);  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> green = (rand() / (<span class=\"keyword\">double</span>)INT_MAX);  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> blue = (rand() / (<span class=\"keyword\">double</span>)INT_MAX);  </span><br><span class=\"line\">    face.backgroundColor = [<span class=\"built_in\">UIColor</span> colorWithRed:red  </span><br><span class=\"line\">                                           green:green  </span><br><span class=\"line\">                                            blue:blue  </span><br><span class=\"line\">                                           alpha:<span class=\"number\">1.0</span>].CGColor;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//apply the transform and return  </span></span><br><span class=\"line\">    face.transform = transform;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> face;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"built_in\">CALayer</span> *)cubeWithTransform:(<span class=\"built_in\">CATransform3D</span>)transform  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//create cube layer  </span></span><br><span class=\"line\">    <span class=\"built_in\">CATransformLayer</span> *cube = [<span class=\"built_in\">CATransformLayer</span> layer];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 1  </span></span><br><span class=\"line\">    <span class=\"built_in\">CATransform3D</span> ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 2  </span></span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DRotate</span>(ct, M_PI_2, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 3  </span></span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">-50</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DRotate</span>(ct, M_PI_2, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 4  </span></span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DRotate</span>(ct, -M_PI_2, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 5  </span></span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">-50</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DRotate</span>(ct, -M_PI_2, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//add cube face 6  </span></span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-50</span>);  </span><br><span class=\"line\">    ct = <span class=\"built_in\">CATransform3DRotate</span>(ct, M_PI, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    [cube addSublayer:[<span class=\"keyword\">self</span> faceWithTransform:ct]];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//center the cube layer within the container  </span></span><br><span class=\"line\">    <span class=\"built_in\">CGSize</span> containerSize = <span class=\"keyword\">self</span>.containerView.bounds.size;  </span><br><span class=\"line\">    cube.position = <span class=\"built_in\">CGPointMake</span>(containerSize.width / <span class=\"number\">2.0</span>,  </span><br><span class=\"line\">                                containerSize.height / <span class=\"number\">2.0</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//apply the transform and return  </span></span><br><span class=\"line\">    cube.transform = transform;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> cube;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//set up the perspective transform  </span></span><br><span class=\"line\">    <span class=\"built_in\">CATransform3D</span> pt = <span class=\"built_in\">CATransform3DIdentity</span>;  </span><br><span class=\"line\">    pt.m34 = <span class=\"number\">-1.0</span> / <span class=\"number\">500.0</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.containerView.layer.sublayerTransform = pt;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//set up the transform for cube 1 and add it  </span></span><br><span class=\"line\">    <span class=\"built_in\">CATransform3D</span> c1t = <span class=\"built_in\">CATransform3DIdentity</span>;  </span><br><span class=\"line\">    c1t = <span class=\"built_in\">CATransform3DTranslate</span>(c1t, <span class=\"number\">-100</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    <span class=\"built_in\">CALayer</span> *cube1 = [<span class=\"keyword\">self</span> cubeWithTransform:c1t];  </span><br><span class=\"line\">    s_Cube = (<span class=\"built_in\">CATransformLayer</span> *)cube1;  </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.containerView.layer addSublayer:cube1];  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//set up the transform for cube 2 and add it  </span></span><br><span class=\"line\">    <span class=\"built_in\">CATransform3D</span> c2t = <span class=\"built_in\">CATransform3DIdentity</span>;  </span><br><span class=\"line\">    c2t = <span class=\"built_in\">CATransform3DTranslate</span>(c2t, <span class=\"number\">100</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    c2t = <span class=\"built_in\">CATransform3DRotate</span>(c2t, -M_PI_4, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    c2t = <span class=\"built_in\">CATransform3DRotate</span>(c2t, -M_PI_4, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    <span class=\"built_in\">CALayer</span> *cube2 = [<span class=\"keyword\">self</span> cubeWithTransform:c2t];  </span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.containerView.layer addSublayer:cube2];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    startPoint = [touch locationInView:<span class=\"keyword\">self</span>.view];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> currentPosition = [touch locationInView:<span class=\"keyword\">self</span>.view];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> deltaX = startPoint.x - currentPosition.x;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> deltaY = startPoint.y - currentPosition.y;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CATransform3D</span> c1t = <span class=\"built_in\">CATransform3DIdentity</span>;  </span><br><span class=\"line\">    c1t = <span class=\"built_in\">CATransform3DTranslate</span>(c1t, <span class=\"number\">-100</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    c1t = <span class=\"built_in\">CATransform3DRotate</span>(c1t, pix+M_PI_2*deltaY/<span class=\"number\">100</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    c1t = <span class=\"built_in\">CATransform3DRotate</span>(c1t, piy-M_PI_2*deltaX/<span class=\"number\">100</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    s_Cube.transform = c1t;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)touchesEnded:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> currentPosition = [touch locationInView:<span class=\"keyword\">self</span>.view];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> deltaX = startPoint.x - currentPosition.x;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> deltaY = startPoint.y - currentPosition.y;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    pix = M_PI_2*deltaY/<span class=\"number\">100</span>;  </span><br><span class=\"line\">    piy = -M_PI_2*deltaX/<span class=\"number\">100</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>给立方体创建每个面，设置不一样的颜色，并添加到同一个transform layer</li>\n<li>给每个面设置不一样的Z轴的值已经旋转角度，增加层次感</li>\n<li>每次旋转都是基于x轴和y轴的偏移。注意，代码里是给 <strong>sublayerTransform</strong> 设置 <strong>transform</strong> 值，它可以应用到transform layer的每个sublayers</li>\n</ol>\n<h2 id=\"CAEmitterLayer\"><a href=\"#CAEmitterLayer\" class=\"headerlink\" title=\"CAEmitterLayer\"></a>CAEmitterLayer</h2><p>CAEmitterLayer 渲染粒子动画，每个粒子都是一个 CAEmitterCell 对象。通过设置 CAEmitterLayer 和 CAEmitterCell 的属性，可以改变粒子的速率，大小，形状，颜色，加速度，生命周期等等。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">JHCAEmitterLayerViewController</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *viewForEmitterLayer;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">JHCAEmitterLayerViewController</span></span></span><br><span class=\"line\">- (<span class=\"built_in\">CAEmitterLayer</span> *)emitterLayer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!_emitterLayer) &#123;</span><br><span class=\"line\">        _emitterLayer = (&#123;</span><br><span class=\"line\">            <span class=\"built_in\">CAEmitterLayer</span> *layer = [<span class=\"built_in\">CAEmitterLayer</span> layer];</span><br><span class=\"line\">            layer.frame=  <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, kScreenWidth, kScreenHeight * <span class=\"number\">0.5</span>);</span><br><span class=\"line\">            layer.seed = [[<span class=\"built_in\">NSDate</span> date] timeIntervalSince1970];</span><br><span class=\"line\">            layer.emitterPosition = <span class=\"built_in\">CGPointMake</span>(kScreenWidth * <span class=\"number\">0.5</span>, kScreenHeight * <span class=\"number\">0.25</span>);</span><br><span class=\"line\">            [_viewForEmitterLayer.layer addSublayer:layer];</span><br><span class=\"line\">            layer;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _emitterLayer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CAEmitterCell</span> *)emitterCell &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!_emitterCell) &#123;</span><br><span class=\"line\">        _emitterCell = (&#123;</span><br><span class=\"line\">            <span class=\"built_in\">CAEmitterCell</span> *emitterCell = [<span class=\"built_in\">CAEmitterCell</span> emitterCell];</span><br><span class=\"line\">            emitterCell.enabled = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">            emitterCell.name = <span class=\"string\">@\"yjh\"</span>;</span><br><span class=\"line\">            emitterCell.contents = (__bridge <span class=\"keyword\">id</span> _Nullable)([<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"smallStar\"</span>].CGImage);</span><br><span class=\"line\">            emitterCell.contentsRect = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            emitterCell.color = [<span class=\"built_in\">UIColor</span> colorWithRed:<span class=\"number\">0</span> green:<span class=\"number\">0</span> blue:<span class=\"number\">0</span> alpha:<span class=\"number\">1.0</span>].CGColor;</span><br><span class=\"line\">            emitterCell.redRange = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            emitterCell.greenRange = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            emitterCell.blueRange = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            emitterCell.alphaRange = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.redSpeed = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.greenSpeed = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.blueSpeed = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.alphaSpeed = <span class=\"number\">-0.5</span>;</span><br><span class=\"line\">            emitterCell.scale = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            emitterCell.scaleRange = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.scaleSpeed = <span class=\"number\">0.1</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">CGFloat</span> zeroDegreesInRadians = [<span class=\"keyword\">self</span> degreesToRadians:<span class=\"number\">0.0</span>];</span><br><span class=\"line\">            emitterCell.spin = [<span class=\"keyword\">self</span> degreesToRadians:<span class=\"number\">130.0</span>];</span><br><span class=\"line\">            emitterCell.spinRange = zeroDegreesInRadians;</span><br><span class=\"line\">            emitterCell.emissionLatitude = zeroDegreesInRadians;</span><br><span class=\"line\">            emitterCell.emissionLongitude = zeroDegreesInRadians;</span><br><span class=\"line\">            emitterCell.emissionRange = [<span class=\"keyword\">self</span> degreesToRadians:<span class=\"number\">360.0</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            emitterCell.lifetime = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            emitterCell.lifetimeRange = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            emitterCell.birthRate = <span class=\"number\">250.0</span>;</span><br><span class=\"line\">            emitterCell.velocity = <span class=\"number\">50.0</span>;</span><br><span class=\"line\">            emitterCell.velocityRange = <span class=\"number\">500.0</span>;</span><br><span class=\"line\">            emitterCell.xAcceleration = <span class=\"number\">-750.0</span>;</span><br><span class=\"line\">            emitterCell.yAcceleration = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            emitterCell;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _emitterCell;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> resetEmitterCells];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>创建 emitter layer 和 emitter cell</li>\n<li>设置 emitter cells 的渲染模式 renderMode</li>\n<li>将异步渲染 drawsAsynchronously 设置为YES，这可以提高性能，因为发射器层必须持续地重绘其发射器单元。</li>\n<li>设置 emitterCell 时，有很多属性需要赋值。contents 设置粒子的内容，然后设置初始速度和最大方差（velocityRange），emitter layer 使用 初始值+/-方差 区间内的随机数来初始化粒子，很多 emitterCell 的属性都有方差设置。</li>\n<li>设置 cell 的生命周期是1秒，默认是0，所以如果你没明确设置，cell 永远不会出现，birthRate（每秒产生数量） 也一样，默认是0，必须设置为正整数才能显示 cell</li>\n<li>设置 x 和 y轴的加速度，它会影响粒子的运动轨迹</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://blog.csdn.net/iunion/article/details/26221213\" target=\"_blank\" rel=\"noopener\">IOS Core Animation Advanced Techniques的学习笔记(五)</a></li>\n<li><a href=\"http://blog.csdn.net/shidongdong2012/article/details/22478463\" target=\"_blank\" rel=\"noopener\">关于贝塞尔曲线</a></li>\n</ul>\n"},{"title":"Masonry 源码分析","date":"2018-01-20T01:50:51.000Z","_content":"\n## 前言\n\n在 iOS 开发中 Masonry 是控件布局中经常使用的一个轻量级框架布局控件，它简化了手写 AutoLayout 代码的难度，本文就分析一下 Masonry 框架的源码。\n\n## Masonry 与 NSLayoutConstraint 调用方式的对比\n\n### 1.NSLayoutConstraint\n\n给一个 View 设置相对父控件的顶部距离 `10个pt`：\n\n```objc\n[NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeTop\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeTop\n                                multiplier:1.0\n                                  constant:10]\n```\n代码相当直观的说明的约束关系。\n\n### 2.Masonry\n\nMasonry 是通过链式调用和匿名闭包的方式来简化设置约束：\n\n```objc\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top).with.offset(10); \n    // 等价于\n    make.top.equalTo(@10);\n    // 等价于\n    make.top.equalTo(superview.mas_top).multipliedBy(1).offset(10); \n}];\n```\n\n## 类结构\n\n### 1. View+MASAdditions\n\n上面使用到的 **mas_makeConstraints** 是 UIView 扩展 **UIView+MASAdditions** 提供给的方法，这个类提供了一系列 **MASViewAttribute** 成员属性，和四个公开的方法： **mas_closestCommonSuperview** 寻找两个视图最近的公共父类、 **mas_makeConstraints** 创建安装约束、 **mas_updateConstraints** 更新已经存在的约束（不存在的就创建）、 **mas_remakeConstraints** 移除已经创建的约束并添加新的约束。\n\n### 2. MASViewAttribute\n\n**MASViewAttribute** 内部有三个属性和三个方法，从这些属性和方法可以看出，它就是对 UIView 和 NSLayoutAttribute 的封装，`MASViewAttribute = UIView + NSLayoutAttribute + item`，view 属性就是要约束的控件，item 就是控件上约束的部分。\n\nitem 属性就是在创建 NSLayoutConstriant 构造方法时 **constraintWithItem** 与 **toItem** 的参数。对于 UIView 来说该 item 就是 UIView 本身。而对于UIViewController，该出 Item 就 topLayoutGuide，bottomLayoutGuide 。\n\n该类中除了初始化方法外还有一个 **isSizeAttribute** 方法，该方法用来判断 MASViewAttribute 类中的 **layoutAttribute** 属性是否是 **NSLayoutAttributeWidth** 或者**NSLayoutAttributeHeight**，如果是Width或者Height的话，那么约束就添加到当前View上，而不是添加在父视图上。\n\n### 3. MASViewConstraint\n\n**MASViewConstraint** 是对 **NSLayoutConstraint** 的进一步封装，对控件设置约束，底层还是使用了 **NSLayoutConstraint** 来设置约束，Masonry 只是简化了代码，所以 **MASViewConstraint** 最重要的事情就是创建 **NSLayoutConstraint** 并设置给相应的视图。**总的来说 MASViewAttribute 是对 View 与 NSLayoutAttribute 进行的封装，所以 MASViewConstraint 类要依赖于 MASViewAttribute 类。**\n\n**MASConstraint** 是 **MASViewConstraint** 的父类，它是个抽象父类，不能实例化，它定义了很多公共接口方法。\n\n**MASConstraint** 还有个子类是 **MASCompositeConstraint** ，它里面只有一个方法 **- (id)initWithChildren:(NSArray *)children;**，其实就是存储一系列约束的类，内部有个私有属性数组 **childConstraints** 存储约束。总的来说是对它就是一个存储 **MASViewAttribute** 对象数组的封装。\n\n### 4. MASConstraintMaker\n\n**MASConstraintMaker** 是个工厂类，负责创建 **MASConstraint** 类型的对象。在 **View+MASAdditions** 中 **mas_makeConstraints** 的 block 参数就是 **MASConstraintMaker** 对象。用户可以通过 block 回调的 **MASConstraintMaker** 对象 给 View 指定约束。类的内部有个 **constraints** 属性来记录它创建的所有 **MASConstraint** 对象。\n\n## View+MASAdditions源码解析\n\n## 1.主要属性和getter方法\n\n\n```objc\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_left;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_top;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_right;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_bottom;\n......\n```\n\n上面是部分属性，属性的类型都是 **MASViewAttribute** 类型，因为 **MASViewAttribute** 是对 View 与 NSLayoutAttribute 进行的封装，所以 **mas_left** 就表示 View 和 NSLayoutAttributeLeft，一次类推别的属性。\n\n查看它们的 getter 方法：\n\n```objc\n#pragma mark - NSLayoutAttribute properties\n\n- (MASViewAttribute *)mas_left {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeLeft];\n}\n\n- (MASViewAttribute *)mas_top {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeTop];\n}\n\n- (MASViewAttribute *)mas_right {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeRight];\n}\n\n- (MASViewAttribute *)mas_bottom {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeBottom];\n}\n```\n\n就可以得知它所做的事情就是创建一个 **MASViewAttribute** ，也就是 **mas_left = self + NSLayoutAttributeLeft**。\n\n### 2. mas_makeConstraints方法解析\n\n```objc\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {\n\t  // 关闭自动添加约束，自己手动添加\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    // 创建 MASConstraintMaker\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];\n    // 给 maker 中的各种属性赋值，通过 block 进行值的回调\n    block(constraintMaker);\n    // 进行约束添加，并返回所有Install的约束数组\n    return [constraintMaker install];\n}\n```\n\n上面也说到用 **mas_makeConstraints** 来添加约束，该方法返回一个数组，数组里存放的是当前视图中添加的所有约束。因为 Masonry 对 **NSLayoutAttribute** 封装成了 **MASViewConstraint** ，所以数组中存储的全是 **MASViewConstraint** 类型的对象。\n\n方法的参数是 **void(^)(MASConstraintMaker *)** 的匿名闭包，无返回值，需要个 **MASConstraintMaker** 对象。在方法中，首先将 **translatesAutoresizingMaskIntoConstraints** 设置为 NO，然后创建了一个 **MASConstraintMaker** 对象，通过 block 将 **MASConstraintMaker** 对象传递给用户来设置约束，也就是让用户使用 **MASConstraintMaker** 中的 **MASConstraint** 类型的属性。\n\n### 3. mas_updateConstraints 与 mas_remakeConstraints 函数的解析\n\n这两个函数内部的是想和 mas_makeConstraints 差不多，只是多设置一个属性。\n\nmas_updateConstraints 中将 `updateExisting` 设置为 YES，就是说添加约束时先检查是否已经被添加，如果被添加了就更新，如果没有被添加就添加。\n\nmas_remakeConstraints 中所做的事情是将 `removeExisting` 设置为 YES，就是说将视图上的旧约束先移除掉，在添加新的约束。\n\n```objc\nconstraintMaker.updateExisting = YES;\n```\n\n```objc\nconstraintMaker.removeExisting = YES;\n```\n\n### 4. mas_closestCommonSuperview\n\n**mas_closestCommonSuperview** 方法负责计算出两个视图的公共父视图，找到最近的那个公共父视图后就返回，如果找不到就返回 nil：\n\n```objc\n- (instancetype)mas_closestCommonSuperview:(MAS_VIEW *)view {\n    // 临时父视图存储\n    MAS_VIEW *closestCommonSuperview = nil;\n\n    MAS_VIEW *secondViewSuperview = view;\n    // 遍历 secondView 所有的父视图\n    while (!closestCommonSuperview && secondViewSuperview) {\n        MAS_VIEW *firstViewSuperview = self;\n        // 遍历当前视图（self）的父视图\n        while (!closestCommonSuperview && firstViewSuperview) {\n            if (secondViewSuperview == firstViewSuperview) {\n                // 找到公共父视图后结束循环\n                closestCommonSuperview = secondViewSuperview;\n            }\n            firstViewSuperview = firstViewSuperview.superview;\n        }\n        secondViewSuperview = secondViewSuperview.superview;\n    }\n    // 返回公共父视图\n    return closestCommonSuperview;\n}\n```\n\n寻找两个视图的公共父视图对于约束很重要，因为相对的约束是添加到其公共父视图上的。比如  viewA.left = viewB.right + 10, 因为是 viewA 与 viewB 的相对约束，那么约束是添加在 viewA 与 viewB 的公共父视图上的，如果 viewB 是 viewA 的父视图，那么约束就添加在 viewB 上从而对 viewA 起到约束作用。\n\n## 工厂类 MASConstraintMaker 解析\n\n### 1. 公共属性\n\n**MASConstraintMaker** 类里面的属性都有对应的 getter 方法：\n\n```objc\n- (MASConstraint *)left {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];\n}\n\n- (MASConstraint *)top {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];\n}\n.....\n```\n\n### 2. 工厂方法\n\ngetter 方法都会调用 **addConstraintWithLayoutAttribute** ，在 **addConstraintWithLayoutAttribute** 方法中又调用了 MASConstraintMaker 工厂类的工厂方法：\n\n```objc\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];\n}\n```\n\n```objc\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    // 创建 MASViewAttribute\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    // 根据 layoutAttribute 创建 MASViewConstraint\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    // constraint 不为 nil时，就和 newConstraint 合并为 MASCompositeConstraint 对象\n    if ([constraint isKindOfClass:MASViewConstraint.class]) {\n        //replace with composite constraint\n        NSArray *children = @[constraint, newConstraint];\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];\n        compositeConstraint.delegate = self;\n        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];\n        return compositeConstraint;\n    }\n    if (!constraint) {\n        // 设置代理 MASConstraintDelegate，链式调用的核心，让 MASViewConstraint 也能调用这个方法\n        newConstraint.delegate = self;\n        // 添加进数组\n        [self.constraints addObject:newConstraint];\n    }\n    return newConstraint;\n}\n```\n\n上面代码根据提供的参数创建 MSAViewConstraint 对象，如果该函数的第一个参数不为空的话就会将新创建的 MSAViewConstraint 对象与参数进行合并组合成 **MASCompositeConstraint** 类（ MASCompositeConstraint 本质上是 MSAViewConstraint 对象的数组）的对象。\n\n创建完 MASConstraint 类的相应的对象后，会把该创建的对象添加进 MASConstraintMaker 工厂类的私有 constraints 数组，来记录该工厂对象创建的所有约束。`newConstraint.delegate = self;` 这句话是非常重要的，由于为 MASConstraint 对象设置了代理，所以才支持链式调用。\n\n举个例子：maker.top.left.right.equalTo(@10)，第一步 maker.top 调用返回了 **MASViewConstraint** 类的对象，当调用 .left 时，其实就是 newConstraint.left ，这意味着，.left 并不是调用 maker 的 left 的 getter 方法，而是 **MASViewConstraint** 的 left 的 getter 方法：\n\n```objc\n// MASConstraint.m\n- (MASConstraint *)left {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];\n}\n```\n\n```objc\n// MASViewConstraint.m\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    NSAssert(!self.hasLayoutRelation, @\"Attributes should be chained before defining the constraint relation\");\n\n    return [self.delegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n}\n```\n\n从上面的代码可以看出，调用 **MASViewConstraint** 的 left 的 getter 方法其实就是调用 delegate 的 **addConstraintWithLayoutAttribute** 方法，而 delegate 就是前面提到的 `maker`，从而实现了链式调用。\n\n### 3. install 方法\n\n```objc\n// 添加约束到View上\n- (NSArray *)install {\n    // 如果是mas_remarkConstraint，先将该视图上的约束 uninstall\n    if (self.removeExisting) {\n        // 获取当前视图上添加的所有约束\n        NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view];\n        // 移除掉所有约束\n        for (MASConstraint *constraint in installedConstraints) {\n            [constraint uninstall];\n        }\n    }\n    \n    // 添加约束\n    // self.constraints 中存储的是通过 Block 中配置的参数\n    NSArray *constraints = self.constraints.copy;\n    for (MASConstraint *constraint in constraints) {\n        // 是否为 更新的约束\n        constraint.updateExisting = self.updateExisting;\n        // install 每个约束\n        [constraint install];\n    }\n    [self.constraints removeAllObjects];\n    return constraints;\n}\n```\n\n从上面的代码可以看出，install 方法就是遍历工厂对象所创建所有约束对象，并调用每个约束对象的 isntall 方法来添加约束。\n\n在安装约束时，如果 self.removeExisting == YES，那么就先 uninstall 旧约束，再 install 新约束。在安装约束时，将 updateExisting 赋值给每个约束，每个约束在调用本身的 install 方法时会判断是否更新。\n\n## MASViewConstraint 解析\n\n**MASConstraintMaker** 工厂类所创建的对象实质上是 **MASViewConstraint** 类的对象。而 **MASViewConstraint** 类实质上是对 **MASLayoutConstraint** 的封装，进一步说 **MASViewConstraint** 负责为 **MASLayoutConstraint** 构造器组织参数并创建 **MASLayoutConstraint** 的对象，并将该对象添加到相应的视图中。\n\n### 1. 链式调用\n\n我们设置约束的时候经常这么使用： **constraint.top.left.equalTo(superView).offset(10);** ，在 Objective-C 中这不是方法调用的形式，在 Objective-C 中的调用形式是 `[]` ，但是 Masonry 使用了 `()`，我们来看下怎么做到的：\n\n```objc\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    NSAssert(!self.hasLayoutRelation, @\"Attributes should be chained before defining the constraint relation\");\n\n    return [self.delegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n}\n``` \n这个在上面说到，调用类似 left、Top 等属性的时候其实是通过 delegate 去调用 maker 工厂类的工厂方法来创建 MASConstraint 对象。\n\n但是 **.offset(10)** 是怎么做到的，因为 OC 中不能通过小括号来调用方法：\n\n```objc\n- (MASConstraint * (^)(CGFloat))offset {\n    return ^id(CGFloat offset){\n        self.offset = offset;\n        return self;\n    };\n}\n```\n\n原来 offset() 是个闭包，它的返回值是个匿名block，参数是个 CGFloat 类型。总的来说 offset() = offset + ()，即先调用了 offset 方法，然后通过 () 调用了返回的匿名 block，闭包返回了 MASConstraint 对象。\n\n### 2. install 方法解析\n\n```objc\nMASLayoutConstraint *layoutConstraint\n        = [MASLayoutConstraint constraintWithItem:firstLayoutItem\n                                        attribute:firstLayoutAttribute\n                                        relatedBy:self.layoutRelation\n                                           toItem:secondLayoutItem\n                                        attribute:secondLayoutAttribute\n                                       multiplier:self.layoutMultiplier\n                                         constant:self.layoutConstant];\n                                         \nlayoutConstraint.priority = self.layoutPriority;\nlayoutConstraint.mas_key = self.mas_key;\n```\n\ninstall 方法创建 **MASLayoutConstraint** 对象，并将该对象添加到相应的 View 上。\n\n上面的代码就是根据获取的属性来创建 MASLayoutConstraint 对象，MASLayoutConstraint 就是继承自 NSLayoutConstraint。\n\n```objc\n// 寻找要添加约束的 View\nif (self.secondViewAttribute.view) {\n\t\t  // 寻找两个视图的公共父视图\n        MAS_VIEW *closestCommonSuperview = [self.firstViewAttribute.view mas_closestCommonSuperview:self.secondViewAttribute.view];\n        NSAssert(closestCommonSuperview,\n                 @\"couldn't find a common superview for %@ and %@\",\n                 self.firstViewAttribute.view, self.secondViewAttribute.view);\n        self.installedView = closestCommonSuperview;\n    } else if (self.firstViewAttribute.isSizeAttribute) {\n        self.installedView = self.firstViewAttribute.view;\n    } else {\n        self.installedView = self.firstViewAttribute.view.superview;\n    }\n```\n\n上面的代码就是创建约束对象后，寻找要添加约束的 View，如果是两个视图相对约束，就获取两种的公共父视图。如果添加的是 Width 或者 Height ，那么就添加到当前视图上。如果既没有指定相对视图，也不是 Size 类型的约束，那么就将该约束对象添加到当前视图的父视图上。\n\n创建完约束对象 **MASLayoutConstraint** ，并且找到要添加约束的 View 后，就要开始添加约束了。添加前判断是不是对约束的更新，如果约束已经存在就更新约束，如果不存在就进行添加。添加成功后通过 **mas_installedConstraints** 属性记录一下本安装的约束。mas_installedConstraints 是通过运行时为 UIView 关联的一个 NSMutable 类型的属性，用来记录约束该视图的所有约束。\n参考下面代码：\n\n```objc\nMASLayoutConstraint *existingConstraint = nil;\n    if (self.updateExisting) {\n        existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint];\n    }\n    if (existingConstraint) {\n        // 更新约束\n        existingConstraint.constant = layoutConstraint.constant;\n        self.layoutConstraint = existingConstraint;\n    } else {\n        // 添加约束\n        [self.installedView addConstraint:layoutConstraint];\n        self.layoutConstraint = layoutConstraint;\n        // 约束所在的 View 记录被添加的约束\n        [firstLayoutItem.mas_installedConstraints addObject:self];\n    }\n```\n\n### 3. UIView 的私有类目 UIView+MASConstraints\n\nMASViewConstraint 中定义了一个 UIView 的私有扩展 `UIView+MASConstraints`，它的作用是为 UIView 通过运行时来关联一个 **NSMutableSet** 类型的 **mas_installedConstraints** 属性。该属性记录了该 View 的所有约束。\n\n```objc\n/*\n\t私有类，只有 MASViewConstraint 使用它\n*/\n@interface MAS_VIEW (MASConstraints)\n\n@property (nonatomic, readonly) NSMutableSet *mas_installedConstraints;\n\n@end\n\n@implementation MAS_VIEW (MASConstraints)\n\n// 动态添加属性的 Key， 用来表示动态添加的属性\nstatic char kInstalledConstraintsKey;\n\n- (NSMutableSet *)mas_installedConstraints {\n    // 通过 kInstalledConstraintsKey 来获取已经动态添加的约束集合\n    NSMutableSet *constraints = objc_getAssociatedObject(self, &kInstalledConstraintsKey);\n    // 如果不存在，创建一个，并进行动态绑定\n    if (!constraints) {\n        constraints = [NSMutableSet set];\n        objc_setAssociatedObject(self, &kInstalledConstraintsKey, constraints, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    }\n    return constraints;\n}\n\n@end\n```\n\n## 总结\n\n本文简单的对 Masonry 的核心代码进行分析，更加细节的东西还请自行去阅读源码。\n\n","source":"_posts/2018-01-20-masonry-analysis.md","raw":"---\ntitle: Masonry 源码分析\ndate: 2018-01-20 09:50:51\ntags: Masonry\ncategory: Source Code Analyze\n---\n\n## 前言\n\n在 iOS 开发中 Masonry 是控件布局中经常使用的一个轻量级框架布局控件，它简化了手写 AutoLayout 代码的难度，本文就分析一下 Masonry 框架的源码。\n\n## Masonry 与 NSLayoutConstraint 调用方式的对比\n\n### 1.NSLayoutConstraint\n\n给一个 View 设置相对父控件的顶部距离 `10个pt`：\n\n```objc\n[NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeTop\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeTop\n                                multiplier:1.0\n                                  constant:10]\n```\n代码相当直观的说明的约束关系。\n\n### 2.Masonry\n\nMasonry 是通过链式调用和匿名闭包的方式来简化设置约束：\n\n```objc\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top).with.offset(10); \n    // 等价于\n    make.top.equalTo(@10);\n    // 等价于\n    make.top.equalTo(superview.mas_top).multipliedBy(1).offset(10); \n}];\n```\n\n## 类结构\n\n### 1. View+MASAdditions\n\n上面使用到的 **mas_makeConstraints** 是 UIView 扩展 **UIView+MASAdditions** 提供给的方法，这个类提供了一系列 **MASViewAttribute** 成员属性，和四个公开的方法： **mas_closestCommonSuperview** 寻找两个视图最近的公共父类、 **mas_makeConstraints** 创建安装约束、 **mas_updateConstraints** 更新已经存在的约束（不存在的就创建）、 **mas_remakeConstraints** 移除已经创建的约束并添加新的约束。\n\n### 2. MASViewAttribute\n\n**MASViewAttribute** 内部有三个属性和三个方法，从这些属性和方法可以看出，它就是对 UIView 和 NSLayoutAttribute 的封装，`MASViewAttribute = UIView + NSLayoutAttribute + item`，view 属性就是要约束的控件，item 就是控件上约束的部分。\n\nitem 属性就是在创建 NSLayoutConstriant 构造方法时 **constraintWithItem** 与 **toItem** 的参数。对于 UIView 来说该 item 就是 UIView 本身。而对于UIViewController，该出 Item 就 topLayoutGuide，bottomLayoutGuide 。\n\n该类中除了初始化方法外还有一个 **isSizeAttribute** 方法，该方法用来判断 MASViewAttribute 类中的 **layoutAttribute** 属性是否是 **NSLayoutAttributeWidth** 或者**NSLayoutAttributeHeight**，如果是Width或者Height的话，那么约束就添加到当前View上，而不是添加在父视图上。\n\n### 3. MASViewConstraint\n\n**MASViewConstraint** 是对 **NSLayoutConstraint** 的进一步封装，对控件设置约束，底层还是使用了 **NSLayoutConstraint** 来设置约束，Masonry 只是简化了代码，所以 **MASViewConstraint** 最重要的事情就是创建 **NSLayoutConstraint** 并设置给相应的视图。**总的来说 MASViewAttribute 是对 View 与 NSLayoutAttribute 进行的封装，所以 MASViewConstraint 类要依赖于 MASViewAttribute 类。**\n\n**MASConstraint** 是 **MASViewConstraint** 的父类，它是个抽象父类，不能实例化，它定义了很多公共接口方法。\n\n**MASConstraint** 还有个子类是 **MASCompositeConstraint** ，它里面只有一个方法 **- (id)initWithChildren:(NSArray *)children;**，其实就是存储一系列约束的类，内部有个私有属性数组 **childConstraints** 存储约束。总的来说是对它就是一个存储 **MASViewAttribute** 对象数组的封装。\n\n### 4. MASConstraintMaker\n\n**MASConstraintMaker** 是个工厂类，负责创建 **MASConstraint** 类型的对象。在 **View+MASAdditions** 中 **mas_makeConstraints** 的 block 参数就是 **MASConstraintMaker** 对象。用户可以通过 block 回调的 **MASConstraintMaker** 对象 给 View 指定约束。类的内部有个 **constraints** 属性来记录它创建的所有 **MASConstraint** 对象。\n\n## View+MASAdditions源码解析\n\n## 1.主要属性和getter方法\n\n\n```objc\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_left;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_top;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_right;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_bottom;\n......\n```\n\n上面是部分属性，属性的类型都是 **MASViewAttribute** 类型，因为 **MASViewAttribute** 是对 View 与 NSLayoutAttribute 进行的封装，所以 **mas_left** 就表示 View 和 NSLayoutAttributeLeft，一次类推别的属性。\n\n查看它们的 getter 方法：\n\n```objc\n#pragma mark - NSLayoutAttribute properties\n\n- (MASViewAttribute *)mas_left {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeLeft];\n}\n\n- (MASViewAttribute *)mas_top {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeTop];\n}\n\n- (MASViewAttribute *)mas_right {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeRight];\n}\n\n- (MASViewAttribute *)mas_bottom {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeBottom];\n}\n```\n\n就可以得知它所做的事情就是创建一个 **MASViewAttribute** ，也就是 **mas_left = self + NSLayoutAttributeLeft**。\n\n### 2. mas_makeConstraints方法解析\n\n```objc\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {\n\t  // 关闭自动添加约束，自己手动添加\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    // 创建 MASConstraintMaker\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];\n    // 给 maker 中的各种属性赋值，通过 block 进行值的回调\n    block(constraintMaker);\n    // 进行约束添加，并返回所有Install的约束数组\n    return [constraintMaker install];\n}\n```\n\n上面也说到用 **mas_makeConstraints** 来添加约束，该方法返回一个数组，数组里存放的是当前视图中添加的所有约束。因为 Masonry 对 **NSLayoutAttribute** 封装成了 **MASViewConstraint** ，所以数组中存储的全是 **MASViewConstraint** 类型的对象。\n\n方法的参数是 **void(^)(MASConstraintMaker *)** 的匿名闭包，无返回值，需要个 **MASConstraintMaker** 对象。在方法中，首先将 **translatesAutoresizingMaskIntoConstraints** 设置为 NO，然后创建了一个 **MASConstraintMaker** 对象，通过 block 将 **MASConstraintMaker** 对象传递给用户来设置约束，也就是让用户使用 **MASConstraintMaker** 中的 **MASConstraint** 类型的属性。\n\n### 3. mas_updateConstraints 与 mas_remakeConstraints 函数的解析\n\n这两个函数内部的是想和 mas_makeConstraints 差不多，只是多设置一个属性。\n\nmas_updateConstraints 中将 `updateExisting` 设置为 YES，就是说添加约束时先检查是否已经被添加，如果被添加了就更新，如果没有被添加就添加。\n\nmas_remakeConstraints 中所做的事情是将 `removeExisting` 设置为 YES，就是说将视图上的旧约束先移除掉，在添加新的约束。\n\n```objc\nconstraintMaker.updateExisting = YES;\n```\n\n```objc\nconstraintMaker.removeExisting = YES;\n```\n\n### 4. mas_closestCommonSuperview\n\n**mas_closestCommonSuperview** 方法负责计算出两个视图的公共父视图，找到最近的那个公共父视图后就返回，如果找不到就返回 nil：\n\n```objc\n- (instancetype)mas_closestCommonSuperview:(MAS_VIEW *)view {\n    // 临时父视图存储\n    MAS_VIEW *closestCommonSuperview = nil;\n\n    MAS_VIEW *secondViewSuperview = view;\n    // 遍历 secondView 所有的父视图\n    while (!closestCommonSuperview && secondViewSuperview) {\n        MAS_VIEW *firstViewSuperview = self;\n        // 遍历当前视图（self）的父视图\n        while (!closestCommonSuperview && firstViewSuperview) {\n            if (secondViewSuperview == firstViewSuperview) {\n                // 找到公共父视图后结束循环\n                closestCommonSuperview = secondViewSuperview;\n            }\n            firstViewSuperview = firstViewSuperview.superview;\n        }\n        secondViewSuperview = secondViewSuperview.superview;\n    }\n    // 返回公共父视图\n    return closestCommonSuperview;\n}\n```\n\n寻找两个视图的公共父视图对于约束很重要，因为相对的约束是添加到其公共父视图上的。比如  viewA.left = viewB.right + 10, 因为是 viewA 与 viewB 的相对约束，那么约束是添加在 viewA 与 viewB 的公共父视图上的，如果 viewB 是 viewA 的父视图，那么约束就添加在 viewB 上从而对 viewA 起到约束作用。\n\n## 工厂类 MASConstraintMaker 解析\n\n### 1. 公共属性\n\n**MASConstraintMaker** 类里面的属性都有对应的 getter 方法：\n\n```objc\n- (MASConstraint *)left {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];\n}\n\n- (MASConstraint *)top {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];\n}\n.....\n```\n\n### 2. 工厂方法\n\ngetter 方法都会调用 **addConstraintWithLayoutAttribute** ，在 **addConstraintWithLayoutAttribute** 方法中又调用了 MASConstraintMaker 工厂类的工厂方法：\n\n```objc\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];\n}\n```\n\n```objc\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    // 创建 MASViewAttribute\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    // 根据 layoutAttribute 创建 MASViewConstraint\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    // constraint 不为 nil时，就和 newConstraint 合并为 MASCompositeConstraint 对象\n    if ([constraint isKindOfClass:MASViewConstraint.class]) {\n        //replace with composite constraint\n        NSArray *children = @[constraint, newConstraint];\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];\n        compositeConstraint.delegate = self;\n        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];\n        return compositeConstraint;\n    }\n    if (!constraint) {\n        // 设置代理 MASConstraintDelegate，链式调用的核心，让 MASViewConstraint 也能调用这个方法\n        newConstraint.delegate = self;\n        // 添加进数组\n        [self.constraints addObject:newConstraint];\n    }\n    return newConstraint;\n}\n```\n\n上面代码根据提供的参数创建 MSAViewConstraint 对象，如果该函数的第一个参数不为空的话就会将新创建的 MSAViewConstraint 对象与参数进行合并组合成 **MASCompositeConstraint** 类（ MASCompositeConstraint 本质上是 MSAViewConstraint 对象的数组）的对象。\n\n创建完 MASConstraint 类的相应的对象后，会把该创建的对象添加进 MASConstraintMaker 工厂类的私有 constraints 数组，来记录该工厂对象创建的所有约束。`newConstraint.delegate = self;` 这句话是非常重要的，由于为 MASConstraint 对象设置了代理，所以才支持链式调用。\n\n举个例子：maker.top.left.right.equalTo(@10)，第一步 maker.top 调用返回了 **MASViewConstraint** 类的对象，当调用 .left 时，其实就是 newConstraint.left ，这意味着，.left 并不是调用 maker 的 left 的 getter 方法，而是 **MASViewConstraint** 的 left 的 getter 方法：\n\n```objc\n// MASConstraint.m\n- (MASConstraint *)left {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];\n}\n```\n\n```objc\n// MASViewConstraint.m\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    NSAssert(!self.hasLayoutRelation, @\"Attributes should be chained before defining the constraint relation\");\n\n    return [self.delegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n}\n```\n\n从上面的代码可以看出，调用 **MASViewConstraint** 的 left 的 getter 方法其实就是调用 delegate 的 **addConstraintWithLayoutAttribute** 方法，而 delegate 就是前面提到的 `maker`，从而实现了链式调用。\n\n### 3. install 方法\n\n```objc\n// 添加约束到View上\n- (NSArray *)install {\n    // 如果是mas_remarkConstraint，先将该视图上的约束 uninstall\n    if (self.removeExisting) {\n        // 获取当前视图上添加的所有约束\n        NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view];\n        // 移除掉所有约束\n        for (MASConstraint *constraint in installedConstraints) {\n            [constraint uninstall];\n        }\n    }\n    \n    // 添加约束\n    // self.constraints 中存储的是通过 Block 中配置的参数\n    NSArray *constraints = self.constraints.copy;\n    for (MASConstraint *constraint in constraints) {\n        // 是否为 更新的约束\n        constraint.updateExisting = self.updateExisting;\n        // install 每个约束\n        [constraint install];\n    }\n    [self.constraints removeAllObjects];\n    return constraints;\n}\n```\n\n从上面的代码可以看出，install 方法就是遍历工厂对象所创建所有约束对象，并调用每个约束对象的 isntall 方法来添加约束。\n\n在安装约束时，如果 self.removeExisting == YES，那么就先 uninstall 旧约束，再 install 新约束。在安装约束时，将 updateExisting 赋值给每个约束，每个约束在调用本身的 install 方法时会判断是否更新。\n\n## MASViewConstraint 解析\n\n**MASConstraintMaker** 工厂类所创建的对象实质上是 **MASViewConstraint** 类的对象。而 **MASViewConstraint** 类实质上是对 **MASLayoutConstraint** 的封装，进一步说 **MASViewConstraint** 负责为 **MASLayoutConstraint** 构造器组织参数并创建 **MASLayoutConstraint** 的对象，并将该对象添加到相应的视图中。\n\n### 1. 链式调用\n\n我们设置约束的时候经常这么使用： **constraint.top.left.equalTo(superView).offset(10);** ，在 Objective-C 中这不是方法调用的形式，在 Objective-C 中的调用形式是 `[]` ，但是 Masonry 使用了 `()`，我们来看下怎么做到的：\n\n```objc\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    NSAssert(!self.hasLayoutRelation, @\"Attributes should be chained before defining the constraint relation\");\n\n    return [self.delegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n}\n``` \n这个在上面说到，调用类似 left、Top 等属性的时候其实是通过 delegate 去调用 maker 工厂类的工厂方法来创建 MASConstraint 对象。\n\n但是 **.offset(10)** 是怎么做到的，因为 OC 中不能通过小括号来调用方法：\n\n```objc\n- (MASConstraint * (^)(CGFloat))offset {\n    return ^id(CGFloat offset){\n        self.offset = offset;\n        return self;\n    };\n}\n```\n\n原来 offset() 是个闭包，它的返回值是个匿名block，参数是个 CGFloat 类型。总的来说 offset() = offset + ()，即先调用了 offset 方法，然后通过 () 调用了返回的匿名 block，闭包返回了 MASConstraint 对象。\n\n### 2. install 方法解析\n\n```objc\nMASLayoutConstraint *layoutConstraint\n        = [MASLayoutConstraint constraintWithItem:firstLayoutItem\n                                        attribute:firstLayoutAttribute\n                                        relatedBy:self.layoutRelation\n                                           toItem:secondLayoutItem\n                                        attribute:secondLayoutAttribute\n                                       multiplier:self.layoutMultiplier\n                                         constant:self.layoutConstant];\n                                         \nlayoutConstraint.priority = self.layoutPriority;\nlayoutConstraint.mas_key = self.mas_key;\n```\n\ninstall 方法创建 **MASLayoutConstraint** 对象，并将该对象添加到相应的 View 上。\n\n上面的代码就是根据获取的属性来创建 MASLayoutConstraint 对象，MASLayoutConstraint 就是继承自 NSLayoutConstraint。\n\n```objc\n// 寻找要添加约束的 View\nif (self.secondViewAttribute.view) {\n\t\t  // 寻找两个视图的公共父视图\n        MAS_VIEW *closestCommonSuperview = [self.firstViewAttribute.view mas_closestCommonSuperview:self.secondViewAttribute.view];\n        NSAssert(closestCommonSuperview,\n                 @\"couldn't find a common superview for %@ and %@\",\n                 self.firstViewAttribute.view, self.secondViewAttribute.view);\n        self.installedView = closestCommonSuperview;\n    } else if (self.firstViewAttribute.isSizeAttribute) {\n        self.installedView = self.firstViewAttribute.view;\n    } else {\n        self.installedView = self.firstViewAttribute.view.superview;\n    }\n```\n\n上面的代码就是创建约束对象后，寻找要添加约束的 View，如果是两个视图相对约束，就获取两种的公共父视图。如果添加的是 Width 或者 Height ，那么就添加到当前视图上。如果既没有指定相对视图，也不是 Size 类型的约束，那么就将该约束对象添加到当前视图的父视图上。\n\n创建完约束对象 **MASLayoutConstraint** ，并且找到要添加约束的 View 后，就要开始添加约束了。添加前判断是不是对约束的更新，如果约束已经存在就更新约束，如果不存在就进行添加。添加成功后通过 **mas_installedConstraints** 属性记录一下本安装的约束。mas_installedConstraints 是通过运行时为 UIView 关联的一个 NSMutable 类型的属性，用来记录约束该视图的所有约束。\n参考下面代码：\n\n```objc\nMASLayoutConstraint *existingConstraint = nil;\n    if (self.updateExisting) {\n        existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint];\n    }\n    if (existingConstraint) {\n        // 更新约束\n        existingConstraint.constant = layoutConstraint.constant;\n        self.layoutConstraint = existingConstraint;\n    } else {\n        // 添加约束\n        [self.installedView addConstraint:layoutConstraint];\n        self.layoutConstraint = layoutConstraint;\n        // 约束所在的 View 记录被添加的约束\n        [firstLayoutItem.mas_installedConstraints addObject:self];\n    }\n```\n\n### 3. UIView 的私有类目 UIView+MASConstraints\n\nMASViewConstraint 中定义了一个 UIView 的私有扩展 `UIView+MASConstraints`，它的作用是为 UIView 通过运行时来关联一个 **NSMutableSet** 类型的 **mas_installedConstraints** 属性。该属性记录了该 View 的所有约束。\n\n```objc\n/*\n\t私有类，只有 MASViewConstraint 使用它\n*/\n@interface MAS_VIEW (MASConstraints)\n\n@property (nonatomic, readonly) NSMutableSet *mas_installedConstraints;\n\n@end\n\n@implementation MAS_VIEW (MASConstraints)\n\n// 动态添加属性的 Key， 用来表示动态添加的属性\nstatic char kInstalledConstraintsKey;\n\n- (NSMutableSet *)mas_installedConstraints {\n    // 通过 kInstalledConstraintsKey 来获取已经动态添加的约束集合\n    NSMutableSet *constraints = objc_getAssociatedObject(self, &kInstalledConstraintsKey);\n    // 如果不存在，创建一个，并进行动态绑定\n    if (!constraints) {\n        constraints = [NSMutableSet set];\n        objc_setAssociatedObject(self, &kInstalledConstraintsKey, constraints, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    }\n    return constraints;\n}\n\n@end\n```\n\n## 总结\n\n本文简单的对 Masonry 的核心代码进行分析，更加细节的东西还请自行去阅读源码。\n\n","slug":"2018-01-20-masonry-analysis","published":1,"updated":"2018-09-02T03:35:02.608Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7ps005a8jpb8atyrb5l","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在 iOS 开发中 Masonry 是控件布局中经常使用的一个轻量级框架布局控件，它简化了手写 AutoLayout 代码的难度，本文就分析一下 Masonry 框架的源码。</p>\n<h2 id=\"Masonry-与-NSLayoutConstraint-调用方式的对比\"><a href=\"#Masonry-与-NSLayoutConstraint-调用方式的对比\" class=\"headerlink\" title=\"Masonry 与 NSLayoutConstraint 调用方式的对比\"></a>Masonry 与 NSLayoutConstraint 调用方式的对比</h2><h3 id=\"1-NSLayoutConstraint\"><a href=\"#1-NSLayoutConstraint\" class=\"headerlink\" title=\"1.NSLayoutConstraint\"></a>1.NSLayoutConstraint</h3><p>给一个 View 设置相对父控件的顶部距离 <code>10个pt</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class=\"line\">                                 attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></span><br><span class=\"line\">                                 relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                                    toItem:superview</span><br><span class=\"line\">                                 attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></span><br><span class=\"line\">                                multiplier:<span class=\"number\">1.0</span></span><br><span class=\"line\">                                  constant:<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure>\n<p>代码相当直观的说明的约束关系。</p>\n<h3 id=\"2-Masonry\"><a href=\"#2-Masonry\" class=\"headerlink\" title=\"2.Masonry\"></a>2.Masonry</h3><p>Masonry 是通过链式调用和匿名闭包的方式来简化设置约束：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.equalTo(superview.mas_top).with.offset(<span class=\"number\">10</span>); </span><br><span class=\"line\">    <span class=\"comment\">// 等价于</span></span><br><span class=\"line\">    make.top.equalTo(@<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 等价于</span></span><br><span class=\"line\">    make.top.equalTo(superview.mas_top).multipliedBy(<span class=\"number\">1</span>).offset(<span class=\"number\">10</span>); </span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h2><h3 id=\"1-View-MASAdditions\"><a href=\"#1-View-MASAdditions\" class=\"headerlink\" title=\"1. View+MASAdditions\"></a>1. View+MASAdditions</h3><p>上面使用到的 <strong>mas_makeConstraints</strong> 是 UIView 扩展 <strong>UIView+MASAdditions</strong> 提供给的方法，这个类提供了一系列 <strong>MASViewAttribute</strong> 成员属性，和四个公开的方法： <strong>mas_closestCommonSuperview</strong> 寻找两个视图最近的公共父类、 <strong>mas_makeConstraints</strong> 创建安装约束、 <strong>mas_updateConstraints</strong> 更新已经存在的约束（不存在的就创建）、 <strong>mas_remakeConstraints</strong> 移除已经创建的约束并添加新的约束。</p>\n<h3 id=\"2-MASViewAttribute\"><a href=\"#2-MASViewAttribute\" class=\"headerlink\" title=\"2. MASViewAttribute\"></a>2. MASViewAttribute</h3><p><strong>MASViewAttribute</strong> 内部有三个属性和三个方法，从这些属性和方法可以看出，它就是对 UIView 和 NSLayoutAttribute 的封装，<code>MASViewAttribute = UIView + NSLayoutAttribute + item</code>，view 属性就是要约束的控件，item 就是控件上约束的部分。</p>\n<p>item 属性就是在创建 NSLayoutConstriant 构造方法时 <strong>constraintWithItem</strong> 与 <strong>toItem</strong> 的参数。对于 UIView 来说该 item 就是 UIView 本身。而对于UIViewController，该出 Item 就 topLayoutGuide，bottomLayoutGuide 。</p>\n<p>该类中除了初始化方法外还有一个 <strong>isSizeAttribute</strong> 方法，该方法用来判断 MASViewAttribute 类中的 <strong>layoutAttribute</strong> 属性是否是 <strong>NSLayoutAttributeWidth</strong> 或者<strong>NSLayoutAttributeHeight</strong>，如果是Width或者Height的话，那么约束就添加到当前View上，而不是添加在父视图上。</p>\n<h3 id=\"3-MASViewConstraint\"><a href=\"#3-MASViewConstraint\" class=\"headerlink\" title=\"3. MASViewConstraint\"></a>3. MASViewConstraint</h3><p><strong>MASViewConstraint</strong> 是对 <strong>NSLayoutConstraint</strong> 的进一步封装，对控件设置约束，底层还是使用了 <strong>NSLayoutConstraint</strong> 来设置约束，Masonry 只是简化了代码，所以 <strong>MASViewConstraint</strong> 最重要的事情就是创建 <strong>NSLayoutConstraint</strong> 并设置给相应的视图。<strong>总的来说 MASViewAttribute 是对 View 与 NSLayoutAttribute 进行的封装，所以 MASViewConstraint 类要依赖于 MASViewAttribute 类。</strong></p>\n<p><strong>MASConstraint</strong> 是 <strong>MASViewConstraint</strong> 的父类，它是个抽象父类，不能实例化，它定义了很多公共接口方法。</p>\n<p><strong>MASConstraint</strong> 还有个子类是 <strong>MASCompositeConstraint</strong> ，它里面只有一个方法 <strong>- (id)initWithChildren:(NSArray *)children;</strong>，其实就是存储一系列约束的类，内部有个私有属性数组 <strong>childConstraints</strong> 存储约束。总的来说是对它就是一个存储 <strong>MASViewAttribute</strong> 对象数组的封装。</p>\n<h3 id=\"4-MASConstraintMaker\"><a href=\"#4-MASConstraintMaker\" class=\"headerlink\" title=\"4. MASConstraintMaker\"></a>4. MASConstraintMaker</h3><p><strong>MASConstraintMaker</strong> 是个工厂类，负责创建 <strong>MASConstraint</strong> 类型的对象。在 <strong>View+MASAdditions</strong> 中 <strong>mas_makeConstraints</strong> 的 block 参数就是 <strong>MASConstraintMaker</strong> 对象。用户可以通过 block 回调的 <strong>MASConstraintMaker</strong> 对象 给 View 指定约束。类的内部有个 <strong>constraints</strong> 属性来记录它创建的所有 <strong>MASConstraint</strong> 对象。</p>\n<h2 id=\"View-MASAdditions源码解析\"><a href=\"#View-MASAdditions源码解析\" class=\"headerlink\" title=\"View+MASAdditions源码解析\"></a>View+MASAdditions源码解析</h2><h2 id=\"1-主要属性和getter方法\"><a href=\"#1-主要属性和getter方法\" class=\"headerlink\" title=\"1.主要属性和getter方法\"></a>1.主要属性和getter方法</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASViewAttribute *mas_left;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASViewAttribute *mas_top;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASViewAttribute *mas_right;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASViewAttribute *mas_bottom;</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>上面是部分属性，属性的类型都是 <strong>MASViewAttribute</strong> 类型，因为 <strong>MASViewAttribute</strong> 是对 View 与 NSLayoutAttribute 进行的封装，所以 <strong>mas_left</strong> 就表示 View 和 NSLayoutAttributeLeft，一次类推别的属性。</p>\n<p>查看它们的 getter 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark - NSLayoutAttribute properties</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (MASViewAttribute *)mas_left &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[MASViewAttribute alloc] initWithView:<span class=\"keyword\">self</span> layoutAttribute:<span class=\"built_in\">NSLayoutAttributeLeft</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (MASViewAttribute *)mas_top &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[MASViewAttribute alloc] initWithView:<span class=\"keyword\">self</span> layoutAttribute:<span class=\"built_in\">NSLayoutAttributeTop</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (MASViewAttribute *)mas_right &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[MASViewAttribute alloc] initWithView:<span class=\"keyword\">self</span> layoutAttribute:<span class=\"built_in\">NSLayoutAttributeRight</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (MASViewAttribute *)mas_bottom &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[MASViewAttribute alloc] initWithView:<span class=\"keyword\">self</span> layoutAttribute:<span class=\"built_in\">NSLayoutAttributeBottom</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就可以得知它所做的事情就是创建一个 <strong>MASViewAttribute</strong> ，也就是 <strong>mas_left = self + NSLayoutAttributeLeft</strong>。</p>\n<h3 id=\"2-mas-makeConstraints方法解析\"><a href=\"#2-mas-makeConstraints方法解析\" class=\"headerlink\" title=\"2. mas_makeConstraints方法解析\"></a>2. mas_makeConstraints方法解析</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_makeConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class=\"line\">\t  <span class=\"comment\">// 关闭自动添加约束，自己手动添加</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 MASConstraintMaker</span></span><br><span class=\"line\">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 给 maker 中的各种属性赋值，通过 block 进行值的回调</span></span><br><span class=\"line\">    block(constraintMaker);</span><br><span class=\"line\">    <span class=\"comment\">// 进行约束添加，并返回所有Install的约束数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [constraintMaker install];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面也说到用 <strong>mas_makeConstraints</strong> 来添加约束，该方法返回一个数组，数组里存放的是当前视图中添加的所有约束。因为 Masonry 对 <strong>NSLayoutAttribute</strong> 封装成了 <strong>MASViewConstraint</strong> ，所以数组中存储的全是 <strong>MASViewConstraint</strong> 类型的对象。</p>\n<p>方法的参数是 <strong>void(^)(MASConstraintMaker *)</strong> 的匿名闭包，无返回值，需要个 <strong>MASConstraintMaker</strong> 对象。在方法中，首先将 <strong>translatesAutoresizingMaskIntoConstraints</strong> 设置为 NO，然后创建了一个 <strong>MASConstraintMaker</strong> 对象，通过 block 将 <strong>MASConstraintMaker</strong> 对象传递给用户来设置约束，也就是让用户使用 <strong>MASConstraintMaker</strong> 中的 <strong>MASConstraint</strong> 类型的属性。</p>\n<h3 id=\"3-mas-updateConstraints-与-mas-remakeConstraints-函数的解析\"><a href=\"#3-mas-updateConstraints-与-mas-remakeConstraints-函数的解析\" class=\"headerlink\" title=\"3. mas_updateConstraints 与 mas_remakeConstraints 函数的解析\"></a>3. mas_updateConstraints 与 mas_remakeConstraints 函数的解析</h3><p>这两个函数内部的是想和 mas_makeConstraints 差不多，只是多设置一个属性。</p>\n<p>mas_updateConstraints 中将 <code>updateExisting</code> 设置为 YES，就是说添加约束时先检查是否已经被添加，如果被添加了就更新，如果没有被添加就添加。</p>\n<p>mas_remakeConstraints 中所做的事情是将 <code>removeExisting</code> 设置为 YES，就是说将视图上的旧约束先移除掉，在添加新的约束。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constraintMaker.updateExisting = <span class=\"literal\">YES</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constraintMaker.removeExisting = <span class=\"literal\">YES</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-mas-closestCommonSuperview\"><a href=\"#4-mas-closestCommonSuperview\" class=\"headerlink\" title=\"4. mas_closestCommonSuperview\"></a>4. mas_closestCommonSuperview</h3><p><strong>mas_closestCommonSuperview</strong> 方法负责计算出两个视图的公共父视图，找到最近的那个公共父视图后就返回，如果找不到就返回 nil：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)mas_closestCommonSuperview:(MAS_VIEW *)view &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 临时父视图存储</span></span><br><span class=\"line\">    MAS_VIEW *closestCommonSuperview = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    MAS_VIEW *secondViewSuperview = view;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历 secondView 所有的父视图</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!closestCommonSuperview &amp;&amp; secondViewSuperview) &#123;</span><br><span class=\"line\">        MAS_VIEW *firstViewSuperview = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历当前视图（self）的父视图</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!closestCommonSuperview &amp;&amp; firstViewSuperview) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (secondViewSuperview == firstViewSuperview) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 找到公共父视图后结束循环</span></span><br><span class=\"line\">                closestCommonSuperview = secondViewSuperview;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            firstViewSuperview = firstViewSuperview.superview;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        secondViewSuperview = secondViewSuperview.superview;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回公共父视图</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> closestCommonSuperview;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>寻找两个视图的公共父视图对于约束很重要，因为相对的约束是添加到其公共父视图上的。比如  viewA.left = viewB.right + 10, 因为是 viewA 与 viewB 的相对约束，那么约束是添加在 viewA 与 viewB 的公共父视图上的，如果 viewB 是 viewA 的父视图，那么约束就添加在 viewB 上从而对 viewA 起到约束作用。</p>\n<h2 id=\"工厂类-MASConstraintMaker-解析\"><a href=\"#工厂类-MASConstraintMaker-解析\" class=\"headerlink\" title=\"工厂类 MASConstraintMaker 解析\"></a>工厂类 MASConstraintMaker 解析</h2><h3 id=\"1-公共属性\"><a href=\"#1-公共属性\" class=\"headerlink\" title=\"1. 公共属性\"></a>1. 公共属性</h3><p><strong>MASConstraintMaker</strong> 类里面的属性都有对应的 getter 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (MASConstraint *)left &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> addConstraintWithLayoutAttribute:<span class=\"built_in\">NSLayoutAttributeLeft</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (MASConstraint *)top &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> addConstraintWithLayoutAttribute:<span class=\"built_in\">NSLayoutAttributeTop</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.....</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-工厂方法\"><a href=\"#2-工厂方法\" class=\"headerlink\" title=\"2. 工厂方法\"></a>2. 工厂方法</h3><p>getter 方法都会调用 <strong>addConstraintWithLayoutAttribute</strong> ，在 <strong>addConstraintWithLayoutAttribute</strong> 方法中又调用了 MASConstraintMaker 工厂类的工厂方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class=\"built_in\">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> constraint:<span class=\"literal\">nil</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(<span class=\"built_in\">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 MASViewAttribute</span></span><br><span class=\"line\">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class=\"keyword\">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class=\"line\">    <span class=\"comment\">// 根据 layoutAttribute 创建 MASViewConstraint</span></span><br><span class=\"line\">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class=\"line\">    <span class=\"comment\">// constraint 不为 nil时，就和 newConstraint 合并为 MASCompositeConstraint 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//replace with composite constraint</span></span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> *children = @[constraint, newConstraint];</span><br><span class=\"line\">        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class=\"line\">        compositeConstraint.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compositeConstraint;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!constraint) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置代理 MASConstraintDelegate，链式调用的核心，让 MASViewConstraint 也能调用这个方法</span></span><br><span class=\"line\">        newConstraint.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 添加进数组</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.constraints addObject:newConstraint];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newConstraint;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码根据提供的参数创建 MSAViewConstraint 对象，如果该函数的第一个参数不为空的话就会将新创建的 MSAViewConstraint 对象与参数进行合并组合成 <strong>MASCompositeConstraint</strong> 类（ MASCompositeConstraint 本质上是 MSAViewConstraint 对象的数组）的对象。</p>\n<p>创建完 MASConstraint 类的相应的对象后，会把该创建的对象添加进 MASConstraintMaker 工厂类的私有 constraints 数组，来记录该工厂对象创建的所有约束。<code>newConstraint.delegate = self;</code> 这句话是非常重要的，由于为 MASConstraint 对象设置了代理，所以才支持链式调用。</p>\n<p>举个例子：maker.top.left.right.equalTo(@10)，第一步 maker.top 调用返回了 <strong>MASViewConstraint</strong> 类的对象，当调用 .left 时，其实就是 newConstraint.left ，这意味着，.left 并不是调用 maker 的 left 的 getter 方法，而是 <strong>MASViewConstraint</strong> 的 left 的 getter 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MASConstraint.m</span></span><br><span class=\"line\">- (MASConstraint *)left &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> addConstraintWithLayoutAttribute:<span class=\"built_in\">NSLayoutAttributeLeft</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MASViewConstraint.m</span></span><br><span class=\"line\">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class=\"built_in\">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>(!<span class=\"keyword\">self</span>.hasLayoutRelation, <span class=\"string\">@\"Attributes should be chained before defining the constraint relation\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.delegate constraint:<span class=\"keyword\">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，调用 <strong>MASViewConstraint</strong> 的 left 的 getter 方法其实就是调用 delegate 的 <strong>addConstraintWithLayoutAttribute</strong> 方法，而 delegate 就是前面提到的 <code>maker</code>，从而实现了链式调用。</p>\n<h3 id=\"3-install-方法\"><a href=\"#3-install-方法\" class=\"headerlink\" title=\"3. install 方法\"></a>3. install 方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加约束到View上</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)install &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是mas_remarkConstraint，先将该视图上的约束 uninstall</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.removeExisting) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前视图上添加的所有约束</span></span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> *installedConstraints = [MASViewConstraint installedConstraintsForView:<span class=\"keyword\">self</span>.view];</span><br><span class=\"line\">        <span class=\"comment\">// 移除掉所有约束</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (MASConstraint *constraint <span class=\"keyword\">in</span> installedConstraints) &#123;</span><br><span class=\"line\">            [constraint uninstall];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加约束</span></span><br><span class=\"line\">    <span class=\"comment\">// self.constraints 中存储的是通过 Block 中配置的参数</span></span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *constraints = <span class=\"keyword\">self</span>.constraints.copy;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (MASConstraint *constraint <span class=\"keyword\">in</span> constraints) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 是否为 更新的约束</span></span><br><span class=\"line\">        constraint.updateExisting = <span class=\"keyword\">self</span>.updateExisting;</span><br><span class=\"line\">        <span class=\"comment\">// install 每个约束</span></span><br><span class=\"line\">        [constraint install];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.constraints removeAllObjects];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> constraints;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，install 方法就是遍历工厂对象所创建所有约束对象，并调用每个约束对象的 isntall 方法来添加约束。</p>\n<p>在安装约束时，如果 self.removeExisting == YES，那么就先 uninstall 旧约束，再 install 新约束。在安装约束时，将 updateExisting 赋值给每个约束，每个约束在调用本身的 install 方法时会判断是否更新。</p>\n<h2 id=\"MASViewConstraint-解析\"><a href=\"#MASViewConstraint-解析\" class=\"headerlink\" title=\"MASViewConstraint 解析\"></a>MASViewConstraint 解析</h2><p><strong>MASConstraintMaker</strong> 工厂类所创建的对象实质上是 <strong>MASViewConstraint</strong> 类的对象。而 <strong>MASViewConstraint</strong> 类实质上是对 <strong>MASLayoutConstraint</strong> 的封装，进一步说 <strong>MASViewConstraint</strong> 负责为 <strong>MASLayoutConstraint</strong> 构造器组织参数并创建 <strong>MASLayoutConstraint</strong> 的对象，并将该对象添加到相应的视图中。</p>\n<h3 id=\"1-链式调用\"><a href=\"#1-链式调用\" class=\"headerlink\" title=\"1. 链式调用\"></a>1. 链式调用</h3><p>我们设置约束的时候经常这么使用： <strong>constraint.top.left.equalTo(superView).offset(10);</strong> ，在 Objective-C 中这不是方法调用的形式，在 Objective-C 中的调用形式是 <code>[]</code> ，但是 Masonry 使用了 <code>()</code>，我们来看下怎么做到的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class=\"built_in\">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>(!<span class=\"keyword\">self</span>.hasLayoutRelation, <span class=\"string\">@\"Attributes should be chained before defining the constraint relation\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.delegate constraint:<span class=\"keyword\">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">这个在上面说到，调用类似 left、Top 等属性的时候其实是通过 delegate 去调用 maker 工厂类的工厂方法来创建 MASConstraint 对象。</span><br><span class=\"line\"></span><br><span class=\"line\">但是 **.offset(<span class=\"number\">10</span>)** 是怎么做到的，因为 OC 中不能通过小括号来调用方法：</span><br><span class=\"line\"></span><br><span class=\"line\">```objc</span><br><span class=\"line\">- (MASConstraint * (^)(<span class=\"built_in\">CGFloat</span>))offset &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^<span class=\"keyword\">id</span>(<span class=\"built_in\">CGFloat</span> offset)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.offset = offset;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原来 offset() 是个闭包，它的返回值是个匿名block，参数是个 CGFloat 类型。总的来说 offset() = offset + ()，即先调用了 offset 方法，然后通过 () 调用了返回的匿名 block，闭包返回了 MASConstraint 对象。</p>\n<h3 id=\"2-install-方法解析\"><a href=\"#2-install-方法解析\" class=\"headerlink\" title=\"2. install 方法解析\"></a>2. install 方法解析</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MASLayoutConstraint *layoutConstraint</span><br><span class=\"line\">        = [MASLayoutConstraint constraintWithItem:firstLayoutItem</span><br><span class=\"line\">                                        attribute:firstLayoutAttribute</span><br><span class=\"line\">                                        relatedBy:<span class=\"keyword\">self</span>.layoutRelation</span><br><span class=\"line\">                                           toItem:secondLayoutItem</span><br><span class=\"line\">                                        attribute:secondLayoutAttribute</span><br><span class=\"line\">                                       multiplier:<span class=\"keyword\">self</span>.layoutMultiplier</span><br><span class=\"line\">                                         constant:<span class=\"keyword\">self</span>.layoutConstant];</span><br><span class=\"line\">                                         </span><br><span class=\"line\">layoutConstraint.priority = <span class=\"keyword\">self</span>.layoutPriority;</span><br><span class=\"line\">layoutConstraint.mas_key = <span class=\"keyword\">self</span>.mas_key;</span><br></pre></td></tr></table></figure>\n<p>install 方法创建 <strong>MASLayoutConstraint</strong> 对象，并将该对象添加到相应的 View 上。</p>\n<p>上面的代码就是根据获取的属性来创建 MASLayoutConstraint 对象，MASLayoutConstraint 就是继承自 NSLayoutConstraint。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寻找要添加约束的 View</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.secondViewAttribute.view) &#123;</span><br><span class=\"line\">\t\t  <span class=\"comment\">// 寻找两个视图的公共父视图</span></span><br><span class=\"line\">        MAS_VIEW *closestCommonSuperview = [<span class=\"keyword\">self</span>.firstViewAttribute.view mas_closestCommonSuperview:<span class=\"keyword\">self</span>.secondViewAttribute.view];</span><br><span class=\"line\">        <span class=\"built_in\">NSAssert</span>(closestCommonSuperview,</span><br><span class=\"line\">                 <span class=\"string\">@\"couldn't find a common superview for %@ and %@\"</span>,</span><br><span class=\"line\">                 <span class=\"keyword\">self</span>.firstViewAttribute.view, <span class=\"keyword\">self</span>.secondViewAttribute.view);</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.installedView = closestCommonSuperview;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.firstViewAttribute.isSizeAttribute) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.installedView = <span class=\"keyword\">self</span>.firstViewAttribute.view;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.installedView = <span class=\"keyword\">self</span>.firstViewAttribute.view.superview;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码就是创建约束对象后，寻找要添加约束的 View，如果是两个视图相对约束，就获取两种的公共父视图。如果添加的是 Width 或者 Height ，那么就添加到当前视图上。如果既没有指定相对视图，也不是 Size 类型的约束，那么就将该约束对象添加到当前视图的父视图上。</p>\n<p>创建完约束对象 <strong>MASLayoutConstraint</strong> ，并且找到要添加约束的 View 后，就要开始添加约束了。添加前判断是不是对约束的更新，如果约束已经存在就更新约束，如果不存在就进行添加。添加成功后通过 <strong>mas_installedConstraints</strong> 属性记录一下本安装的约束。mas_installedConstraints 是通过运行时为 UIView 关联的一个 NSMutable 类型的属性，用来记录约束该视图的所有约束。<br>参考下面代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MASLayoutConstraint *existingConstraint = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.updateExisting) &#123;</span><br><span class=\"line\">        existingConstraint = [<span class=\"keyword\">self</span> layoutConstraintSimilarTo:layoutConstraint];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existingConstraint) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新约束</span></span><br><span class=\"line\">        existingConstraint.constant = layoutConstraint.constant;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.layoutConstraint = existingConstraint;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 添加约束</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.installedView addConstraint:layoutConstraint];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.layoutConstraint = layoutConstraint;</span><br><span class=\"line\">        <span class=\"comment\">// 约束所在的 View 记录被添加的约束</span></span><br><span class=\"line\">        [firstLayoutItem.mas_installedConstraints addObject:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-UIView-的私有类目-UIView-MASConstraints\"><a href=\"#3-UIView-的私有类目-UIView-MASConstraints\" class=\"headerlink\" title=\"3. UIView 的私有类目 UIView+MASConstraints\"></a>3. UIView 的私有类目 UIView+MASConstraints</h3><p>MASViewConstraint 中定义了一个 UIView 的私有扩展 <code>UIView+MASConstraints</code>，它的作用是为 UIView 通过运行时来关联一个 <strong>NSMutableSet</strong> 类型的 <strong>mas_installedConstraints</strong> 属性。该属性记录了该 View 的所有约束。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t私有类，只有 MASViewConstraint 使用它</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MAS_VIEW</span> (<span class=\"title\">MASConstraints</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSMutableSet</span> *mas_installedConstraints;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MAS_VIEW</span> (<span class=\"title\">MASConstraints</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态添加属性的 Key， 用来表示动态添加的属性</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> kInstalledConstraintsKey;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableSet</span> *)mas_installedConstraints &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 kInstalledConstraintsKey 来获取已经动态添加的约束集合</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableSet</span> *constraints = objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;kInstalledConstraintsKey);</span><br><span class=\"line\">    <span class=\"comment\">// 如果不存在，创建一个，并进行动态绑定</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!constraints) &#123;</span><br><span class=\"line\">        constraints = [<span class=\"built_in\">NSMutableSet</span> set];</span><br><span class=\"line\">        objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;kInstalledConstraintsKey, constraints, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> constraints;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文简单的对 Masonry 的核心代码进行分析，更加细节的东西还请自行去阅读源码。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在 iOS 开发中 Masonry 是控件布局中经常使用的一个轻量级框架布局控件，它简化了手写 AutoLayout 代码的难度，本文就分析一下 Masonry 框架的源码。</p>\n<h2 id=\"Masonry-与-NSLayoutConstraint-调用方式的对比\"><a href=\"#Masonry-与-NSLayoutConstraint-调用方式的对比\" class=\"headerlink\" title=\"Masonry 与 NSLayoutConstraint 调用方式的对比\"></a>Masonry 与 NSLayoutConstraint 调用方式的对比</h2><h3 id=\"1-NSLayoutConstraint\"><a href=\"#1-NSLayoutConstraint\" class=\"headerlink\" title=\"1.NSLayoutConstraint\"></a>1.NSLayoutConstraint</h3><p>给一个 View 设置相对父控件的顶部距离 <code>10个pt</code>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class=\"line\">                                 attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></span><br><span class=\"line\">                                 relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                                    toItem:superview</span><br><span class=\"line\">                                 attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></span><br><span class=\"line\">                                multiplier:<span class=\"number\">1.0</span></span><br><span class=\"line\">                                  constant:<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure>\n<p>代码相当直观的说明的约束关系。</p>\n<h3 id=\"2-Masonry\"><a href=\"#2-Masonry\" class=\"headerlink\" title=\"2.Masonry\"></a>2.Masonry</h3><p>Masonry 是通过链式调用和匿名闭包的方式来简化设置约束：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.top.equalTo(superview.mas_top).with.offset(<span class=\"number\">10</span>); </span><br><span class=\"line\">    <span class=\"comment\">// 等价于</span></span><br><span class=\"line\">    make.top.equalTo(@<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 等价于</span></span><br><span class=\"line\">    make.top.equalTo(superview.mas_top).multipliedBy(<span class=\"number\">1</span>).offset(<span class=\"number\">10</span>); </span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h2><h3 id=\"1-View-MASAdditions\"><a href=\"#1-View-MASAdditions\" class=\"headerlink\" title=\"1. View+MASAdditions\"></a>1. View+MASAdditions</h3><p>上面使用到的 <strong>mas_makeConstraints</strong> 是 UIView 扩展 <strong>UIView+MASAdditions</strong> 提供给的方法，这个类提供了一系列 <strong>MASViewAttribute</strong> 成员属性，和四个公开的方法： <strong>mas_closestCommonSuperview</strong> 寻找两个视图最近的公共父类、 <strong>mas_makeConstraints</strong> 创建安装约束、 <strong>mas_updateConstraints</strong> 更新已经存在的约束（不存在的就创建）、 <strong>mas_remakeConstraints</strong> 移除已经创建的约束并添加新的约束。</p>\n<h3 id=\"2-MASViewAttribute\"><a href=\"#2-MASViewAttribute\" class=\"headerlink\" title=\"2. MASViewAttribute\"></a>2. MASViewAttribute</h3><p><strong>MASViewAttribute</strong> 内部有三个属性和三个方法，从这些属性和方法可以看出，它就是对 UIView 和 NSLayoutAttribute 的封装，<code>MASViewAttribute = UIView + NSLayoutAttribute + item</code>，view 属性就是要约束的控件，item 就是控件上约束的部分。</p>\n<p>item 属性就是在创建 NSLayoutConstriant 构造方法时 <strong>constraintWithItem</strong> 与 <strong>toItem</strong> 的参数。对于 UIView 来说该 item 就是 UIView 本身。而对于UIViewController，该出 Item 就 topLayoutGuide，bottomLayoutGuide 。</p>\n<p>该类中除了初始化方法外还有一个 <strong>isSizeAttribute</strong> 方法，该方法用来判断 MASViewAttribute 类中的 <strong>layoutAttribute</strong> 属性是否是 <strong>NSLayoutAttributeWidth</strong> 或者<strong>NSLayoutAttributeHeight</strong>，如果是Width或者Height的话，那么约束就添加到当前View上，而不是添加在父视图上。</p>\n<h3 id=\"3-MASViewConstraint\"><a href=\"#3-MASViewConstraint\" class=\"headerlink\" title=\"3. MASViewConstraint\"></a>3. MASViewConstraint</h3><p><strong>MASViewConstraint</strong> 是对 <strong>NSLayoutConstraint</strong> 的进一步封装，对控件设置约束，底层还是使用了 <strong>NSLayoutConstraint</strong> 来设置约束，Masonry 只是简化了代码，所以 <strong>MASViewConstraint</strong> 最重要的事情就是创建 <strong>NSLayoutConstraint</strong> 并设置给相应的视图。<strong>总的来说 MASViewAttribute 是对 View 与 NSLayoutAttribute 进行的封装，所以 MASViewConstraint 类要依赖于 MASViewAttribute 类。</strong></p>\n<p><strong>MASConstraint</strong> 是 <strong>MASViewConstraint</strong> 的父类，它是个抽象父类，不能实例化，它定义了很多公共接口方法。</p>\n<p><strong>MASConstraint</strong> 还有个子类是 <strong>MASCompositeConstraint</strong> ，它里面只有一个方法 <strong>- (id)initWithChildren:(NSArray *)children;</strong>，其实就是存储一系列约束的类，内部有个私有属性数组 <strong>childConstraints</strong> 存储约束。总的来说是对它就是一个存储 <strong>MASViewAttribute</strong> 对象数组的封装。</p>\n<h3 id=\"4-MASConstraintMaker\"><a href=\"#4-MASConstraintMaker\" class=\"headerlink\" title=\"4. MASConstraintMaker\"></a>4. MASConstraintMaker</h3><p><strong>MASConstraintMaker</strong> 是个工厂类，负责创建 <strong>MASConstraint</strong> 类型的对象。在 <strong>View+MASAdditions</strong> 中 <strong>mas_makeConstraints</strong> 的 block 参数就是 <strong>MASConstraintMaker</strong> 对象。用户可以通过 block 回调的 <strong>MASConstraintMaker</strong> 对象 给 View 指定约束。类的内部有个 <strong>constraints</strong> 属性来记录它创建的所有 <strong>MASConstraint</strong> 对象。</p>\n<h2 id=\"View-MASAdditions源码解析\"><a href=\"#View-MASAdditions源码解析\" class=\"headerlink\" title=\"View+MASAdditions源码解析\"></a>View+MASAdditions源码解析</h2><h2 id=\"1-主要属性和getter方法\"><a href=\"#1-主要属性和getter方法\" class=\"headerlink\" title=\"1.主要属性和getter方法\"></a>1.主要属性和getter方法</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASViewAttribute *mas_left;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASViewAttribute *mas_top;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASViewAttribute *mas_right;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASViewAttribute *mas_bottom;</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>上面是部分属性，属性的类型都是 <strong>MASViewAttribute</strong> 类型，因为 <strong>MASViewAttribute</strong> 是对 View 与 NSLayoutAttribute 进行的封装，所以 <strong>mas_left</strong> 就表示 View 和 NSLayoutAttributeLeft，一次类推别的属性。</p>\n<p>查看它们的 getter 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark - NSLayoutAttribute properties</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (MASViewAttribute *)mas_left &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[MASViewAttribute alloc] initWithView:<span class=\"keyword\">self</span> layoutAttribute:<span class=\"built_in\">NSLayoutAttributeLeft</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (MASViewAttribute *)mas_top &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[MASViewAttribute alloc] initWithView:<span class=\"keyword\">self</span> layoutAttribute:<span class=\"built_in\">NSLayoutAttributeTop</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (MASViewAttribute *)mas_right &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[MASViewAttribute alloc] initWithView:<span class=\"keyword\">self</span> layoutAttribute:<span class=\"built_in\">NSLayoutAttributeRight</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (MASViewAttribute *)mas_bottom &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[MASViewAttribute alloc] initWithView:<span class=\"keyword\">self</span> layoutAttribute:<span class=\"built_in\">NSLayoutAttributeBottom</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就可以得知它所做的事情就是创建一个 <strong>MASViewAttribute</strong> ，也就是 <strong>mas_left = self + NSLayoutAttributeLeft</strong>。</p>\n<h3 id=\"2-mas-makeConstraints方法解析\"><a href=\"#2-mas-makeConstraints方法解析\" class=\"headerlink\" title=\"2. mas_makeConstraints方法解析\"></a>2. mas_makeConstraints方法解析</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_makeConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class=\"line\">\t  <span class=\"comment\">// 关闭自动添加约束，自己手动添加</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 MASConstraintMaker</span></span><br><span class=\"line\">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 给 maker 中的各种属性赋值，通过 block 进行值的回调</span></span><br><span class=\"line\">    block(constraintMaker);</span><br><span class=\"line\">    <span class=\"comment\">// 进行约束添加，并返回所有Install的约束数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [constraintMaker install];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面也说到用 <strong>mas_makeConstraints</strong> 来添加约束，该方法返回一个数组，数组里存放的是当前视图中添加的所有约束。因为 Masonry 对 <strong>NSLayoutAttribute</strong> 封装成了 <strong>MASViewConstraint</strong> ，所以数组中存储的全是 <strong>MASViewConstraint</strong> 类型的对象。</p>\n<p>方法的参数是 <strong>void(^)(MASConstraintMaker *)</strong> 的匿名闭包，无返回值，需要个 <strong>MASConstraintMaker</strong> 对象。在方法中，首先将 <strong>translatesAutoresizingMaskIntoConstraints</strong> 设置为 NO，然后创建了一个 <strong>MASConstraintMaker</strong> 对象，通过 block 将 <strong>MASConstraintMaker</strong> 对象传递给用户来设置约束，也就是让用户使用 <strong>MASConstraintMaker</strong> 中的 <strong>MASConstraint</strong> 类型的属性。</p>\n<h3 id=\"3-mas-updateConstraints-与-mas-remakeConstraints-函数的解析\"><a href=\"#3-mas-updateConstraints-与-mas-remakeConstraints-函数的解析\" class=\"headerlink\" title=\"3. mas_updateConstraints 与 mas_remakeConstraints 函数的解析\"></a>3. mas_updateConstraints 与 mas_remakeConstraints 函数的解析</h3><p>这两个函数内部的是想和 mas_makeConstraints 差不多，只是多设置一个属性。</p>\n<p>mas_updateConstraints 中将 <code>updateExisting</code> 设置为 YES，就是说添加约束时先检查是否已经被添加，如果被添加了就更新，如果没有被添加就添加。</p>\n<p>mas_remakeConstraints 中所做的事情是将 <code>removeExisting</code> 设置为 YES，就是说将视图上的旧约束先移除掉，在添加新的约束。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constraintMaker.updateExisting = <span class=\"literal\">YES</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constraintMaker.removeExisting = <span class=\"literal\">YES</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-mas-closestCommonSuperview\"><a href=\"#4-mas-closestCommonSuperview\" class=\"headerlink\" title=\"4. mas_closestCommonSuperview\"></a>4. mas_closestCommonSuperview</h3><p><strong>mas_closestCommonSuperview</strong> 方法负责计算出两个视图的公共父视图，找到最近的那个公共父视图后就返回，如果找不到就返回 nil：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)mas_closestCommonSuperview:(MAS_VIEW *)view &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 临时父视图存储</span></span><br><span class=\"line\">    MAS_VIEW *closestCommonSuperview = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    MAS_VIEW *secondViewSuperview = view;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历 secondView 所有的父视图</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!closestCommonSuperview &amp;&amp; secondViewSuperview) &#123;</span><br><span class=\"line\">        MAS_VIEW *firstViewSuperview = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历当前视图（self）的父视图</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!closestCommonSuperview &amp;&amp; firstViewSuperview) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (secondViewSuperview == firstViewSuperview) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 找到公共父视图后结束循环</span></span><br><span class=\"line\">                closestCommonSuperview = secondViewSuperview;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            firstViewSuperview = firstViewSuperview.superview;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        secondViewSuperview = secondViewSuperview.superview;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回公共父视图</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> closestCommonSuperview;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>寻找两个视图的公共父视图对于约束很重要，因为相对的约束是添加到其公共父视图上的。比如  viewA.left = viewB.right + 10, 因为是 viewA 与 viewB 的相对约束，那么约束是添加在 viewA 与 viewB 的公共父视图上的，如果 viewB 是 viewA 的父视图，那么约束就添加在 viewB 上从而对 viewA 起到约束作用。</p>\n<h2 id=\"工厂类-MASConstraintMaker-解析\"><a href=\"#工厂类-MASConstraintMaker-解析\" class=\"headerlink\" title=\"工厂类 MASConstraintMaker 解析\"></a>工厂类 MASConstraintMaker 解析</h2><h3 id=\"1-公共属性\"><a href=\"#1-公共属性\" class=\"headerlink\" title=\"1. 公共属性\"></a>1. 公共属性</h3><p><strong>MASConstraintMaker</strong> 类里面的属性都有对应的 getter 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (MASConstraint *)left &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> addConstraintWithLayoutAttribute:<span class=\"built_in\">NSLayoutAttributeLeft</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (MASConstraint *)top &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> addConstraintWithLayoutAttribute:<span class=\"built_in\">NSLayoutAttributeTop</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.....</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-工厂方法\"><a href=\"#2-工厂方法\" class=\"headerlink\" title=\"2. 工厂方法\"></a>2. 工厂方法</h3><p>getter 方法都会调用 <strong>addConstraintWithLayoutAttribute</strong> ，在 <strong>addConstraintWithLayoutAttribute</strong> 方法中又调用了 MASConstraintMaker 工厂类的工厂方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class=\"built_in\">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> constraint:<span class=\"literal\">nil</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(<span class=\"built_in\">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 MASViewAttribute</span></span><br><span class=\"line\">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class=\"keyword\">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class=\"line\">    <span class=\"comment\">// 根据 layoutAttribute 创建 MASViewConstraint</span></span><br><span class=\"line\">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class=\"line\">    <span class=\"comment\">// constraint 不为 nil时，就和 newConstraint 合并为 MASCompositeConstraint 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//replace with composite constraint</span></span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> *children = @[constraint, newConstraint];</span><br><span class=\"line\">        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class=\"line\">        compositeConstraint.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compositeConstraint;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!constraint) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置代理 MASConstraintDelegate，链式调用的核心，让 MASViewConstraint 也能调用这个方法</span></span><br><span class=\"line\">        newConstraint.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 添加进数组</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.constraints addObject:newConstraint];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newConstraint;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码根据提供的参数创建 MSAViewConstraint 对象，如果该函数的第一个参数不为空的话就会将新创建的 MSAViewConstraint 对象与参数进行合并组合成 <strong>MASCompositeConstraint</strong> 类（ MASCompositeConstraint 本质上是 MSAViewConstraint 对象的数组）的对象。</p>\n<p>创建完 MASConstraint 类的相应的对象后，会把该创建的对象添加进 MASConstraintMaker 工厂类的私有 constraints 数组，来记录该工厂对象创建的所有约束。<code>newConstraint.delegate = self;</code> 这句话是非常重要的，由于为 MASConstraint 对象设置了代理，所以才支持链式调用。</p>\n<p>举个例子：maker.top.left.right.equalTo(@10)，第一步 maker.top 调用返回了 <strong>MASViewConstraint</strong> 类的对象，当调用 .left 时，其实就是 newConstraint.left ，这意味着，.left 并不是调用 maker 的 left 的 getter 方法，而是 <strong>MASViewConstraint</strong> 的 left 的 getter 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MASConstraint.m</span></span><br><span class=\"line\">- (MASConstraint *)left &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> addConstraintWithLayoutAttribute:<span class=\"built_in\">NSLayoutAttributeLeft</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MASViewConstraint.m</span></span><br><span class=\"line\">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class=\"built_in\">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>(!<span class=\"keyword\">self</span>.hasLayoutRelation, <span class=\"string\">@\"Attributes should be chained before defining the constraint relation\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.delegate constraint:<span class=\"keyword\">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，调用 <strong>MASViewConstraint</strong> 的 left 的 getter 方法其实就是调用 delegate 的 <strong>addConstraintWithLayoutAttribute</strong> 方法，而 delegate 就是前面提到的 <code>maker</code>，从而实现了链式调用。</p>\n<h3 id=\"3-install-方法\"><a href=\"#3-install-方法\" class=\"headerlink\" title=\"3. install 方法\"></a>3. install 方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加约束到View上</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)install &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是mas_remarkConstraint，先将该视图上的约束 uninstall</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.removeExisting) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前视图上添加的所有约束</span></span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> *installedConstraints = [MASViewConstraint installedConstraintsForView:<span class=\"keyword\">self</span>.view];</span><br><span class=\"line\">        <span class=\"comment\">// 移除掉所有约束</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (MASConstraint *constraint <span class=\"keyword\">in</span> installedConstraints) &#123;</span><br><span class=\"line\">            [constraint uninstall];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加约束</span></span><br><span class=\"line\">    <span class=\"comment\">// self.constraints 中存储的是通过 Block 中配置的参数</span></span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *constraints = <span class=\"keyword\">self</span>.constraints.copy;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (MASConstraint *constraint <span class=\"keyword\">in</span> constraints) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 是否为 更新的约束</span></span><br><span class=\"line\">        constraint.updateExisting = <span class=\"keyword\">self</span>.updateExisting;</span><br><span class=\"line\">        <span class=\"comment\">// install 每个约束</span></span><br><span class=\"line\">        [constraint install];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.constraints removeAllObjects];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> constraints;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，install 方法就是遍历工厂对象所创建所有约束对象，并调用每个约束对象的 isntall 方法来添加约束。</p>\n<p>在安装约束时，如果 self.removeExisting == YES，那么就先 uninstall 旧约束，再 install 新约束。在安装约束时，将 updateExisting 赋值给每个约束，每个约束在调用本身的 install 方法时会判断是否更新。</p>\n<h2 id=\"MASViewConstraint-解析\"><a href=\"#MASViewConstraint-解析\" class=\"headerlink\" title=\"MASViewConstraint 解析\"></a>MASViewConstraint 解析</h2><p><strong>MASConstraintMaker</strong> 工厂类所创建的对象实质上是 <strong>MASViewConstraint</strong> 类的对象。而 <strong>MASViewConstraint</strong> 类实质上是对 <strong>MASLayoutConstraint</strong> 的封装，进一步说 <strong>MASViewConstraint</strong> 负责为 <strong>MASLayoutConstraint</strong> 构造器组织参数并创建 <strong>MASLayoutConstraint</strong> 的对象，并将该对象添加到相应的视图中。</p>\n<h3 id=\"1-链式调用\"><a href=\"#1-链式调用\" class=\"headerlink\" title=\"1. 链式调用\"></a>1. 链式调用</h3><p>我们设置约束的时候经常这么使用： <strong>constraint.top.left.equalTo(superView).offset(10);</strong> ，在 Objective-C 中这不是方法调用的形式，在 Objective-C 中的调用形式是 <code>[]</code> ，但是 Masonry 使用了 <code>()</code>，我们来看下怎么做到的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class=\"built_in\">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>(!<span class=\"keyword\">self</span>.hasLayoutRelation, <span class=\"string\">@\"Attributes should be chained before defining the constraint relation\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.delegate constraint:<span class=\"keyword\">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">这个在上面说到，调用类似 left、Top 等属性的时候其实是通过 delegate 去调用 maker 工厂类的工厂方法来创建 MASConstraint 对象。</span><br><span class=\"line\"></span><br><span class=\"line\">但是 **.offset(<span class=\"number\">10</span>)** 是怎么做到的，因为 OC 中不能通过小括号来调用方法：</span><br><span class=\"line\"></span><br><span class=\"line\">```objc</span><br><span class=\"line\">- (MASConstraint * (^)(<span class=\"built_in\">CGFloat</span>))offset &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^<span class=\"keyword\">id</span>(<span class=\"built_in\">CGFloat</span> offset)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.offset = offset;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原来 offset() 是个闭包，它的返回值是个匿名block，参数是个 CGFloat 类型。总的来说 offset() = offset + ()，即先调用了 offset 方法，然后通过 () 调用了返回的匿名 block，闭包返回了 MASConstraint 对象。</p>\n<h3 id=\"2-install-方法解析\"><a href=\"#2-install-方法解析\" class=\"headerlink\" title=\"2. install 方法解析\"></a>2. install 方法解析</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MASLayoutConstraint *layoutConstraint</span><br><span class=\"line\">        = [MASLayoutConstraint constraintWithItem:firstLayoutItem</span><br><span class=\"line\">                                        attribute:firstLayoutAttribute</span><br><span class=\"line\">                                        relatedBy:<span class=\"keyword\">self</span>.layoutRelation</span><br><span class=\"line\">                                           toItem:secondLayoutItem</span><br><span class=\"line\">                                        attribute:secondLayoutAttribute</span><br><span class=\"line\">                                       multiplier:<span class=\"keyword\">self</span>.layoutMultiplier</span><br><span class=\"line\">                                         constant:<span class=\"keyword\">self</span>.layoutConstant];</span><br><span class=\"line\">                                         </span><br><span class=\"line\">layoutConstraint.priority = <span class=\"keyword\">self</span>.layoutPriority;</span><br><span class=\"line\">layoutConstraint.mas_key = <span class=\"keyword\">self</span>.mas_key;</span><br></pre></td></tr></table></figure>\n<p>install 方法创建 <strong>MASLayoutConstraint</strong> 对象，并将该对象添加到相应的 View 上。</p>\n<p>上面的代码就是根据获取的属性来创建 MASLayoutConstraint 对象，MASLayoutConstraint 就是继承自 NSLayoutConstraint。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寻找要添加约束的 View</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.secondViewAttribute.view) &#123;</span><br><span class=\"line\">\t\t  <span class=\"comment\">// 寻找两个视图的公共父视图</span></span><br><span class=\"line\">        MAS_VIEW *closestCommonSuperview = [<span class=\"keyword\">self</span>.firstViewAttribute.view mas_closestCommonSuperview:<span class=\"keyword\">self</span>.secondViewAttribute.view];</span><br><span class=\"line\">        <span class=\"built_in\">NSAssert</span>(closestCommonSuperview,</span><br><span class=\"line\">                 <span class=\"string\">@\"couldn't find a common superview for %@ and %@\"</span>,</span><br><span class=\"line\">                 <span class=\"keyword\">self</span>.firstViewAttribute.view, <span class=\"keyword\">self</span>.secondViewAttribute.view);</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.installedView = closestCommonSuperview;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.firstViewAttribute.isSizeAttribute) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.installedView = <span class=\"keyword\">self</span>.firstViewAttribute.view;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.installedView = <span class=\"keyword\">self</span>.firstViewAttribute.view.superview;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码就是创建约束对象后，寻找要添加约束的 View，如果是两个视图相对约束，就获取两种的公共父视图。如果添加的是 Width 或者 Height ，那么就添加到当前视图上。如果既没有指定相对视图，也不是 Size 类型的约束，那么就将该约束对象添加到当前视图的父视图上。</p>\n<p>创建完约束对象 <strong>MASLayoutConstraint</strong> ，并且找到要添加约束的 View 后，就要开始添加约束了。添加前判断是不是对约束的更新，如果约束已经存在就更新约束，如果不存在就进行添加。添加成功后通过 <strong>mas_installedConstraints</strong> 属性记录一下本安装的约束。mas_installedConstraints 是通过运行时为 UIView 关联的一个 NSMutable 类型的属性，用来记录约束该视图的所有约束。<br>参考下面代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MASLayoutConstraint *existingConstraint = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.updateExisting) &#123;</span><br><span class=\"line\">        existingConstraint = [<span class=\"keyword\">self</span> layoutConstraintSimilarTo:layoutConstraint];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existingConstraint) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新约束</span></span><br><span class=\"line\">        existingConstraint.constant = layoutConstraint.constant;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.layoutConstraint = existingConstraint;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 添加约束</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.installedView addConstraint:layoutConstraint];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.layoutConstraint = layoutConstraint;</span><br><span class=\"line\">        <span class=\"comment\">// 约束所在的 View 记录被添加的约束</span></span><br><span class=\"line\">        [firstLayoutItem.mas_installedConstraints addObject:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-UIView-的私有类目-UIView-MASConstraints\"><a href=\"#3-UIView-的私有类目-UIView-MASConstraints\" class=\"headerlink\" title=\"3. UIView 的私有类目 UIView+MASConstraints\"></a>3. UIView 的私有类目 UIView+MASConstraints</h3><p>MASViewConstraint 中定义了一个 UIView 的私有扩展 <code>UIView+MASConstraints</code>，它的作用是为 UIView 通过运行时来关联一个 <strong>NSMutableSet</strong> 类型的 <strong>mas_installedConstraints</strong> 属性。该属性记录了该 View 的所有约束。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t私有类，只有 MASViewConstraint 使用它</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MAS_VIEW</span> (<span class=\"title\">MASConstraints</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSMutableSet</span> *mas_installedConstraints;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MAS_VIEW</span> (<span class=\"title\">MASConstraints</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态添加属性的 Key， 用来表示动态添加的属性</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> kInstalledConstraintsKey;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableSet</span> *)mas_installedConstraints &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 kInstalledConstraintsKey 来获取已经动态添加的约束集合</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableSet</span> *constraints = objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;kInstalledConstraintsKey);</span><br><span class=\"line\">    <span class=\"comment\">// 如果不存在，创建一个，并进行动态绑定</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!constraints) &#123;</span><br><span class=\"line\">        constraints = [<span class=\"built_in\">NSMutableSet</span> set];</span><br><span class=\"line\">        objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;kInstalledConstraintsKey, constraints, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> constraints;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文简单的对 Masonry 的核心代码进行分析，更加细节的东西还请自行去阅读源码。</p>\n"},{"title":"AFURLSerialization 解析（四）","date":"2017-01-08T09:55:59.000Z","_content":"\n## 前言\n前面的文字已经分析了 **AFURLSessionManager** 和 **AFNetworkReachabilityManager**，一个是 AFN 的核心，另一个是 AFN 非常有用的工具类。\n\n这里我们接着了解 AFURLSessionManager 中使用到的**对发出请求和接收响应时**进行序列化的两个模块：\n* AFURLResponseSerialization\n* AFURLRequestSerialization\n\n前者是处理响应的模块，将请求返回的数据解析成对用的格式。后者主要是修改请求的头部（主要是 HTTP 请求）。\n\nAFURLResponseSerialization 主要使用在 AFURLSessionManager 中，而 AFURLRequestSerialization 主要用于 AFHTTPSessionManager 中，因为它主要用于**修改 HTTP 头部**。\n\n## AFURLResponseSerialization\n\nAFURLResponseSerialization 其实并不是一个类，它是个协议，它只有一个需要实现的方法：\n\n```objc\n@protocol AFURLResponseSerialization <NSObject, NSSecureCoding, NSCopying>\n- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response\n                           data:(nullable NSData *)data\n                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;\n@end\n```\n\n遵循这个协议的同时也需要遵循 NSObject, NSSecureCoding 和 NSCopying 这三个协议，实现安全编码、拷贝以及Objective-C 对象的基本行为。\n\n先了解下 AFURLResponseSerialization 的模型结构：\n{% asset_img Snip20170126_3.png AFURLResponseSerialization %}\n\n* AFHTTPResponseSerializer 是模型中所有Serializer的根类\n* 所有Serializer 都需要遵循 AFURLResponseSerialization 协议\n\n## AFHTTPResponseSerializer\nAFHTTPResponseSerializer 是所有响应解析的根类，因为它遵循了 AFURLResponseSerialization 协议，所以子类也要遵循。\n\n### 初始化\n\n```objc\n+ (instancetype)serializer {\n    return [[self alloc] init];\n}\n\n- (instancetype)init {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n\n    self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];\n    self.acceptableContentTypes = nil;\n\n    return self;\n}\n```\n\nacceptableStatusCodes 设置为从 200 到 299 之间的状态码, 因为只有这些状态码表示获得了有效的响应。\n\n### 验证响应\n\nAFHTTPResponseSerializer 最重要的方法 **- [AFHTTPResponseSerializer validateResponse:data:error:]**\n\n\n```objc\n- (BOOL)validateResponse:(NSHTTPURLResponse *)response\n                    data:(NSData *)data\n                   error:(NSError * __autoreleasing *)error\n{\n    BOOL responseIsValid = YES;\n    NSError *validationError = nil;\n\n    if (response && [response isKindOfClass:[NSHTTPURLResponse class]]) {\n        if (self.acceptableContentTypes && ![self.acceptableContentTypes containsObject:[response MIMEType]] &&\n            !([response MIMEType] == nil && [data length] == 0)) {\n\n            #1: 返回的数据类型无效\n        }\n\n        if (self.acceptableStatusCodes && ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] && [response URL]) {\n            #2: 返回的状态码无效\n        }\n    }\n\n    if (error && !responseIsValid) {\n        *error = validationError;\n    }\n\n    return responseIsValid;\n}\n```\n\n```objc\nif (self.acceptableContentTypes && ![self.acceptableContentTypes containsObject:[response MIMEType]] &&\n            !([response MIMEType] == nil && [data length] == 0)) {\n\n  if ([data length] > 0 && [response URL]) {\n      NSMutableDictionary *mutableUserInfo = [@{\n                                                NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@\"Request failed: unacceptable content-type: %@\", @\"AFNetworking\", nil), [response MIMEType]],\n                                                NSURLErrorFailingURLErrorKey:[response URL],\n                                                AFNetworkingOperationFailingURLResponseErrorKey: response,\n                                              } mutableCopy];\n      if (data) {\n          mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;\n      }\n\n      validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);\n  }\n\n  responseIsValid = NO;\n}\n```\n* 先判断 acceptableContentTypes 集合里面是否包含响应类型，如果不包含进入 if\n* 在 if 里面通过 AFErrorWithUnderlyingError 包装错误信息，最后设置 responseIsValid = NO\n\n第二段代码也是差不多的实现。\n\n\n### 实现协议\n其实就是调用👆的验证方法，然后返回数据\n```objc\n- (id)responseObjectForResponse:(NSURLResponse *)response\n                           data:(NSData *)data\n                          error:(NSError *__autoreleasing *)error\n{\n    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];\n\n    return data;\n}\n```\n\n### NSSecureCoding，NSCopying\n最后是实现 NSSecureCoding，NSCopying 这两个协议，没什么好说的。\n\n## AFJSONResponseSerializer\n\n现在看下 AFJSONResponseSerializer ，它继承自 AFHTTPResponseSerializer。\n\n### 初始化\n\n调用父类初始化后，增加了 acceptableContentTypes 赋值\n\n```objc\nself.acceptableContentTypes = [NSSet setWithObjects:@\"application/json\", @\"text/json\", @\"text/javascript\", nil];\n```\n\n\n### 实现协议\n\n这个子类对 AFURLResponseSerialization 协议实现比父类复杂得多\n\n```objc\n- (id)responseObjectForResponse:(NSURLResponse *)response\n                           data:(NSData *)data\n                          error:(NSError *__autoreleasing *)error\n{\n\t  // 去父类验证响应有效\n    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {\n        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {\n            return nil;\n        }\n    }\n\n    // Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.\n    // See https://github.com/rails/rails/issues/1742\n    \n    // 解决只有一个空格引起的bug\n    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:\" \" length:1]];\n    \n    if (data.length == 0 || isSpace) {\n        return nil;\n    }\n    \n    NSError *serializationError = nil;\n    \n    // 序列化JSON\n    id responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&serializationError];\n\n    if (!responseObject)\n    {\n        if (error) {\n            *error = AFErrorWithUnderlyingError(serializationError, *error);\n        }\n        return nil;\n    }\n    \n    // JSON是否移除 ‘NSNull’ 默认是 NO\n    if (self.removesKeysWithNullValues) {\n        return AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);\n    }\n\n    return responseObject;\n}\n```\n\n移除 JSON 中 null 的函数 AFJSONObjectByRemovingKeysWithNullValues 是一个递归调用的函数：\n\n```objc\nstatic id AFJSONObjectByRemovingKeysWithNullValues(id JSONObject, NSJSONReadingOptions readingOptions) {\n    if ([JSONObject isKindOfClass:[NSArray class]]) {\n        NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]];\n        for (id value in (NSArray *)JSONObject) {\n            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];\n        }\n\n        return (readingOptions & NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray];\n    } else if ([JSONObject isKindOfClass:[NSDictionary class]]) {\n        NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject];\n        for (id <NSCopying> key in [(NSDictionary *)JSONObject allKeys]) {\n            id value = (NSDictionary *)JSONObject[key];\n            if (!value || [value isEqual:[NSNull null]]) {\n                [mutableDictionary removeObjectForKey:key];\n            } else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) {\n                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);\n            }\n        }\n\n        return (readingOptions & NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary];\n    }\n\n    return JSONObject;\n}\n```\n方法中判断类型是 NSArray 还是 NSDictionary，只有 NSDictionary 中存在 ‘null’，所有移除是靠 **[mutableDictionary removeObjectForKey:key];**\n\n## AFURLRequestSerialization\n\nAFURLRequestSerialization 相对复杂些，它的主要工作是对发出的 HTTP 请求进行处理。\n这个文件中大部分类都是为 AFHTTPRequestSerializer 服务的：\n\n1. 处理请求参数\n2. 设置 HTTP 请求头\n3. 设置请求URL的属性\n4. 分块上传\n\n> 分块上传相对复杂得多，有兴趣的可以去研究下，这里不进行细讲\n\n### 处理请求参数\n\n设置查询参数主要是通过 **AFQueryStringPair** 完成，它有两个属性 field 和 value 对应HTTP 请求的查询 URL 中的参数。\n\n```objc\n@interface AFQueryStringPair : NSObject\n@property (readwrite, nonatomic, strong) id field;\n@property (readwrite, nonatomic, strong) id value;\n\n- (instancetype)initWithField:(id)field value:(id)value;\n\n- (NSString *)URLEncodedStringValue;\n@end\n```\n\n其中 **- [AFQueryStringPair URLEncodedStringValue]** 会返回 **key=value** 这种格式，同时使用 **AFPercentEscapedStringFromString** 函数来对 field 和 value 进行处理，将其中的 :#[]@!$&'()*+,;= 等字符转换为百分号表示的形式。\n\n```objc\n- (NSString *)URLEncodedStringValue {\n    if (!self.value || [self.value isEqual:[NSNull null]]) {\n        return AFPercentEscapedStringFromString([self.field description]);\n    } else {\n        return [NSString stringWithFormat:@\"%@=%@\", AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])];\n    }\n}\n```\n\n**AFQueryStringPairsFromKeyAndValue** 方法，如果 value 是集合类型，它会不断递归调用自己：\n\n```objc\nNSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) {\n    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];\n\n    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@\"description\" ascending:YES selector:@selector(compare:)];\n\n    if ([value isKindOfClass:[NSDictionary class]]) {\n        NSDictionary *dictionary = value;\n        // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries\n        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) {\n            id nestedValue = dictionary[nestedKey];\n            if (nestedValue) {\n                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@\"%@[%@]\", key, nestedKey] : nestedKey), nestedValue)];\n            }\n        }\n    } else if ([value isKindOfClass:[NSArray class]]) {\n        NSArray *array = value;\n        for (id nestedValue in array) {\n            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@\"%@[]\", key], nestedValue)];\n        }\n    } else if ([value isKindOfClass:[NSSet class]]) {\n        NSSet *set = value;\n        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) {\n            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];\n        }\n    } else {\n        // 不是集合类型，就创建 AFQueryStringPair 对象，添加到数组\n        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];\n    }\n\n    return mutableQueryStringComponents;\n}\n```\n最后会返回一个数组，数组里面是一个个 AFQueryStringPair 对象。\n\n得到数组后会调用 **AFQueryStringFromParameters** 使用 **&** 来拼接它们。\n\n```objc\nNSString * AFQueryStringFromParameters(NSDictionary *parameters) {\n    NSMutableArray *mutablePairs = [NSMutableArray array];\n    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) {\n        [mutablePairs addObject:[pair URLEncodedStringValue]];\n    }\n\n    return [mutablePairs componentsJoinedByString:@\"&\"];\n}\n```\n最终得到：\n\n```\nusername=haha&password=123456\n```\n\n### 设置 HTTP 请求头\n\nAFHTTPRequestSerializer 对外提供了 **- [AFHTTPRequestSerializer setValue:forHTTPHeaderField:]** 方法来设置请求头，内部实现是通过给一个可变字典 **mutableHTTPRequestHeaders** 赋值和取值获取：\n\n```objc\n- (void)setValue:(NSString *)value\nforHTTPHeaderField:(NSString *)field\n{\n\t[self.mutableHTTPRequestHeaders setValue:value forKey:field];\n}\n\n- (NSString *)valueForHTTPHeaderField:(NSString *)field {\n    return [self.mutableHTTPRequestHeaders valueForKey:field];\n}\n```\n\n真正用到的时候又是通过 **HTTPRequestHeaders** 这个方法获取不可变字典：\n\n```objc\n- (NSDictionary *)HTTPRequestHeaders {\n    return [NSDictionary dictionaryWithDictionary:self.mutableHTTPRequestHeaders];\n}\n\n```\n\n我们设置一般的请求头字段时，可以参考 AFHTTPRequestSerializer 初始化的设置\n\n```objc\nuserAgent = [NSString stringWithFormat:@\"%@/%@ (%@; iOS %@; Scale/%0.2f)\", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@\"CFBundleShortVersionString\"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];\n\n[self setValue:userAgent forHTTPHeaderField:@\"User-Agent\"];\n```\n\n验证用户名和密码时，调用 **- [AFHTTPRequestSerializer setAuthorizationHeaderFieldWithUsername:password:]**：\n\n```objc\n- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username\n                                       password:(NSString *)password\n{\n    NSData *basicAuthCredentials = [[NSString stringWithFormat:@\"%@:%@\", username, password] dataUsingEncoding:NSUTF8StringEncoding];\n    NSString *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];\n    [self setValue:[NSString stringWithFormat:@\"Basic %@\", base64AuthCredentials] forHTTPHeaderField:@\"Authorization\"];\n}\n```\n\n### 设置请求URL的属性\n\n设置完请求头和请求参数，还有一些关于请求的设置：\n\n```objc\n/**\n 字符串编码，默认 `NSUTF8StringEncoding`.\n */\n@property (nonatomic, assign) NSStringEncoding stringEncoding;\n\n/**\n 请求能够使用蜂窝无线电，默认 YES.\n */\n@property (nonatomic, assign) BOOL allowsCellularAccess;\n\n/**\n 缓存策略，默认 `NSURLRequestUseProtocolCachePolicy`.\n */\n@property (nonatomic, assign) NSURLRequestCachePolicy cachePolicy;\n\n/**\n 请求是否使用默认的cookie处理，默认 `YES`.\n */\n@property (nonatomic, assign) BOOL HTTPShouldHandleCookies;\n\n/**\n 请求是否使用 管道， 默认 `NO` .\n */\n@property (nonatomic, assign) BOOL HTTPShouldUsePipelining;\n\n/**\n 网络请求的服务类型，默认 `NSURLNetworkServiceTypeDefault`.\n */\n@property (nonatomic, assign) NSURLRequestNetworkServiceType networkServiceType;\n\n/**\n 请求超时时间，默认是 60s.\n */\n@property (nonatomic, assign) NSTimeInterval timeoutInterval;\n```\n\n这些值会通过调用 **AFHTTPRequestSerializerObservedKeyPaths** 返回一个数组：\n```objc\nstatic NSArray * AFHTTPRequestSerializerObservedKeyPaths() {\n    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];\n    });\n\n    return _AFHTTPRequestSerializerObservedKeyPaths;\n}\n```\n\nAFURLRequestSerialization 是通过 KVO监听这些值的变化，当这些值被设置时，会触发KVO，然后把新的属性存储在 **mutableObservedChangedKeyPaths** 字典中：\n\n```objc\n+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key {\n    // 手动控制通知方式\n    if ([AFHTTPRequestSerializerObservedKeyPaths() containsObject:key]) {\n        return NO;\n    }\n    // 默认自动通知\n    return [super automaticallyNotifiesObserversForKey:key];\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(__unused id)object\n                        change:(NSDictionary *)change\n                       context:(void *)context\n{\n    if (context == AFHTTPRequestSerializerObserverContext) {\n        if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) {\n            [self.mutableObservedChangedKeyPaths removeObject:keyPath];\n        } else {\n            [self.mutableObservedChangedKeyPaths addObject:keyPath];\n        }\n    }\n}\n```\n\n最后在生成 NSURLRequest 请求时设置：\n\n```objc\nNSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];\nmutableRequest.HTTPMethod = method;\n\nfor (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {\n   if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {\n       [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];\n   }\n}\n```\n\n\n### 初始化\n\n```objc\n- (instancetype)init {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n\n    self.stringEncoding = NSUTF8StringEncoding;\n\n    self.mutableHTTPRequestHeaders = [NSMutableDictionary dictionary];\n\n    #1: 设置 Accept-Language，User-Agent等。忽略\n\n    // HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\n    self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@\"GET\", @\"HEAD\", @\"DELETE\", nil];\n\n    self.mutableObservedChangedKeyPaths = [NSMutableSet set];\n    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {\n        if ([self respondsToSelector:NSSelectorFromString(keyPath)]) {\n            [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];\n        }\n    }\n\n    return self;\n}\n```\n上面提到到 KVO 监听属性变化，就是在初始化的时候做的，确保它们在改变后更新 NSMutableURLRequest 中对应的属性。\n\n初始化完成后，如果调用普通的请求方法，就会进入这个方法：\n\n```objc\n- (NSMutableURLRequest *)requestWithMethod:(NSString *)method\n                                 URLString:(NSString *)URLString\n                                parameters:(id)parameters\n                                     error:(NSError *__autoreleasing *)error\n{\n    // 检测参数\n    NSParameterAssert(method);\n    NSParameterAssert(URLString);\n\n    // 生成url\n    NSURL *url = [NSURL URLWithString:URLString];\n\n    NSParameterAssert(url);\n\n    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];\n    // 设置请求方式\n    mutableRequest.HTTPMethod = method;\n    // 设置kVO监听的请求属性\n    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {\n        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {\n            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];\n        }\n    }\n    // 设置 HTTP 请求头和请求参数\n    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];\n\n\treturn mutableRequest;\n}\n```\n\n调用 **- [AFHTTPRequestSerializer requestBySerializingRequest:withParameters:error:]** 方法，设置 HTTP 请求头和请求参数：\n```objc\n- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request\n                               withParameters:(id)parameters\n                                        error:(NSError *__autoreleasing *)error\n{\n    NSParameterAssert(request);\n\n    NSMutableURLRequest *mutableRequest = [request mutableCopy];\n\n    // 设置请求头\n    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) {\n        if (![request valueForHTTPHeaderField:field]) {\n            [mutableRequest setValue:value forHTTPHeaderField:field];\n        }\n    }];\n\n    NSString *query = nil;\n    if (parameters) {\n        if (self.queryStringSerialization) {\n            NSError *serializationError;\n            query = self.queryStringSerialization(request, parameters, &serializationError);\n\n            if (serializationError) {\n                if (error) {\n                    *error = serializationError;\n                }\n\n                return nil;\n            }\n        } else {\n            switch (self.queryStringSerializationStyle) {\n                case AFHTTPRequestQueryStringDefaultStyle:\n                    // 把请求参数转换为 &拼接的字符串\n                    query = AFQueryStringFromParameters(parameters);\n                    break;\n            }\n        }\n    }\n    \n    // 如果是 `GET`，`HEAD` 和 `DELETE`的请求，请求参数拼接到URL后面\n    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) {\n        if (query && query.length > 0) {\n            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @\"&%@\" : @\"?%@\", query]];\n        }\n    } else {\n        // #2864: an empty string is a valid x-www-form-urlencoded payload\n        if (!query) {\n            query = @\"\";\n        }\n        if (![mutableRequest valueForHTTPHeaderField:@\"Content-Type\"]) {\n            [mutableRequest setValue:@\"application/x-www-form-urlencoded\" forHTTPHeaderField:@\"Content-Type\"];\n        }\n        // 请求参数放入请求体\n        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];\n    }\n\n    return mutableRequest;\n}\n```\n\n\n## 总结\n1. AFURLResponseSerialization 负责对返回的数据进行序列化\n2. AFURLRequestSerialization 负责生成 NSMutableURLRequest，为请求设置 HTTP 请求头和请求参数，管理发出的请求\n\n## 参考链接\n* [AFNetworking](https://github.com/AFNetworking/AFNetworking)\n* [AFNetworking源码阅读（六）](http://www.cnblogs.com/polobymulberry/p/5174298.html)\n* [处理请求和响应 AFURLSerialization（三）](https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%20AFURLSerialization%EF%BC%88%E4%B8%89%EF%BC%89.md#afurlresponseserialization)\n\n","source":"_posts/AFNetworking-AFURLSerialization-4.md","raw":"---\ntitle: AFURLSerialization 解析（四）\ndate: 2017-01-08 17:55:59\ntags: AFNetworking\ncategory: Source Code Analyze\n---\n\n## 前言\n前面的文字已经分析了 **AFURLSessionManager** 和 **AFNetworkReachabilityManager**，一个是 AFN 的核心，另一个是 AFN 非常有用的工具类。\n\n这里我们接着了解 AFURLSessionManager 中使用到的**对发出请求和接收响应时**进行序列化的两个模块：\n* AFURLResponseSerialization\n* AFURLRequestSerialization\n\n前者是处理响应的模块，将请求返回的数据解析成对用的格式。后者主要是修改请求的头部（主要是 HTTP 请求）。\n\nAFURLResponseSerialization 主要使用在 AFURLSessionManager 中，而 AFURLRequestSerialization 主要用于 AFHTTPSessionManager 中，因为它主要用于**修改 HTTP 头部**。\n\n## AFURLResponseSerialization\n\nAFURLResponseSerialization 其实并不是一个类，它是个协议，它只有一个需要实现的方法：\n\n```objc\n@protocol AFURLResponseSerialization <NSObject, NSSecureCoding, NSCopying>\n- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response\n                           data:(nullable NSData *)data\n                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;\n@end\n```\n\n遵循这个协议的同时也需要遵循 NSObject, NSSecureCoding 和 NSCopying 这三个协议，实现安全编码、拷贝以及Objective-C 对象的基本行为。\n\n先了解下 AFURLResponseSerialization 的模型结构：\n{% asset_img Snip20170126_3.png AFURLResponseSerialization %}\n\n* AFHTTPResponseSerializer 是模型中所有Serializer的根类\n* 所有Serializer 都需要遵循 AFURLResponseSerialization 协议\n\n## AFHTTPResponseSerializer\nAFHTTPResponseSerializer 是所有响应解析的根类，因为它遵循了 AFURLResponseSerialization 协议，所以子类也要遵循。\n\n### 初始化\n\n```objc\n+ (instancetype)serializer {\n    return [[self alloc] init];\n}\n\n- (instancetype)init {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n\n    self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];\n    self.acceptableContentTypes = nil;\n\n    return self;\n}\n```\n\nacceptableStatusCodes 设置为从 200 到 299 之间的状态码, 因为只有这些状态码表示获得了有效的响应。\n\n### 验证响应\n\nAFHTTPResponseSerializer 最重要的方法 **- [AFHTTPResponseSerializer validateResponse:data:error:]**\n\n\n```objc\n- (BOOL)validateResponse:(NSHTTPURLResponse *)response\n                    data:(NSData *)data\n                   error:(NSError * __autoreleasing *)error\n{\n    BOOL responseIsValid = YES;\n    NSError *validationError = nil;\n\n    if (response && [response isKindOfClass:[NSHTTPURLResponse class]]) {\n        if (self.acceptableContentTypes && ![self.acceptableContentTypes containsObject:[response MIMEType]] &&\n            !([response MIMEType] == nil && [data length] == 0)) {\n\n            #1: 返回的数据类型无效\n        }\n\n        if (self.acceptableStatusCodes && ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] && [response URL]) {\n            #2: 返回的状态码无效\n        }\n    }\n\n    if (error && !responseIsValid) {\n        *error = validationError;\n    }\n\n    return responseIsValid;\n}\n```\n\n```objc\nif (self.acceptableContentTypes && ![self.acceptableContentTypes containsObject:[response MIMEType]] &&\n            !([response MIMEType] == nil && [data length] == 0)) {\n\n  if ([data length] > 0 && [response URL]) {\n      NSMutableDictionary *mutableUserInfo = [@{\n                                                NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@\"Request failed: unacceptable content-type: %@\", @\"AFNetworking\", nil), [response MIMEType]],\n                                                NSURLErrorFailingURLErrorKey:[response URL],\n                                                AFNetworkingOperationFailingURLResponseErrorKey: response,\n                                              } mutableCopy];\n      if (data) {\n          mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;\n      }\n\n      validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);\n  }\n\n  responseIsValid = NO;\n}\n```\n* 先判断 acceptableContentTypes 集合里面是否包含响应类型，如果不包含进入 if\n* 在 if 里面通过 AFErrorWithUnderlyingError 包装错误信息，最后设置 responseIsValid = NO\n\n第二段代码也是差不多的实现。\n\n\n### 实现协议\n其实就是调用👆的验证方法，然后返回数据\n```objc\n- (id)responseObjectForResponse:(NSURLResponse *)response\n                           data:(NSData *)data\n                          error:(NSError *__autoreleasing *)error\n{\n    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];\n\n    return data;\n}\n```\n\n### NSSecureCoding，NSCopying\n最后是实现 NSSecureCoding，NSCopying 这两个协议，没什么好说的。\n\n## AFJSONResponseSerializer\n\n现在看下 AFJSONResponseSerializer ，它继承自 AFHTTPResponseSerializer。\n\n### 初始化\n\n调用父类初始化后，增加了 acceptableContentTypes 赋值\n\n```objc\nself.acceptableContentTypes = [NSSet setWithObjects:@\"application/json\", @\"text/json\", @\"text/javascript\", nil];\n```\n\n\n### 实现协议\n\n这个子类对 AFURLResponseSerialization 协议实现比父类复杂得多\n\n```objc\n- (id)responseObjectForResponse:(NSURLResponse *)response\n                           data:(NSData *)data\n                          error:(NSError *__autoreleasing *)error\n{\n\t  // 去父类验证响应有效\n    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {\n        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {\n            return nil;\n        }\n    }\n\n    // Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.\n    // See https://github.com/rails/rails/issues/1742\n    \n    // 解决只有一个空格引起的bug\n    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:\" \" length:1]];\n    \n    if (data.length == 0 || isSpace) {\n        return nil;\n    }\n    \n    NSError *serializationError = nil;\n    \n    // 序列化JSON\n    id responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&serializationError];\n\n    if (!responseObject)\n    {\n        if (error) {\n            *error = AFErrorWithUnderlyingError(serializationError, *error);\n        }\n        return nil;\n    }\n    \n    // JSON是否移除 ‘NSNull’ 默认是 NO\n    if (self.removesKeysWithNullValues) {\n        return AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);\n    }\n\n    return responseObject;\n}\n```\n\n移除 JSON 中 null 的函数 AFJSONObjectByRemovingKeysWithNullValues 是一个递归调用的函数：\n\n```objc\nstatic id AFJSONObjectByRemovingKeysWithNullValues(id JSONObject, NSJSONReadingOptions readingOptions) {\n    if ([JSONObject isKindOfClass:[NSArray class]]) {\n        NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]];\n        for (id value in (NSArray *)JSONObject) {\n            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];\n        }\n\n        return (readingOptions & NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray];\n    } else if ([JSONObject isKindOfClass:[NSDictionary class]]) {\n        NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject];\n        for (id <NSCopying> key in [(NSDictionary *)JSONObject allKeys]) {\n            id value = (NSDictionary *)JSONObject[key];\n            if (!value || [value isEqual:[NSNull null]]) {\n                [mutableDictionary removeObjectForKey:key];\n            } else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) {\n                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);\n            }\n        }\n\n        return (readingOptions & NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary];\n    }\n\n    return JSONObject;\n}\n```\n方法中判断类型是 NSArray 还是 NSDictionary，只有 NSDictionary 中存在 ‘null’，所有移除是靠 **[mutableDictionary removeObjectForKey:key];**\n\n## AFURLRequestSerialization\n\nAFURLRequestSerialization 相对复杂些，它的主要工作是对发出的 HTTP 请求进行处理。\n这个文件中大部分类都是为 AFHTTPRequestSerializer 服务的：\n\n1. 处理请求参数\n2. 设置 HTTP 请求头\n3. 设置请求URL的属性\n4. 分块上传\n\n> 分块上传相对复杂得多，有兴趣的可以去研究下，这里不进行细讲\n\n### 处理请求参数\n\n设置查询参数主要是通过 **AFQueryStringPair** 完成，它有两个属性 field 和 value 对应HTTP 请求的查询 URL 中的参数。\n\n```objc\n@interface AFQueryStringPair : NSObject\n@property (readwrite, nonatomic, strong) id field;\n@property (readwrite, nonatomic, strong) id value;\n\n- (instancetype)initWithField:(id)field value:(id)value;\n\n- (NSString *)URLEncodedStringValue;\n@end\n```\n\n其中 **- [AFQueryStringPair URLEncodedStringValue]** 会返回 **key=value** 这种格式，同时使用 **AFPercentEscapedStringFromString** 函数来对 field 和 value 进行处理，将其中的 :#[]@!$&'()*+,;= 等字符转换为百分号表示的形式。\n\n```objc\n- (NSString *)URLEncodedStringValue {\n    if (!self.value || [self.value isEqual:[NSNull null]]) {\n        return AFPercentEscapedStringFromString([self.field description]);\n    } else {\n        return [NSString stringWithFormat:@\"%@=%@\", AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])];\n    }\n}\n```\n\n**AFQueryStringPairsFromKeyAndValue** 方法，如果 value 是集合类型，它会不断递归调用自己：\n\n```objc\nNSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) {\n    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];\n\n    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@\"description\" ascending:YES selector:@selector(compare:)];\n\n    if ([value isKindOfClass:[NSDictionary class]]) {\n        NSDictionary *dictionary = value;\n        // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries\n        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) {\n            id nestedValue = dictionary[nestedKey];\n            if (nestedValue) {\n                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@\"%@[%@]\", key, nestedKey] : nestedKey), nestedValue)];\n            }\n        }\n    } else if ([value isKindOfClass:[NSArray class]]) {\n        NSArray *array = value;\n        for (id nestedValue in array) {\n            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@\"%@[]\", key], nestedValue)];\n        }\n    } else if ([value isKindOfClass:[NSSet class]]) {\n        NSSet *set = value;\n        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) {\n            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];\n        }\n    } else {\n        // 不是集合类型，就创建 AFQueryStringPair 对象，添加到数组\n        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];\n    }\n\n    return mutableQueryStringComponents;\n}\n```\n最后会返回一个数组，数组里面是一个个 AFQueryStringPair 对象。\n\n得到数组后会调用 **AFQueryStringFromParameters** 使用 **&** 来拼接它们。\n\n```objc\nNSString * AFQueryStringFromParameters(NSDictionary *parameters) {\n    NSMutableArray *mutablePairs = [NSMutableArray array];\n    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) {\n        [mutablePairs addObject:[pair URLEncodedStringValue]];\n    }\n\n    return [mutablePairs componentsJoinedByString:@\"&\"];\n}\n```\n最终得到：\n\n```\nusername=haha&password=123456\n```\n\n### 设置 HTTP 请求头\n\nAFHTTPRequestSerializer 对外提供了 **- [AFHTTPRequestSerializer setValue:forHTTPHeaderField:]** 方法来设置请求头，内部实现是通过给一个可变字典 **mutableHTTPRequestHeaders** 赋值和取值获取：\n\n```objc\n- (void)setValue:(NSString *)value\nforHTTPHeaderField:(NSString *)field\n{\n\t[self.mutableHTTPRequestHeaders setValue:value forKey:field];\n}\n\n- (NSString *)valueForHTTPHeaderField:(NSString *)field {\n    return [self.mutableHTTPRequestHeaders valueForKey:field];\n}\n```\n\n真正用到的时候又是通过 **HTTPRequestHeaders** 这个方法获取不可变字典：\n\n```objc\n- (NSDictionary *)HTTPRequestHeaders {\n    return [NSDictionary dictionaryWithDictionary:self.mutableHTTPRequestHeaders];\n}\n\n```\n\n我们设置一般的请求头字段时，可以参考 AFHTTPRequestSerializer 初始化的设置\n\n```objc\nuserAgent = [NSString stringWithFormat:@\"%@/%@ (%@; iOS %@; Scale/%0.2f)\", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@\"CFBundleShortVersionString\"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];\n\n[self setValue:userAgent forHTTPHeaderField:@\"User-Agent\"];\n```\n\n验证用户名和密码时，调用 **- [AFHTTPRequestSerializer setAuthorizationHeaderFieldWithUsername:password:]**：\n\n```objc\n- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username\n                                       password:(NSString *)password\n{\n    NSData *basicAuthCredentials = [[NSString stringWithFormat:@\"%@:%@\", username, password] dataUsingEncoding:NSUTF8StringEncoding];\n    NSString *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];\n    [self setValue:[NSString stringWithFormat:@\"Basic %@\", base64AuthCredentials] forHTTPHeaderField:@\"Authorization\"];\n}\n```\n\n### 设置请求URL的属性\n\n设置完请求头和请求参数，还有一些关于请求的设置：\n\n```objc\n/**\n 字符串编码，默认 `NSUTF8StringEncoding`.\n */\n@property (nonatomic, assign) NSStringEncoding stringEncoding;\n\n/**\n 请求能够使用蜂窝无线电，默认 YES.\n */\n@property (nonatomic, assign) BOOL allowsCellularAccess;\n\n/**\n 缓存策略，默认 `NSURLRequestUseProtocolCachePolicy`.\n */\n@property (nonatomic, assign) NSURLRequestCachePolicy cachePolicy;\n\n/**\n 请求是否使用默认的cookie处理，默认 `YES`.\n */\n@property (nonatomic, assign) BOOL HTTPShouldHandleCookies;\n\n/**\n 请求是否使用 管道， 默认 `NO` .\n */\n@property (nonatomic, assign) BOOL HTTPShouldUsePipelining;\n\n/**\n 网络请求的服务类型，默认 `NSURLNetworkServiceTypeDefault`.\n */\n@property (nonatomic, assign) NSURLRequestNetworkServiceType networkServiceType;\n\n/**\n 请求超时时间，默认是 60s.\n */\n@property (nonatomic, assign) NSTimeInterval timeoutInterval;\n```\n\n这些值会通过调用 **AFHTTPRequestSerializerObservedKeyPaths** 返回一个数组：\n```objc\nstatic NSArray * AFHTTPRequestSerializerObservedKeyPaths() {\n    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];\n    });\n\n    return _AFHTTPRequestSerializerObservedKeyPaths;\n}\n```\n\nAFURLRequestSerialization 是通过 KVO监听这些值的变化，当这些值被设置时，会触发KVO，然后把新的属性存储在 **mutableObservedChangedKeyPaths** 字典中：\n\n```objc\n+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key {\n    // 手动控制通知方式\n    if ([AFHTTPRequestSerializerObservedKeyPaths() containsObject:key]) {\n        return NO;\n    }\n    // 默认自动通知\n    return [super automaticallyNotifiesObserversForKey:key];\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(__unused id)object\n                        change:(NSDictionary *)change\n                       context:(void *)context\n{\n    if (context == AFHTTPRequestSerializerObserverContext) {\n        if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) {\n            [self.mutableObservedChangedKeyPaths removeObject:keyPath];\n        } else {\n            [self.mutableObservedChangedKeyPaths addObject:keyPath];\n        }\n    }\n}\n```\n\n最后在生成 NSURLRequest 请求时设置：\n\n```objc\nNSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];\nmutableRequest.HTTPMethod = method;\n\nfor (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {\n   if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {\n       [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];\n   }\n}\n```\n\n\n### 初始化\n\n```objc\n- (instancetype)init {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n\n    self.stringEncoding = NSUTF8StringEncoding;\n\n    self.mutableHTTPRequestHeaders = [NSMutableDictionary dictionary];\n\n    #1: 设置 Accept-Language，User-Agent等。忽略\n\n    // HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\n    self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@\"GET\", @\"HEAD\", @\"DELETE\", nil];\n\n    self.mutableObservedChangedKeyPaths = [NSMutableSet set];\n    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {\n        if ([self respondsToSelector:NSSelectorFromString(keyPath)]) {\n            [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];\n        }\n    }\n\n    return self;\n}\n```\n上面提到到 KVO 监听属性变化，就是在初始化的时候做的，确保它们在改变后更新 NSMutableURLRequest 中对应的属性。\n\n初始化完成后，如果调用普通的请求方法，就会进入这个方法：\n\n```objc\n- (NSMutableURLRequest *)requestWithMethod:(NSString *)method\n                                 URLString:(NSString *)URLString\n                                parameters:(id)parameters\n                                     error:(NSError *__autoreleasing *)error\n{\n    // 检测参数\n    NSParameterAssert(method);\n    NSParameterAssert(URLString);\n\n    // 生成url\n    NSURL *url = [NSURL URLWithString:URLString];\n\n    NSParameterAssert(url);\n\n    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];\n    // 设置请求方式\n    mutableRequest.HTTPMethod = method;\n    // 设置kVO监听的请求属性\n    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {\n        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {\n            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];\n        }\n    }\n    // 设置 HTTP 请求头和请求参数\n    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];\n\n\treturn mutableRequest;\n}\n```\n\n调用 **- [AFHTTPRequestSerializer requestBySerializingRequest:withParameters:error:]** 方法，设置 HTTP 请求头和请求参数：\n```objc\n- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request\n                               withParameters:(id)parameters\n                                        error:(NSError *__autoreleasing *)error\n{\n    NSParameterAssert(request);\n\n    NSMutableURLRequest *mutableRequest = [request mutableCopy];\n\n    // 设置请求头\n    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) {\n        if (![request valueForHTTPHeaderField:field]) {\n            [mutableRequest setValue:value forHTTPHeaderField:field];\n        }\n    }];\n\n    NSString *query = nil;\n    if (parameters) {\n        if (self.queryStringSerialization) {\n            NSError *serializationError;\n            query = self.queryStringSerialization(request, parameters, &serializationError);\n\n            if (serializationError) {\n                if (error) {\n                    *error = serializationError;\n                }\n\n                return nil;\n            }\n        } else {\n            switch (self.queryStringSerializationStyle) {\n                case AFHTTPRequestQueryStringDefaultStyle:\n                    // 把请求参数转换为 &拼接的字符串\n                    query = AFQueryStringFromParameters(parameters);\n                    break;\n            }\n        }\n    }\n    \n    // 如果是 `GET`，`HEAD` 和 `DELETE`的请求，请求参数拼接到URL后面\n    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) {\n        if (query && query.length > 0) {\n            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @\"&%@\" : @\"?%@\", query]];\n        }\n    } else {\n        // #2864: an empty string is a valid x-www-form-urlencoded payload\n        if (!query) {\n            query = @\"\";\n        }\n        if (![mutableRequest valueForHTTPHeaderField:@\"Content-Type\"]) {\n            [mutableRequest setValue:@\"application/x-www-form-urlencoded\" forHTTPHeaderField:@\"Content-Type\"];\n        }\n        // 请求参数放入请求体\n        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];\n    }\n\n    return mutableRequest;\n}\n```\n\n\n## 总结\n1. AFURLResponseSerialization 负责对返回的数据进行序列化\n2. AFURLRequestSerialization 负责生成 NSMutableURLRequest，为请求设置 HTTP 请求头和请求参数，管理发出的请求\n\n## 参考链接\n* [AFNetworking](https://github.com/AFNetworking/AFNetworking)\n* [AFNetworking源码阅读（六）](http://www.cnblogs.com/polobymulberry/p/5174298.html)\n* [处理请求和响应 AFURLSerialization（三）](https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%20AFURLSerialization%EF%BC%88%E4%B8%89%EF%BC%89.md#afurlresponseserialization)\n\n","slug":"AFNetworking-AFURLSerialization-4","published":1,"updated":"2017-01-26T13:39:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7pt005b8jpbzvsph2xx","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面的文字已经分析了 <strong>AFURLSessionManager</strong> 和 <strong>AFNetworkReachabilityManager</strong>，一个是 AFN 的核心，另一个是 AFN 非常有用的工具类。</p>\n<p>这里我们接着了解 AFURLSessionManager 中使用到的<strong>对发出请求和接收响应时</strong>进行序列化的两个模块：</p>\n<ul>\n<li>AFURLResponseSerialization</li>\n<li>AFURLRequestSerialization</li>\n</ul>\n<p>前者是处理响应的模块，将请求返回的数据解析成对用的格式。后者主要是修改请求的头部（主要是 HTTP 请求）。</p>\n<p>AFURLResponseSerialization 主要使用在 AFURLSessionManager 中，而 AFURLRequestSerialization 主要用于 AFHTTPSessionManager 中，因为它主要用于<strong>修改 HTTP 头部</strong>。</p>\n<h2 id=\"AFURLResponseSerialization\"><a href=\"#AFURLResponseSerialization\" class=\"headerlink\" title=\"AFURLResponseSerialization\"></a>AFURLResponseSerialization</h2><p>AFURLResponseSerialization 其实并不是一个类，它是个协议，它只有一个需要实现的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">AFURLResponseSerialization</span> &lt;<span class=\"title\">NSObject</span>, <span class=\"title\">NSSecureCoding</span>, <span class=\"title\">NSCopying</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)responseObjectForResponse:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSURLResponse</span> *)response</span><br><span class=\"line\">                           data:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                          error:(<span class=\"built_in\">NSError</span> * _Nullable __autoreleasing *)error <span class=\"built_in\">NS_SWIFT_NOTHROW</span>;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>遵循这个协议的同时也需要遵循 NSObject, NSSecureCoding 和 NSCopying 这三个协议，实现安全编码、拷贝以及Objective-C 对象的基本行为。</p>\n<p>先了解下 AFURLResponseSerialization 的模型结构：<br><img src=\"/2017/01/08/AFNetworking-AFURLSerialization-4/Snip20170126_3.png\" title=\"AFURLResponseSerialization\"></p>\n<ul>\n<li>AFHTTPResponseSerializer 是模型中所有Serializer的根类</li>\n<li>所有Serializer 都需要遵循 AFURLResponseSerialization 协议</li>\n</ul>\n<h2 id=\"AFHTTPResponseSerializer\"><a href=\"#AFHTTPResponseSerializer\" class=\"headerlink\" title=\"AFHTTPResponseSerializer\"></a>AFHTTPResponseSerializer</h2><p>AFHTTPResponseSerializer 是所有响应解析的根类，因为它遵循了 AFURLResponseSerialization 协议，所以子类也要遵循。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)serializer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.acceptableStatusCodes = [<span class=\"built_in\">NSIndexSet</span> indexSetWithIndexesInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">200</span>, <span class=\"number\">100</span>)];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.acceptableContentTypes = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>acceptableStatusCodes 设置为从 200 到 299 之间的状态码, 因为只有这些状态码表示获得了有效的响应。</p>\n<h3 id=\"验证响应\"><a href=\"#验证响应\" class=\"headerlink\" title=\"验证响应\"></a>验证响应</h3><p>AFHTTPResponseSerializer 最重要的方法 <strong>- [AFHTTPResponseSerializer validateResponse:data:error:]</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)validateResponse:(<span class=\"built_in\">NSHTTPURLResponse</span> *)response</span><br><span class=\"line\">                    data:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                   error:(<span class=\"built_in\">NSError</span> * __autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> responseIsValid = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *validationError = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response &amp;&amp; [response isKindOfClass:[<span class=\"built_in\">NSHTTPURLResponse</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.acceptableContentTypes &amp;&amp; ![<span class=\"keyword\">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class=\"line\">            !([response MIMEType] == <span class=\"literal\">nil</span> &amp;&amp; [data length] == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">#1: 返回的数据类型无效</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.acceptableStatusCodes &amp;&amp; ![<span class=\"keyword\">self</span>.acceptableStatusCodes containsIndex:(<span class=\"built_in\">NSUInteger</span>)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class=\"line\">            <span class=\"meta\">#2: 返回的状态码无效</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class=\"line\">        *error = validationError;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> responseIsValid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.acceptableContentTypes &amp;&amp; ![<span class=\"keyword\">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class=\"line\">            !([response MIMEType] == <span class=\"literal\">nil</span> &amp;&amp; [data length] == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ([data length] &gt; <span class=\"number\">0</span> &amp;&amp; [response URL]) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class=\"line\">                                                <span class=\"built_in\">NSLocalizedDescriptionKey</span>: [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"built_in\">NSLocalizedStringFromTable</span>(<span class=\"string\">@\"Request failed: unacceptable content-type: %@\"</span>, <span class=\"string\">@\"AFNetworking\"</span>, <span class=\"literal\">nil</span>), [response MIMEType]],</span><br><span class=\"line\">                                                <span class=\"built_in\">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class=\"line\">                                                AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class=\"line\">                                              &#125; mutableCopy];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">          mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      validationError = AFErrorWithUnderlyingError([<span class=\"built_in\">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class=\"built_in\">NSURLErrorCannotDecodeContentData</span> userInfo:mutableUserInfo], validationError);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  responseIsValid = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>先判断 acceptableContentTypes 集合里面是否包含响应类型，如果不包含进入 if</li>\n<li>在 if 里面通过 AFErrorWithUnderlyingError 包装错误信息，最后设置 responseIsValid = NO</li>\n</ul>\n<p>第二段代码也是差不多的实现。</p>\n<h3 id=\"实现协议\"><a href=\"#实现协议\" class=\"headerlink\" title=\"实现协议\"></a>实现协议</h3><p>其实就是调用👆的验证方法，然后返回数据<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)responseObjectForResponse:(<span class=\"built_in\">NSURLResponse</span> *)response</span><br><span class=\"line\">                           data:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                          error:(<span class=\"built_in\">NSError</span> *__autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> validateResponse:(<span class=\"built_in\">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"NSSecureCoding，NSCopying\"><a href=\"#NSSecureCoding，NSCopying\" class=\"headerlink\" title=\"NSSecureCoding，NSCopying\"></a>NSSecureCoding，NSCopying</h3><p>最后是实现 NSSecureCoding，NSCopying 这两个协议，没什么好说的。</p>\n<h2 id=\"AFJSONResponseSerializer\"><a href=\"#AFJSONResponseSerializer\" class=\"headerlink\" title=\"AFJSONResponseSerializer\"></a>AFJSONResponseSerializer</h2><p>现在看下 AFJSONResponseSerializer ，它继承自 AFHTTPResponseSerializer。</p>\n<h3 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>调用父类初始化后，增加了 acceptableContentTypes 赋值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@\"application/json\"</span>, <span class=\"string\">@\"text/json\"</span>, <span class=\"string\">@\"text/javascript\"</span>, <span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现协议-1\"><a href=\"#实现协议-1\" class=\"headerlink\" title=\"实现协议\"></a>实现协议</h3><p>这个子类对 AFURLResponseSerialization 协议实现比父类复杂得多</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)responseObjectForResponse:(<span class=\"built_in\">NSURLResponse</span> *)response</span><br><span class=\"line\">                           data:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                          error:(<span class=\"built_in\">NSError</span> *__autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t  <span class=\"comment\">// 去父类验证响应有效</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> validateResponse:(<span class=\"built_in\">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class=\"built_in\">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span></span><br><span class=\"line\">    <span class=\"comment\">// See https://github.com/rails/rails/issues/1742</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 解决只有一个空格引起的bug</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> isSpace = [data isEqualToData:[<span class=\"built_in\">NSData</span> dataWithBytes:<span class=\"string\">\" \"</span> length:<span class=\"number\">1</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.length == <span class=\"number\">0</span> || isSpace) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *serializationError = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 序列化JSON</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> responseObject = [<span class=\"built_in\">NSJSONSerialization</span> JSONObjectWithData:data options:<span class=\"keyword\">self</span>.readingOptions error:&amp;serializationError];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!responseObject)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">            *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// JSON是否移除 ‘NSNull’ 默认是 NO</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.removesKeysWithNullValues) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class=\"keyword\">self</span>.readingOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> responseObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>移除 JSON 中 null 的函数 AFJSONObjectByRemovingKeysWithNullValues 是一个递归调用的函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">id</span> AFJSONObjectByRemovingKeysWithNullValues(<span class=\"keyword\">id</span> JSONObject, <span class=\"built_in\">NSJSONReadingOptions</span> readingOptions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([JSONObject isKindOfClass:[<span class=\"built_in\">NSArray</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *mutableArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithCapacity:[(<span class=\"built_in\">NSArray</span> *)JSONObject count]];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> value <span class=\"keyword\">in</span> (<span class=\"built_in\">NSArray</span> *)JSONObject) &#123;</span><br><span class=\"line\">            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (readingOptions &amp; <span class=\"built_in\">NSJSONReadingMutableContainers</span>) ? mutableArray : [<span class=\"built_in\">NSArray</span> arrayWithArray:mutableArray];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([JSONObject isKindOfClass:[<span class=\"built_in\">NSDictionary</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableDictionary</span> *mutableDictionary = [<span class=\"built_in\">NSMutableDictionary</span> dictionaryWithDictionary:JSONObject];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSCopying</span>&gt; key <span class=\"keyword\">in</span> [(<span class=\"built_in\">NSDictionary</span> *)JSONObject allKeys]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">id</span> value = (<span class=\"built_in\">NSDictionary</span> *)JSONObject[key];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!value || [value isEqual:[<span class=\"built_in\">NSNull</span> null]]) &#123;</span><br><span class=\"line\">                [mutableDictionary removeObjectForKey:key];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSArray</span> <span class=\"keyword\">class</span>]] || [value isKindOfClass:[<span class=\"built_in\">NSDictionary</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (readingOptions &amp; <span class=\"built_in\">NSJSONReadingMutableContainers</span>) ? mutableDictionary : [<span class=\"built_in\">NSDictionary</span> dictionaryWithDictionary:mutableDictionary];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> JSONObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法中判断类型是 NSArray 还是 NSDictionary，只有 NSDictionary 中存在 ‘null’，所有移除是靠 <strong>[mutableDictionary removeObjectForKey:key];</strong></p>\n<h2 id=\"AFURLRequestSerialization\"><a href=\"#AFURLRequestSerialization\" class=\"headerlink\" title=\"AFURLRequestSerialization\"></a>AFURLRequestSerialization</h2><p>AFURLRequestSerialization 相对复杂些，它的主要工作是对发出的 HTTP 请求进行处理。<br>这个文件中大部分类都是为 AFHTTPRequestSerializer 服务的：</p>\n<ol>\n<li>处理请求参数</li>\n<li>设置 HTTP 请求头</li>\n<li>设置请求URL的属性</li>\n<li>分块上传</li>\n</ol>\n<blockquote>\n<p>分块上传相对复杂得多，有兴趣的可以去研究下，这里不进行细讲</p>\n</blockquote>\n<h3 id=\"处理请求参数\"><a href=\"#处理请求参数\" class=\"headerlink\" title=\"处理请求参数\"></a>处理请求参数</h3><p>设置查询参数主要是通过 <strong>AFQueryStringPair</strong> 完成，它有两个属性 field 和 value 对应HTTP 请求的查询 URL 中的参数。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">AFQueryStringPair</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"keyword\">id</span> field;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"keyword\">id</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithField:(<span class=\"keyword\">id</span>)field value:(<span class=\"keyword\">id</span>)value;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)URLEncodedStringValue;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>其中 <strong>- [AFQueryStringPair URLEncodedStringValue]</strong> 会返回 <strong>key=value</strong> 这种格式，同时使用 <strong>AFPercentEscapedStringFromString</strong> 函数来对 field 和 value 进行处理，将其中的 :#[]@!$&amp;’()*+,;= 等字符转换为百分号表示的形式。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)URLEncodedStringValue &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.value || [<span class=\"keyword\">self</span>.value isEqual:[<span class=\"built_in\">NSNull</span> null]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> AFPercentEscapedStringFromString([<span class=\"keyword\">self</span>.field description]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@=%@\"</span>, AFPercentEscapedStringFromString([<span class=\"keyword\">self</span>.field description]), AFPercentEscapedStringFromString([<span class=\"keyword\">self</span>.value description])];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>AFQueryStringPairsFromKeyAndValue</strong> 方法，如果 value 是集合类型，它会不断递归调用自己：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class=\"built_in\">NSString</span> *key, <span class=\"keyword\">id</span> value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *mutableQueryStringComponents = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSSortDescriptor</span> *sortDescriptor = [<span class=\"built_in\">NSSortDescriptor</span> sortDescriptorWithKey:<span class=\"string\">@\"description\"</span> ascending:<span class=\"literal\">YES</span> selector:<span class=\"keyword\">@selector</span>(compare:)];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSDictionary</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSDictionary</span> *dictionary = value;</span><br><span class=\"line\">        <span class=\"comment\">// Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> nestedKey <span class=\"keyword\">in</span> [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">id</span> nestedValue = dictionary[nestedKey];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nestedValue) &#123;</span><br><span class=\"line\">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@[%@]\"</span>, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSArray</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> *array = value;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> nestedValue <span class=\"keyword\">in</span> array) &#123;</span><br><span class=\"line\">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@[]\"</span>, key], nestedValue)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSSet</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSSet</span> *set = value;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> obj <span class=\"keyword\">in</span> [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class=\"line\">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不是集合类型，就创建 AFQueryStringPair 对象，添加到数组</span></span><br><span class=\"line\">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mutableQueryStringComponents;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后会返回一个数组，数组里面是一个个 AFQueryStringPair 对象。</p>\n<p>得到数组后会调用 <strong>AFQueryStringFromParameters</strong> 使用 <strong>&amp;</strong> 来拼接它们。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> * AFQueryStringFromParameters(<span class=\"built_in\">NSDictionary</span> *parameters) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *mutablePairs = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (AFQueryStringPair *pair <span class=\"keyword\">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class=\"line\">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [mutablePairs componentsJoinedByString:<span class=\"string\">@\"&amp;\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username=haha&amp;password=123456</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置-HTTP-请求头\"><a href=\"#设置-HTTP-请求头\" class=\"headerlink\" title=\"设置 HTTP 请求头\"></a>设置 HTTP 请求头</h3><p>AFHTTPRequestSerializer 对外提供了 <strong>- [AFHTTPRequestSerializer setValue:forHTTPHeaderField:]</strong> 方法来设置请求头，内部实现是通过给一个可变字典 <strong>mutableHTTPRequestHeaders</strong> 赋值和取值获取：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"built_in\">NSString</span> *)value</span><br><span class=\"line\">forHTTPHeaderField:(<span class=\"built_in\">NSString</span> *)field</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.mutableHTTPRequestHeaders setValue:value forKey:field];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)valueForHTTPHeaderField:(<span class=\"built_in\">NSString</span> *)field &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.mutableHTTPRequestHeaders valueForKey:field];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>真正用到的时候又是通过 <strong>HTTPRequestHeaders</strong> 这个方法获取不可变字典：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span> *)HTTPRequestHeaders &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSDictionary</span> dictionaryWithDictionary:<span class=\"keyword\">self</span>.mutableHTTPRequestHeaders];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们设置一般的请求头字段时，可以参考 AFHTTPRequestSerializer 初始化的设置</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userAgent = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/%@ (%@; iOS %@; Scale/%0.2f)\"</span>, [[<span class=\"built_in\">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class=\"built_in\">NSString</span> *)kCFBundleExecutableKey] ?: [[<span class=\"built_in\">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class=\"built_in\">NSString</span> *)kCFBundleIdentifierKey], [[<span class=\"built_in\">NSBundle</span> mainBundle] infoDictionary][<span class=\"string\">@\"CFBundleShortVersionString\"</span>] ?: [[<span class=\"built_in\">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class=\"built_in\">NSString</span> *)kCFBundleVersionKey], [[<span class=\"built_in\">UIDevice</span> currentDevice] model], [[<span class=\"built_in\">UIDevice</span> currentDevice] systemVersion], [[<span class=\"built_in\">UIScreen</span> mainScreen] scale]];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">self</span> setValue:userAgent forHTTPHeaderField:<span class=\"string\">@\"User-Agent\"</span>];</span><br></pre></td></tr></table></figure>\n<p>验证用户名和密码时，调用 <strong>- [AFHTTPRequestSerializer setAuthorizationHeaderFieldWithUsername:password:]</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setAuthorizationHeaderFieldWithUsername:(<span class=\"built_in\">NSString</span> *)username</span><br><span class=\"line\">                                       password:(<span class=\"built_in\">NSString</span> *)password</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *basicAuthCredentials = [[<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@:%@\"</span>, username, password] dataUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(<span class=\"built_in\">NSDataBase64EncodingOptions</span>)<span class=\"number\">0</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setValue:[<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Basic %@\"</span>, base64AuthCredentials] forHTTPHeaderField:<span class=\"string\">@\"Authorization\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置请求URL的属性\"><a href=\"#设置请求URL的属性\" class=\"headerlink\" title=\"设置请求URL的属性\"></a>设置请求URL的属性</h3><p>设置完请求头和请求参数，还有一些关于请求的设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 字符串编码，默认 `NSUTF8StringEncoding`.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSStringEncoding</span> stringEncoding;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 请求能够使用蜂窝无线电，默认 YES.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">BOOL</span> allowsCellularAccess;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 缓存策略，默认 `NSURLRequestUseProtocolCachePolicy`.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSURLRequestCachePolicy</span> cachePolicy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 请求是否使用默认的cookie处理，默认 `YES`.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">BOOL</span> HTTPShouldHandleCookies;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 请求是否使用 管道， 默认 `NO` .</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">BOOL</span> HTTPShouldUsePipelining;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 网络请求的服务类型，默认 `NSURLNetworkServiceTypeDefault`.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSURLRequestNetworkServiceType</span> networkServiceType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 请求超时时间，默认是 60s.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSTimeInterval</span> timeoutInterval;</span><br></pre></td></tr></table></figure>\n<p>这些值会通过调用 <strong>AFHTTPRequestSerializerObservedKeyPaths</strong> 返回一个数组：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSArray</span> * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSArray</span> *_AFHTTPRequestSerializerObservedKeyPaths = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(allowsCellularAccess)), <span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(cachePolicy)), <span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(HTTPShouldHandleCookies)), <span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(HTTPShouldUsePipelining)), <span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(networkServiceType)), <span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(timeoutInterval))];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>AFURLRequestSerialization 是通过 KVO监听这些值的变化，当这些值被设置时，会触发KVO，然后把新的属性存储在 <strong>mutableObservedChangedKeyPaths</strong> 字典中：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class=\"built_in\">NSString</span> *)key &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 手动控制通知方式</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([AFHTTPRequestSerializerObservedKeyPaths() containsObject:key]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 默认自动通知</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath</span><br><span class=\"line\">                      ofObject:(__unused <span class=\"keyword\">id</span>)object</span><br><span class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change</span><br><span class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([change[<span class=\"built_in\">NSKeyValueChangeNewKey</span>] isEqual:[<span class=\"built_in\">NSNull</span> null]]) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后在生成 NSURLRequest 请求时设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> *mutableRequest = [[<span class=\"built_in\">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class=\"line\">mutableRequest.HTTPMethod = method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *keyPath <span class=\"keyword\">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class=\"line\">       [mutableRequest setValue:[<span class=\"keyword\">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化-2\"><a href=\"#初始化-2\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.stringEncoding = <span class=\"built_in\">NSUTF8StringEncoding</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.mutableHTTPRequestHeaders = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#1: 设置 Accept-Language，User-Agent等。忽略</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.HTTPMethodsEncodingParametersInURI = [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@\"GET\"</span>, <span class=\"string\">@\"HEAD\"</span>, <span class=\"string\">@\"DELETE\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.mutableObservedChangedKeyPaths = [<span class=\"built_in\">NSMutableSet</span> set];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *keyPath <span class=\"keyword\">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"built_in\">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> addObserver:<span class=\"keyword\">self</span> forKeyPath:keyPath options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:AFHTTPRequestSerializerObserverContext];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面提到到 KVO 监听属性变化，就是在初始化的时候做的，确保它们在改变后更新 NSMutableURLRequest 中对应的属性。</p>\n<p>初始化完成后，如果调用普通的请求方法，就会进入这个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)requestWithMethod:(<span class=\"built_in\">NSString</span> *)method</span><br><span class=\"line\">                                 URLString:(<span class=\"built_in\">NSString</span> *)URLString</span><br><span class=\"line\">                                parameters:(<span class=\"keyword\">id</span>)parameters</span><br><span class=\"line\">                                     error:(<span class=\"built_in\">NSError</span> *__autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检测参数</span></span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(method);</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(URLString);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生成url</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:URLString];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(url);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> *mutableRequest = [[<span class=\"built_in\">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class=\"line\">    <span class=\"comment\">// 设置请求方式</span></span><br><span class=\"line\">    mutableRequest.HTTPMethod = method;</span><br><span class=\"line\">    <span class=\"comment\">// 设置kVO监听的请求属性</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *keyPath <span class=\"keyword\">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class=\"line\">            [mutableRequest setValue:[<span class=\"keyword\">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置 HTTP 请求头和请求参数</span></span><br><span class=\"line\">    mutableRequest = [[<span class=\"keyword\">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mutableRequest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用 <strong>- [AFHTTPRequestSerializer requestBySerializingRequest:withParameters:error:]</strong> 方法，设置 HTTP 请求头和请求参数：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSURLRequest</span> *)requestBySerializingRequest:(<span class=\"built_in\">NSURLRequest</span> *)request</span><br><span class=\"line\">                               withParameters:(<span class=\"keyword\">id</span>)parameters</span><br><span class=\"line\">                                        error:(<span class=\"built_in\">NSError</span> *__autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置请求头</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class=\"keyword\">id</span> field, <span class=\"keyword\">id</span> value, <span class=\"built_in\">BOOL</span> * __unused stop) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class=\"line\">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *query = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parameters) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.queryStringSerialization) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSError</span> *serializationError;</span><br><span class=\"line\">            query = <span class=\"keyword\">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (serializationError) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">                    *error = serializationError;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (<span class=\"keyword\">self</span>.queryStringSerializationStyle) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class=\"line\">                    <span class=\"comment\">// 把请求参数转换为 &amp;拼接的字符串</span></span><br><span class=\"line\">                    query = AFQueryStringFromParameters(parameters);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果是 `GET`，`HEAD` 和 `DELETE`的请求，请求参数拼接到URL后面</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (query &amp;&amp; query.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mutableRequest.URL = [<span class=\"built_in\">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class=\"string\">@\"&amp;%@\"</span> : <span class=\"string\">@\"?%@\"</span>, query]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!query) &#123;</span><br><span class=\"line\">            query = <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (![mutableRequest valueForHTTPHeaderField:<span class=\"string\">@\"Content-Type\"</span>]) &#123;</span><br><span class=\"line\">            [mutableRequest setValue:<span class=\"string\">@\"application/x-www-form-urlencoded\"</span> forHTTPHeaderField:<span class=\"string\">@\"Content-Type\"</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 请求参数放入请求体</span></span><br><span class=\"line\">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class=\"keyword\">self</span>.stringEncoding]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mutableRequest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>AFURLResponseSerialization 负责对返回的数据进行序列化</li>\n<li>AFURLRequestSerialization 负责生成 NSMutableURLRequest，为请求设置 HTTP 请求头和请求参数，管理发出的请求</li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a></li>\n<li><a href=\"http://www.cnblogs.com/polobymulberry/p/5174298.html\" target=\"_blank\" rel=\"noopener\">AFNetworking源码阅读（六）</a></li>\n<li><a href=\"https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%20AFURLSerialization%EF%BC%88%E4%B8%89%EF%BC%89.md#afurlresponseserialization\" target=\"_blank\" rel=\"noopener\">处理请求和响应 AFURLSerialization（三）</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面的文字已经分析了 <strong>AFURLSessionManager</strong> 和 <strong>AFNetworkReachabilityManager</strong>，一个是 AFN 的核心，另一个是 AFN 非常有用的工具类。</p>\n<p>这里我们接着了解 AFURLSessionManager 中使用到的<strong>对发出请求和接收响应时</strong>进行序列化的两个模块：</p>\n<ul>\n<li>AFURLResponseSerialization</li>\n<li>AFURLRequestSerialization</li>\n</ul>\n<p>前者是处理响应的模块，将请求返回的数据解析成对用的格式。后者主要是修改请求的头部（主要是 HTTP 请求）。</p>\n<p>AFURLResponseSerialization 主要使用在 AFURLSessionManager 中，而 AFURLRequestSerialization 主要用于 AFHTTPSessionManager 中，因为它主要用于<strong>修改 HTTP 头部</strong>。</p>\n<h2 id=\"AFURLResponseSerialization\"><a href=\"#AFURLResponseSerialization\" class=\"headerlink\" title=\"AFURLResponseSerialization\"></a>AFURLResponseSerialization</h2><p>AFURLResponseSerialization 其实并不是一个类，它是个协议，它只有一个需要实现的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">AFURLResponseSerialization</span> &lt;<span class=\"title\">NSObject</span>, <span class=\"title\">NSSecureCoding</span>, <span class=\"title\">NSCopying</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)responseObjectForResponse:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSURLResponse</span> *)response</span><br><span class=\"line\">                           data:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                          error:(<span class=\"built_in\">NSError</span> * _Nullable __autoreleasing *)error <span class=\"built_in\">NS_SWIFT_NOTHROW</span>;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>遵循这个协议的同时也需要遵循 NSObject, NSSecureCoding 和 NSCopying 这三个协议，实现安全编码、拷贝以及Objective-C 对象的基本行为。</p>\n<p>先了解下 AFURLResponseSerialization 的模型结构：<br><img src=\"/2017/01/08/AFNetworking-AFURLSerialization-4/Snip20170126_3.png\" title=\"AFURLResponseSerialization\"></p>\n<ul>\n<li>AFHTTPResponseSerializer 是模型中所有Serializer的根类</li>\n<li>所有Serializer 都需要遵循 AFURLResponseSerialization 协议</li>\n</ul>\n<h2 id=\"AFHTTPResponseSerializer\"><a href=\"#AFHTTPResponseSerializer\" class=\"headerlink\" title=\"AFHTTPResponseSerializer\"></a>AFHTTPResponseSerializer</h2><p>AFHTTPResponseSerializer 是所有响应解析的根类，因为它遵循了 AFURLResponseSerialization 协议，所以子类也要遵循。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)serializer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.acceptableStatusCodes = [<span class=\"built_in\">NSIndexSet</span> indexSetWithIndexesInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">200</span>, <span class=\"number\">100</span>)];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.acceptableContentTypes = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>acceptableStatusCodes 设置为从 200 到 299 之间的状态码, 因为只有这些状态码表示获得了有效的响应。</p>\n<h3 id=\"验证响应\"><a href=\"#验证响应\" class=\"headerlink\" title=\"验证响应\"></a>验证响应</h3><p>AFHTTPResponseSerializer 最重要的方法 <strong>- [AFHTTPResponseSerializer validateResponse:data:error:]</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)validateResponse:(<span class=\"built_in\">NSHTTPURLResponse</span> *)response</span><br><span class=\"line\">                    data:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                   error:(<span class=\"built_in\">NSError</span> * __autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> responseIsValid = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *validationError = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response &amp;&amp; [response isKindOfClass:[<span class=\"built_in\">NSHTTPURLResponse</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.acceptableContentTypes &amp;&amp; ![<span class=\"keyword\">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class=\"line\">            !([response MIMEType] == <span class=\"literal\">nil</span> &amp;&amp; [data length] == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">#1: 返回的数据类型无效</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.acceptableStatusCodes &amp;&amp; ![<span class=\"keyword\">self</span>.acceptableStatusCodes containsIndex:(<span class=\"built_in\">NSUInteger</span>)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class=\"line\">            <span class=\"meta\">#2: 返回的状态码无效</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class=\"line\">        *error = validationError;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> responseIsValid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.acceptableContentTypes &amp;&amp; ![<span class=\"keyword\">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class=\"line\">            !([response MIMEType] == <span class=\"literal\">nil</span> &amp;&amp; [data length] == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ([data length] &gt; <span class=\"number\">0</span> &amp;&amp; [response URL]) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class=\"line\">                                                <span class=\"built_in\">NSLocalizedDescriptionKey</span>: [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"built_in\">NSLocalizedStringFromTable</span>(<span class=\"string\">@\"Request failed: unacceptable content-type: %@\"</span>, <span class=\"string\">@\"AFNetworking\"</span>, <span class=\"literal\">nil</span>), [response MIMEType]],</span><br><span class=\"line\">                                                <span class=\"built_in\">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class=\"line\">                                                AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class=\"line\">                                              &#125; mutableCopy];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">          mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      validationError = AFErrorWithUnderlyingError([<span class=\"built_in\">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class=\"built_in\">NSURLErrorCannotDecodeContentData</span> userInfo:mutableUserInfo], validationError);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  responseIsValid = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>先判断 acceptableContentTypes 集合里面是否包含响应类型，如果不包含进入 if</li>\n<li>在 if 里面通过 AFErrorWithUnderlyingError 包装错误信息，最后设置 responseIsValid = NO</li>\n</ul>\n<p>第二段代码也是差不多的实现。</p>\n<h3 id=\"实现协议\"><a href=\"#实现协议\" class=\"headerlink\" title=\"实现协议\"></a>实现协议</h3><p>其实就是调用👆的验证方法，然后返回数据<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)responseObjectForResponse:(<span class=\"built_in\">NSURLResponse</span> *)response</span><br><span class=\"line\">                           data:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                          error:(<span class=\"built_in\">NSError</span> *__autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> validateResponse:(<span class=\"built_in\">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"NSSecureCoding，NSCopying\"><a href=\"#NSSecureCoding，NSCopying\" class=\"headerlink\" title=\"NSSecureCoding，NSCopying\"></a>NSSecureCoding，NSCopying</h3><p>最后是实现 NSSecureCoding，NSCopying 这两个协议，没什么好说的。</p>\n<h2 id=\"AFJSONResponseSerializer\"><a href=\"#AFJSONResponseSerializer\" class=\"headerlink\" title=\"AFJSONResponseSerializer\"></a>AFJSONResponseSerializer</h2><p>现在看下 AFJSONResponseSerializer ，它继承自 AFHTTPResponseSerializer。</p>\n<h3 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>调用父类初始化后，增加了 acceptableContentTypes 赋值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@\"application/json\"</span>, <span class=\"string\">@\"text/json\"</span>, <span class=\"string\">@\"text/javascript\"</span>, <span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现协议-1\"><a href=\"#实现协议-1\" class=\"headerlink\" title=\"实现协议\"></a>实现协议</h3><p>这个子类对 AFURLResponseSerialization 协议实现比父类复杂得多</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)responseObjectForResponse:(<span class=\"built_in\">NSURLResponse</span> *)response</span><br><span class=\"line\">                           data:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                          error:(<span class=\"built_in\">NSError</span> *__autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t  <span class=\"comment\">// 去父类验证响应有效</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> validateResponse:(<span class=\"built_in\">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class=\"built_in\">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span></span><br><span class=\"line\">    <span class=\"comment\">// See https://github.com/rails/rails/issues/1742</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 解决只有一个空格引起的bug</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> isSpace = [data isEqualToData:[<span class=\"built_in\">NSData</span> dataWithBytes:<span class=\"string\">\" \"</span> length:<span class=\"number\">1</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.length == <span class=\"number\">0</span> || isSpace) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *serializationError = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 序列化JSON</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> responseObject = [<span class=\"built_in\">NSJSONSerialization</span> JSONObjectWithData:data options:<span class=\"keyword\">self</span>.readingOptions error:&amp;serializationError];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!responseObject)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">            *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// JSON是否移除 ‘NSNull’ 默认是 NO</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.removesKeysWithNullValues) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class=\"keyword\">self</span>.readingOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> responseObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>移除 JSON 中 null 的函数 AFJSONObjectByRemovingKeysWithNullValues 是一个递归调用的函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">id</span> AFJSONObjectByRemovingKeysWithNullValues(<span class=\"keyword\">id</span> JSONObject, <span class=\"built_in\">NSJSONReadingOptions</span> readingOptions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([JSONObject isKindOfClass:[<span class=\"built_in\">NSArray</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *mutableArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithCapacity:[(<span class=\"built_in\">NSArray</span> *)JSONObject count]];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> value <span class=\"keyword\">in</span> (<span class=\"built_in\">NSArray</span> *)JSONObject) &#123;</span><br><span class=\"line\">            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (readingOptions &amp; <span class=\"built_in\">NSJSONReadingMutableContainers</span>) ? mutableArray : [<span class=\"built_in\">NSArray</span> arrayWithArray:mutableArray];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([JSONObject isKindOfClass:[<span class=\"built_in\">NSDictionary</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableDictionary</span> *mutableDictionary = [<span class=\"built_in\">NSMutableDictionary</span> dictionaryWithDictionary:JSONObject];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSCopying</span>&gt; key <span class=\"keyword\">in</span> [(<span class=\"built_in\">NSDictionary</span> *)JSONObject allKeys]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">id</span> value = (<span class=\"built_in\">NSDictionary</span> *)JSONObject[key];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!value || [value isEqual:[<span class=\"built_in\">NSNull</span> null]]) &#123;</span><br><span class=\"line\">                [mutableDictionary removeObjectForKey:key];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSArray</span> <span class=\"keyword\">class</span>]] || [value isKindOfClass:[<span class=\"built_in\">NSDictionary</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (readingOptions &amp; <span class=\"built_in\">NSJSONReadingMutableContainers</span>) ? mutableDictionary : [<span class=\"built_in\">NSDictionary</span> dictionaryWithDictionary:mutableDictionary];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> JSONObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法中判断类型是 NSArray 还是 NSDictionary，只有 NSDictionary 中存在 ‘null’，所有移除是靠 <strong>[mutableDictionary removeObjectForKey:key];</strong></p>\n<h2 id=\"AFURLRequestSerialization\"><a href=\"#AFURLRequestSerialization\" class=\"headerlink\" title=\"AFURLRequestSerialization\"></a>AFURLRequestSerialization</h2><p>AFURLRequestSerialization 相对复杂些，它的主要工作是对发出的 HTTP 请求进行处理。<br>这个文件中大部分类都是为 AFHTTPRequestSerializer 服务的：</p>\n<ol>\n<li>处理请求参数</li>\n<li>设置 HTTP 请求头</li>\n<li>设置请求URL的属性</li>\n<li>分块上传</li>\n</ol>\n<blockquote>\n<p>分块上传相对复杂得多，有兴趣的可以去研究下，这里不进行细讲</p>\n</blockquote>\n<h3 id=\"处理请求参数\"><a href=\"#处理请求参数\" class=\"headerlink\" title=\"处理请求参数\"></a>处理请求参数</h3><p>设置查询参数主要是通过 <strong>AFQueryStringPair</strong> 完成，它有两个属性 field 和 value 对应HTTP 请求的查询 URL 中的参数。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">AFQueryStringPair</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"keyword\">id</span> field;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"keyword\">id</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithField:(<span class=\"keyword\">id</span>)field value:(<span class=\"keyword\">id</span>)value;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)URLEncodedStringValue;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>其中 <strong>- [AFQueryStringPair URLEncodedStringValue]</strong> 会返回 <strong>key=value</strong> 这种格式，同时使用 <strong>AFPercentEscapedStringFromString</strong> 函数来对 field 和 value 进行处理，将其中的 :#[]@!$&amp;’()*+,;= 等字符转换为百分号表示的形式。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)URLEncodedStringValue &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.value || [<span class=\"keyword\">self</span>.value isEqual:[<span class=\"built_in\">NSNull</span> null]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> AFPercentEscapedStringFromString([<span class=\"keyword\">self</span>.field description]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@=%@\"</span>, AFPercentEscapedStringFromString([<span class=\"keyword\">self</span>.field description]), AFPercentEscapedStringFromString([<span class=\"keyword\">self</span>.value description])];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>AFQueryStringPairsFromKeyAndValue</strong> 方法，如果 value 是集合类型，它会不断递归调用自己：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class=\"built_in\">NSString</span> *key, <span class=\"keyword\">id</span> value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *mutableQueryStringComponents = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSSortDescriptor</span> *sortDescriptor = [<span class=\"built_in\">NSSortDescriptor</span> sortDescriptorWithKey:<span class=\"string\">@\"description\"</span> ascending:<span class=\"literal\">YES</span> selector:<span class=\"keyword\">@selector</span>(compare:)];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSDictionary</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSDictionary</span> *dictionary = value;</span><br><span class=\"line\">        <span class=\"comment\">// Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> nestedKey <span class=\"keyword\">in</span> [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">id</span> nestedValue = dictionary[nestedKey];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nestedValue) &#123;</span><br><span class=\"line\">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@[%@]\"</span>, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSArray</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> *array = value;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> nestedValue <span class=\"keyword\">in</span> array) &#123;</span><br><span class=\"line\">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@[]\"</span>, key], nestedValue)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSSet</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSSet</span> *set = value;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> obj <span class=\"keyword\">in</span> [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class=\"line\">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不是集合类型，就创建 AFQueryStringPair 对象，添加到数组</span></span><br><span class=\"line\">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mutableQueryStringComponents;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后会返回一个数组，数组里面是一个个 AFQueryStringPair 对象。</p>\n<p>得到数组后会调用 <strong>AFQueryStringFromParameters</strong> 使用 <strong>&amp;</strong> 来拼接它们。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> * AFQueryStringFromParameters(<span class=\"built_in\">NSDictionary</span> *parameters) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *mutablePairs = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (AFQueryStringPair *pair <span class=\"keyword\">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class=\"line\">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [mutablePairs componentsJoinedByString:<span class=\"string\">@\"&amp;\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username=haha&amp;password=123456</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置-HTTP-请求头\"><a href=\"#设置-HTTP-请求头\" class=\"headerlink\" title=\"设置 HTTP 请求头\"></a>设置 HTTP 请求头</h3><p>AFHTTPRequestSerializer 对外提供了 <strong>- [AFHTTPRequestSerializer setValue:forHTTPHeaderField:]</strong> 方法来设置请求头，内部实现是通过给一个可变字典 <strong>mutableHTTPRequestHeaders</strong> 赋值和取值获取：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"built_in\">NSString</span> *)value</span><br><span class=\"line\">forHTTPHeaderField:(<span class=\"built_in\">NSString</span> *)field</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.mutableHTTPRequestHeaders setValue:value forKey:field];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)valueForHTTPHeaderField:(<span class=\"built_in\">NSString</span> *)field &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.mutableHTTPRequestHeaders valueForKey:field];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>真正用到的时候又是通过 <strong>HTTPRequestHeaders</strong> 这个方法获取不可变字典：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span> *)HTTPRequestHeaders &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSDictionary</span> dictionaryWithDictionary:<span class=\"keyword\">self</span>.mutableHTTPRequestHeaders];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们设置一般的请求头字段时，可以参考 AFHTTPRequestSerializer 初始化的设置</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userAgent = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@/%@ (%@; iOS %@; Scale/%0.2f)\"</span>, [[<span class=\"built_in\">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class=\"built_in\">NSString</span> *)kCFBundleExecutableKey] ?: [[<span class=\"built_in\">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class=\"built_in\">NSString</span> *)kCFBundleIdentifierKey], [[<span class=\"built_in\">NSBundle</span> mainBundle] infoDictionary][<span class=\"string\">@\"CFBundleShortVersionString\"</span>] ?: [[<span class=\"built_in\">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class=\"built_in\">NSString</span> *)kCFBundleVersionKey], [[<span class=\"built_in\">UIDevice</span> currentDevice] model], [[<span class=\"built_in\">UIDevice</span> currentDevice] systemVersion], [[<span class=\"built_in\">UIScreen</span> mainScreen] scale]];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">self</span> setValue:userAgent forHTTPHeaderField:<span class=\"string\">@\"User-Agent\"</span>];</span><br></pre></td></tr></table></figure>\n<p>验证用户名和密码时，调用 <strong>- [AFHTTPRequestSerializer setAuthorizationHeaderFieldWithUsername:password:]</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setAuthorizationHeaderFieldWithUsername:(<span class=\"built_in\">NSString</span> *)username</span><br><span class=\"line\">                                       password:(<span class=\"built_in\">NSString</span> *)password</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *basicAuthCredentials = [[<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@:%@\"</span>, username, password] dataUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(<span class=\"built_in\">NSDataBase64EncodingOptions</span>)<span class=\"number\">0</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setValue:[<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Basic %@\"</span>, base64AuthCredentials] forHTTPHeaderField:<span class=\"string\">@\"Authorization\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置请求URL的属性\"><a href=\"#设置请求URL的属性\" class=\"headerlink\" title=\"设置请求URL的属性\"></a>设置请求URL的属性</h3><p>设置完请求头和请求参数，还有一些关于请求的设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 字符串编码，默认 `NSUTF8StringEncoding`.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSStringEncoding</span> stringEncoding;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 请求能够使用蜂窝无线电，默认 YES.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">BOOL</span> allowsCellularAccess;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 缓存策略，默认 `NSURLRequestUseProtocolCachePolicy`.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSURLRequestCachePolicy</span> cachePolicy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 请求是否使用默认的cookie处理，默认 `YES`.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">BOOL</span> HTTPShouldHandleCookies;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 请求是否使用 管道， 默认 `NO` .</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">BOOL</span> HTTPShouldUsePipelining;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 网络请求的服务类型，默认 `NSURLNetworkServiceTypeDefault`.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSURLRequestNetworkServiceType</span> networkServiceType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 请求超时时间，默认是 60s.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSTimeInterval</span> timeoutInterval;</span><br></pre></td></tr></table></figure>\n<p>这些值会通过调用 <strong>AFHTTPRequestSerializerObservedKeyPaths</strong> 返回一个数组：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSArray</span> * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSArray</span> *_AFHTTPRequestSerializerObservedKeyPaths = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(allowsCellularAccess)), <span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(cachePolicy)), <span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(HTTPShouldHandleCookies)), <span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(HTTPShouldUsePipelining)), <span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(networkServiceType)), <span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(timeoutInterval))];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>AFURLRequestSerialization 是通过 KVO监听这些值的变化，当这些值被设置时，会触发KVO，然后把新的属性存储在 <strong>mutableObservedChangedKeyPaths</strong> 字典中：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class=\"built_in\">NSString</span> *)key &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 手动控制通知方式</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([AFHTTPRequestSerializerObservedKeyPaths() containsObject:key]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 默认自动通知</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath</span><br><span class=\"line\">                      ofObject:(__unused <span class=\"keyword\">id</span>)object</span><br><span class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change</span><br><span class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([change[<span class=\"built_in\">NSKeyValueChangeNewKey</span>] isEqual:[<span class=\"built_in\">NSNull</span> null]]) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后在生成 NSURLRequest 请求时设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> *mutableRequest = [[<span class=\"built_in\">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class=\"line\">mutableRequest.HTTPMethod = method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *keyPath <span class=\"keyword\">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class=\"line\">       [mutableRequest setValue:[<span class=\"keyword\">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化-2\"><a href=\"#初始化-2\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.stringEncoding = <span class=\"built_in\">NSUTF8StringEncoding</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.mutableHTTPRequestHeaders = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#1: 设置 Accept-Language，User-Agent等。忽略</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.HTTPMethodsEncodingParametersInURI = [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@\"GET\"</span>, <span class=\"string\">@\"HEAD\"</span>, <span class=\"string\">@\"DELETE\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.mutableObservedChangedKeyPaths = [<span class=\"built_in\">NSMutableSet</span> set];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *keyPath <span class=\"keyword\">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"built_in\">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> addObserver:<span class=\"keyword\">self</span> forKeyPath:keyPath options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:AFHTTPRequestSerializerObserverContext];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面提到到 KVO 监听属性变化，就是在初始化的时候做的，确保它们在改变后更新 NSMutableURLRequest 中对应的属性。</p>\n<p>初始化完成后，如果调用普通的请求方法，就会进入这个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)requestWithMethod:(<span class=\"built_in\">NSString</span> *)method</span><br><span class=\"line\">                                 URLString:(<span class=\"built_in\">NSString</span> *)URLString</span><br><span class=\"line\">                                parameters:(<span class=\"keyword\">id</span>)parameters</span><br><span class=\"line\">                                     error:(<span class=\"built_in\">NSError</span> *__autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检测参数</span></span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(method);</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(URLString);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生成url</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:URLString];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(url);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> *mutableRequest = [[<span class=\"built_in\">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class=\"line\">    <span class=\"comment\">// 设置请求方式</span></span><br><span class=\"line\">    mutableRequest.HTTPMethod = method;</span><br><span class=\"line\">    <span class=\"comment\">// 设置kVO监听的请求属性</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *keyPath <span class=\"keyword\">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class=\"line\">            [mutableRequest setValue:[<span class=\"keyword\">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置 HTTP 请求头和请求参数</span></span><br><span class=\"line\">    mutableRequest = [[<span class=\"keyword\">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mutableRequest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用 <strong>- [AFHTTPRequestSerializer requestBySerializingRequest:withParameters:error:]</strong> 方法，设置 HTTP 请求头和请求参数：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSURLRequest</span> *)requestBySerializingRequest:(<span class=\"built_in\">NSURLRequest</span> *)request</span><br><span class=\"line\">                               withParameters:(<span class=\"keyword\">id</span>)parameters</span><br><span class=\"line\">                                        error:(<span class=\"built_in\">NSError</span> *__autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置请求头</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class=\"keyword\">id</span> field, <span class=\"keyword\">id</span> value, <span class=\"built_in\">BOOL</span> * __unused stop) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class=\"line\">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *query = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parameters) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.queryStringSerialization) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSError</span> *serializationError;</span><br><span class=\"line\">            query = <span class=\"keyword\">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (serializationError) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">                    *error = serializationError;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (<span class=\"keyword\">self</span>.queryStringSerializationStyle) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class=\"line\">                    <span class=\"comment\">// 把请求参数转换为 &amp;拼接的字符串</span></span><br><span class=\"line\">                    query = AFQueryStringFromParameters(parameters);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果是 `GET`，`HEAD` 和 `DELETE`的请求，请求参数拼接到URL后面</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (query &amp;&amp; query.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mutableRequest.URL = [<span class=\"built_in\">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class=\"string\">@\"&amp;%@\"</span> : <span class=\"string\">@\"?%@\"</span>, query]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!query) &#123;</span><br><span class=\"line\">            query = <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (![mutableRequest valueForHTTPHeaderField:<span class=\"string\">@\"Content-Type\"</span>]) &#123;</span><br><span class=\"line\">            [mutableRequest setValue:<span class=\"string\">@\"application/x-www-form-urlencoded\"</span> forHTTPHeaderField:<span class=\"string\">@\"Content-Type\"</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 请求参数放入请求体</span></span><br><span class=\"line\">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class=\"keyword\">self</span>.stringEncoding]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mutableRequest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>AFURLResponseSerialization 负责对返回的数据进行序列化</li>\n<li>AFURLRequestSerialization 负责生成 NSMutableURLRequest，为请求设置 HTTP 请求头和请求参数，管理发出的请求</li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a></li>\n<li><a href=\"http://www.cnblogs.com/polobymulberry/p/5174298.html\" target=\"_blank\" rel=\"noopener\">AFNetworking源码阅读（六）</a></li>\n<li><a href=\"https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%20AFURLSerialization%EF%BC%88%E4%B8%89%EF%BC%89.md#afurlresponseserialization\" target=\"_blank\" rel=\"noopener\">处理请求和响应 AFURLSerialization（三）</a></li>\n</ul>\n"},{"title":"学习ReactNative基础（六）","date":"2017-04-27T06:18:48.000Z","_content":"\n## 前言\n\n本篇文章将学习 Navigator组件、TabBarIOS组件和fetch网络请求。\n\n## Navigator 组件\n\n[官方文档](https://facebook.github.io/react-native/docs/navigator.html)\n\napp 由很多公共视图组成，一个应用中重要的功能之一是“导航”，在ReactNative中成为“路由route”，使用导航器可以让你在应用的不同场景（页面）间进行切换。\n\n在ReactNative中，有两个实现导航功能的组件：`Navigator` 和 `NavigatorIOS`\n\n* Navigator支持安卓和iOS，NavigatorIOS支持iOS\n* NavigatorIOS比Navigator具有更多的属性和方法，在UI方面可以进行更多的设置，例如：backButtonIcon、backButtonTitle、onLeftButtonPress等等，比较方便，如果想实现更多的自定义设置，建议使用Navigator\n\n### 导航功能\n\n导航器通过路由对象(route)来分辨不同的场景。每个路由对象都对应一个页面组件，开发者设置什么，导航器显示什么，所有route是导航器中重要的一个对象。\n\n三部操作实现导航功能：\n\n1. 设置路由对象（告诉导航器我要现实哪个页面），创建路由对象，对象的内容自定义，但是必须包含该场景需要展示的页面组件\n2. 场景渲染配置（告诉导航器我要什么样的页面跳转效果）\n3. 渲染场景（告诉导航器如何渲染页面）\n    利用第一步设置的路由对象进行渲染场景\n    \n    \n```JavaScript\n// 定义一个页面\n// FirstPage 一个button，点击进入下一级页面\nvar FirstPage = React.createClass({\n  // 按钮onPress事件处理方法\n  pressPush: function() {\n    // 推出下一级页面\n    var nextRoute = {\n      component: SecondPage\n    };\n    this.props.navigator.push(nextRoute);\n  },\n  render: function() {\n    return (\n      <View style={[styles.flex, {backgroundColor:'green'}]}>\n        <TouchableOpacity style={styles.btn} onPress={this.pressPush}>\n          <Text>点击推出下一级页面</Text>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n});\n\n// 定义第二个页面\n// SecondPage 一个button，点击返回上一级页面\n\nvar SecondPage = React.createClass({\n  // 按钮onPress事件处理方法\n  pressPop: function() {\n    // 返回上一级页面\n    this.props.navigator.pop();\n  },\n  render: function() {\n    return (\n      <View style={[styles.flex, {backgroundColor:'pink'}]}>\n        <TouchableOpacity style={styles.btn} onPress={this.pressPop}>\n          <Text>点击返回上一级页面</Text>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n});\n\nvar LessonNavigator = React.createClass({\n  render: function() {\n    var rootRoute = {\n      component: FirstPage\n    };\n    return(\n      <Navigator\n        /*\n          第一步：\n          initialRoute\n\n          这个指定了默认的页面，也就是启动APP之后会看到界面的第一屏\n          对象的属性是自定义的，这个对象中的内容会在renderScene方法中处理\n\n          备注：必须包含的属性，即component，表示需要渲染的页面组件\n        */\n        initialRoute={rootRoute}\n        /*\n          第二步：\n          configureScene\n\n          场景渲染的配置\n        */\n        configureScene={(route) => {\n          return Navigator.SceneConfigs.PushFromRight;\n        }}\n        /*\n          第三步：\n          renderScene\n\n          渲染场景\n\n          参数：route (第一步创建并设置给导航器的路由对象)，navigator（导航器对象）\n          实现：给需要显示的组件设置属性\n        */\n        renderScene={(route, navigator) => {\n          // 从route对象中获取页面组件\n          var Component = route.component;\n          return (\n            <Component\n              navigator={navigator}\n              route={route}\n            />\n          );\n        }}\n      />\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  flex: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  btn: {\n    width: 150,\n    height: 30,\n    backgroundColor: '#0089FF',\n    borderWidth: 1,\n    borderRadius: 3,\n    justifyContent: 'center',\n    alignItems: 'center',\n  }\n});\n\nmodule.exports = LessonNavigator;\n```\n\n### 传值功能\n\n将第一个界面输入的值，传递到第二个界面显示。\n\n```JavaScript\n// 有输入的页面\nvar InputPage = React.createClass({\n  getInitialState: function() {\n    return {\n      // 记录输入的值\n      content: ''\n    };\n  },\n  getInputContent: function(inputText) {\n    // 将输入框的值进行记录\n    this.setState({\n      content: inputText\n    });\n  },\n  pushNextPage: function() {\n    //进入下一个界面并传值\n    var route = {\n      component: DetailsPage,\n      passProps: {\n        showText: this.state.content\n      }\n    };\n    this.props.navigator.push(route);\n  },\n  render: function() {\n    return (\n      <View style={inputStyle.container}>\n        <TextInput\n          style={inputStyle.input}\n          placeholder='请输入内容'\n          onChangeText={this.getInputContent}\n        />\n        <TouchableOpacity style={inputStyle.btn} onPress={this.pushNextPage}>\n          <Text>进入下一页</Text>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n});\n\nvar inputStyle = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'white',\n  },\n  input: {\n    height: 45,\n    marginLeft: 25,\n    marginRight: 25,\n    paddingLeft: 5,\n    borderWidth: 1,\n    borderColor: 'black',\n    borderRadius: 4,\n  },\n  btn: {\n    marginTop: 20,\n    height: 30,\n    borderWidth: 1,\n    borderRadius: 4,\n    borderColor: 'black',\n    padding: 5,\n    justifyContent: 'center',\n    alignItems: 'center',\n  }\n});\n\n// 显示输入内容的页面\n\nvar DetailsPage = React.createClass({\n  popFrontPage: function() {\n    // 返回上一级\n    this.props.navigator.pop();\n  },\n  render: function() {\n    return (\n      <View style={detailStyle.container}>\n        <Text style={detailStyle.text}>{this.props.showText}</Text>\n        <TouchableOpacity style={detailStyle.btn} onPress={this.popFrontPage}>\n          <Text>返回上一页</Text>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n});\n\nvar detailStyle = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'white',\n  },\n  text: {\n    marginLeft: 25,\n    marginRight: 25,\n    padding: 25,\n    backgroundColor: 'cyan',\n    fontSize: 20,\n    textAlign: 'center',\n  },\n  btn: {\n    marginTop: 20,\n    height: 30,\n    borderWidth: 1,\n    borderRadius: 4,\n    borderColor: 'black',\n    padding: 5,\n    justifyContent: 'center',\n    alignItems: 'center',\n  }\n});\n\nvar LessonNavigator = React.createClass({\n  render: function() {\n    var rootRoute = {\n      component: InputPage,\n      // 存储需要传递的内容\n      passProps: {\n\n      }\n    };\n    return (\n      <View style={{flex:1}}>\n        <Navigator\n          initialRoute={rootRoute}\n          configureScene={(route) => {\n            return Navigator.SceneConfigs.PushFromRight;\n          }}\n          renderScene={(route, navigator) => {\n            var Component = route.component;\n            return (\n              <Component\n                navigator={navigator}\n                route={route}\n                {...route.passProps}\n              />\n            );\n          }}\n        />\n      </View>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n\n});\n\nmodule.exports = LessonNavigator;\n```\n\n## TabBarIOS\n\n[官方文档](https://facebook.github.io/react-native/docs/tabbarios.html)\n\n在ReactNative中，实现页面切换，提供了两个组件：TabBarIOS和TabBarIOS.Item，常用功能：\n\n* selected：是否选中某个Tab。如果为true则选中并显示组件\n* title： 标题\n* barTintColor：Tab栏的背景颜色\n* icon：图标\n* onPress：点击事件，当某个tab被选中时，需要改变组件的select={true}\n\n实现原理：点击tab时触发onPress方法，记录被点击tab的title。再通过title设置tab是否被选中（通过比较设置selected的值，true/false）\n\n例子：先创建三个页面，引入模块，在 `index.ios.js` 中统一装配\n\n\n```JavaScript\nvar LessonTextInput = require('./testInput');\nvar LessonImage = require('./loadImage');\nvar MovieList = require('./movieList');\n\nvar LessonTabBarIOS = React.createClass({\n  getInitialState: function() {\n    return {\n      // 记录点击tab的title\n      tab: 'LessonTextInput'\n    };\n  },\n  // TabBarIOS.Item 的onPress触发方法\n  select: function(tabName) {\n    this.setState({\n      tab: tabName\n    });\n  },\n  render: function() {\n    return (\n      <TabBarIOS style={{flex:1}}>\n        <TabBarIOS.Item\n          title='LessonTextInput'\n          icon={require('./img/icon_chat_normal@3x.png')}\n          onPress={this.select.bind(this, 'LessonTextInput')}\n          selected={this.state.tab==='LessonTextInput'}\n          >\n            <LessonTextInput></LessonTextInput>\n        </TabBarIOS.Item>\n        <TabBarIOS.Item\n          title='LessonImage'\n          systemIcon='bookmarks'\n          onPress={this.select.bind(this, 'LessonImage')}\n          selected={this.state.tab==='LessonImage'}\n          >\n            <LessonImage></LessonImage>\n        </TabBarIOS.Item>\n        <TabBarIOS.Item\n          title='MovieList'\n          icon={require('./img/icon_discover_selected@3x.png')}\n          onPress={this.select.bind(this, 'MovieList')}\n          selected={this.state.tab==='MovieList'}\n          >\n            <MovieList></MovieList>\n        </TabBarIOS.Item>\n      </TabBarIOS>\n    );\n  }\n});\n```\n\n## fetch网络请求\n\n在ReactNative中，使用fetch实现了网络请求。fetch和XMLHttpRequest非常类似，是一个封装程度更高的网络API，使用起来很简洁，因为使用了Promise。\n\nPromise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件），更加合理和强大，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。简单点说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。\n\nPromise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成）、Rejected（已失败）。\n\nPromise对象生成后，可以分别指定“完成”和“失败”状态的回调函数，链式调用方法。\n\n语法：\n\n```JavaScript\nfetch(参数)\n  .then(完成的回调函数)\n  .catch(失败的回调函数)\n\n  // opts 网络请求的配置\n  fetch(url, opts)\n  .then((response) => {\n    // 网络请求成功执行该回调函数，得到相应对象，通过response可以获取请求的数据\n    // 例如：json、text等等\n\n    return response.text();\n    // return response.json();\n  })\n  .then((responseData) = > {\n    // 处理请求得到的数据\n\n  })\n  .catch((error) => {\n    // 网络请求失败执行该回调函数，得到错误信息\n\n  })\n```\n\n### GET请求\n\n\n```JavaScript\nfunction getRequest(url) {\n  var opts = {\n    method: 'GET'\n  }\n\n  fetch(url, opts)\n  .then((response) => {\n    return response.text();\n  })\n  .then((responseText) => {\n    alert(responseText);\n  })\n  .catch((error) => {\n    alert(error);\n  })\n}\n```\n\n### POST请求\n\nPOST请求需要请求参数，配置请求参数需要先认识一个类 `FromData`。\n\nWeb应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest的2级定义了FormData类型，FromData主要用于实现序列化表单已经创建与表单格式相同的数据：\n\n```JavaScript\nvar data = new FormData();\ndata.append('name', 'yjh');\n```\n\nappend方法接收两个参数：键和值，分别对应表单字段的名字和值，可添加多个键值对。\n\n> 在jquery中，‘key1=value1&key2=value2’作为参数传入对象框架会自动封装成FormData形式\n在Fetch中进行的post请求时，需要自动创建FormData对象传给body\n\n\n```JavaScript\nfunction postRequest(url) {\n  let formData = new FormData();\n  formData.append('username', 'yjh');\n  formData.append('password', '123456');\n\n  var opts = {\n    method: 'POST',\n    body: formData\n  }\n\n  fetch(url, opts)\n  .then((response) => {\n    return response.text();\n  })\n  .then((responseText) => {\n    alert(responseText);\n  })\n  .catch((error) => {\n    alert(error);\n  })\n}\n\nvar GetData = React.createClass({\n  render: function() {\n    return (\n      <View style={styles.container}>\n        <TouchableOpacity onPress={getRequest.bind(this, 'https://httpbin.org/get?userName=yjh')}>\n          <View style={styles.btn}>\n            <Text>GET</Text>\n          </View>\n        </TouchableOpacity>\n        <TouchableOpacity>\n          <View style={styles.btn} onPress={postRequest.bind(this, 'https://httpbin.org/post')}>\n            <Text>POST</Text>\n          </View>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    marginTop: 30,\n    backgroundColor: 'cyan',\n    flexDirection: 'row',\n    justifyContent: 'space-around',\n    alignItems: 'center',\n  },\n  btn: {\n    width: 60,\n    height: 30,\n    borderWidth: 1,\n    borderRadius: 3,\n    borderColor: 'black',\n    backgroundColor: 'yellow',\n    justifyContent: 'center',\n    alignItems: 'center',\n  }\n});\n\nmodule.exports = GetData;\n```\n\n\n\n### 网络请求获取电影列表数据\n\n\n```JavaScript\n/*\n  请求电影列表\n\n  未获得数据时，显示等待页面；获取数据后，显示电影列表页面\n  需要给state添加一个属性，用于记录下载状态\n*/\n\nvar REQUEST_URL = 'https://raw.githubusercontent.com/facebook/react-native/master/docs/MoviesExample.json';\n\nvar MovieList = React.createClass({\n  getInitialState: function() {\n    var ds = new ListView.DataSource({\n      rowHasChanged: (oldRow, newRow) => oldRow!==newRow\n    });\n    return {\n      loaded: false, // 数据是否请求完成\n      dataSource: ds,\n    };\n  },\n  getData: function() {\n    fetch(REQUEST_URL)\n    .then((response) => {\n      return response.json();\n    })\n    .then((responseData) => {\n      // 刷新组件，展示ListView\n      // 更新dataSource\n      this.setState({\n        loaded: true,\n        dataSource: this.state.dataSource.cloneWithRows(responseData.movies),\n      });\n    })\n    .catch((error) => {\n      alert(error);\n    })\n  },\n  render: function() {\n    // 判断请求是否完成\n    if (!this.state.loaded) {\n      return this.renderLoadingView();\n    }\n\n    // 电影列表\n    return (\n      <ListView\n        style={styles.listView}\n        dataSource={this.state.dataSource}\n        renderRow={this._renderRow}\n        renderHeader={this._renderHeader}\n        renderSeparator={this._renderSeparator}\n        // 一开始渲染的行数\n        initialListSize={10}\n      />\n    );\n  },\n  // 组件挂载完成\n  componentDidMount: function() {\n    // 组件挂载后，开始下载数据\n    this.getData();\n  },\n  // 等待请求页面\n  renderLoadingView: function() {\n    return (\n      <View style={styles.loadingContainer}>\n        <Text style={styles.loadingText}>Loading movie.....</Text>\n      </View>\n    );\n  },\n  // 渲染行组件\n  _renderRow: function(movie) {\n    return (\n      <View style={styles.row}>\n        <Image\n          style={styles.thumbnail}\n          source={{uri:movie.posters.thumbnail}}/>\n        <View style={styles.rightContainer}>\n          <Text style={styles.title}>{movie.title}</Text>\n          <Text style={styles.year}>{movie.year}</Text>\n        </View>\n      </View>\n    );\n  },\n  // 渲染头部\n  _renderHeader: function() {\n    return (\n      <View style={styles.header}>\n        <Text style={styles.header_text}>Movies List</Text>\n        <View style={styles.separator}></View>\n      </View>\n    );\n  },\n  // 渲染分隔线\n  _renderSeparator: function(sectionID:number, rowID:number) {\n    return (\n      <View style={styles.separator} key={sectionID+rowID}></View>\n    );\n  },\n});\n\n\nvar styles = StyleSheet.create({\n  // Loading样式\n  loadingContainer: {\n    flex: 1,\n    marginTop: 25,\n    backgroundColor: 'cyan',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  loadingText: {\n    fontSize: 30,\n    fontWeight: 'bold',\n    textAlign: 'center',\n    marginLeft: 10,\n    marginRight: 10,\n  },\n  // listView\n  listView: {\n    marginTop: 25,\n    flex: 1,\n    backgroundColor: '#F5FCFF',\n  },\n  row: {\n    flexDirection: 'row',\n    padding: 5,\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF'\n  },\n  thumbnail: {\n    width: 53,\n    height: 81,\n    backgroundColor: 'gray'\n  },\n  rightContainer: {\n    marginLeft: 10,\n    flex: 1,\n  },\n  title: {\n    fontSize: 10,\n    marginTop: 3,\n    marginBottom: 3,\n    textAlign: 'center'\n  },\n  year: {\n    marginBottom: 3,\n    textAlign: 'center',\n  },\n  // header\n  header: {\n    height: 44,\n    backgroundColor: '#F5FCFF',\n  },\n  header_text: {\n    flex: 1,\n    fontSize: 20,\n    fontWeight: 'bold',\n    textAlign: 'center',\n    lineHeight: 44,\n  },\n  // 分隔线\n  separator: {\n    height: 1,\n    backgroundColor: '#CCCCCC',\n  },\n});\n\nmodule.exports = MovieList;\n```\n\n## 总结\n\n截止至本章，学习 ReactNative 基础系列文章，已经把 ReactNative 基础的内容都已经过了个遍，通过这几篇文章的内容学习，相信你应该对 ReactNative 已经有个大致的了解，并且能够上手完成一个小应用了，如果你还想深入了解 ReactNative 的高级特性，可以去官网上查阅文档。\n\n","source":"_posts/Learn-ReactNative-6.md","raw":"---\ntitle: 学习ReactNative基础（六）\ndate: 2017-04-27 14:18:48\ntags: RN\ncategory: ReactNative\n---\n\n## 前言\n\n本篇文章将学习 Navigator组件、TabBarIOS组件和fetch网络请求。\n\n## Navigator 组件\n\n[官方文档](https://facebook.github.io/react-native/docs/navigator.html)\n\napp 由很多公共视图组成，一个应用中重要的功能之一是“导航”，在ReactNative中成为“路由route”，使用导航器可以让你在应用的不同场景（页面）间进行切换。\n\n在ReactNative中，有两个实现导航功能的组件：`Navigator` 和 `NavigatorIOS`\n\n* Navigator支持安卓和iOS，NavigatorIOS支持iOS\n* NavigatorIOS比Navigator具有更多的属性和方法，在UI方面可以进行更多的设置，例如：backButtonIcon、backButtonTitle、onLeftButtonPress等等，比较方便，如果想实现更多的自定义设置，建议使用Navigator\n\n### 导航功能\n\n导航器通过路由对象(route)来分辨不同的场景。每个路由对象都对应一个页面组件，开发者设置什么，导航器显示什么，所有route是导航器中重要的一个对象。\n\n三部操作实现导航功能：\n\n1. 设置路由对象（告诉导航器我要现实哪个页面），创建路由对象，对象的内容自定义，但是必须包含该场景需要展示的页面组件\n2. 场景渲染配置（告诉导航器我要什么样的页面跳转效果）\n3. 渲染场景（告诉导航器如何渲染页面）\n    利用第一步设置的路由对象进行渲染场景\n    \n    \n```JavaScript\n// 定义一个页面\n// FirstPage 一个button，点击进入下一级页面\nvar FirstPage = React.createClass({\n  // 按钮onPress事件处理方法\n  pressPush: function() {\n    // 推出下一级页面\n    var nextRoute = {\n      component: SecondPage\n    };\n    this.props.navigator.push(nextRoute);\n  },\n  render: function() {\n    return (\n      <View style={[styles.flex, {backgroundColor:'green'}]}>\n        <TouchableOpacity style={styles.btn} onPress={this.pressPush}>\n          <Text>点击推出下一级页面</Text>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n});\n\n// 定义第二个页面\n// SecondPage 一个button，点击返回上一级页面\n\nvar SecondPage = React.createClass({\n  // 按钮onPress事件处理方法\n  pressPop: function() {\n    // 返回上一级页面\n    this.props.navigator.pop();\n  },\n  render: function() {\n    return (\n      <View style={[styles.flex, {backgroundColor:'pink'}]}>\n        <TouchableOpacity style={styles.btn} onPress={this.pressPop}>\n          <Text>点击返回上一级页面</Text>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n});\n\nvar LessonNavigator = React.createClass({\n  render: function() {\n    var rootRoute = {\n      component: FirstPage\n    };\n    return(\n      <Navigator\n        /*\n          第一步：\n          initialRoute\n\n          这个指定了默认的页面，也就是启动APP之后会看到界面的第一屏\n          对象的属性是自定义的，这个对象中的内容会在renderScene方法中处理\n\n          备注：必须包含的属性，即component，表示需要渲染的页面组件\n        */\n        initialRoute={rootRoute}\n        /*\n          第二步：\n          configureScene\n\n          场景渲染的配置\n        */\n        configureScene={(route) => {\n          return Navigator.SceneConfigs.PushFromRight;\n        }}\n        /*\n          第三步：\n          renderScene\n\n          渲染场景\n\n          参数：route (第一步创建并设置给导航器的路由对象)，navigator（导航器对象）\n          实现：给需要显示的组件设置属性\n        */\n        renderScene={(route, navigator) => {\n          // 从route对象中获取页面组件\n          var Component = route.component;\n          return (\n            <Component\n              navigator={navigator}\n              route={route}\n            />\n          );\n        }}\n      />\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  flex: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  btn: {\n    width: 150,\n    height: 30,\n    backgroundColor: '#0089FF',\n    borderWidth: 1,\n    borderRadius: 3,\n    justifyContent: 'center',\n    alignItems: 'center',\n  }\n});\n\nmodule.exports = LessonNavigator;\n```\n\n### 传值功能\n\n将第一个界面输入的值，传递到第二个界面显示。\n\n```JavaScript\n// 有输入的页面\nvar InputPage = React.createClass({\n  getInitialState: function() {\n    return {\n      // 记录输入的值\n      content: ''\n    };\n  },\n  getInputContent: function(inputText) {\n    // 将输入框的值进行记录\n    this.setState({\n      content: inputText\n    });\n  },\n  pushNextPage: function() {\n    //进入下一个界面并传值\n    var route = {\n      component: DetailsPage,\n      passProps: {\n        showText: this.state.content\n      }\n    };\n    this.props.navigator.push(route);\n  },\n  render: function() {\n    return (\n      <View style={inputStyle.container}>\n        <TextInput\n          style={inputStyle.input}\n          placeholder='请输入内容'\n          onChangeText={this.getInputContent}\n        />\n        <TouchableOpacity style={inputStyle.btn} onPress={this.pushNextPage}>\n          <Text>进入下一页</Text>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n});\n\nvar inputStyle = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'white',\n  },\n  input: {\n    height: 45,\n    marginLeft: 25,\n    marginRight: 25,\n    paddingLeft: 5,\n    borderWidth: 1,\n    borderColor: 'black',\n    borderRadius: 4,\n  },\n  btn: {\n    marginTop: 20,\n    height: 30,\n    borderWidth: 1,\n    borderRadius: 4,\n    borderColor: 'black',\n    padding: 5,\n    justifyContent: 'center',\n    alignItems: 'center',\n  }\n});\n\n// 显示输入内容的页面\n\nvar DetailsPage = React.createClass({\n  popFrontPage: function() {\n    // 返回上一级\n    this.props.navigator.pop();\n  },\n  render: function() {\n    return (\n      <View style={detailStyle.container}>\n        <Text style={detailStyle.text}>{this.props.showText}</Text>\n        <TouchableOpacity style={detailStyle.btn} onPress={this.popFrontPage}>\n          <Text>返回上一页</Text>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n});\n\nvar detailStyle = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'white',\n  },\n  text: {\n    marginLeft: 25,\n    marginRight: 25,\n    padding: 25,\n    backgroundColor: 'cyan',\n    fontSize: 20,\n    textAlign: 'center',\n  },\n  btn: {\n    marginTop: 20,\n    height: 30,\n    borderWidth: 1,\n    borderRadius: 4,\n    borderColor: 'black',\n    padding: 5,\n    justifyContent: 'center',\n    alignItems: 'center',\n  }\n});\n\nvar LessonNavigator = React.createClass({\n  render: function() {\n    var rootRoute = {\n      component: InputPage,\n      // 存储需要传递的内容\n      passProps: {\n\n      }\n    };\n    return (\n      <View style={{flex:1}}>\n        <Navigator\n          initialRoute={rootRoute}\n          configureScene={(route) => {\n            return Navigator.SceneConfigs.PushFromRight;\n          }}\n          renderScene={(route, navigator) => {\n            var Component = route.component;\n            return (\n              <Component\n                navigator={navigator}\n                route={route}\n                {...route.passProps}\n              />\n            );\n          }}\n        />\n      </View>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n\n});\n\nmodule.exports = LessonNavigator;\n```\n\n## TabBarIOS\n\n[官方文档](https://facebook.github.io/react-native/docs/tabbarios.html)\n\n在ReactNative中，实现页面切换，提供了两个组件：TabBarIOS和TabBarIOS.Item，常用功能：\n\n* selected：是否选中某个Tab。如果为true则选中并显示组件\n* title： 标题\n* barTintColor：Tab栏的背景颜色\n* icon：图标\n* onPress：点击事件，当某个tab被选中时，需要改变组件的select={true}\n\n实现原理：点击tab时触发onPress方法，记录被点击tab的title。再通过title设置tab是否被选中（通过比较设置selected的值，true/false）\n\n例子：先创建三个页面，引入模块，在 `index.ios.js` 中统一装配\n\n\n```JavaScript\nvar LessonTextInput = require('./testInput');\nvar LessonImage = require('./loadImage');\nvar MovieList = require('./movieList');\n\nvar LessonTabBarIOS = React.createClass({\n  getInitialState: function() {\n    return {\n      // 记录点击tab的title\n      tab: 'LessonTextInput'\n    };\n  },\n  // TabBarIOS.Item 的onPress触发方法\n  select: function(tabName) {\n    this.setState({\n      tab: tabName\n    });\n  },\n  render: function() {\n    return (\n      <TabBarIOS style={{flex:1}}>\n        <TabBarIOS.Item\n          title='LessonTextInput'\n          icon={require('./img/icon_chat_normal@3x.png')}\n          onPress={this.select.bind(this, 'LessonTextInput')}\n          selected={this.state.tab==='LessonTextInput'}\n          >\n            <LessonTextInput></LessonTextInput>\n        </TabBarIOS.Item>\n        <TabBarIOS.Item\n          title='LessonImage'\n          systemIcon='bookmarks'\n          onPress={this.select.bind(this, 'LessonImage')}\n          selected={this.state.tab==='LessonImage'}\n          >\n            <LessonImage></LessonImage>\n        </TabBarIOS.Item>\n        <TabBarIOS.Item\n          title='MovieList'\n          icon={require('./img/icon_discover_selected@3x.png')}\n          onPress={this.select.bind(this, 'MovieList')}\n          selected={this.state.tab==='MovieList'}\n          >\n            <MovieList></MovieList>\n        </TabBarIOS.Item>\n      </TabBarIOS>\n    );\n  }\n});\n```\n\n## fetch网络请求\n\n在ReactNative中，使用fetch实现了网络请求。fetch和XMLHttpRequest非常类似，是一个封装程度更高的网络API，使用起来很简洁，因为使用了Promise。\n\nPromise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件），更加合理和强大，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。简单点说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。\n\nPromise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成）、Rejected（已失败）。\n\nPromise对象生成后，可以分别指定“完成”和“失败”状态的回调函数，链式调用方法。\n\n语法：\n\n```JavaScript\nfetch(参数)\n  .then(完成的回调函数)\n  .catch(失败的回调函数)\n\n  // opts 网络请求的配置\n  fetch(url, opts)\n  .then((response) => {\n    // 网络请求成功执行该回调函数，得到相应对象，通过response可以获取请求的数据\n    // 例如：json、text等等\n\n    return response.text();\n    // return response.json();\n  })\n  .then((responseData) = > {\n    // 处理请求得到的数据\n\n  })\n  .catch((error) => {\n    // 网络请求失败执行该回调函数，得到错误信息\n\n  })\n```\n\n### GET请求\n\n\n```JavaScript\nfunction getRequest(url) {\n  var opts = {\n    method: 'GET'\n  }\n\n  fetch(url, opts)\n  .then((response) => {\n    return response.text();\n  })\n  .then((responseText) => {\n    alert(responseText);\n  })\n  .catch((error) => {\n    alert(error);\n  })\n}\n```\n\n### POST请求\n\nPOST请求需要请求参数，配置请求参数需要先认识一个类 `FromData`。\n\nWeb应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest的2级定义了FormData类型，FromData主要用于实现序列化表单已经创建与表单格式相同的数据：\n\n```JavaScript\nvar data = new FormData();\ndata.append('name', 'yjh');\n```\n\nappend方法接收两个参数：键和值，分别对应表单字段的名字和值，可添加多个键值对。\n\n> 在jquery中，‘key1=value1&key2=value2’作为参数传入对象框架会自动封装成FormData形式\n在Fetch中进行的post请求时，需要自动创建FormData对象传给body\n\n\n```JavaScript\nfunction postRequest(url) {\n  let formData = new FormData();\n  formData.append('username', 'yjh');\n  formData.append('password', '123456');\n\n  var opts = {\n    method: 'POST',\n    body: formData\n  }\n\n  fetch(url, opts)\n  .then((response) => {\n    return response.text();\n  })\n  .then((responseText) => {\n    alert(responseText);\n  })\n  .catch((error) => {\n    alert(error);\n  })\n}\n\nvar GetData = React.createClass({\n  render: function() {\n    return (\n      <View style={styles.container}>\n        <TouchableOpacity onPress={getRequest.bind(this, 'https://httpbin.org/get?userName=yjh')}>\n          <View style={styles.btn}>\n            <Text>GET</Text>\n          </View>\n        </TouchableOpacity>\n        <TouchableOpacity>\n          <View style={styles.btn} onPress={postRequest.bind(this, 'https://httpbin.org/post')}>\n            <Text>POST</Text>\n          </View>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    marginTop: 30,\n    backgroundColor: 'cyan',\n    flexDirection: 'row',\n    justifyContent: 'space-around',\n    alignItems: 'center',\n  },\n  btn: {\n    width: 60,\n    height: 30,\n    borderWidth: 1,\n    borderRadius: 3,\n    borderColor: 'black',\n    backgroundColor: 'yellow',\n    justifyContent: 'center',\n    alignItems: 'center',\n  }\n});\n\nmodule.exports = GetData;\n```\n\n\n\n### 网络请求获取电影列表数据\n\n\n```JavaScript\n/*\n  请求电影列表\n\n  未获得数据时，显示等待页面；获取数据后，显示电影列表页面\n  需要给state添加一个属性，用于记录下载状态\n*/\n\nvar REQUEST_URL = 'https://raw.githubusercontent.com/facebook/react-native/master/docs/MoviesExample.json';\n\nvar MovieList = React.createClass({\n  getInitialState: function() {\n    var ds = new ListView.DataSource({\n      rowHasChanged: (oldRow, newRow) => oldRow!==newRow\n    });\n    return {\n      loaded: false, // 数据是否请求完成\n      dataSource: ds,\n    };\n  },\n  getData: function() {\n    fetch(REQUEST_URL)\n    .then((response) => {\n      return response.json();\n    })\n    .then((responseData) => {\n      // 刷新组件，展示ListView\n      // 更新dataSource\n      this.setState({\n        loaded: true,\n        dataSource: this.state.dataSource.cloneWithRows(responseData.movies),\n      });\n    })\n    .catch((error) => {\n      alert(error);\n    })\n  },\n  render: function() {\n    // 判断请求是否完成\n    if (!this.state.loaded) {\n      return this.renderLoadingView();\n    }\n\n    // 电影列表\n    return (\n      <ListView\n        style={styles.listView}\n        dataSource={this.state.dataSource}\n        renderRow={this._renderRow}\n        renderHeader={this._renderHeader}\n        renderSeparator={this._renderSeparator}\n        // 一开始渲染的行数\n        initialListSize={10}\n      />\n    );\n  },\n  // 组件挂载完成\n  componentDidMount: function() {\n    // 组件挂载后，开始下载数据\n    this.getData();\n  },\n  // 等待请求页面\n  renderLoadingView: function() {\n    return (\n      <View style={styles.loadingContainer}>\n        <Text style={styles.loadingText}>Loading movie.....</Text>\n      </View>\n    );\n  },\n  // 渲染行组件\n  _renderRow: function(movie) {\n    return (\n      <View style={styles.row}>\n        <Image\n          style={styles.thumbnail}\n          source={{uri:movie.posters.thumbnail}}/>\n        <View style={styles.rightContainer}>\n          <Text style={styles.title}>{movie.title}</Text>\n          <Text style={styles.year}>{movie.year}</Text>\n        </View>\n      </View>\n    );\n  },\n  // 渲染头部\n  _renderHeader: function() {\n    return (\n      <View style={styles.header}>\n        <Text style={styles.header_text}>Movies List</Text>\n        <View style={styles.separator}></View>\n      </View>\n    );\n  },\n  // 渲染分隔线\n  _renderSeparator: function(sectionID:number, rowID:number) {\n    return (\n      <View style={styles.separator} key={sectionID+rowID}></View>\n    );\n  },\n});\n\n\nvar styles = StyleSheet.create({\n  // Loading样式\n  loadingContainer: {\n    flex: 1,\n    marginTop: 25,\n    backgroundColor: 'cyan',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  loadingText: {\n    fontSize: 30,\n    fontWeight: 'bold',\n    textAlign: 'center',\n    marginLeft: 10,\n    marginRight: 10,\n  },\n  // listView\n  listView: {\n    marginTop: 25,\n    flex: 1,\n    backgroundColor: '#F5FCFF',\n  },\n  row: {\n    flexDirection: 'row',\n    padding: 5,\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF'\n  },\n  thumbnail: {\n    width: 53,\n    height: 81,\n    backgroundColor: 'gray'\n  },\n  rightContainer: {\n    marginLeft: 10,\n    flex: 1,\n  },\n  title: {\n    fontSize: 10,\n    marginTop: 3,\n    marginBottom: 3,\n    textAlign: 'center'\n  },\n  year: {\n    marginBottom: 3,\n    textAlign: 'center',\n  },\n  // header\n  header: {\n    height: 44,\n    backgroundColor: '#F5FCFF',\n  },\n  header_text: {\n    flex: 1,\n    fontSize: 20,\n    fontWeight: 'bold',\n    textAlign: 'center',\n    lineHeight: 44,\n  },\n  // 分隔线\n  separator: {\n    height: 1,\n    backgroundColor: '#CCCCCC',\n  },\n});\n\nmodule.exports = MovieList;\n```\n\n## 总结\n\n截止至本章，学习 ReactNative 基础系列文章，已经把 ReactNative 基础的内容都已经过了个遍，通过这几篇文章的内容学习，相信你应该对 ReactNative 已经有个大致的了解，并且能够上手完成一个小应用了，如果你还想深入了解 ReactNative 的高级特性，可以去官网上查阅文档。\n\n","slug":"Learn-ReactNative-6","published":1,"updated":"2017-05-01T06:48:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7pu005d8jpbmas5bxkc","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇文章将学习 Navigator组件、TabBarIOS组件和fetch网络请求。</p>\n<h2 id=\"Navigator-组件\"><a href=\"#Navigator-组件\" class=\"headerlink\" title=\"Navigator 组件\"></a>Navigator 组件</h2><p><a href=\"https://facebook.github.io/react-native/docs/navigator.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p>app 由很多公共视图组成，一个应用中重要的功能之一是“导航”，在ReactNative中成为“路由route”，使用导航器可以让你在应用的不同场景（页面）间进行切换。</p>\n<p>在ReactNative中，有两个实现导航功能的组件：<code>Navigator</code> 和 <code>NavigatorIOS</code></p>\n<ul>\n<li>Navigator支持安卓和iOS，NavigatorIOS支持iOS</li>\n<li>NavigatorIOS比Navigator具有更多的属性和方法，在UI方面可以进行更多的设置，例如：backButtonIcon、backButtonTitle、onLeftButtonPress等等，比较方便，如果想实现更多的自定义设置，建议使用Navigator</li>\n</ul>\n<h3 id=\"导航功能\"><a href=\"#导航功能\" class=\"headerlink\" title=\"导航功能\"></a>导航功能</h3><p>导航器通过路由对象(route)来分辨不同的场景。每个路由对象都对应一个页面组件，开发者设置什么，导航器显示什么，所有route是导航器中重要的一个对象。</p>\n<p>三部操作实现导航功能：</p>\n<ol>\n<li>设置路由对象（告诉导航器我要现实哪个页面），创建路由对象，对象的内容自定义，但是必须包含该场景需要展示的页面组件</li>\n<li>场景渲染配置（告诉导航器我要什么样的页面跳转效果）</li>\n<li>渲染场景（告诉导航器如何渲染页面）<br> 利用第一步设置的路由对象进行渲染场景</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个页面</span></span><br><span class=\"line\"><span class=\"comment\">// FirstPage 一个button，点击进入下一级页面</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> FirstPage = React.createClass(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 按钮onPress事件处理方法</span></span><br><span class=\"line\">  pressPush: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 推出下一级页面</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextRoute = &#123;</span><br><span class=\"line\">      component: SecondPage</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.navigator.push(nextRoute);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;[styles.flex, &#123;<span class=\"attr\">backgroundColor</span>:<span class=\"string\">'green'</span>&#125;]&#125;&gt;</span><br><span class=\"line\">        &lt;TouchableOpacity style=&#123;styles.btn&#125; onPress=&#123;<span class=\"keyword\">this</span>.pressPush&#125;&gt;</span><br><span class=\"line\">          &lt;Text&gt;点击推出下一级页面&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>TouchableOpacity&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 定义第二个页面</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ SecondPage 一个button，点击返回上一级页面</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var SecondPage = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ 按钮onPress事件处理方法</span></span><br><span class=\"line\"><span class=\"regexp\">  pressPop: function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 返回上一级页面</span></span><br><span class=\"line\"><span class=\"regexp\">    this.props.navigator.pop();</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  render: function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;View style=&#123;[styles.flex, &#123;backgroundColor:'pink'&#125;]&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TouchableOpacity style=&#123;styles.btn&#125; onPress=&#123;this.pressPop&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Text&gt;点击返回上一级页面&lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TouchableOpacity&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> LessonNavigator = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rootRoute = &#123;</span><br><span class=\"line\">      component: FirstPage</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">      &lt;Navigator</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          第一步：</span></span><br><span class=\"line\"><span class=\"comment\">          initialRoute</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          这个指定了默认的页面，也就是启动APP之后会看到界面的第一屏</span></span><br><span class=\"line\"><span class=\"comment\">          对象的属性是自定义的，这个对象中的内容会在renderScene方法中处理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          备注：必须包含的属性，即component，表示需要渲染的页面组件</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        initialRoute=&#123;rootRoute&#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          第二步：</span></span><br><span class=\"line\"><span class=\"comment\">          configureScene</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          场景渲染的配置</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        configureScene=&#123;(route) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> Navigator.SceneConfigs.PushFromRight;</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          第三步：</span></span><br><span class=\"line\"><span class=\"comment\">          renderScene</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          渲染场景</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          参数：route (第一步创建并设置给导航器的路由对象)，navigator（导航器对象）</span></span><br><span class=\"line\"><span class=\"comment\">          实现：给需要显示的组件设置属性</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        renderScene=&#123;(route, navigator) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 从route对象中获取页面组件</span></span><br><span class=\"line\">          <span class=\"keyword\">var</span> Component = route.component;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;Component</span><br><span class=\"line\">              navigator=&#123;navigator&#125;</span><br><span class=\"line\">              route=&#123;route&#125;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  flex: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  btn: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">150</span>,</span><br><span class=\"line\">    height: <span class=\"number\">30</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#0089FF'</span>,</span><br><span class=\"line\">    borderWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    borderRadius: <span class=\"number\">3</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = LessonNavigator;</span><br></pre></td></tr></table></figure>\n<h3 id=\"传值功能\"><a href=\"#传值功能\" class=\"headerlink\" title=\"传值功能\"></a>传值功能</h3><p>将第一个界面输入的值，传递到第二个界面显示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有输入的页面</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> InputPage = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 记录输入的值</span></span><br><span class=\"line\">      content: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getInputContent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">inputText</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将输入框的值进行记录</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      content: inputText</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  pushNextPage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//进入下一个界面并传值</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> route = &#123;</span><br><span class=\"line\">      component: DetailsPage,</span><br><span class=\"line\">      passProps: &#123;</span><br><span class=\"line\">        showText: <span class=\"keyword\">this</span>.state.content</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.navigator.push(route);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;inputStyle.container&#125;&gt;</span><br><span class=\"line\">        &lt;TextInput</span><br><span class=\"line\">          style=&#123;inputStyle.input&#125;</span><br><span class=\"line\">          placeholder=<span class=\"string\">'请输入内容'</span></span><br><span class=\"line\">          onChangeText=&#123;<span class=\"keyword\">this</span>.getInputContent&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">        &lt;TouchableOpacity style=&#123;inputStyle.btn&#125; onPress=&#123;<span class=\"keyword\">this</span>.pushNextPage&#125;&gt;</span><br><span class=\"line\">          &lt;Text&gt;进入下一页&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>TouchableOpacity&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var inputStyle = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  container: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    flex: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    justifyContent: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'white',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  input: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 45,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginLeft: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginRight: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    paddingLeft: 5,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderWidth: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderColor: 'black',</span></span><br><span class=\"line\"><span class=\"regexp\">    borderRadius: 4,</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  btn: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    marginTop: 20,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 30,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderWidth: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderRadius: 4,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderColor: 'black',</span></span><br><span class=\"line\"><span class=\"regexp\">    padding: 5,</span></span><br><span class=\"line\"><span class=\"regexp\">    justifyContent: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 显示输入内容的页面</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var DetailsPage = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  popFrontPage: function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 返回上一级</span></span><br><span class=\"line\"><span class=\"regexp\">    this.props.navigator.pop();</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  render: function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;View style=&#123;detailStyle.container&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Text style=&#123;detailStyle.text&#125;&gt;&#123;this.props.showText&#125;&lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;TouchableOpacity style=&#123;detailStyle.btn&#125; onPress=&#123;<span class=\"keyword\">this</span>.popFrontPage&#125;&gt;</span><br><span class=\"line\">          &lt;Text&gt;返回上一页&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>TouchableOpacity&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var detailStyle = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  container: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    flex: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    justifyContent: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'white',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  text: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    marginLeft: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginRight: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    padding: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'cyan',</span></span><br><span class=\"line\"><span class=\"regexp\">    fontSize: 20,</span></span><br><span class=\"line\"><span class=\"regexp\">    textAlign: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  btn: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    marginTop: 20,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 30,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderWidth: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderRadius: 4,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderColor: 'black',</span></span><br><span class=\"line\"><span class=\"regexp\">    padding: 5,</span></span><br><span class=\"line\"><span class=\"regexp\">    justifyContent: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var LessonNavigator = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  render: function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    var rootRoute = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      component: InputPage,</span></span><br><span class=\"line\"><span class=\"regexp\">      /</span><span class=\"regexp\">/ 存储需要传递的内容</span></span><br><span class=\"line\"><span class=\"regexp\">      passProps: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Navigator</span></span><br><span class=\"line\"><span class=\"regexp\">          initialRoute=&#123;rootRoute&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          configureScene=&#123;(route) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            return Navigator.SceneConfigs.PushFromRight;</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          renderScene=&#123;(route, navigator) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            var Component = route.component;</span></span><br><span class=\"line\"><span class=\"regexp\">            return (</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;Component</span></span><br><span class=\"line\"><span class=\"regexp\">                navigator=&#123;navigator&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">                route=&#123;route&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;...route.passProps&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">              /</span>&gt;</span><br><span class=\"line\">            );</span><br><span class=\"line\">          &#125;&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">module.exports = LessonNavigator;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"TabBarIOS\"><a href=\"#TabBarIOS\" class=\"headerlink\" title=\"TabBarIOS\"></a>TabBarIOS</h2><p><a href=\"https://facebook.github.io/react-native/docs/tabbarios.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p>在ReactNative中，实现页面切换，提供了两个组件：TabBarIOS和TabBarIOS.Item，常用功能：</p>\n<ul>\n<li>selected：是否选中某个Tab。如果为true则选中并显示组件</li>\n<li>title： 标题</li>\n<li>barTintColor：Tab栏的背景颜色</li>\n<li>icon：图标</li>\n<li>onPress：点击事件，当某个tab被选中时，需要改变组件的select={true}</li>\n</ul>\n<p>实现原理：点击tab时触发onPress方法，记录被点击tab的title。再通过title设置tab是否被选中（通过比较设置selected的值，true/false）</p>\n<p>例子：先创建三个页面，引入模块，在 <code>index.ios.js</code> 中统一装配</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> LessonTextInput = <span class=\"built_in\">require</span>(<span class=\"string\">'./testInput'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> LessonImage = <span class=\"built_in\">require</span>(<span class=\"string\">'./loadImage'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> MovieList = <span class=\"built_in\">require</span>(<span class=\"string\">'./movieList'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> LessonTabBarIOS = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 记录点击tab的title</span></span><br><span class=\"line\">      tab: <span class=\"string\">'LessonTextInput'</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// TabBarIOS.Item 的onPress触发方法</span></span><br><span class=\"line\">  select: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tabName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      tab: tabName</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;TabBarIOS style=&#123;&#123;<span class=\"attr\">flex</span>:<span class=\"number\">1</span>&#125;&#125;&gt;</span><br><span class=\"line\">        &lt;TabBarIOS.Item</span><br><span class=\"line\">          title=<span class=\"string\">'LessonTextInput'</span></span><br><span class=\"line\">          icon=&#123;<span class=\"built_in\">require</span>(<span class=\"string\">'./img/icon_chat_normal@3x.png'</span>)&#125;</span><br><span class=\"line\">          onPress=&#123;<span class=\"keyword\">this</span>.select.bind(<span class=\"keyword\">this</span>, <span class=\"string\">'LessonTextInput'</span>)&#125;</span><br><span class=\"line\">          selected=&#123;<span class=\"keyword\">this</span>.state.tab===<span class=\"string\">'LessonTextInput'</span>&#125;</span><br><span class=\"line\">          &gt;</span><br><span class=\"line\">            &lt;LessonTextInput&gt;&lt;/LessonTextInput&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TabBarIOS.Item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TabBarIOS.Item</span></span><br><span class=\"line\"><span class=\"regexp\">          title='LessonImage'</span></span><br><span class=\"line\"><span class=\"regexp\">          systemIcon='bookmarks'</span></span><br><span class=\"line\"><span class=\"regexp\">          onPress=&#123;this.select.bind(this, 'LessonImage')&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          selected=&#123;this.state.tab==='LessonImage'&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          &gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;LessonImage&gt;&lt;/</span>LessonImage&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TabBarIOS.Item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TabBarIOS.Item</span></span><br><span class=\"line\"><span class=\"regexp\">          title='MovieList'</span></span><br><span class=\"line\"><span class=\"regexp\">          icon=&#123;require('./img</span><span class=\"regexp\">/icon_discover_selected@3x.png')&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          onPress=&#123;this.select.bind(this, 'MovieList')&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          selected=&#123;this.state.tab==='MovieList'&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          &gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;MovieList&gt;&lt;/</span>MovieList&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TabBarIOS.Item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>TabBarIOS&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"fetch网络请求\"><a href=\"#fetch网络请求\" class=\"headerlink\" title=\"fetch网络请求\"></a>fetch网络请求</h2><p>在ReactNative中，使用fetch实现了网络请求。fetch和XMLHttpRequest非常类似，是一个封装程度更高的网络API，使用起来很简洁，因为使用了Promise。</p>\n<p>Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件），更加合理和强大，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。简单点说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>\n<p>Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成）、Rejected（已失败）。</p>\n<p>Promise对象生成后，可以分别指定“完成”和“失败”状态的回调函数，链式调用方法。</p>\n<p>语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(参数)</span><br><span class=\"line\">  .then(完成的回调函数)</span><br><span class=\"line\">  .catch(失败的回调函数)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// opts 网络请求的配置</span></span><br><span class=\"line\">  fetch(url, opts)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求成功执行该回调函数，得到相应对象，通过response可以获取请求的数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 例如：json、text等等</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">    <span class=\"comment\">// return response.json();</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then((responseData) = &gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理请求得到的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求失败执行该回调函数，得到错误信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a>GET请求</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRequest</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> opts = &#123;</span><br><span class=\"line\">    method: <span class=\"string\">'GET'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fetch(url, opts)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">responseText</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    alert(responseText);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    alert(error);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"POST请求\"><a href=\"#POST请求\" class=\"headerlink\" title=\"POST请求\"></a>POST请求</h3><p>POST请求需要请求参数，配置请求参数需要先认识一个类 <code>FromData</code>。</p>\n<p>Web应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest的2级定义了FormData类型，FromData主要用于实现序列化表单已经创建与表单格式相同的数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">data.append(<span class=\"string\">'name'</span>, <span class=\"string\">'yjh'</span>);</span><br></pre></td></tr></table></figure>\n<p>append方法接收两个参数：键和值，分别对应表单字段的名字和值，可添加多个键值对。</p>\n<blockquote>\n<p>在jquery中，‘key1=value1&amp;key2=value2’作为参数传入对象框架会自动封装成FormData形式<br>在Fetch中进行的post请求时，需要自动创建FormData对象传给body</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postRequest</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> formData = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">  formData.append(<span class=\"string\">'username'</span>, <span class=\"string\">'yjh'</span>);</span><br><span class=\"line\">  formData.append(<span class=\"string\">'password'</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> opts = &#123;</span><br><span class=\"line\">    method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    body: formData</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fetch(url, opts)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">responseText</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    alert(responseText);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    alert(error);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetData = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;TouchableOpacity onPress=&#123;getRequest.bind(<span class=\"keyword\">this</span>, <span class=\"string\">'https://httpbin.org/get?userName=yjh'</span>)&#125;&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.btn&#125;&gt;</span><br><span class=\"line\">            &lt;Text&gt;GET&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>View&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TouchableOpacity&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TouchableOpacity&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;View style=&#123;styles.btn&#125; onPress=&#123;postRequest.bind(this, 'https:/</span><span class=\"regexp\">/httpbin.org/</span>post<span class=\"string\">')&#125;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;Text&gt;POST&lt;/Text&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;/View&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/TouchableOpacity&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/View&gt;</span></span><br><span class=\"line\"><span class=\"string\">    );</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">var styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"string\">  container: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    flex: 1,</span></span><br><span class=\"line\"><span class=\"string\">    marginTop: 30,</span></span><br><span class=\"line\"><span class=\"string\">    backgroundColor: '</span>cyan<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    flexDirection: '</span>row<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    justifyContent: '</span>space-around<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    alignItems: '</span>center<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">  &#125;,</span></span><br><span class=\"line\"><span class=\"string\">  btn: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    width: 60,</span></span><br><span class=\"line\"><span class=\"string\">    height: 30,</span></span><br><span class=\"line\"><span class=\"string\">    borderWidth: 1,</span></span><br><span class=\"line\"><span class=\"string\">    borderRadius: 3,</span></span><br><span class=\"line\"><span class=\"string\">    borderColor: '</span>black<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    backgroundColor: '</span>yellow<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    justifyContent: '</span>center<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    alignItems: '</span>center<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">module.exports = GetData;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"网络请求获取电影列表数据\"><a href=\"#网络请求获取电影列表数据\" class=\"headerlink\" title=\"网络请求获取电影列表数据\"></a>网络请求获取电影列表数据</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  请求电影列表</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">  未获得数据时，显示等待页面；获取数据后，显示电影列表页面</span></span><br><span class=\"line\"><span class=\"comment\">  需要给state添加一个属性，用于记录下载状态</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> REQUEST_URL = <span class=\"string\">'https://raw.githubusercontent.com/facebook/react-native/master/docs/MoviesExample.json'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> MovieList = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ds = <span class=\"keyword\">new</span> ListView.DataSource(&#123;</span><br><span class=\"line\">      rowHasChanged: <span class=\"function\">(<span class=\"params\">oldRow, newRow</span>) =&gt;</span> oldRow!==newRow</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      loaded: <span class=\"literal\">false</span>, <span class=\"comment\">// 数据是否请求完成</span></span><br><span class=\"line\">      dataSource: ds,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    fetch(REQUEST_URL)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> response.json();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">responseData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 刷新组件，展示ListView</span></span><br><span class=\"line\">      <span class=\"comment\">// 更新dataSource</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        loaded: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        dataSource: <span class=\"keyword\">this</span>.state.dataSource.cloneWithRows(responseData.movies),</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      alert(error);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断请求是否完成</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.state.loaded) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.renderLoadingView();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 电影列表</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ListView</span><br><span class=\"line\">        style=&#123;styles.listView&#125;</span><br><span class=\"line\">        dataSource=&#123;<span class=\"keyword\">this</span>.state.dataSource&#125;</span><br><span class=\"line\">        renderRow=&#123;<span class=\"keyword\">this</span>._renderRow&#125;</span><br><span class=\"line\">        renderHeader=&#123;<span class=\"keyword\">this</span>._renderHeader&#125;</span><br><span class=\"line\">        renderSeparator=&#123;<span class=\"keyword\">this</span>._renderSeparator&#125;</span><br><span class=\"line\">        <span class=\"comment\">// 一开始渲染的行数</span></span><br><span class=\"line\">        initialListSize=&#123;<span class=\"number\">10</span>&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 组件挂载完成</span></span><br><span class=\"line\">  componentDidMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 组件挂载后，开始下载数据</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getData();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 等待请求页面</span></span><br><span class=\"line\">  renderLoadingView: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.loadingContainer&#125;&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.loadingText&#125;&gt;Loading movie.....&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 渲染行组件</span></span><br><span class=\"line\">  _renderRow: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">movie</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.row&#125;&gt;</span><br><span class=\"line\">        &lt;Image</span><br><span class=\"line\">          style=&#123;styles.thumbnail&#125;</span><br><span class=\"line\">          source=&#123;&#123;<span class=\"attr\">uri</span>:movie.posters.thumbnail&#125;&#125;/&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.rightContainer&#125;&gt;</span><br><span class=\"line\">          &lt;Text style=&#123;styles.title&#125;&gt;&#123;movie.title&#125;&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Text style=&#123;styles.year&#125;&gt;&#123;movie.year&#125;&lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 渲染头部</span></span><br><span class=\"line\">  _renderHeader: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.header&#125;&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.header_text&#125;&gt;Movies List&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;View style=&#123;styles.separator&#125;&gt;&lt;/</span>View&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ 渲染分隔线</span></span><br><span class=\"line\"><span class=\"regexp\">  _renderSeparator: function(sectionID:number, rowID:number) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;View style=&#123;styles.separator&#125; key=&#123;sectionID+rowID&#125;&gt;&lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Loading样式</span></span><br><span class=\"line\">  loadingContainer: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'cyan'</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  loadingText: &#123;</span><br><span class=\"line\">    fontSize: <span class=\"number\">30</span>,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">10</span>,</span><br><span class=\"line\">    marginRight: <span class=\"number\">10</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// listView</span></span><br><span class=\"line\">  listView: &#123;</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  row: &#123;</span><br><span class=\"line\">    flexDirection: <span class=\"string\">'row'</span>,</span><br><span class=\"line\">    padding: <span class=\"number\">5</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  thumbnail: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">53</span>,</span><br><span class=\"line\">    height: <span class=\"number\">81</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'gray'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  rightContainer: &#123;</span><br><span class=\"line\">    marginLeft: <span class=\"number\">10</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  title: &#123;</span><br><span class=\"line\">    fontSize: <span class=\"number\">10</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">3</span>,</span><br><span class=\"line\">    marginBottom: <span class=\"number\">3</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  year: &#123;</span><br><span class=\"line\">    marginBottom: <span class=\"number\">3</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// header</span></span><br><span class=\"line\">  header: &#123;</span><br><span class=\"line\">    height: <span class=\"number\">44</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  header_text: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    fontSize: <span class=\"number\">20</span>,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    lineHeight: <span class=\"number\">44</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 分隔线</span></span><br><span class=\"line\">  separator: &#123;</span><br><span class=\"line\">    height: <span class=\"number\">1</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#CCCCCC'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = MovieList;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>截止至本章，学习 ReactNative 基础系列文章，已经把 ReactNative 基础的内容都已经过了个遍，通过这几篇文章的内容学习，相信你应该对 ReactNative 已经有个大致的了解，并且能够上手完成一个小应用了，如果你还想深入了解 ReactNative 的高级特性，可以去官网上查阅文档。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇文章将学习 Navigator组件、TabBarIOS组件和fetch网络请求。</p>\n<h2 id=\"Navigator-组件\"><a href=\"#Navigator-组件\" class=\"headerlink\" title=\"Navigator 组件\"></a>Navigator 组件</h2><p><a href=\"https://facebook.github.io/react-native/docs/navigator.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p>app 由很多公共视图组成，一个应用中重要的功能之一是“导航”，在ReactNative中成为“路由route”，使用导航器可以让你在应用的不同场景（页面）间进行切换。</p>\n<p>在ReactNative中，有两个实现导航功能的组件：<code>Navigator</code> 和 <code>NavigatorIOS</code></p>\n<ul>\n<li>Navigator支持安卓和iOS，NavigatorIOS支持iOS</li>\n<li>NavigatorIOS比Navigator具有更多的属性和方法，在UI方面可以进行更多的设置，例如：backButtonIcon、backButtonTitle、onLeftButtonPress等等，比较方便，如果想实现更多的自定义设置，建议使用Navigator</li>\n</ul>\n<h3 id=\"导航功能\"><a href=\"#导航功能\" class=\"headerlink\" title=\"导航功能\"></a>导航功能</h3><p>导航器通过路由对象(route)来分辨不同的场景。每个路由对象都对应一个页面组件，开发者设置什么，导航器显示什么，所有route是导航器中重要的一个对象。</p>\n<p>三部操作实现导航功能：</p>\n<ol>\n<li>设置路由对象（告诉导航器我要现实哪个页面），创建路由对象，对象的内容自定义，但是必须包含该场景需要展示的页面组件</li>\n<li>场景渲染配置（告诉导航器我要什么样的页面跳转效果）</li>\n<li>渲染场景（告诉导航器如何渲染页面）<br> 利用第一步设置的路由对象进行渲染场景</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个页面</span></span><br><span class=\"line\"><span class=\"comment\">// FirstPage 一个button，点击进入下一级页面</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> FirstPage = React.createClass(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 按钮onPress事件处理方法</span></span><br><span class=\"line\">  pressPush: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 推出下一级页面</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextRoute = &#123;</span><br><span class=\"line\">      component: SecondPage</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.navigator.push(nextRoute);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;[styles.flex, &#123;<span class=\"attr\">backgroundColor</span>:<span class=\"string\">'green'</span>&#125;]&#125;&gt;</span><br><span class=\"line\">        &lt;TouchableOpacity style=&#123;styles.btn&#125; onPress=&#123;<span class=\"keyword\">this</span>.pressPush&#125;&gt;</span><br><span class=\"line\">          &lt;Text&gt;点击推出下一级页面&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>TouchableOpacity&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 定义第二个页面</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ SecondPage 一个button，点击返回上一级页面</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var SecondPage = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ 按钮onPress事件处理方法</span></span><br><span class=\"line\"><span class=\"regexp\">  pressPop: function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 返回上一级页面</span></span><br><span class=\"line\"><span class=\"regexp\">    this.props.navigator.pop();</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  render: function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;View style=&#123;[styles.flex, &#123;backgroundColor:'pink'&#125;]&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TouchableOpacity style=&#123;styles.btn&#125; onPress=&#123;this.pressPop&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Text&gt;点击返回上一级页面&lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TouchableOpacity&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> LessonNavigator = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rootRoute = &#123;</span><br><span class=\"line\">      component: FirstPage</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">      &lt;Navigator</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          第一步：</span></span><br><span class=\"line\"><span class=\"comment\">          initialRoute</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          这个指定了默认的页面，也就是启动APP之后会看到界面的第一屏</span></span><br><span class=\"line\"><span class=\"comment\">          对象的属性是自定义的，这个对象中的内容会在renderScene方法中处理</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          备注：必须包含的属性，即component，表示需要渲染的页面组件</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        initialRoute=&#123;rootRoute&#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          第二步：</span></span><br><span class=\"line\"><span class=\"comment\">          configureScene</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          场景渲染的配置</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        configureScene=&#123;(route) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> Navigator.SceneConfigs.PushFromRight;</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          第三步：</span></span><br><span class=\"line\"><span class=\"comment\">          renderScene</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          渲染场景</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          参数：route (第一步创建并设置给导航器的路由对象)，navigator（导航器对象）</span></span><br><span class=\"line\"><span class=\"comment\">          实现：给需要显示的组件设置属性</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        renderScene=&#123;(route, navigator) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 从route对象中获取页面组件</span></span><br><span class=\"line\">          <span class=\"keyword\">var</span> Component = route.component;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;Component</span><br><span class=\"line\">              navigator=&#123;navigator&#125;</span><br><span class=\"line\">              route=&#123;route&#125;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  flex: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  btn: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">150</span>,</span><br><span class=\"line\">    height: <span class=\"number\">30</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#0089FF'</span>,</span><br><span class=\"line\">    borderWidth: <span class=\"number\">1</span>,</span><br><span class=\"line\">    borderRadius: <span class=\"number\">3</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = LessonNavigator;</span><br></pre></td></tr></table></figure>\n<h3 id=\"传值功能\"><a href=\"#传值功能\" class=\"headerlink\" title=\"传值功能\"></a>传值功能</h3><p>将第一个界面输入的值，传递到第二个界面显示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有输入的页面</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> InputPage = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 记录输入的值</span></span><br><span class=\"line\">      content: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getInputContent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">inputText</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将输入框的值进行记录</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      content: inputText</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  pushNextPage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//进入下一个界面并传值</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> route = &#123;</span><br><span class=\"line\">      component: DetailsPage,</span><br><span class=\"line\">      passProps: &#123;</span><br><span class=\"line\">        showText: <span class=\"keyword\">this</span>.state.content</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.navigator.push(route);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;inputStyle.container&#125;&gt;</span><br><span class=\"line\">        &lt;TextInput</span><br><span class=\"line\">          style=&#123;inputStyle.input&#125;</span><br><span class=\"line\">          placeholder=<span class=\"string\">'请输入内容'</span></span><br><span class=\"line\">          onChangeText=&#123;<span class=\"keyword\">this</span>.getInputContent&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">        &lt;TouchableOpacity style=&#123;inputStyle.btn&#125; onPress=&#123;<span class=\"keyword\">this</span>.pushNextPage&#125;&gt;</span><br><span class=\"line\">          &lt;Text&gt;进入下一页&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>TouchableOpacity&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var inputStyle = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  container: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    flex: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    justifyContent: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'white',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  input: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 45,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginLeft: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginRight: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    paddingLeft: 5,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderWidth: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderColor: 'black',</span></span><br><span class=\"line\"><span class=\"regexp\">    borderRadius: 4,</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  btn: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    marginTop: 20,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 30,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderWidth: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderRadius: 4,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderColor: 'black',</span></span><br><span class=\"line\"><span class=\"regexp\">    padding: 5,</span></span><br><span class=\"line\"><span class=\"regexp\">    justifyContent: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 显示输入内容的页面</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var DetailsPage = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  popFrontPage: function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 返回上一级</span></span><br><span class=\"line\"><span class=\"regexp\">    this.props.navigator.pop();</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  render: function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;View style=&#123;detailStyle.container&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Text style=&#123;detailStyle.text&#125;&gt;&#123;this.props.showText&#125;&lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;TouchableOpacity style=&#123;detailStyle.btn&#125; onPress=&#123;<span class=\"keyword\">this</span>.popFrontPage&#125;&gt;</span><br><span class=\"line\">          &lt;Text&gt;返回上一页&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>TouchableOpacity&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var detailStyle = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  container: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    flex: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    justifyContent: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'white',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  text: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    marginLeft: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    marginRight: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    padding: 25,</span></span><br><span class=\"line\"><span class=\"regexp\">    backgroundColor: 'cyan',</span></span><br><span class=\"line\"><span class=\"regexp\">    fontSize: 20,</span></span><br><span class=\"line\"><span class=\"regexp\">    textAlign: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  btn: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    marginTop: 20,</span></span><br><span class=\"line\"><span class=\"regexp\">    height: 30,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderWidth: 1,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderRadius: 4,</span></span><br><span class=\"line\"><span class=\"regexp\">    borderColor: 'black',</span></span><br><span class=\"line\"><span class=\"regexp\">    padding: 5,</span></span><br><span class=\"line\"><span class=\"regexp\">    justifyContent: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">    alignItems: 'center',</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var LessonNavigator = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  render: function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    var rootRoute = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      component: InputPage,</span></span><br><span class=\"line\"><span class=\"regexp\">      /</span><span class=\"regexp\">/ 存储需要传递的内容</span></span><br><span class=\"line\"><span class=\"regexp\">      passProps: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Navigator</span></span><br><span class=\"line\"><span class=\"regexp\">          initialRoute=&#123;rootRoute&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          configureScene=&#123;(route) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            return Navigator.SceneConfigs.PushFromRight;</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          renderScene=&#123;(route, navigator) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            var Component = route.component;</span></span><br><span class=\"line\"><span class=\"regexp\">            return (</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;Component</span></span><br><span class=\"line\"><span class=\"regexp\">                navigator=&#123;navigator&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">                route=&#123;route&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;...route.passProps&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">              /</span>&gt;</span><br><span class=\"line\">            );</span><br><span class=\"line\">          &#125;&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">module.exports = LessonNavigator;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"TabBarIOS\"><a href=\"#TabBarIOS\" class=\"headerlink\" title=\"TabBarIOS\"></a>TabBarIOS</h2><p><a href=\"https://facebook.github.io/react-native/docs/tabbarios.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p>在ReactNative中，实现页面切换，提供了两个组件：TabBarIOS和TabBarIOS.Item，常用功能：</p>\n<ul>\n<li>selected：是否选中某个Tab。如果为true则选中并显示组件</li>\n<li>title： 标题</li>\n<li>barTintColor：Tab栏的背景颜色</li>\n<li>icon：图标</li>\n<li>onPress：点击事件，当某个tab被选中时，需要改变组件的select={true}</li>\n</ul>\n<p>实现原理：点击tab时触发onPress方法，记录被点击tab的title。再通过title设置tab是否被选中（通过比较设置selected的值，true/false）</p>\n<p>例子：先创建三个页面，引入模块，在 <code>index.ios.js</code> 中统一装配</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> LessonTextInput = <span class=\"built_in\">require</span>(<span class=\"string\">'./testInput'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> LessonImage = <span class=\"built_in\">require</span>(<span class=\"string\">'./loadImage'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> MovieList = <span class=\"built_in\">require</span>(<span class=\"string\">'./movieList'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> LessonTabBarIOS = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 记录点击tab的title</span></span><br><span class=\"line\">      tab: <span class=\"string\">'LessonTextInput'</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// TabBarIOS.Item 的onPress触发方法</span></span><br><span class=\"line\">  select: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tabName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      tab: tabName</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;TabBarIOS style=&#123;&#123;<span class=\"attr\">flex</span>:<span class=\"number\">1</span>&#125;&#125;&gt;</span><br><span class=\"line\">        &lt;TabBarIOS.Item</span><br><span class=\"line\">          title=<span class=\"string\">'LessonTextInput'</span></span><br><span class=\"line\">          icon=&#123;<span class=\"built_in\">require</span>(<span class=\"string\">'./img/icon_chat_normal@3x.png'</span>)&#125;</span><br><span class=\"line\">          onPress=&#123;<span class=\"keyword\">this</span>.select.bind(<span class=\"keyword\">this</span>, <span class=\"string\">'LessonTextInput'</span>)&#125;</span><br><span class=\"line\">          selected=&#123;<span class=\"keyword\">this</span>.state.tab===<span class=\"string\">'LessonTextInput'</span>&#125;</span><br><span class=\"line\">          &gt;</span><br><span class=\"line\">            &lt;LessonTextInput&gt;&lt;/LessonTextInput&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TabBarIOS.Item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TabBarIOS.Item</span></span><br><span class=\"line\"><span class=\"regexp\">          title='LessonImage'</span></span><br><span class=\"line\"><span class=\"regexp\">          systemIcon='bookmarks'</span></span><br><span class=\"line\"><span class=\"regexp\">          onPress=&#123;this.select.bind(this, 'LessonImage')&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          selected=&#123;this.state.tab==='LessonImage'&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          &gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;LessonImage&gt;&lt;/</span>LessonImage&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TabBarIOS.Item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TabBarIOS.Item</span></span><br><span class=\"line\"><span class=\"regexp\">          title='MovieList'</span></span><br><span class=\"line\"><span class=\"regexp\">          icon=&#123;require('./img</span><span class=\"regexp\">/icon_discover_selected@3x.png')&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          onPress=&#123;this.select.bind(this, 'MovieList')&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          selected=&#123;this.state.tab==='MovieList'&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          &gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;MovieList&gt;&lt;/</span>MovieList&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TabBarIOS.Item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>TabBarIOS&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"fetch网络请求\"><a href=\"#fetch网络请求\" class=\"headerlink\" title=\"fetch网络请求\"></a>fetch网络请求</h2><p>在ReactNative中，使用fetch实现了网络请求。fetch和XMLHttpRequest非常类似，是一个封装程度更高的网络API，使用起来很简洁，因为使用了Promise。</p>\n<p>Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件），更加合理和强大，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。简单点说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>\n<p>Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成）、Rejected（已失败）。</p>\n<p>Promise对象生成后，可以分别指定“完成”和“失败”状态的回调函数，链式调用方法。</p>\n<p>语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(参数)</span><br><span class=\"line\">  .then(完成的回调函数)</span><br><span class=\"line\">  .catch(失败的回调函数)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// opts 网络请求的配置</span></span><br><span class=\"line\">  fetch(url, opts)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求成功执行该回调函数，得到相应对象，通过response可以获取请求的数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 例如：json、text等等</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">    <span class=\"comment\">// return response.json();</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then((responseData) = &gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理请求得到的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求失败执行该回调函数，得到错误信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a>GET请求</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRequest</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> opts = &#123;</span><br><span class=\"line\">    method: <span class=\"string\">'GET'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fetch(url, opts)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">responseText</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    alert(responseText);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    alert(error);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"POST请求\"><a href=\"#POST请求\" class=\"headerlink\" title=\"POST请求\"></a>POST请求</h3><p>POST请求需要请求参数，配置请求参数需要先认识一个类 <code>FromData</code>。</p>\n<p>Web应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest的2级定义了FormData类型，FromData主要用于实现序列化表单已经创建与表单格式相同的数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">data.append(<span class=\"string\">'name'</span>, <span class=\"string\">'yjh'</span>);</span><br></pre></td></tr></table></figure>\n<p>append方法接收两个参数：键和值，分别对应表单字段的名字和值，可添加多个键值对。</p>\n<blockquote>\n<p>在jquery中，‘key1=value1&amp;key2=value2’作为参数传入对象框架会自动封装成FormData形式<br>在Fetch中进行的post请求时，需要自动创建FormData对象传给body</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postRequest</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> formData = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">  formData.append(<span class=\"string\">'username'</span>, <span class=\"string\">'yjh'</span>);</span><br><span class=\"line\">  formData.append(<span class=\"string\">'password'</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> opts = &#123;</span><br><span class=\"line\">    method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    body: formData</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fetch(url, opts)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">responseText</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    alert(responseText);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    alert(error);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetData = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">        &lt;TouchableOpacity onPress=&#123;getRequest.bind(<span class=\"keyword\">this</span>, <span class=\"string\">'https://httpbin.org/get?userName=yjh'</span>)&#125;&gt;</span><br><span class=\"line\">          &lt;View style=&#123;styles.btn&#125;&gt;</span><br><span class=\"line\">            &lt;Text&gt;GET&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>View&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/TouchableOpacity&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;TouchableOpacity&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;View style=&#123;styles.btn&#125; onPress=&#123;postRequest.bind(this, 'https:/</span><span class=\"regexp\">/httpbin.org/</span>post<span class=\"string\">')&#125;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;Text&gt;POST&lt;/Text&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;/View&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/TouchableOpacity&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/View&gt;</span></span><br><span class=\"line\"><span class=\"string\">    );</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">var styles = StyleSheet.create(&#123;</span></span><br><span class=\"line\"><span class=\"string\">  container: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    flex: 1,</span></span><br><span class=\"line\"><span class=\"string\">    marginTop: 30,</span></span><br><span class=\"line\"><span class=\"string\">    backgroundColor: '</span>cyan<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    flexDirection: '</span>row<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    justifyContent: '</span>space-around<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    alignItems: '</span>center<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">  &#125;,</span></span><br><span class=\"line\"><span class=\"string\">  btn: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    width: 60,</span></span><br><span class=\"line\"><span class=\"string\">    height: 30,</span></span><br><span class=\"line\"><span class=\"string\">    borderWidth: 1,</span></span><br><span class=\"line\"><span class=\"string\">    borderRadius: 3,</span></span><br><span class=\"line\"><span class=\"string\">    borderColor: '</span>black<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    backgroundColor: '</span>yellow<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    justifyContent: '</span>center<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">    alignItems: '</span>center<span class=\"string\">',</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">module.exports = GetData;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"网络请求获取电影列表数据\"><a href=\"#网络请求获取电影列表数据\" class=\"headerlink\" title=\"网络请求获取电影列表数据\"></a>网络请求获取电影列表数据</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  请求电影列表</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">  未获得数据时，显示等待页面；获取数据后，显示电影列表页面</span></span><br><span class=\"line\"><span class=\"comment\">  需要给state添加一个属性，用于记录下载状态</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> REQUEST_URL = <span class=\"string\">'https://raw.githubusercontent.com/facebook/react-native/master/docs/MoviesExample.json'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> MovieList = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ds = <span class=\"keyword\">new</span> ListView.DataSource(&#123;</span><br><span class=\"line\">      rowHasChanged: <span class=\"function\">(<span class=\"params\">oldRow, newRow</span>) =&gt;</span> oldRow!==newRow</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      loaded: <span class=\"literal\">false</span>, <span class=\"comment\">// 数据是否请求完成</span></span><br><span class=\"line\">      dataSource: ds,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    fetch(REQUEST_URL)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> response.json();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">responseData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 刷新组件，展示ListView</span></span><br><span class=\"line\">      <span class=\"comment\">// 更新dataSource</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        loaded: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        dataSource: <span class=\"keyword\">this</span>.state.dataSource.cloneWithRows(responseData.movies),</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      alert(error);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断请求是否完成</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.state.loaded) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.renderLoadingView();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 电影列表</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ListView</span><br><span class=\"line\">        style=&#123;styles.listView&#125;</span><br><span class=\"line\">        dataSource=&#123;<span class=\"keyword\">this</span>.state.dataSource&#125;</span><br><span class=\"line\">        renderRow=&#123;<span class=\"keyword\">this</span>._renderRow&#125;</span><br><span class=\"line\">        renderHeader=&#123;<span class=\"keyword\">this</span>._renderHeader&#125;</span><br><span class=\"line\">        renderSeparator=&#123;<span class=\"keyword\">this</span>._renderSeparator&#125;</span><br><span class=\"line\">        <span class=\"comment\">// 一开始渲染的行数</span></span><br><span class=\"line\">        initialListSize=&#123;<span class=\"number\">10</span>&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 组件挂载完成</span></span><br><span class=\"line\">  componentDidMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 组件挂载后，开始下载数据</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getData();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 等待请求页面</span></span><br><span class=\"line\">  renderLoadingView: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.loadingContainer&#125;&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.loadingText&#125;&gt;Loading movie.....&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 渲染行组件</span></span><br><span class=\"line\">  _renderRow: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">movie</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.row&#125;&gt;</span><br><span class=\"line\">        &lt;Image</span><br><span class=\"line\">          style=&#123;styles.thumbnail&#125;</span><br><span class=\"line\">          source=&#123;&#123;<span class=\"attr\">uri</span>:movie.posters.thumbnail&#125;&#125;/&gt;</span><br><span class=\"line\">        &lt;View style=&#123;styles.rightContainer&#125;&gt;</span><br><span class=\"line\">          &lt;Text style=&#123;styles.title&#125;&gt;&#123;movie.title&#125;&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Text style=&#123;styles.year&#125;&gt;&#123;movie.year&#125;&lt;/</span>Text&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 渲染头部</span></span><br><span class=\"line\">  _renderHeader: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;View style=&#123;styles.header&#125;&gt;</span><br><span class=\"line\">        &lt;Text style=&#123;styles.header_text&#125;&gt;Movies List&lt;<span class=\"regexp\">/Text&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;View style=&#123;styles.separator&#125;&gt;&lt;/</span>View&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/View&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ 渲染分隔线</span></span><br><span class=\"line\"><span class=\"regexp\">  _renderSeparator: function(sectionID:number, rowID:number) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;View style=&#123;styles.separator&#125; key=&#123;sectionID+rowID&#125;&gt;&lt;/</span>View&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Loading样式</span></span><br><span class=\"line\">  loadingContainer: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'cyan'</span>,</span><br><span class=\"line\">    justifyContent: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  loadingText: &#123;</span><br><span class=\"line\">    fontSize: <span class=\"number\">30</span>,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    marginLeft: <span class=\"number\">10</span>,</span><br><span class=\"line\">    marginRight: <span class=\"number\">10</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// listView</span></span><br><span class=\"line\">  listView: &#123;</span><br><span class=\"line\">    marginTop: <span class=\"number\">25</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  row: &#123;</span><br><span class=\"line\">    flexDirection: <span class=\"string\">'row'</span>,</span><br><span class=\"line\">    padding: <span class=\"number\">5</span>,</span><br><span class=\"line\">    alignItems: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  thumbnail: &#123;</span><br><span class=\"line\">    width: <span class=\"number\">53</span>,</span><br><span class=\"line\">    height: <span class=\"number\">81</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'gray'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  rightContainer: &#123;</span><br><span class=\"line\">    marginLeft: <span class=\"number\">10</span>,</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  title: &#123;</span><br><span class=\"line\">    fontSize: <span class=\"number\">10</span>,</span><br><span class=\"line\">    marginTop: <span class=\"number\">3</span>,</span><br><span class=\"line\">    marginBottom: <span class=\"number\">3</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  year: &#123;</span><br><span class=\"line\">    marginBottom: <span class=\"number\">3</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// header</span></span><br><span class=\"line\">  header: &#123;</span><br><span class=\"line\">    height: <span class=\"number\">44</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#F5FCFF'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  header_text: &#123;</span><br><span class=\"line\">    flex: <span class=\"number\">1</span>,</span><br><span class=\"line\">    fontSize: <span class=\"number\">20</span>,</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">    textAlign: <span class=\"string\">'center'</span>,</span><br><span class=\"line\">    lineHeight: <span class=\"number\">44</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 分隔线</span></span><br><span class=\"line\">  separator: &#123;</span><br><span class=\"line\">    height: <span class=\"number\">1</span>,</span><br><span class=\"line\">    backgroundColor: <span class=\"string\">'#CCCCCC'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = MovieList;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>截止至本章，学习 ReactNative 基础系列文章，已经把 ReactNative 基础的内容都已经过了个遍，通过这几篇文章的内容学习，相信你应该对 ReactNative 已经有个大致的了解，并且能够上手完成一个小应用了，如果你还想深入了解 ReactNative 的高级特性，可以去官网上查阅文档。</p>\n"},{"title":"Moya 源码分析（二）","date":"2017-09-09T09:46:51.000Z","_content":"\n\n## 前言\n\n上一篇文章[《Moya 源码分析（一）》](http://piglikeyoung.com/2017/08/27/moya-analysis-1/)分析了 **TargetType**，本文将分析 Moya 的核心 **Provider**\n\n## MoyaProvider\n\nMoyaProvider是Moya的基础，它是你API的端点的管理者。Moya的所有功能都是通过MoyaProvider来使用。\n\n### 定义\n\nMoyaProvider 的定义：\n\n```swift\nopen class MoyaProvider<Target: TargetType>: MoyaProviderType\n```\n\n它使用了泛型，接收一个遵守 **TargetType** 的类型，自己遵守了 **MoyaProviderType**协议。\n\n`Provider真正做的事情可以用一个流来表示：Target -> Endpoint -> Request`\n\n使用Demo的例子来说就是，它将 **GitHubAPI** 转换成 **Endpoint**，再将其转换成 **NSRURLRequest**，最后将这个 **NSRURLRequest** 交给 **Alamofire** 去网络请求。\n\n### 属性\n\n#### EndpointClosure\n\n```swift\n/// Closure that defines the endpoints for the provider.\npublic typealias EndpointClosure = (Target) -> Endpoint<Target>\n```\n\n**EndpointClosure** 属性是一个闭包，用于让我们对 **Moya** 生成的 **Endpoint** 进行一些我们自己的定制然后返回一个 **Endpoint** 类，例如：我们想增加一个新的HttpHeader：\n\n```swift\nlet endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in\n    let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)\n    return defaultEndpoint.adding(newHTTPHeaderFields: [\"APP_NAME\": \"MY_APP\"])\n}\nlet provider = MoyaProvider<GitHub>(endpointClosure: endpointClosure)\n```\n\n这个闭包输入一个 **target**，返回 **Endpoint**。就是前面说的 `Target -> Endpoint的转换`\n\n> Endpoint 稍后就分析!\n\n#### RequestClosure\n\n```swift\n/// Closure that resolves an `Endpoint` into a `RequestResult`.\npublic typealias RequestClosure = (Endpoint<Target>, @escaping RequestResultClosure) -> Void\n```\n\n这个闭包就是实现将`Endpoint -> NSURLRequest`，Moya也提供了一个默认实现：\n\n```swift\n/// MoyaProvider+Defaults.swift\npublic final class func defaultRequestMapping(for endpoint: Endpoint<Target>, closure: RequestResultClosure) {\n    do {\n        let urlRequest = try endpoint.urlRequest()\n        closure(.success(urlRequest))\n    } catch MoyaError.requestMapping(let url) {\n        closure(.failure(MoyaError.requestMapping(url)))\n    } catch MoyaError.parameterEncoding(let error) {\n        closure(.failure(MoyaError.parameterEncoding(error)))\n    } catch {\n        closure(.failure(MoyaError.underlying(error, nil)))\n    }\n}\n```\n\n默认实现也只是简单地调用endpoint.urlRequest取得一个NSURLRequest实例。然后调用了closure。然而，你可以在这里修改这个请求Request, 事实上这也是Moya给你的最后的机会。举个例子, 你想禁用所有的cookie，并且设置超时时间等。那么你可以实现这样的闭包：\n\n```swift\nlet requestClosure = { (endpoint: Endpoint<GitHub>, done: MoyaProvider.RequestResultClosure) in\n    // 可以在这里修改request\n    var request: URLRequest = endpoint.urlRequest\n    request.httpShouldHandleCookies = false\n    request.timeoutInterval = 20 \n\n    done(.success(request))\n}\n\nprovider = MoyaProvider(requestClosure: requestClosure)\n```\n\n#### RequestResultClosure\n\n创建 requestClosure 时，用到了闭包 RequestResultClosure，它的参数类型是 `Result`，这是使用了 **[Result框架](https://github.com/antitypical/Result)**，**用来将throw的方式换成Result<data,error>的方式返回**。\n\n```swift\n/// Closure that decides if and what request should be performed.\npublic typealias RequestResultClosure = (Result<URLRequest, MoyaError>) -> Void\n```\n\n从上面可以看出，**EndpointClosure** 和 **RequestClosure** 实现了 Target -> Endpoint -> NSRequest的转换流。\n\n#### StubClosure\n\n```swift\n/// Closure that decides if/how a request should be stubbed.\npublic typealias StubClosure = (Target) -> Moya.StubBehavior\n```\n\n这个闭包比较简单，返回一个 **Moya.StubBehavior** 的枚举值。它就是让你告诉Moya你是否使用Stub返回数据或者怎样使用Stub返回数据\n\n```swift\npublic enum StubBehavior {\n\n    /// 不使用Stub返回数据\n    case never\n\n    /// 立即使用Stub返回数据\n    case immediate\n\n    /// 一段时间间隔后使用Stub返回的数据\n    case delayed(seconds: TimeInterval)\n}\n```\n\nNever  表明不使用Stub来返回模拟的网络数据， Immediate表示马上返回Stub的数据， Delayed  是在几秒后返回。Moya 默认是不使用Stub来测试。\n\n在 API 中我们给 sampleData 赋值后，这个属性是返回的Stub数据。\n\n```swift\nextension AccountAPI: TargetType {\n    ...\n    var sampleData: NSData {\n        switch self {\n        case .Login:\n            return \"{'code': 400, 'Token':'123455'}\".dataUsingEncoding(NSUTF8StringEncoding)!\n        case .Register(let userName, let passwd):\n            return \"找不到数据\"\n        }\n    }\n}\n\nlet endPointAction = { (target: TargetType) -> Endpoint<AccountAPI> in\n    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString\n\n    switch target {\n    case .Login:\n        return Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)\n    case .Register:\n        return Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(404, target.sampleData)}, method: target.method, parameters: target.parameters)\n    }\n}\n\nlet stubAction: (type: AccountAPI) -> Moya.StubBehavior  = { type in\n    switch type {\n    case .Login:\n        return Moya.StubBehavior.Immediate\n    case .Register:\n        return Moya.StubBehavior.Delayed(seconds: 3)\n    }\n}\nlet loginAPIProvider = MoyaProvider<AccountAPI>(\n    endpointClosure: endPointAction,\n    stubClosure: stubAction\n)\n\nloginAPIProvider.request(AccountAPI.Login(userName: \"user\", passwd: \"123456\")) { (result) in\n    switch result {\n    case .Success(let respones) :\n        print(respones)\n\n    case .Failure(_) :\n        print(\"We got an error\")\n    }\n    print(result)\n}\n```\n\n这样就实现了一个 Stub。\nLogin 和 Register 都使用了Stub返回的数据。\n\n> 注意：Moya中Provider对象在销毁的时候会去Cancel网络请求。为了得到正确的结果，你必须保证在网络请求的时候你的Provider不会被释放。否者你会得到下面的错误 “But don’t forget to keep a reference for it in property. If it gets deallocated you’ll see -999 “cancelled” error on response” 。通常为了避免这种情况，你可以将Provider实例设置为类成员变量，或者shared实例\n\n\n#### Manager\n\nMoya 并不是一个网络请求的三方库，它只是一个抽象的网络层。它对其他网络库的进行了桥接，真正进行网络请求是别人的网络库（比如默认的Alamofire.Manager） \n\nMoya 为此做了几件事情：\n\n首先抽象了一个RequestType协议，利用这个协议将Alamofire隐藏了起来，让Provider类依赖于这个协议，而不是具体细节。\n\n```swift\n/// Plugin.swift\npublic protocol RequestType {\n\n    // Note:\n    //\n    // We use this protocol instead of the Alamofire request to avoid leaking that abstraction.\n    // A plugin should not know about Alamofire at all.\n\n    /// Retrieve an `NSURLRequest` representation.\n    var request: URLRequest? { get }\n\n    /// Authenticates the request with a username and password.\n    func authenticate(user: String, password: String, persistence: URLCredential.Persistence) -> Self\n\n    /// Authenticates the request with an `NSURLCredential` instance.\n    func authenticate(usingCredential credential: URLCredential) -> Self\n}\n```\n\n然后让Moya.Manager == Alamofire.Manager，并且让Alamofire.Manager也实现RequestType协议\n\n```swift\n/// Moya+Alamofire.swift\npublic typealias Manager = Alamofire.SessionManager\n\n/// Choice of parameter encoding.\npublic typealias ParameterEncoding = Alamofire.ParameterEncoding\n\n/// 让Alamofire.Request也实现 RequestType协议\ninternal typealias Request = Alamofire.Request\nextension Request: RequestType { }\n```\n\n上面几步，就完成了Alamofire的封装、桥接。正因为桥接封装了Alamofire, 因此Moya的request,最终一定会调用Alamofire的request。\n\n```swift\n/// Moya+Internal.swift\nfunc sendRequest(_ target: Target, request: URLRequest, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -> CancellableToken {\n        let initialRequest = manager.request(request as URLRequestConvertible)\n        let alamoRequest = target.validate ? initialRequest.validate() : initialRequest\n        return sendAlamofireRequest(alamoRequest, target: target, callbackQueue: callbackQueue, progress: progress, completion: completion)\n}\n```\n\n在 Moya 的 **sendRequest** 方法中就是用 `manager` 去发送请求（默认是 Alamofire）\n\n如果你想自定义你自己的 Manager, 你可以传入你自己的 Manager 到 Privoder。之后所有的请求都会经过你的这个 Manager 。\n\n```swift\nlet policies: [String: ServerTrustPolicy] = [\n    \"example.com\": .PinPublicKeys(\n        publicKeys: ServerTrustPolicy.publicKeysInBundle(),\n        validateCertificateChain: true,\n        validateHost: true\n    )\n]\n\nlet manager = Manager(\n    configuration: NSURLSessionConfiguration.defaultSessionConfiguration(),\n    serverTrustPolicyManager: ServerTrustPolicyManager(policies: policies)\n)\n\nlet provider = MoyaProvider<MyTarget>(manager: manager)\n```\n\n### requestNormal\n\n```swift\nfunc requestNormal(_ target: Target, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -> Cancellable {\n    /// 生成端点\n    let endpoint = self.endpoint(target)\n    /// 生成测试表现\n    let stubBehavior = self.stubClosure(target)\n    /// 生成取消请求的Token\n    let cancellableToken = CancellableWrapper()\n\n    // Allow plugins to modify response\n    /// 通过自定义的插件完善请求回调的闭包\n    let pluginsWithCompletion: Moya.Completion = { result in\n        let processedResult = self.plugins.reduce(result) { $1.process($0, target: target) }\n        completion(processedResult)\n    }\n\n    /// 是否最终运行中的请求\n    if trackInflights {\n        /// 进入原子锁\n        objc_sync_enter(self)\n        /// 保存请求Endpoint\n        var inflightCompletionBlocks = self.inflightRequests[endpoint]\n        inflightCompletionBlocks?.append(pluginsWithCompletion)\n        self.inflightRequests[endpoint] = inflightCompletionBlocks\n        /// 退出原子锁\n        objc_sync_exit(self)\n\n        /// 如果有正在运行中的CompletionBlock则取消本次请求，反之则记录本次请求\n        if inflightCompletionBlocks != nil {\n            return cancellableToken\n        } else {\n            objc_sync_enter(self)\n            self.inflightRequests[endpoint] = [pluginsWithCompletion]\n            objc_sync_exit(self)\n        }\n    }\n\n    /// 准备请求工作\n    let performNetworking = { (requestResult: Result<URLRequest, MoyaError>) in\n        /// 如果本次请求被取消了则返回\n        if cancellableToken.isCancelled {\n            self.cancelCompletion(pluginsWithCompletion, target: target)\n            return\n        }\n\n        var request: URLRequest!\n        /// 模式匹配取出request\n        switch requestResult {\n        case .success(let urlRequest):\n            request = urlRequest\n        case .failure(let error):\n            pluginsWithCompletion(.failure(error))\n            return\n        }\n\n        // Allow plugins to modify request\n        // 通过自定义插件完善请求的闭包\n        let preparedRequest = self.plugins.reduce(request) { $1.prepare($0, target: target) }\n\n        let networkCompletion: Moya.Completion = { result in\n          if self.trackInflights {\n            self.inflightRequests[endpoint]?.forEach { $0(result) }\n\n            objc_sync_enter(self)\n            self.inflightRequests.removeValue(forKey: endpoint)\n            objc_sync_exit(self)\n          } else {\n            pluginsWithCompletion(result)\n          }\n        }\n\n        cancellableToken.innerCancellable = self.performRequest(target, request: preparedRequest, callbackQueue: callbackQueue, progress: progress, completion: networkCompletion, endpoint: endpoint, stubBehavior: stubBehavior)\n    }\n\n    requestClosure(endpoint, performNetworking)\n\n    return cancellableToken\n}\n```\n\n## Endpoint（端点）\n\n通过 MoyaProvider 产生了一个 API Endpoint，然后通过这个 **Endpoint** 发起请求。\n\n\n```swift\nopen class Endpoint<Target> {\n    public typealias SampleResponseClosure = () -> EndpointSampleResponse\n\n    /// A string representation of the URL for the request.\n    open let url: String\n\n    /// A closure responsible for returning an `EndpointSampleResponse`.\n    open let sampleResponseClosure: SampleResponseClosure\n\n    /// The HTTP method for the request.\n    open let method: Moya.Method\n\n    /// The `Task` for the request.\n    open let task: Task\n\n    /// The HTTP header fields for the request.\n    open let httpHeaderFields: [String: String]?\n\n    public init(url: String,\n                sampleResponseClosure: @escaping SampleResponseClosure,\n                method: Moya.Method,\n                task: Task,\n                httpHeaderFields: [String: String]?) {\n\n        self.url = url\n        self.sampleResponseClosure = sampleResponseClosure\n        self.method = method\n        self.task = task\n        self.httpHeaderFields = httpHeaderFields\n    }\n\n    /// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with added HTTP header fields.\n    open func adding(newHTTPHeaderFields: [String: String]) -> Endpoint<Target> {\n        return Endpoint(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: add(httpHeaderFields: newHTTPHeaderFields))\n    }\n\n    /// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with replaced `task` parameter.\n    open func replacing(task: Task) -> Endpoint<Target> {\n        return Endpoint(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: httpHeaderFields)\n    }\n\n    fileprivate func add(httpHeaderFields headers: [String: String]?) -> [String: String]? {\n        guard let unwrappedHeaders = headers, unwrappedHeaders.isEmpty == false else {\n            return self.httpHeaderFields\n        }\n\n        var newHTTPHeaderFields = self.httpHeaderFields ?? [:]\n        unwrappedHeaders.forEach { key, value in\n            newHTTPHeaderFields[key] = value\n        }\n        return newHTTPHeaderFields\n    }\n}\n```\n\nEndpoint 包含着我们这次请求的所有信息。\n\n### Endpoint.urlRequest\n\n```swift\nextension Endpoint {\n    /// Returns the `Endpoint` converted to a `URLRequest` if valid. Throws an error otherwise.\n    public func urlRequest() throws -> URLRequest {\n        guard let requestURL = Foundation.URL(string: url) else {\n            throw MoyaError.requestMapping(url)\n        }\n\n        var request = URLRequest(url: requestURL)\n        request.httpMethod = method.rawValue\n        request.allHTTPHeaderFields = httpHeaderFields\n\n        switch task {\n        case .requestPlain, .uploadFile, .uploadMultipart, .downloadDestination:\n            return request\n        case .requestData(let data):\n            request.httpBody = data\n            return request\n        case let .requestJSONEncodable(encodable):\n            return try request.encoded(encodable: encodable)\n        case let .requestParameters(parameters, parameterEncoding):\n            return try request.encoded(parameters: parameters, parameterEncoding: parameterEncoding)\n        case let .uploadCompositeMultipart(_, urlParameters):\n            let parameterEncoding = URLEncoding(destination: .queryString)\n            return try request.encoded(parameters: urlParameters, parameterEncoding: parameterEncoding)\n        case let .downloadParameters(parameters, parameterEncoding, _):\n            return try request.encoded(parameters: parameters, parameterEncoding: parameterEncoding)\n        case let .requestCompositeData(bodyData: bodyData, urlParameters: urlParameters):\n            request.httpBody = bodyData\n            let parameterEncoding = URLEncoding(destination: .queryString)\n            return try request.encoded(parameters: urlParameters, parameterEncoding: parameterEncoding)\n        case let .requestCompositeParameters(bodyParameters: bodyParameters, bodyEncoding: bodyParameterEncoding, urlParameters: urlParameters):\n            if bodyParameterEncoding is URLEncoding { fatalError(\"URLEncoding is disallowed as bodyEncoding.\") }\n            let bodyfulRequest = try request.encoded(parameters: bodyParameters, parameterEncoding: bodyParameterEncoding)\n            let urlEncoding = URLEncoding(destination: .queryString)\n            return try bodyfulRequest.encoded(parameters: urlParameters, parameterEncoding: urlEncoding)\n        }\n    }\n}\n```\n\n这段代码可以知道 通过 **urlRequest()** 将 `Endpoint` 转换为一个 `URLRequest`\n\n### Endpoint 比较\n\n```swift\nextension Endpoint: Equatable, Hashable {\n    public var hashValue: Int {\n        let request = try? urlRequest()\n        return request?.hashValue ?? url.hashValue\n    }\n\n    /// Note: If both Endpoints fail to produce a URLRequest the comparison will\n    /// fall back to comparing each Endpoint's hashValue.\n    public static func == <T>(lhs: Endpoint<T>, rhs: Endpoint<T>) -> Bool {\n        let lhsRequest = try? lhs.urlRequest()\n        let rhsRequest = try? rhs.urlRequest()\n        if lhsRequest != nil, rhsRequest == nil { return false }\n        if lhsRequest == nil, rhsRequest != nil { return false }\n        if lhsRequest == nil, rhsRequest == nil { return lhs.hashValue == rhs.hashValue }\n        return (lhsRequest == rhsRequest)\n    }\n}\n```\n\n遵守 **Equatable** 和 **Hashable** 协议并实现响应方法即可为自己的类提供==比较方法.这个对比方法用来追踪已经在请求中的request。排除多次无用请求。\n\nMoya 提供了一个默认的 **EndpointClosure** 的函数，来实现这个Target到Endpoint的转换：\n\n```swift\npublic final class func defaultEndpointMapping(for target: Target) -> Endpoint<Target> {\n    return Endpoint(\n        url: URL(target: target).absoluteString,\n        sampleResponseClosure: { .networkResponse(200, target.sampleData) },\n        method: target.method,\n        task: target.task,\n        httpHeaderFields: target.headers\n    )\n}\n```\n\n### SampleResponseClosure\n\nEndpoint 有一个叫做 SampleResponseClosure 的 Enum，用来返回定制的测试networkResponse。比如特定的StautsCode之类的。\n\n```swift\n/// Used for stubbing responses.\npublic enum EndpointSampleResponse {\n\n    /// The network returned a response, including status code and data.\n    case networkResponse(Int, Data)\n\n    /// The network returned response which can be fully customized.\n    case response(HTTPURLResponse, Data)\n\n    /// The network failed to send the request, or failed to retrieve a response (eg a timeout).\n    case networkError(NSError)\n}\n```\n\n## 总结\n\n1. **endpointClosure**、**requestClosure**、**stubClosure**，这3个Closure是让我们定制请求、响应和进行测试时的回调，非常有用。\n\n2. **Manager** 是真正用来网络请求的类，Moya 自己并不提供 Manager 类，Moya只是对其他网络请求类进行了简单的桥接。这么做是为了让调用方可以轻易地定制、更换网络请求的库。比如你不想用Alamofire，可以十分简单的换成其他库。\n\n3. **PluginType** 数组。Moya 提供了一个插件机制，使我们可以建立自己的插件类来做一些额外的事情。比如写Log，显示“菊花”等。抽离出Plugin层的目的，就是让Provider职责单一，满足开闭原则。把和自己网络无关的行为抽离。避免各种业务揉在一起不利于扩展。\n\n\n","source":"_posts/moya-analysis-2.md","raw":"---\ntitle: Moya 源码分析（二）\ndate: 2017-09-09 17:46:51\ntags: Moya\ncategory: Source Code Analyze\n---\n\n\n## 前言\n\n上一篇文章[《Moya 源码分析（一）》](http://piglikeyoung.com/2017/08/27/moya-analysis-1/)分析了 **TargetType**，本文将分析 Moya 的核心 **Provider**\n\n## MoyaProvider\n\nMoyaProvider是Moya的基础，它是你API的端点的管理者。Moya的所有功能都是通过MoyaProvider来使用。\n\n### 定义\n\nMoyaProvider 的定义：\n\n```swift\nopen class MoyaProvider<Target: TargetType>: MoyaProviderType\n```\n\n它使用了泛型，接收一个遵守 **TargetType** 的类型，自己遵守了 **MoyaProviderType**协议。\n\n`Provider真正做的事情可以用一个流来表示：Target -> Endpoint -> Request`\n\n使用Demo的例子来说就是，它将 **GitHubAPI** 转换成 **Endpoint**，再将其转换成 **NSRURLRequest**，最后将这个 **NSRURLRequest** 交给 **Alamofire** 去网络请求。\n\n### 属性\n\n#### EndpointClosure\n\n```swift\n/// Closure that defines the endpoints for the provider.\npublic typealias EndpointClosure = (Target) -> Endpoint<Target>\n```\n\n**EndpointClosure** 属性是一个闭包，用于让我们对 **Moya** 生成的 **Endpoint** 进行一些我们自己的定制然后返回一个 **Endpoint** 类，例如：我们想增加一个新的HttpHeader：\n\n```swift\nlet endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in\n    let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)\n    return defaultEndpoint.adding(newHTTPHeaderFields: [\"APP_NAME\": \"MY_APP\"])\n}\nlet provider = MoyaProvider<GitHub>(endpointClosure: endpointClosure)\n```\n\n这个闭包输入一个 **target**，返回 **Endpoint**。就是前面说的 `Target -> Endpoint的转换`\n\n> Endpoint 稍后就分析!\n\n#### RequestClosure\n\n```swift\n/// Closure that resolves an `Endpoint` into a `RequestResult`.\npublic typealias RequestClosure = (Endpoint<Target>, @escaping RequestResultClosure) -> Void\n```\n\n这个闭包就是实现将`Endpoint -> NSURLRequest`，Moya也提供了一个默认实现：\n\n```swift\n/// MoyaProvider+Defaults.swift\npublic final class func defaultRequestMapping(for endpoint: Endpoint<Target>, closure: RequestResultClosure) {\n    do {\n        let urlRequest = try endpoint.urlRequest()\n        closure(.success(urlRequest))\n    } catch MoyaError.requestMapping(let url) {\n        closure(.failure(MoyaError.requestMapping(url)))\n    } catch MoyaError.parameterEncoding(let error) {\n        closure(.failure(MoyaError.parameterEncoding(error)))\n    } catch {\n        closure(.failure(MoyaError.underlying(error, nil)))\n    }\n}\n```\n\n默认实现也只是简单地调用endpoint.urlRequest取得一个NSURLRequest实例。然后调用了closure。然而，你可以在这里修改这个请求Request, 事实上这也是Moya给你的最后的机会。举个例子, 你想禁用所有的cookie，并且设置超时时间等。那么你可以实现这样的闭包：\n\n```swift\nlet requestClosure = { (endpoint: Endpoint<GitHub>, done: MoyaProvider.RequestResultClosure) in\n    // 可以在这里修改request\n    var request: URLRequest = endpoint.urlRequest\n    request.httpShouldHandleCookies = false\n    request.timeoutInterval = 20 \n\n    done(.success(request))\n}\n\nprovider = MoyaProvider(requestClosure: requestClosure)\n```\n\n#### RequestResultClosure\n\n创建 requestClosure 时，用到了闭包 RequestResultClosure，它的参数类型是 `Result`，这是使用了 **[Result框架](https://github.com/antitypical/Result)**，**用来将throw的方式换成Result<data,error>的方式返回**。\n\n```swift\n/// Closure that decides if and what request should be performed.\npublic typealias RequestResultClosure = (Result<URLRequest, MoyaError>) -> Void\n```\n\n从上面可以看出，**EndpointClosure** 和 **RequestClosure** 实现了 Target -> Endpoint -> NSRequest的转换流。\n\n#### StubClosure\n\n```swift\n/// Closure that decides if/how a request should be stubbed.\npublic typealias StubClosure = (Target) -> Moya.StubBehavior\n```\n\n这个闭包比较简单，返回一个 **Moya.StubBehavior** 的枚举值。它就是让你告诉Moya你是否使用Stub返回数据或者怎样使用Stub返回数据\n\n```swift\npublic enum StubBehavior {\n\n    /// 不使用Stub返回数据\n    case never\n\n    /// 立即使用Stub返回数据\n    case immediate\n\n    /// 一段时间间隔后使用Stub返回的数据\n    case delayed(seconds: TimeInterval)\n}\n```\n\nNever  表明不使用Stub来返回模拟的网络数据， Immediate表示马上返回Stub的数据， Delayed  是在几秒后返回。Moya 默认是不使用Stub来测试。\n\n在 API 中我们给 sampleData 赋值后，这个属性是返回的Stub数据。\n\n```swift\nextension AccountAPI: TargetType {\n    ...\n    var sampleData: NSData {\n        switch self {\n        case .Login:\n            return \"{'code': 400, 'Token':'123455'}\".dataUsingEncoding(NSUTF8StringEncoding)!\n        case .Register(let userName, let passwd):\n            return \"找不到数据\"\n        }\n    }\n}\n\nlet endPointAction = { (target: TargetType) -> Endpoint<AccountAPI> in\n    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString\n\n    switch target {\n    case .Login:\n        return Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)\n    case .Register:\n        return Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(404, target.sampleData)}, method: target.method, parameters: target.parameters)\n    }\n}\n\nlet stubAction: (type: AccountAPI) -> Moya.StubBehavior  = { type in\n    switch type {\n    case .Login:\n        return Moya.StubBehavior.Immediate\n    case .Register:\n        return Moya.StubBehavior.Delayed(seconds: 3)\n    }\n}\nlet loginAPIProvider = MoyaProvider<AccountAPI>(\n    endpointClosure: endPointAction,\n    stubClosure: stubAction\n)\n\nloginAPIProvider.request(AccountAPI.Login(userName: \"user\", passwd: \"123456\")) { (result) in\n    switch result {\n    case .Success(let respones) :\n        print(respones)\n\n    case .Failure(_) :\n        print(\"We got an error\")\n    }\n    print(result)\n}\n```\n\n这样就实现了一个 Stub。\nLogin 和 Register 都使用了Stub返回的数据。\n\n> 注意：Moya中Provider对象在销毁的时候会去Cancel网络请求。为了得到正确的结果，你必须保证在网络请求的时候你的Provider不会被释放。否者你会得到下面的错误 “But don’t forget to keep a reference for it in property. If it gets deallocated you’ll see -999 “cancelled” error on response” 。通常为了避免这种情况，你可以将Provider实例设置为类成员变量，或者shared实例\n\n\n#### Manager\n\nMoya 并不是一个网络请求的三方库，它只是一个抽象的网络层。它对其他网络库的进行了桥接，真正进行网络请求是别人的网络库（比如默认的Alamofire.Manager） \n\nMoya 为此做了几件事情：\n\n首先抽象了一个RequestType协议，利用这个协议将Alamofire隐藏了起来，让Provider类依赖于这个协议，而不是具体细节。\n\n```swift\n/// Plugin.swift\npublic protocol RequestType {\n\n    // Note:\n    //\n    // We use this protocol instead of the Alamofire request to avoid leaking that abstraction.\n    // A plugin should not know about Alamofire at all.\n\n    /// Retrieve an `NSURLRequest` representation.\n    var request: URLRequest? { get }\n\n    /// Authenticates the request with a username and password.\n    func authenticate(user: String, password: String, persistence: URLCredential.Persistence) -> Self\n\n    /// Authenticates the request with an `NSURLCredential` instance.\n    func authenticate(usingCredential credential: URLCredential) -> Self\n}\n```\n\n然后让Moya.Manager == Alamofire.Manager，并且让Alamofire.Manager也实现RequestType协议\n\n```swift\n/// Moya+Alamofire.swift\npublic typealias Manager = Alamofire.SessionManager\n\n/// Choice of parameter encoding.\npublic typealias ParameterEncoding = Alamofire.ParameterEncoding\n\n/// 让Alamofire.Request也实现 RequestType协议\ninternal typealias Request = Alamofire.Request\nextension Request: RequestType { }\n```\n\n上面几步，就完成了Alamofire的封装、桥接。正因为桥接封装了Alamofire, 因此Moya的request,最终一定会调用Alamofire的request。\n\n```swift\n/// Moya+Internal.swift\nfunc sendRequest(_ target: Target, request: URLRequest, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -> CancellableToken {\n        let initialRequest = manager.request(request as URLRequestConvertible)\n        let alamoRequest = target.validate ? initialRequest.validate() : initialRequest\n        return sendAlamofireRequest(alamoRequest, target: target, callbackQueue: callbackQueue, progress: progress, completion: completion)\n}\n```\n\n在 Moya 的 **sendRequest** 方法中就是用 `manager` 去发送请求（默认是 Alamofire）\n\n如果你想自定义你自己的 Manager, 你可以传入你自己的 Manager 到 Privoder。之后所有的请求都会经过你的这个 Manager 。\n\n```swift\nlet policies: [String: ServerTrustPolicy] = [\n    \"example.com\": .PinPublicKeys(\n        publicKeys: ServerTrustPolicy.publicKeysInBundle(),\n        validateCertificateChain: true,\n        validateHost: true\n    )\n]\n\nlet manager = Manager(\n    configuration: NSURLSessionConfiguration.defaultSessionConfiguration(),\n    serverTrustPolicyManager: ServerTrustPolicyManager(policies: policies)\n)\n\nlet provider = MoyaProvider<MyTarget>(manager: manager)\n```\n\n### requestNormal\n\n```swift\nfunc requestNormal(_ target: Target, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -> Cancellable {\n    /// 生成端点\n    let endpoint = self.endpoint(target)\n    /// 生成测试表现\n    let stubBehavior = self.stubClosure(target)\n    /// 生成取消请求的Token\n    let cancellableToken = CancellableWrapper()\n\n    // Allow plugins to modify response\n    /// 通过自定义的插件完善请求回调的闭包\n    let pluginsWithCompletion: Moya.Completion = { result in\n        let processedResult = self.plugins.reduce(result) { $1.process($0, target: target) }\n        completion(processedResult)\n    }\n\n    /// 是否最终运行中的请求\n    if trackInflights {\n        /// 进入原子锁\n        objc_sync_enter(self)\n        /// 保存请求Endpoint\n        var inflightCompletionBlocks = self.inflightRequests[endpoint]\n        inflightCompletionBlocks?.append(pluginsWithCompletion)\n        self.inflightRequests[endpoint] = inflightCompletionBlocks\n        /// 退出原子锁\n        objc_sync_exit(self)\n\n        /// 如果有正在运行中的CompletionBlock则取消本次请求，反之则记录本次请求\n        if inflightCompletionBlocks != nil {\n            return cancellableToken\n        } else {\n            objc_sync_enter(self)\n            self.inflightRequests[endpoint] = [pluginsWithCompletion]\n            objc_sync_exit(self)\n        }\n    }\n\n    /// 准备请求工作\n    let performNetworking = { (requestResult: Result<URLRequest, MoyaError>) in\n        /// 如果本次请求被取消了则返回\n        if cancellableToken.isCancelled {\n            self.cancelCompletion(pluginsWithCompletion, target: target)\n            return\n        }\n\n        var request: URLRequest!\n        /// 模式匹配取出request\n        switch requestResult {\n        case .success(let urlRequest):\n            request = urlRequest\n        case .failure(let error):\n            pluginsWithCompletion(.failure(error))\n            return\n        }\n\n        // Allow plugins to modify request\n        // 通过自定义插件完善请求的闭包\n        let preparedRequest = self.plugins.reduce(request) { $1.prepare($0, target: target) }\n\n        let networkCompletion: Moya.Completion = { result in\n          if self.trackInflights {\n            self.inflightRequests[endpoint]?.forEach { $0(result) }\n\n            objc_sync_enter(self)\n            self.inflightRequests.removeValue(forKey: endpoint)\n            objc_sync_exit(self)\n          } else {\n            pluginsWithCompletion(result)\n          }\n        }\n\n        cancellableToken.innerCancellable = self.performRequest(target, request: preparedRequest, callbackQueue: callbackQueue, progress: progress, completion: networkCompletion, endpoint: endpoint, stubBehavior: stubBehavior)\n    }\n\n    requestClosure(endpoint, performNetworking)\n\n    return cancellableToken\n}\n```\n\n## Endpoint（端点）\n\n通过 MoyaProvider 产生了一个 API Endpoint，然后通过这个 **Endpoint** 发起请求。\n\n\n```swift\nopen class Endpoint<Target> {\n    public typealias SampleResponseClosure = () -> EndpointSampleResponse\n\n    /// A string representation of the URL for the request.\n    open let url: String\n\n    /// A closure responsible for returning an `EndpointSampleResponse`.\n    open let sampleResponseClosure: SampleResponseClosure\n\n    /// The HTTP method for the request.\n    open let method: Moya.Method\n\n    /// The `Task` for the request.\n    open let task: Task\n\n    /// The HTTP header fields for the request.\n    open let httpHeaderFields: [String: String]?\n\n    public init(url: String,\n                sampleResponseClosure: @escaping SampleResponseClosure,\n                method: Moya.Method,\n                task: Task,\n                httpHeaderFields: [String: String]?) {\n\n        self.url = url\n        self.sampleResponseClosure = sampleResponseClosure\n        self.method = method\n        self.task = task\n        self.httpHeaderFields = httpHeaderFields\n    }\n\n    /// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with added HTTP header fields.\n    open func adding(newHTTPHeaderFields: [String: String]) -> Endpoint<Target> {\n        return Endpoint(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: add(httpHeaderFields: newHTTPHeaderFields))\n    }\n\n    /// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with replaced `task` parameter.\n    open func replacing(task: Task) -> Endpoint<Target> {\n        return Endpoint(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: httpHeaderFields)\n    }\n\n    fileprivate func add(httpHeaderFields headers: [String: String]?) -> [String: String]? {\n        guard let unwrappedHeaders = headers, unwrappedHeaders.isEmpty == false else {\n            return self.httpHeaderFields\n        }\n\n        var newHTTPHeaderFields = self.httpHeaderFields ?? [:]\n        unwrappedHeaders.forEach { key, value in\n            newHTTPHeaderFields[key] = value\n        }\n        return newHTTPHeaderFields\n    }\n}\n```\n\nEndpoint 包含着我们这次请求的所有信息。\n\n### Endpoint.urlRequest\n\n```swift\nextension Endpoint {\n    /// Returns the `Endpoint` converted to a `URLRequest` if valid. Throws an error otherwise.\n    public func urlRequest() throws -> URLRequest {\n        guard let requestURL = Foundation.URL(string: url) else {\n            throw MoyaError.requestMapping(url)\n        }\n\n        var request = URLRequest(url: requestURL)\n        request.httpMethod = method.rawValue\n        request.allHTTPHeaderFields = httpHeaderFields\n\n        switch task {\n        case .requestPlain, .uploadFile, .uploadMultipart, .downloadDestination:\n            return request\n        case .requestData(let data):\n            request.httpBody = data\n            return request\n        case let .requestJSONEncodable(encodable):\n            return try request.encoded(encodable: encodable)\n        case let .requestParameters(parameters, parameterEncoding):\n            return try request.encoded(parameters: parameters, parameterEncoding: parameterEncoding)\n        case let .uploadCompositeMultipart(_, urlParameters):\n            let parameterEncoding = URLEncoding(destination: .queryString)\n            return try request.encoded(parameters: urlParameters, parameterEncoding: parameterEncoding)\n        case let .downloadParameters(parameters, parameterEncoding, _):\n            return try request.encoded(parameters: parameters, parameterEncoding: parameterEncoding)\n        case let .requestCompositeData(bodyData: bodyData, urlParameters: urlParameters):\n            request.httpBody = bodyData\n            let parameterEncoding = URLEncoding(destination: .queryString)\n            return try request.encoded(parameters: urlParameters, parameterEncoding: parameterEncoding)\n        case let .requestCompositeParameters(bodyParameters: bodyParameters, bodyEncoding: bodyParameterEncoding, urlParameters: urlParameters):\n            if bodyParameterEncoding is URLEncoding { fatalError(\"URLEncoding is disallowed as bodyEncoding.\") }\n            let bodyfulRequest = try request.encoded(parameters: bodyParameters, parameterEncoding: bodyParameterEncoding)\n            let urlEncoding = URLEncoding(destination: .queryString)\n            return try bodyfulRequest.encoded(parameters: urlParameters, parameterEncoding: urlEncoding)\n        }\n    }\n}\n```\n\n这段代码可以知道 通过 **urlRequest()** 将 `Endpoint` 转换为一个 `URLRequest`\n\n### Endpoint 比较\n\n```swift\nextension Endpoint: Equatable, Hashable {\n    public var hashValue: Int {\n        let request = try? urlRequest()\n        return request?.hashValue ?? url.hashValue\n    }\n\n    /// Note: If both Endpoints fail to produce a URLRequest the comparison will\n    /// fall back to comparing each Endpoint's hashValue.\n    public static func == <T>(lhs: Endpoint<T>, rhs: Endpoint<T>) -> Bool {\n        let lhsRequest = try? lhs.urlRequest()\n        let rhsRequest = try? rhs.urlRequest()\n        if lhsRequest != nil, rhsRequest == nil { return false }\n        if lhsRequest == nil, rhsRequest != nil { return false }\n        if lhsRequest == nil, rhsRequest == nil { return lhs.hashValue == rhs.hashValue }\n        return (lhsRequest == rhsRequest)\n    }\n}\n```\n\n遵守 **Equatable** 和 **Hashable** 协议并实现响应方法即可为自己的类提供==比较方法.这个对比方法用来追踪已经在请求中的request。排除多次无用请求。\n\nMoya 提供了一个默认的 **EndpointClosure** 的函数，来实现这个Target到Endpoint的转换：\n\n```swift\npublic final class func defaultEndpointMapping(for target: Target) -> Endpoint<Target> {\n    return Endpoint(\n        url: URL(target: target).absoluteString,\n        sampleResponseClosure: { .networkResponse(200, target.sampleData) },\n        method: target.method,\n        task: target.task,\n        httpHeaderFields: target.headers\n    )\n}\n```\n\n### SampleResponseClosure\n\nEndpoint 有一个叫做 SampleResponseClosure 的 Enum，用来返回定制的测试networkResponse。比如特定的StautsCode之类的。\n\n```swift\n/// Used for stubbing responses.\npublic enum EndpointSampleResponse {\n\n    /// The network returned a response, including status code and data.\n    case networkResponse(Int, Data)\n\n    /// The network returned response which can be fully customized.\n    case response(HTTPURLResponse, Data)\n\n    /// The network failed to send the request, or failed to retrieve a response (eg a timeout).\n    case networkError(NSError)\n}\n```\n\n## 总结\n\n1. **endpointClosure**、**requestClosure**、**stubClosure**，这3个Closure是让我们定制请求、响应和进行测试时的回调，非常有用。\n\n2. **Manager** 是真正用来网络请求的类，Moya 自己并不提供 Manager 类，Moya只是对其他网络请求类进行了简单的桥接。这么做是为了让调用方可以轻易地定制、更换网络请求的库。比如你不想用Alamofire，可以十分简单的换成其他库。\n\n3. **PluginType** 数组。Moya 提供了一个插件机制，使我们可以建立自己的插件类来做一些额外的事情。比如写Log，显示“菊花”等。抽离出Plugin层的目的，就是让Provider职责单一，满足开闭原则。把和自己网络无关的行为抽离。避免各种业务揉在一起不利于扩展。\n\n\n","slug":"moya-analysis-2","published":1,"updated":"2018-01-20T14:17:11.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7pv005f8jpbb4s9ihmd","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇文章<a href=\"http://piglikeyoung.com/2017/08/27/moya-analysis-1/\">《Moya 源码分析（一）》</a>分析了 <strong>TargetType</strong>，本文将分析 Moya 的核心 <strong>Provider</strong></p>\n<h2 id=\"MoyaProvider\"><a href=\"#MoyaProvider\" class=\"headerlink\" title=\"MoyaProvider\"></a>MoyaProvider</h2><p>MoyaProvider是Moya的基础，它是你API的端点的管理者。Moya的所有功能都是通过MoyaProvider来使用。</p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>MoyaProvider 的定义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MoyaProvider</span>&lt;<span class=\"title\">Target</span>: <span class=\"title\">TargetType</span>&gt;: <span class=\"title\">MoyaProviderType</span></span></span><br></pre></td></tr></table></figure>\n<p>它使用了泛型，接收一个遵守 <strong>TargetType</strong> 的类型，自己遵守了 <strong>MoyaProviderType</strong>协议。</p>\n<p><code>Provider真正做的事情可以用一个流来表示：Target -&gt; Endpoint -&gt; Request</code></p>\n<p>使用Demo的例子来说就是，它将 <strong>GitHubAPI</strong> 转换成 <strong>Endpoint</strong>，再将其转换成 <strong>NSRURLRequest</strong>，最后将这个 <strong>NSRURLRequest</strong> 交给 <strong>Alamofire</strong> 去网络请求。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><h4 id=\"EndpointClosure\"><a href=\"#EndpointClosure\" class=\"headerlink\" title=\"EndpointClosure\"></a>EndpointClosure</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Closure that defines the endpoints for the provider.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">EndpointClosure</span> = (<span class=\"type\">Target</span>) -&gt; <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">Target</span>&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>EndpointClosure</strong> 属性是一个闭包，用于让我们对 <strong>Moya</strong> 生成的 <strong>Endpoint</strong> 进行一些我们自己的定制然后返回一个 <strong>Endpoint</strong> 类，例如：我们想增加一个新的HttpHeader：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> endpointClosure = &#123; (target: <span class=\"type\">MyTarget</span>) -&gt; <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">MyTarget</span>&gt; <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultEndpoint = <span class=\"type\">MoyaProvider</span>.defaultEndpointMapping(<span class=\"keyword\">for</span>: target)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultEndpoint.adding(newHTTPHeaderFields: [<span class=\"string\">\"APP_NAME\"</span>: <span class=\"string\">\"MY_APP\"</span>])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> provider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">GitHub</span>&gt;(endpointClosure: endpointClosure)</span><br></pre></td></tr></table></figure>\n<p>这个闭包输入一个 <strong>target</strong>，返回 <strong>Endpoint</strong>。就是前面说的 <code>Target -&gt; Endpoint的转换</code></p>\n<blockquote>\n<p>Endpoint 稍后就分析!</p>\n</blockquote>\n<h4 id=\"RequestClosure\"><a href=\"#RequestClosure\" class=\"headerlink\" title=\"RequestClosure\"></a>RequestClosure</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Closure that resolves an `Endpoint` into a `RequestResult`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">RequestClosure</span> = (<span class=\"type\">Endpoint</span>&lt;<span class=\"type\">Target</span>&gt;, @escaping <span class=\"type\">RequestResultClosure</span>) -&gt; <span class=\"type\">Void</span></span><br></pre></td></tr></table></figure>\n<p>这个闭包就是实现将<code>Endpoint -&gt; NSURLRequest</code>，Moya也提供了一个默认实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// MoyaProvider+Defaults.swift</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">defaultRequestMapping</span>(<span class=\"title\">for</span> <span class=\"title\">endpoint</span>: <span class=\"title\">Endpoint</span>&lt;<span class=\"title\">Target</span>&gt;, <span class=\"title\">closure</span>: <span class=\"title\">RequestResultClosure</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> urlRequest = <span class=\"keyword\">try</span> endpoint.urlRequest()</span><br><span class=\"line\">        closure(.success(urlRequest))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> <span class=\"type\">MoyaError</span>.requestMapping(<span class=\"keyword\">let</span> url) &#123;</span><br><span class=\"line\">        closure(.failure(<span class=\"type\">MoyaError</span>.requestMapping(url)))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> <span class=\"type\">MoyaError</span>.parameterEncoding(<span class=\"keyword\">let</span> error) &#123;</span><br><span class=\"line\">        closure(.failure(<span class=\"type\">MoyaError</span>.parameterEncoding(error)))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        closure(.failure(<span class=\"type\">MoyaError</span>.underlying(error, <span class=\"literal\">nil</span>)))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认实现也只是简单地调用endpoint.urlRequest取得一个NSURLRequest实例。然后调用了closure。然而，你可以在这里修改这个请求Request, 事实上这也是Moya给你的最后的机会。举个例子, 你想禁用所有的cookie，并且设置超时时间等。那么你可以实现这样的闭包：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> requestClosure = &#123; (endpoint: <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">GitHub</span>&gt;, done: <span class=\"type\">MoyaProvider</span>.<span class=\"type\">RequestResultClosure</span>) <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以在这里修改request</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> request: <span class=\"type\">URLRequest</span> = endpoint.urlRequest</span><br><span class=\"line\">    request.httpShouldHandleCookies = <span class=\"literal\">false</span></span><br><span class=\"line\">    request.timeoutInterval = <span class=\"number\">20</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    done(.success(request))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">provider = <span class=\"type\">MoyaProvider</span>(requestClosure: requestClosure)</span><br></pre></td></tr></table></figure>\n<h4 id=\"RequestResultClosure\"><a href=\"#RequestResultClosure\" class=\"headerlink\" title=\"RequestResultClosure\"></a>RequestResultClosure</h4><p>创建 requestClosure 时，用到了闭包 RequestResultClosure，它的参数类型是 <code>Result</code>，这是使用了 <strong><a href=\"https://github.com/antitypical/Result\" target=\"_blank\" rel=\"noopener\">Result框架</a></strong>，<strong>用来将throw的方式换成Result&lt;data,error&gt;的方式返回</strong>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Closure that decides if and what request should be performed.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">RequestResultClosure</span> = (<span class=\"type\">Result</span>&lt;<span class=\"type\">URLRequest</span>, <span class=\"type\">MoyaError</span>&gt;) -&gt; <span class=\"type\">Void</span></span><br></pre></td></tr></table></figure>\n<p>从上面可以看出，<strong>EndpointClosure</strong> 和 <strong>RequestClosure</strong> 实现了 Target -&gt; Endpoint -&gt; NSRequest的转换流。</p>\n<h4 id=\"StubClosure\"><a href=\"#StubClosure\" class=\"headerlink\" title=\"StubClosure\"></a>StubClosure</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Closure that decides if/how a request should be stubbed.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">StubClosure</span> = (<span class=\"type\">Target</span>) -&gt; <span class=\"type\">Moya</span>.<span class=\"type\">StubBehavior</span></span><br></pre></td></tr></table></figure>\n<p>这个闭包比较简单，返回一个 <strong>Moya.StubBehavior</strong> 的枚举值。它就是让你告诉Moya你是否使用Stub返回数据或者怎样使用Stub返回数据</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">StubBehavior</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 不使用Stub返回数据</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> never</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 立即使用Stub返回数据</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> immediate</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 一段时间间隔后使用Stub返回的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> delayed(seconds: <span class=\"type\">TimeInterval</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Never  表明不使用Stub来返回模拟的网络数据， Immediate表示马上返回Stub的数据， Delayed  是在几秒后返回。Moya 默认是不使用Stub来测试。</p>\n<p>在 API 中我们给 sampleData 赋值后，这个属性是返回的Stub数据。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">AccountAPI</span>: <span class=\"title\">TargetType</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sampleData: <span class=\"type\">NSData</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .<span class=\"type\">Login</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&#123;'code': 400, 'Token':'123455'&#125;\"</span>.dataUsingEncoding(<span class=\"type\">NSUTF8StringEncoding</span>)!</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .<span class=\"type\">Register</span>(<span class=\"keyword\">let</span> userName, <span class=\"keyword\">let</span> passwd):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"找不到数据\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> endPointAction = &#123; (target: <span class=\"type\">TargetType</span>) -&gt; <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">AccountAPI</span>&gt; <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = target.baseURL.<span class=\"type\">URLByAppendingPathComponent</span>(target.path).absoluteString</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> target &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Login</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Endpoint</span>(<span class=\"type\">URL</span>: url, sampleResponseClosure: &#123;.<span class=\"type\">NetworkResponse</span>(<span class=\"number\">200</span>, target.sampleData)&#125;, method: target.method, parameters: target.parameters)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Register</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Endpoint</span>(<span class=\"type\">URL</span>: url, sampleResponseClosure: &#123;.<span class=\"type\">NetworkResponse</span>(<span class=\"number\">404</span>, target.sampleData)&#125;, method: target.method, parameters: target.parameters)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> stubAction: (type: <span class=\"type\">AccountAPI</span>) -&gt; <span class=\"type\">Moya</span>.<span class=\"type\">StubBehavior</span>  = &#123; type <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Login</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Moya</span>.<span class=\"type\">StubBehavior</span>.<span class=\"type\">Immediate</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Register</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Moya</span>.<span class=\"type\">StubBehavior</span>.<span class=\"type\">Delayed</span>(seconds: <span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> loginAPIProvider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">AccountAPI</span>&gt;(</span><br><span class=\"line\">    endpointClosure: endPointAction,</span><br><span class=\"line\">    stubClosure: stubAction</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">loginAPIProvider.request(<span class=\"type\">AccountAPI</span>.<span class=\"type\">Login</span>(userName: <span class=\"string\">\"user\"</span>, passwd: <span class=\"string\">\"123456\"</span>)) &#123; (result) <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> result &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Success</span>(<span class=\"keyword\">let</span> respones) :</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(respones)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Failure</span>(<span class=\"number\">_</span>) :</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"We got an error\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就实现了一个 Stub。<br>Login 和 Register 都使用了Stub返回的数据。</p>\n<blockquote>\n<p>注意：Moya中Provider对象在销毁的时候会去Cancel网络请求。为了得到正确的结果，你必须保证在网络请求的时候你的Provider不会被释放。否者你会得到下面的错误 “But don’t forget to keep a reference for it in property. If it gets deallocated you’ll see -999 “cancelled” error on response” 。通常为了避免这种情况，你可以将Provider实例设置为类成员变量，或者shared实例</p>\n</blockquote>\n<h4 id=\"Manager\"><a href=\"#Manager\" class=\"headerlink\" title=\"Manager\"></a>Manager</h4><p>Moya 并不是一个网络请求的三方库，它只是一个抽象的网络层。它对其他网络库的进行了桥接，真正进行网络请求是别人的网络库（比如默认的Alamofire.Manager） </p>\n<p>Moya 为此做了几件事情：</p>\n<p>首先抽象了一个RequestType协议，利用这个协议将Alamofire隐藏了起来，让Provider类依赖于这个协议，而不是具体细节。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Plugin.swift</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">RequestType</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Note:</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// We use this protocol instead of the Alamofire request to avoid leaking that abstraction.</span></span><br><span class=\"line\">    <span class=\"comment\">// A plugin should not know about Alamofire at all.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Retrieve an `NSURLRequest` representation.</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> request: <span class=\"type\">URLRequest?</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Authenticates the request with a username and password.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">authenticate</span><span class=\"params\">(user: String, password: String, persistence: URLCredential.Persistence)</span></span> -&gt; <span class=\"type\">Self</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Authenticates the request with an `NSURLCredential` instance.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">authenticate</span><span class=\"params\">(usingCredential credential: URLCredential)</span></span> -&gt; <span class=\"type\">Self</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后让Moya.Manager == Alamofire.Manager，并且让Alamofire.Manager也实现RequestType协议</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Moya+Alamofire.swift</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">Manager</span> = <span class=\"type\">Alamofire</span>.<span class=\"type\">SessionManager</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Choice of parameter encoding.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">ParameterEncoding</span> = <span class=\"type\">Alamofire</span>.<span class=\"type\">ParameterEncoding</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 让Alamofire.Request也实现 RequestType协议</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">typealias</span> <span class=\"type\">Request</span> = <span class=\"type\">Alamofire</span>.<span class=\"type\">Request</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Request</span>: <span class=\"title\">RequestType</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>上面几步，就完成了Alamofire的封装、桥接。正因为桥接封装了Alamofire, 因此Moya的request,最终一定会调用Alamofire的request。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Moya+Internal.swift</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendRequest</span><span class=\"params\">(<span class=\"number\">_</span> target: Target, request: URLRequest, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion)</span></span> -&gt; <span class=\"type\">CancellableToken</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> initialRequest = manager.request(request <span class=\"keyword\">as</span> <span class=\"type\">URLRequestConvertible</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> alamoRequest = target.validate ? initialRequest.validate() : initialRequest</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sendAlamofireRequest(alamoRequest, target: target, callbackQueue: callbackQueue, progress: progress, completion: completion)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Moya 的 <strong>sendRequest</strong> 方法中就是用 <code>manager</code> 去发送请求（默认是 Alamofire）</p>\n<p>如果你想自定义你自己的 Manager, 你可以传入你自己的 Manager 到 Privoder。之后所有的请求都会经过你的这个 Manager 。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> policies: [<span class=\"type\">String</span>: <span class=\"type\">ServerTrustPolicy</span>] = [</span><br><span class=\"line\">    <span class=\"string\">\"example.com\"</span>: .<span class=\"type\">PinPublicKeys</span>(</span><br><span class=\"line\">        publicKeys: <span class=\"type\">ServerTrustPolicy</span>.publicKeysInBundle(),</span><br><span class=\"line\">        validateCertificateChain: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        validateHost: <span class=\"literal\">true</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> manager = <span class=\"type\">Manager</span>(</span><br><span class=\"line\">    configuration: <span class=\"type\">NSURLSessionConfiguration</span>.defaultSessionConfiguration(),</span><br><span class=\"line\">    serverTrustPolicyManager: <span class=\"type\">ServerTrustPolicyManager</span>(policies: policies)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> provider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">MyTarget</span>&gt;(manager: manager)</span><br></pre></td></tr></table></figure>\n<h3 id=\"requestNormal\"><a href=\"#requestNormal\" class=\"headerlink\" title=\"requestNormal\"></a>requestNormal</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">requestNormal</span><span class=\"params\">(<span class=\"number\">_</span> target: Target, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion)</span></span> -&gt; <span class=\"type\">Cancellable</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 生成端点</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> endpoint = <span class=\"keyword\">self</span>.endpoint(target)</span><br><span class=\"line\">    <span class=\"comment\">/// 生成测试表现</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> stubBehavior = <span class=\"keyword\">self</span>.stubClosure(target)</span><br><span class=\"line\">    <span class=\"comment\">/// 生成取消请求的Token</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> cancellableToken = <span class=\"type\">CancellableWrapper</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allow plugins to modify response</span></span><br><span class=\"line\">    <span class=\"comment\">/// 通过自定义的插件完善请求回调的闭包</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> pluginsWithCompletion: <span class=\"type\">Moya</span>.<span class=\"type\">Completion</span> = &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> processedResult = <span class=\"keyword\">self</span>.plugins.<span class=\"built_in\">reduce</span>(result) &#123; $<span class=\"number\">1</span>.process($<span class=\"number\">0</span>, target: target) &#125;</span><br><span class=\"line\">        completion(processedResult)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 是否最终运行中的请求</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> trackInflights &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 进入原子锁</span></span><br><span class=\"line\">        objc_sync_enter(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"comment\">/// 保存请求Endpoint</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> inflightCompletionBlocks = <span class=\"keyword\">self</span>.inflightRequests[endpoint]</span><br><span class=\"line\">        inflightCompletionBlocks?.append(pluginsWithCompletion)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.inflightRequests[endpoint] = inflightCompletionBlocks</span><br><span class=\"line\">        <span class=\"comment\">/// 退出原子锁</span></span><br><span class=\"line\">        objc_sync_exit(<span class=\"keyword\">self</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/// 如果有正在运行中的CompletionBlock则取消本次请求，反之则记录本次请求</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> inflightCompletionBlocks != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cancellableToken</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            objc_sync_enter(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.inflightRequests[endpoint] = [pluginsWithCompletion]</span><br><span class=\"line\">            objc_sync_exit(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 准备请求工作</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> performNetworking = &#123; (requestResult: <span class=\"type\">Result</span>&lt;<span class=\"type\">URLRequest</span>, <span class=\"type\">MoyaError</span>&gt;) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">/// 如果本次请求被取消了则返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cancellableToken.isCancelled &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.cancelCompletion(pluginsWithCompletion, target: target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> request: <span class=\"type\">URLRequest!</span></span><br><span class=\"line\">        <span class=\"comment\">/// 模式匹配取出request</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> requestResult &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .success(<span class=\"keyword\">let</span> urlRequest):</span><br><span class=\"line\">            request = urlRequest</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .failure(<span class=\"keyword\">let</span> error):</span><br><span class=\"line\">            pluginsWithCompletion(.failure(error))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Allow plugins to modify request</span></span><br><span class=\"line\">        <span class=\"comment\">// 通过自定义插件完善请求的闭包</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> preparedRequest = <span class=\"keyword\">self</span>.plugins.<span class=\"built_in\">reduce</span>(request) &#123; $<span class=\"number\">1</span>.prepare($<span class=\"number\">0</span>, target: target) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> networkCompletion: <span class=\"type\">Moya</span>.<span class=\"type\">Completion</span> = &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.trackInflights &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.inflightRequests[endpoint]?.forEach &#123; $<span class=\"number\">0</span>(result) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            objc_sync_enter(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.inflightRequests.removeValue(forKey: endpoint)</span><br><span class=\"line\">            objc_sync_exit(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pluginsWithCompletion(result)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        cancellableToken.innerCancellable = <span class=\"keyword\">self</span>.performRequest(target, request: preparedRequest, callbackQueue: callbackQueue, progress: progress, completion: networkCompletion, endpoint: endpoint, stubBehavior: stubBehavior)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    requestClosure(endpoint, performNetworking)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cancellableToken</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Endpoint（端点）\"><a href=\"#Endpoint（端点）\" class=\"headerlink\" title=\"Endpoint（端点）\"></a>Endpoint（端点）</h2><p>通过 MoyaProvider 产生了一个 API Endpoint，然后通过这个 <strong>Endpoint</strong> 发起请求。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Endpoint</span>&lt;<span class=\"title\">Target</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">SampleResponseClosure</span> = () -&gt; <span class=\"type\">EndpointSampleResponse</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// A string representation of the URL for the request.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">let</span> url: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// A closure responsible for returning an `EndpointSampleResponse`.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">let</span> sampleResponseClosure: <span class=\"type\">SampleResponseClosure</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The HTTP method for the request.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">let</span> method: <span class=\"type\">Moya</span>.<span class=\"type\">Method</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The `Task` for the request.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">let</span> task: <span class=\"type\">Task</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The HTTP header fields for the request.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">let</span> httpHeaderFields: [<span class=\"type\">String</span>: <span class=\"type\">String</span>]?</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(url: <span class=\"type\">String</span>,</span><br><span class=\"line\">                sampleResponseClosure: @escaping <span class=\"type\">SampleResponseClosure</span>,</span><br><span class=\"line\">                method: <span class=\"type\">Moya</span>.<span class=\"type\">Method</span>,</span><br><span class=\"line\">                task: <span class=\"type\">Task</span>,</span><br><span class=\"line\">                httpHeaderFields: [<span class=\"type\">String</span>: <span class=\"type\">String</span>]?) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.url = url</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.sampleResponseClosure = sampleResponseClosure</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.method = method</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.task = task</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.httpHeaderFields = httpHeaderFields</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with added HTTP header fields.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adding</span><span class=\"params\">(newHTTPHeaderFields: [String: String])</span></span> -&gt; <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">Target</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Endpoint</span>(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: add(httpHeaderFields: newHTTPHeaderFields))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with replaced `task` parameter.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">replacing</span><span class=\"params\">(task: Task)</span></span> -&gt; <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">Target</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Endpoint</span>(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: httpHeaderFields)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(httpHeaderFields headers: [String: String]?)</span></span> -&gt; [<span class=\"type\">String</span>: <span class=\"type\">String</span>]? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> unwrappedHeaders = headers, unwrappedHeaders.isEmpty == <span class=\"literal\">false</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.httpHeaderFields</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> newHTTPHeaderFields = <span class=\"keyword\">self</span>.httpHeaderFields ?? [:]</span><br><span class=\"line\">        unwrappedHeaders.forEach &#123; key, value <span class=\"keyword\">in</span></span><br><span class=\"line\">            newHTTPHeaderFields[key] = value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHTTPHeaderFields</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Endpoint 包含着我们这次请求的所有信息。</p>\n<h3 id=\"Endpoint-urlRequest\"><a href=\"#Endpoint-urlRequest\" class=\"headerlink\" title=\"Endpoint.urlRequest\"></a>Endpoint.urlRequest</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Endpoint</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Returns the `Endpoint` converted to a `URLRequest` if valid. Throws an error otherwise.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">urlRequest</span><span class=\"params\">()</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">URLRequest</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> requestURL = <span class=\"type\">Foundation</span>.<span class=\"type\">URL</span>(string: url) <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">MoyaError</span>.requestMapping(url)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> request = <span class=\"type\">URLRequest</span>(url: requestURL)</span><br><span class=\"line\">        request.httpMethod = method.rawValue</span><br><span class=\"line\">        request.allHTTPHeaderFields = httpHeaderFields</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> task &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .requestPlain, .uploadFile, .uploadMultipart, .downloadDestination:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> request</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .requestData(<span class=\"keyword\">let</span> data):</span><br><span class=\"line\">            request.httpBody = data</span><br><span class=\"line\">            <span class=\"keyword\">return</span> request</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .requestJSONEncodable(encodable):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> request.encoded(encodable: encodable)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .requestParameters(parameters, parameterEncoding):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> request.encoded(parameters: parameters, parameterEncoding: parameterEncoding)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .uploadCompositeMultipart(<span class=\"number\">_</span>, urlParameters):</span><br><span class=\"line\">            <span class=\"keyword\">let</span> parameterEncoding = <span class=\"type\">URLEncoding</span>(destination: .queryString)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> request.encoded(parameters: urlParameters, parameterEncoding: parameterEncoding)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .downloadParameters(parameters, parameterEncoding, <span class=\"number\">_</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> request.encoded(parameters: parameters, parameterEncoding: parameterEncoding)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .requestCompositeData(bodyData: bodyData, urlParameters: urlParameters):</span><br><span class=\"line\">            request.httpBody = bodyData</span><br><span class=\"line\">            <span class=\"keyword\">let</span> parameterEncoding = <span class=\"type\">URLEncoding</span>(destination: .queryString)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> request.encoded(parameters: urlParameters, parameterEncoding: parameterEncoding)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .requestCompositeParameters(bodyParameters: bodyParameters, bodyEncoding: bodyParameterEncoding, urlParameters: urlParameters):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> bodyParameterEncoding <span class=\"keyword\">is</span> <span class=\"type\">URLEncoding</span> &#123; <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"URLEncoding is disallowed as bodyEncoding.\"</span>) &#125;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> bodyfulRequest = <span class=\"keyword\">try</span> request.encoded(parameters: bodyParameters, parameterEncoding: bodyParameterEncoding)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> urlEncoding = <span class=\"type\">URLEncoding</span>(destination: .queryString)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> bodyfulRequest.encoded(parameters: urlParameters, parameterEncoding: urlEncoding)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码可以知道 通过 <strong>urlRequest()</strong> 将 <code>Endpoint</code> 转换为一个 <code>URLRequest</code></p>\n<h3 id=\"Endpoint-比较\"><a href=\"#Endpoint-比较\" class=\"headerlink\" title=\"Endpoint 比较\"></a>Endpoint 比较</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Endpoint</span>: <span class=\"title\">Equatable</span>, <span class=\"title\">Hashable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> hashValue: <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> request = <span class=\"keyword\">try</span>? urlRequest()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> request?.hashValue ?? url.hashValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Note: If both Endpoints fail to produce a URLRequest the comparison will</span></span><br><span class=\"line\">    <span class=\"comment\">/// fall back to comparing each Endpoint's hashValue.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> == &lt;T&gt;<span class=\"params\">(lhs: Endpoint&lt;T&gt;, rhs: Endpoint&lt;T&gt;)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> lhsRequest = <span class=\"keyword\">try</span>? lhs.urlRequest()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> rhsRequest = <span class=\"keyword\">try</span>? rhs.urlRequest()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lhsRequest != <span class=\"literal\">nil</span>, rhsRequest == <span class=\"literal\">nil</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lhsRequest == <span class=\"literal\">nil</span>, rhsRequest != <span class=\"literal\">nil</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lhsRequest == <span class=\"literal\">nil</span>, rhsRequest == <span class=\"literal\">nil</span> &#123; <span class=\"keyword\">return</span> lhs.hashValue == rhs.hashValue &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (lhsRequest == rhsRequest)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>遵守 <strong>Equatable</strong> 和 <strong>Hashable</strong> 协议并实现响应方法即可为自己的类提供==比较方法.这个对比方法用来追踪已经在请求中的request。排除多次无用请求。</p>\n<p>Moya 提供了一个默认的 <strong>EndpointClosure</strong> 的函数，来实现这个Target到Endpoint的转换：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">defaultEndpointMapping</span>(<span class=\"title\">for</span> <span class=\"title\">target</span>: <span class=\"title\">Target</span>) -&gt; <span class=\"title\">Endpoint</span>&lt;<span class=\"title\">Target</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">Endpoint</span>(</span><br><span class=\"line\">        url: <span class=\"type\">URL</span>(target: target).absoluteString,</span><br><span class=\"line\">        sampleResponseClosure: &#123; .networkResponse(<span class=\"number\">200</span>, target.sampleData) &#125;,</span><br><span class=\"line\">        method: target.method,</span><br><span class=\"line\">        task: target.task,</span><br><span class=\"line\">        httpHeaderFields: target.headers</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"SampleResponseClosure\"><a href=\"#SampleResponseClosure\" class=\"headerlink\" title=\"SampleResponseClosure\"></a>SampleResponseClosure</h3><p>Endpoint 有一个叫做 SampleResponseClosure 的 Enum，用来返回定制的测试networkResponse。比如特定的StautsCode之类的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Used for stubbing responses.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">EndpointSampleResponse</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The network returned a response, including status code and data.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> networkResponse(<span class=\"type\">Int</span>, <span class=\"type\">Data</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The network returned response which can be fully customized.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> response(<span class=\"type\">HTTPURLResponse</span>, <span class=\"type\">Data</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The network failed to send the request, or failed to retrieve a response (eg a timeout).</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> networkError(<span class=\"type\">NSError</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li><p><strong>endpointClosure</strong>、<strong>requestClosure</strong>、<strong>stubClosure</strong>，这3个Closure是让我们定制请求、响应和进行测试时的回调，非常有用。</p>\n</li>\n<li><p><strong>Manager</strong> 是真正用来网络请求的类，Moya 自己并不提供 Manager 类，Moya只是对其他网络请求类进行了简单的桥接。这么做是为了让调用方可以轻易地定制、更换网络请求的库。比如你不想用Alamofire，可以十分简单的换成其他库。</p>\n</li>\n<li><p><strong>PluginType</strong> 数组。Moya 提供了一个插件机制，使我们可以建立自己的插件类来做一些额外的事情。比如写Log，显示“菊花”等。抽离出Plugin层的目的，就是让Provider职责单一，满足开闭原则。把和自己网络无关的行为抽离。避免各种业务揉在一起不利于扩展。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇文章<a href=\"http://piglikeyoung.com/2017/08/27/moya-analysis-1/\">《Moya 源码分析（一）》</a>分析了 <strong>TargetType</strong>，本文将分析 Moya 的核心 <strong>Provider</strong></p>\n<h2 id=\"MoyaProvider\"><a href=\"#MoyaProvider\" class=\"headerlink\" title=\"MoyaProvider\"></a>MoyaProvider</h2><p>MoyaProvider是Moya的基础，它是你API的端点的管理者。Moya的所有功能都是通过MoyaProvider来使用。</p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>MoyaProvider 的定义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MoyaProvider</span>&lt;<span class=\"title\">Target</span>: <span class=\"title\">TargetType</span>&gt;: <span class=\"title\">MoyaProviderType</span></span></span><br></pre></td></tr></table></figure>\n<p>它使用了泛型，接收一个遵守 <strong>TargetType</strong> 的类型，自己遵守了 <strong>MoyaProviderType</strong>协议。</p>\n<p><code>Provider真正做的事情可以用一个流来表示：Target -&gt; Endpoint -&gt; Request</code></p>\n<p>使用Demo的例子来说就是，它将 <strong>GitHubAPI</strong> 转换成 <strong>Endpoint</strong>，再将其转换成 <strong>NSRURLRequest</strong>，最后将这个 <strong>NSRURLRequest</strong> 交给 <strong>Alamofire</strong> 去网络请求。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><h4 id=\"EndpointClosure\"><a href=\"#EndpointClosure\" class=\"headerlink\" title=\"EndpointClosure\"></a>EndpointClosure</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Closure that defines the endpoints for the provider.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">EndpointClosure</span> = (<span class=\"type\">Target</span>) -&gt; <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">Target</span>&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>EndpointClosure</strong> 属性是一个闭包，用于让我们对 <strong>Moya</strong> 生成的 <strong>Endpoint</strong> 进行一些我们自己的定制然后返回一个 <strong>Endpoint</strong> 类，例如：我们想增加一个新的HttpHeader：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> endpointClosure = &#123; (target: <span class=\"type\">MyTarget</span>) -&gt; <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">MyTarget</span>&gt; <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultEndpoint = <span class=\"type\">MoyaProvider</span>.defaultEndpointMapping(<span class=\"keyword\">for</span>: target)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultEndpoint.adding(newHTTPHeaderFields: [<span class=\"string\">\"APP_NAME\"</span>: <span class=\"string\">\"MY_APP\"</span>])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> provider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">GitHub</span>&gt;(endpointClosure: endpointClosure)</span><br></pre></td></tr></table></figure>\n<p>这个闭包输入一个 <strong>target</strong>，返回 <strong>Endpoint</strong>。就是前面说的 <code>Target -&gt; Endpoint的转换</code></p>\n<blockquote>\n<p>Endpoint 稍后就分析!</p>\n</blockquote>\n<h4 id=\"RequestClosure\"><a href=\"#RequestClosure\" class=\"headerlink\" title=\"RequestClosure\"></a>RequestClosure</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Closure that resolves an `Endpoint` into a `RequestResult`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">RequestClosure</span> = (<span class=\"type\">Endpoint</span>&lt;<span class=\"type\">Target</span>&gt;, @escaping <span class=\"type\">RequestResultClosure</span>) -&gt; <span class=\"type\">Void</span></span><br></pre></td></tr></table></figure>\n<p>这个闭包就是实现将<code>Endpoint -&gt; NSURLRequest</code>，Moya也提供了一个默认实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// MoyaProvider+Defaults.swift</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">defaultRequestMapping</span>(<span class=\"title\">for</span> <span class=\"title\">endpoint</span>: <span class=\"title\">Endpoint</span>&lt;<span class=\"title\">Target</span>&gt;, <span class=\"title\">closure</span>: <span class=\"title\">RequestResultClosure</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> urlRequest = <span class=\"keyword\">try</span> endpoint.urlRequest()</span><br><span class=\"line\">        closure(.success(urlRequest))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> <span class=\"type\">MoyaError</span>.requestMapping(<span class=\"keyword\">let</span> url) &#123;</span><br><span class=\"line\">        closure(.failure(<span class=\"type\">MoyaError</span>.requestMapping(url)))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> <span class=\"type\">MoyaError</span>.parameterEncoding(<span class=\"keyword\">let</span> error) &#123;</span><br><span class=\"line\">        closure(.failure(<span class=\"type\">MoyaError</span>.parameterEncoding(error)))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        closure(.failure(<span class=\"type\">MoyaError</span>.underlying(error, <span class=\"literal\">nil</span>)))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认实现也只是简单地调用endpoint.urlRequest取得一个NSURLRequest实例。然后调用了closure。然而，你可以在这里修改这个请求Request, 事实上这也是Moya给你的最后的机会。举个例子, 你想禁用所有的cookie，并且设置超时时间等。那么你可以实现这样的闭包：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> requestClosure = &#123; (endpoint: <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">GitHub</span>&gt;, done: <span class=\"type\">MoyaProvider</span>.<span class=\"type\">RequestResultClosure</span>) <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以在这里修改request</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> request: <span class=\"type\">URLRequest</span> = endpoint.urlRequest</span><br><span class=\"line\">    request.httpShouldHandleCookies = <span class=\"literal\">false</span></span><br><span class=\"line\">    request.timeoutInterval = <span class=\"number\">20</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    done(.success(request))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">provider = <span class=\"type\">MoyaProvider</span>(requestClosure: requestClosure)</span><br></pre></td></tr></table></figure>\n<h4 id=\"RequestResultClosure\"><a href=\"#RequestResultClosure\" class=\"headerlink\" title=\"RequestResultClosure\"></a>RequestResultClosure</h4><p>创建 requestClosure 时，用到了闭包 RequestResultClosure，它的参数类型是 <code>Result</code>，这是使用了 <strong><a href=\"https://github.com/antitypical/Result\" target=\"_blank\" rel=\"noopener\">Result框架</a></strong>，<strong>用来将throw的方式换成Result&lt;data,error&gt;的方式返回</strong>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Closure that decides if and what request should be performed.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">RequestResultClosure</span> = (<span class=\"type\">Result</span>&lt;<span class=\"type\">URLRequest</span>, <span class=\"type\">MoyaError</span>&gt;) -&gt; <span class=\"type\">Void</span></span><br></pre></td></tr></table></figure>\n<p>从上面可以看出，<strong>EndpointClosure</strong> 和 <strong>RequestClosure</strong> 实现了 Target -&gt; Endpoint -&gt; NSRequest的转换流。</p>\n<h4 id=\"StubClosure\"><a href=\"#StubClosure\" class=\"headerlink\" title=\"StubClosure\"></a>StubClosure</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Closure that decides if/how a request should be stubbed.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">StubClosure</span> = (<span class=\"type\">Target</span>) -&gt; <span class=\"type\">Moya</span>.<span class=\"type\">StubBehavior</span></span><br></pre></td></tr></table></figure>\n<p>这个闭包比较简单，返回一个 <strong>Moya.StubBehavior</strong> 的枚举值。它就是让你告诉Moya你是否使用Stub返回数据或者怎样使用Stub返回数据</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">StubBehavior</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 不使用Stub返回数据</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> never</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 立即使用Stub返回数据</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> immediate</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 一段时间间隔后使用Stub返回的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> delayed(seconds: <span class=\"type\">TimeInterval</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Never  表明不使用Stub来返回模拟的网络数据， Immediate表示马上返回Stub的数据， Delayed  是在几秒后返回。Moya 默认是不使用Stub来测试。</p>\n<p>在 API 中我们给 sampleData 赋值后，这个属性是返回的Stub数据。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">AccountAPI</span>: <span class=\"title\">TargetType</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sampleData: <span class=\"type\">NSData</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .<span class=\"type\">Login</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&#123;'code': 400, 'Token':'123455'&#125;\"</span>.dataUsingEncoding(<span class=\"type\">NSUTF8StringEncoding</span>)!</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .<span class=\"type\">Register</span>(<span class=\"keyword\">let</span> userName, <span class=\"keyword\">let</span> passwd):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"找不到数据\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> endPointAction = &#123; (target: <span class=\"type\">TargetType</span>) -&gt; <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">AccountAPI</span>&gt; <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = target.baseURL.<span class=\"type\">URLByAppendingPathComponent</span>(target.path).absoluteString</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> target &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Login</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Endpoint</span>(<span class=\"type\">URL</span>: url, sampleResponseClosure: &#123;.<span class=\"type\">NetworkResponse</span>(<span class=\"number\">200</span>, target.sampleData)&#125;, method: target.method, parameters: target.parameters)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Register</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Endpoint</span>(<span class=\"type\">URL</span>: url, sampleResponseClosure: &#123;.<span class=\"type\">NetworkResponse</span>(<span class=\"number\">404</span>, target.sampleData)&#125;, method: target.method, parameters: target.parameters)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> stubAction: (type: <span class=\"type\">AccountAPI</span>) -&gt; <span class=\"type\">Moya</span>.<span class=\"type\">StubBehavior</span>  = &#123; type <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Login</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Moya</span>.<span class=\"type\">StubBehavior</span>.<span class=\"type\">Immediate</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Register</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Moya</span>.<span class=\"type\">StubBehavior</span>.<span class=\"type\">Delayed</span>(seconds: <span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> loginAPIProvider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">AccountAPI</span>&gt;(</span><br><span class=\"line\">    endpointClosure: endPointAction,</span><br><span class=\"line\">    stubClosure: stubAction</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">loginAPIProvider.request(<span class=\"type\">AccountAPI</span>.<span class=\"type\">Login</span>(userName: <span class=\"string\">\"user\"</span>, passwd: <span class=\"string\">\"123456\"</span>)) &#123; (result) <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> result &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Success</span>(<span class=\"keyword\">let</span> respones) :</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(respones)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> .<span class=\"type\">Failure</span>(<span class=\"number\">_</span>) :</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"We got an error\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就实现了一个 Stub。<br>Login 和 Register 都使用了Stub返回的数据。</p>\n<blockquote>\n<p>注意：Moya中Provider对象在销毁的时候会去Cancel网络请求。为了得到正确的结果，你必须保证在网络请求的时候你的Provider不会被释放。否者你会得到下面的错误 “But don’t forget to keep a reference for it in property. If it gets deallocated you’ll see -999 “cancelled” error on response” 。通常为了避免这种情况，你可以将Provider实例设置为类成员变量，或者shared实例</p>\n</blockquote>\n<h4 id=\"Manager\"><a href=\"#Manager\" class=\"headerlink\" title=\"Manager\"></a>Manager</h4><p>Moya 并不是一个网络请求的三方库，它只是一个抽象的网络层。它对其他网络库的进行了桥接，真正进行网络请求是别人的网络库（比如默认的Alamofire.Manager） </p>\n<p>Moya 为此做了几件事情：</p>\n<p>首先抽象了一个RequestType协议，利用这个协议将Alamofire隐藏了起来，让Provider类依赖于这个协议，而不是具体细节。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Plugin.swift</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">RequestType</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Note:</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// We use this protocol instead of the Alamofire request to avoid leaking that abstraction.</span></span><br><span class=\"line\">    <span class=\"comment\">// A plugin should not know about Alamofire at all.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Retrieve an `NSURLRequest` representation.</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> request: <span class=\"type\">URLRequest?</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Authenticates the request with a username and password.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">authenticate</span><span class=\"params\">(user: String, password: String, persistence: URLCredential.Persistence)</span></span> -&gt; <span class=\"type\">Self</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Authenticates the request with an `NSURLCredential` instance.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">authenticate</span><span class=\"params\">(usingCredential credential: URLCredential)</span></span> -&gt; <span class=\"type\">Self</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后让Moya.Manager == Alamofire.Manager，并且让Alamofire.Manager也实现RequestType协议</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Moya+Alamofire.swift</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">Manager</span> = <span class=\"type\">Alamofire</span>.<span class=\"type\">SessionManager</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Choice of parameter encoding.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">ParameterEncoding</span> = <span class=\"type\">Alamofire</span>.<span class=\"type\">ParameterEncoding</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 让Alamofire.Request也实现 RequestType协议</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">typealias</span> <span class=\"type\">Request</span> = <span class=\"type\">Alamofire</span>.<span class=\"type\">Request</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Request</span>: <span class=\"title\">RequestType</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>上面几步，就完成了Alamofire的封装、桥接。正因为桥接封装了Alamofire, 因此Moya的request,最终一定会调用Alamofire的request。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Moya+Internal.swift</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendRequest</span><span class=\"params\">(<span class=\"number\">_</span> target: Target, request: URLRequest, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion)</span></span> -&gt; <span class=\"type\">CancellableToken</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> initialRequest = manager.request(request <span class=\"keyword\">as</span> <span class=\"type\">URLRequestConvertible</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> alamoRequest = target.validate ? initialRequest.validate() : initialRequest</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sendAlamofireRequest(alamoRequest, target: target, callbackQueue: callbackQueue, progress: progress, completion: completion)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Moya 的 <strong>sendRequest</strong> 方法中就是用 <code>manager</code> 去发送请求（默认是 Alamofire）</p>\n<p>如果你想自定义你自己的 Manager, 你可以传入你自己的 Manager 到 Privoder。之后所有的请求都会经过你的这个 Manager 。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> policies: [<span class=\"type\">String</span>: <span class=\"type\">ServerTrustPolicy</span>] = [</span><br><span class=\"line\">    <span class=\"string\">\"example.com\"</span>: .<span class=\"type\">PinPublicKeys</span>(</span><br><span class=\"line\">        publicKeys: <span class=\"type\">ServerTrustPolicy</span>.publicKeysInBundle(),</span><br><span class=\"line\">        validateCertificateChain: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        validateHost: <span class=\"literal\">true</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> manager = <span class=\"type\">Manager</span>(</span><br><span class=\"line\">    configuration: <span class=\"type\">NSURLSessionConfiguration</span>.defaultSessionConfiguration(),</span><br><span class=\"line\">    serverTrustPolicyManager: <span class=\"type\">ServerTrustPolicyManager</span>(policies: policies)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> provider = <span class=\"type\">MoyaProvider</span>&lt;<span class=\"type\">MyTarget</span>&gt;(manager: manager)</span><br></pre></td></tr></table></figure>\n<h3 id=\"requestNormal\"><a href=\"#requestNormal\" class=\"headerlink\" title=\"requestNormal\"></a>requestNormal</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">requestNormal</span><span class=\"params\">(<span class=\"number\">_</span> target: Target, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion)</span></span> -&gt; <span class=\"type\">Cancellable</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 生成端点</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> endpoint = <span class=\"keyword\">self</span>.endpoint(target)</span><br><span class=\"line\">    <span class=\"comment\">/// 生成测试表现</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> stubBehavior = <span class=\"keyword\">self</span>.stubClosure(target)</span><br><span class=\"line\">    <span class=\"comment\">/// 生成取消请求的Token</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> cancellableToken = <span class=\"type\">CancellableWrapper</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allow plugins to modify response</span></span><br><span class=\"line\">    <span class=\"comment\">/// 通过自定义的插件完善请求回调的闭包</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> pluginsWithCompletion: <span class=\"type\">Moya</span>.<span class=\"type\">Completion</span> = &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> processedResult = <span class=\"keyword\">self</span>.plugins.<span class=\"built_in\">reduce</span>(result) &#123; $<span class=\"number\">1</span>.process($<span class=\"number\">0</span>, target: target) &#125;</span><br><span class=\"line\">        completion(processedResult)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 是否最终运行中的请求</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> trackInflights &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 进入原子锁</span></span><br><span class=\"line\">        objc_sync_enter(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"comment\">/// 保存请求Endpoint</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> inflightCompletionBlocks = <span class=\"keyword\">self</span>.inflightRequests[endpoint]</span><br><span class=\"line\">        inflightCompletionBlocks?.append(pluginsWithCompletion)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.inflightRequests[endpoint] = inflightCompletionBlocks</span><br><span class=\"line\">        <span class=\"comment\">/// 退出原子锁</span></span><br><span class=\"line\">        objc_sync_exit(<span class=\"keyword\">self</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/// 如果有正在运行中的CompletionBlock则取消本次请求，反之则记录本次请求</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> inflightCompletionBlocks != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cancellableToken</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            objc_sync_enter(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.inflightRequests[endpoint] = [pluginsWithCompletion]</span><br><span class=\"line\">            objc_sync_exit(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 准备请求工作</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> performNetworking = &#123; (requestResult: <span class=\"type\">Result</span>&lt;<span class=\"type\">URLRequest</span>, <span class=\"type\">MoyaError</span>&gt;) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">/// 如果本次请求被取消了则返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cancellableToken.isCancelled &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.cancelCompletion(pluginsWithCompletion, target: target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> request: <span class=\"type\">URLRequest!</span></span><br><span class=\"line\">        <span class=\"comment\">/// 模式匹配取出request</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> requestResult &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .success(<span class=\"keyword\">let</span> urlRequest):</span><br><span class=\"line\">            request = urlRequest</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .failure(<span class=\"keyword\">let</span> error):</span><br><span class=\"line\">            pluginsWithCompletion(.failure(error))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Allow plugins to modify request</span></span><br><span class=\"line\">        <span class=\"comment\">// 通过自定义插件完善请求的闭包</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> preparedRequest = <span class=\"keyword\">self</span>.plugins.<span class=\"built_in\">reduce</span>(request) &#123; $<span class=\"number\">1</span>.prepare($<span class=\"number\">0</span>, target: target) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> networkCompletion: <span class=\"type\">Moya</span>.<span class=\"type\">Completion</span> = &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.trackInflights &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.inflightRequests[endpoint]?.forEach &#123; $<span class=\"number\">0</span>(result) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            objc_sync_enter(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.inflightRequests.removeValue(forKey: endpoint)</span><br><span class=\"line\">            objc_sync_exit(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pluginsWithCompletion(result)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        cancellableToken.innerCancellable = <span class=\"keyword\">self</span>.performRequest(target, request: preparedRequest, callbackQueue: callbackQueue, progress: progress, completion: networkCompletion, endpoint: endpoint, stubBehavior: stubBehavior)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    requestClosure(endpoint, performNetworking)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cancellableToken</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Endpoint（端点）\"><a href=\"#Endpoint（端点）\" class=\"headerlink\" title=\"Endpoint（端点）\"></a>Endpoint（端点）</h2><p>通过 MoyaProvider 产生了一个 API Endpoint，然后通过这个 <strong>Endpoint</strong> 发起请求。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Endpoint</span>&lt;<span class=\"title\">Target</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">SampleResponseClosure</span> = () -&gt; <span class=\"type\">EndpointSampleResponse</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// A string representation of the URL for the request.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">let</span> url: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// A closure responsible for returning an `EndpointSampleResponse`.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">let</span> sampleResponseClosure: <span class=\"type\">SampleResponseClosure</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The HTTP method for the request.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">let</span> method: <span class=\"type\">Moya</span>.<span class=\"type\">Method</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The `Task` for the request.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">let</span> task: <span class=\"type\">Task</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The HTTP header fields for the request.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">let</span> httpHeaderFields: [<span class=\"type\">String</span>: <span class=\"type\">String</span>]?</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(url: <span class=\"type\">String</span>,</span><br><span class=\"line\">                sampleResponseClosure: @escaping <span class=\"type\">SampleResponseClosure</span>,</span><br><span class=\"line\">                method: <span class=\"type\">Moya</span>.<span class=\"type\">Method</span>,</span><br><span class=\"line\">                task: <span class=\"type\">Task</span>,</span><br><span class=\"line\">                httpHeaderFields: [<span class=\"type\">String</span>: <span class=\"type\">String</span>]?) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.url = url</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.sampleResponseClosure = sampleResponseClosure</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.method = method</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.task = task</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.httpHeaderFields = httpHeaderFields</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with added HTTP header fields.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adding</span><span class=\"params\">(newHTTPHeaderFields: [String: String])</span></span> -&gt; <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">Target</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Endpoint</span>(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: add(httpHeaderFields: newHTTPHeaderFields))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with replaced `task` parameter.</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">replacing</span><span class=\"params\">(task: Task)</span></span> -&gt; <span class=\"type\">Endpoint</span>&lt;<span class=\"type\">Target</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Endpoint</span>(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: httpHeaderFields)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(httpHeaderFields headers: [String: String]?)</span></span> -&gt; [<span class=\"type\">String</span>: <span class=\"type\">String</span>]? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> unwrappedHeaders = headers, unwrappedHeaders.isEmpty == <span class=\"literal\">false</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.httpHeaderFields</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> newHTTPHeaderFields = <span class=\"keyword\">self</span>.httpHeaderFields ?? [:]</span><br><span class=\"line\">        unwrappedHeaders.forEach &#123; key, value <span class=\"keyword\">in</span></span><br><span class=\"line\">            newHTTPHeaderFields[key] = value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHTTPHeaderFields</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Endpoint 包含着我们这次请求的所有信息。</p>\n<h3 id=\"Endpoint-urlRequest\"><a href=\"#Endpoint-urlRequest\" class=\"headerlink\" title=\"Endpoint.urlRequest\"></a>Endpoint.urlRequest</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Endpoint</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Returns the `Endpoint` converted to a `URLRequest` if valid. Throws an error otherwise.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">urlRequest</span><span class=\"params\">()</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">URLRequest</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> requestURL = <span class=\"type\">Foundation</span>.<span class=\"type\">URL</span>(string: url) <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">MoyaError</span>.requestMapping(url)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> request = <span class=\"type\">URLRequest</span>(url: requestURL)</span><br><span class=\"line\">        request.httpMethod = method.rawValue</span><br><span class=\"line\">        request.allHTTPHeaderFields = httpHeaderFields</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> task &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .requestPlain, .uploadFile, .uploadMultipart, .downloadDestination:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> request</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .requestData(<span class=\"keyword\">let</span> data):</span><br><span class=\"line\">            request.httpBody = data</span><br><span class=\"line\">            <span class=\"keyword\">return</span> request</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .requestJSONEncodable(encodable):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> request.encoded(encodable: encodable)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .requestParameters(parameters, parameterEncoding):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> request.encoded(parameters: parameters, parameterEncoding: parameterEncoding)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .uploadCompositeMultipart(<span class=\"number\">_</span>, urlParameters):</span><br><span class=\"line\">            <span class=\"keyword\">let</span> parameterEncoding = <span class=\"type\">URLEncoding</span>(destination: .queryString)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> request.encoded(parameters: urlParameters, parameterEncoding: parameterEncoding)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .downloadParameters(parameters, parameterEncoding, <span class=\"number\">_</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> request.encoded(parameters: parameters, parameterEncoding: parameterEncoding)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .requestCompositeData(bodyData: bodyData, urlParameters: urlParameters):</span><br><span class=\"line\">            request.httpBody = bodyData</span><br><span class=\"line\">            <span class=\"keyword\">let</span> parameterEncoding = <span class=\"type\">URLEncoding</span>(destination: .queryString)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> request.encoded(parameters: urlParameters, parameterEncoding: parameterEncoding)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .requestCompositeParameters(bodyParameters: bodyParameters, bodyEncoding: bodyParameterEncoding, urlParameters: urlParameters):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> bodyParameterEncoding <span class=\"keyword\">is</span> <span class=\"type\">URLEncoding</span> &#123; <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"URLEncoding is disallowed as bodyEncoding.\"</span>) &#125;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> bodyfulRequest = <span class=\"keyword\">try</span> request.encoded(parameters: bodyParameters, parameterEncoding: bodyParameterEncoding)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> urlEncoding = <span class=\"type\">URLEncoding</span>(destination: .queryString)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> bodyfulRequest.encoded(parameters: urlParameters, parameterEncoding: urlEncoding)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码可以知道 通过 <strong>urlRequest()</strong> 将 <code>Endpoint</code> 转换为一个 <code>URLRequest</code></p>\n<h3 id=\"Endpoint-比较\"><a href=\"#Endpoint-比较\" class=\"headerlink\" title=\"Endpoint 比较\"></a>Endpoint 比较</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Endpoint</span>: <span class=\"title\">Equatable</span>, <span class=\"title\">Hashable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> hashValue: <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> request = <span class=\"keyword\">try</span>? urlRequest()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> request?.hashValue ?? url.hashValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Note: If both Endpoints fail to produce a URLRequest the comparison will</span></span><br><span class=\"line\">    <span class=\"comment\">/// fall back to comparing each Endpoint's hashValue.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> == &lt;T&gt;<span class=\"params\">(lhs: Endpoint&lt;T&gt;, rhs: Endpoint&lt;T&gt;)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> lhsRequest = <span class=\"keyword\">try</span>? lhs.urlRequest()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> rhsRequest = <span class=\"keyword\">try</span>? rhs.urlRequest()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lhsRequest != <span class=\"literal\">nil</span>, rhsRequest == <span class=\"literal\">nil</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lhsRequest == <span class=\"literal\">nil</span>, rhsRequest != <span class=\"literal\">nil</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lhsRequest == <span class=\"literal\">nil</span>, rhsRequest == <span class=\"literal\">nil</span> &#123; <span class=\"keyword\">return</span> lhs.hashValue == rhs.hashValue &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (lhsRequest == rhsRequest)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>遵守 <strong>Equatable</strong> 和 <strong>Hashable</strong> 协议并实现响应方法即可为自己的类提供==比较方法.这个对比方法用来追踪已经在请求中的request。排除多次无用请求。</p>\n<p>Moya 提供了一个默认的 <strong>EndpointClosure</strong> 的函数，来实现这个Target到Endpoint的转换：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">defaultEndpointMapping</span>(<span class=\"title\">for</span> <span class=\"title\">target</span>: <span class=\"title\">Target</span>) -&gt; <span class=\"title\">Endpoint</span>&lt;<span class=\"title\">Target</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">Endpoint</span>(</span><br><span class=\"line\">        url: <span class=\"type\">URL</span>(target: target).absoluteString,</span><br><span class=\"line\">        sampleResponseClosure: &#123; .networkResponse(<span class=\"number\">200</span>, target.sampleData) &#125;,</span><br><span class=\"line\">        method: target.method,</span><br><span class=\"line\">        task: target.task,</span><br><span class=\"line\">        httpHeaderFields: target.headers</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"SampleResponseClosure\"><a href=\"#SampleResponseClosure\" class=\"headerlink\" title=\"SampleResponseClosure\"></a>SampleResponseClosure</h3><p>Endpoint 有一个叫做 SampleResponseClosure 的 Enum，用来返回定制的测试networkResponse。比如特定的StautsCode之类的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Used for stubbing responses.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">EndpointSampleResponse</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The network returned a response, including status code and data.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> networkResponse(<span class=\"type\">Int</span>, <span class=\"type\">Data</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The network returned response which can be fully customized.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> response(<span class=\"type\">HTTPURLResponse</span>, <span class=\"type\">Data</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The network failed to send the request, or failed to retrieve a response (eg a timeout).</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> networkError(<span class=\"type\">NSError</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li><p><strong>endpointClosure</strong>、<strong>requestClosure</strong>、<strong>stubClosure</strong>，这3个Closure是让我们定制请求、响应和进行测试时的回调，非常有用。</p>\n</li>\n<li><p><strong>Manager</strong> 是真正用来网络请求的类，Moya 自己并不提供 Manager 类，Moya只是对其他网络请求类进行了简单的桥接。这么做是为了让调用方可以轻易地定制、更换网络请求的库。比如你不想用Alamofire，可以十分简单的换成其他库。</p>\n</li>\n<li><p><strong>PluginType</strong> 数组。Moya 提供了一个插件机制，使我们可以建立自己的插件类来做一些额外的事情。比如写Log，显示“菊花”等。抽离出Plugin层的目的，就是让Provider职责单一，满足开闭原则。把和自己网络无关的行为抽离。避免各种业务揉在一起不利于扩展。</p>\n</li>\n</ol>\n"},{"title":"AFNetworking 核心 AFURLSessionManager（二）","date":"2016-12-24T02:33:37.000Z","_content":"\n## 前言\n上一章对 AFNetworking进行了概述，这一章重点对 AFN 的核心 **AFURLSessionManager**进行分析\n\n## AFURLSessionManager属性\n\n主要属性：\n\n```objc\n/**\n AFURLSessionManager管理的Session对象\n */\n@property (readonly, nonatomic, strong) NSURLSession *session;\n\n/**\n delegate的回调所在队列\n */\n@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;\n\n/**\n 解析网络请求返回的数据，遵循AFURLResponseSerialization协议，并且不能为nil\n */\n@property (nonatomic, strong) id <AFURLResponseSerialization> responseSerializer;\n\n/**\n securityPolicy 是处理网络连接安全的对象，无特别的要求一般使用‘defaultPolicy’\n */\n@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;\n\n/**\n reachabilityManager 是用于监控网络状态的对象，默认使用‘sharedManager’\n */\n@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;\n\n/**\n Session中正在运行的 Task ，包括 dataTask，uploadTask，downloadTask\n */\n@property (readonly, nonatomic, strong) NSArray <NSURLSessionTask *> *tasks;\n\n/**\n Session中正在运行的 dataTask\n */\n@property (readonly, nonatomic, strong) NSArray <NSURLSessionDataTask *> *dataTasks;\n\n/**\n Session中正在运行的 uploadTask\n */\n@property (readonly, nonatomic, strong) NSArray <NSURLSessionUploadTask *> *uploadTasks;\n\n/**\n Session中正在运行的 downloadTask\n */\n@property (readonly, nonatomic, strong) NSArray <NSURLSessionDownloadTask *> *downloadTasks;\n\n/**\n completionBlock的回调GCD队列，如果未主动设置，默认是 main queue\n */\n@property (nonatomic, strong, nullable) dispatch_queue_t completionQueue;\n\n/**\n completionBlock的回调Group-GCD队列，如果未主动设置，默认是 private dispatch group\n */\n@property (nonatomic, strong, nullable) dispatch_group_t completionGroup;\n\n///---------------------------------\n/// @name Working Around System Bugs\n///---------------------------------\n\n/**\n 当在后台session创建 upload task 返回‘nil’的时候，是否尝试重新创建 upload tasks，默认是NO\n\n @bug 这是 iOS 7.0的 bug，这个 bug 是当在后台session 创建 upload task 时，upload task 有时候会初始化为‘nil’。作为一种替代方法，如果这个属性设置为 YES ，AFN 会按照 Apple 推荐的方式创建 Task。\n\n @详见 https://github.com/AFNetworking/AFNetworking/issues/1675\n */\n@property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions;\n```\n\nAFURLSessionManager 的属性不是很多，也不是很复杂，注释也非常详尽。\n\n## 使用AFURLSessionManager完成网络请求\n\n使用AFURLSessionManager完成网络获取网络数据，仅需要如下几个步骤：\n\n```objc\n// 1.初始化AFURLSessionManager对象\nNSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\nAFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];\n    \n// 初始请求\nNSURLRequest *request = [[NSURLRequest alloc] initWithURL:[[NSURL alloc] initWithString:@\"https://github.com\"]];\n    \n// 2.获取AFURLSessionManager的task对象\nNSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {\n   if (error) {\n       NSLog(@\"Error: %@\", error);\n   } else {\n       NSLog(@\"Get Net data success!\");\n   }\n}];\n// 3.启动task\n[dataTask resume];\n```\n除了初始化 NSURLRequest ，完成整个数据请求只需要的三步，👇逐步分析如何实现的\n\n### 初始化AFURLSessionManager\n\n调用这个方法来初始化 AFURLSessionManager\n```objc\n- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration\n```\n它只有一个 NSURLSessionConfiguration 参数。\n\n实现的代码：\n\n```objc\n- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n\n    // ======================== 设置NSURLSession ==============================\n    // 如果 configuration 为 ‘nil’，使用 defaultSessionConfiguration\n    if (!configuration) {\n        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    }\n\n    self.sessionConfiguration = configuration;\n\n    self.operationQueue = [[NSOperationQueue alloc] init];\n    // delegate 回调队列，最大并发数为 1\n    self.operationQueue.maxConcurrentOperationCount = 1;\n\n    // 初始化 Session\n    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];\n    \n    // ======================== 初始化 response 序列化 ==============================\n    self.responseSerializer = [AFJSONResponseSerializer serializer];\n    \n    // ======================== 初始化 网络安全策略 ==============================\n    self.securityPolicy = [AFSecurityPolicy defaultPolicy];\n\n    // ======================== 初始化 网络监控 ==============================\n#if !TARGET_OS_WATCH\n    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];\n#endif\n\n    // ======================== 初始化 Task 和 AFURLSessionManagerTaskDelegate 字典 ==============================\n    // key 为 taskId，value 为 AFURLSessionManagerTaskDelegate\n    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];\n\n    // ======================== 初始化 mutableTaskDelegatesKeyedByTaskIdentifier 字典锁  ==============================\n    // 保证 mutableTaskDelegatesKeyedByTaskIdentifier 的多线程安全\n    self.lock = [[NSLock alloc] init];\n    self.lock.name = AFURLSessionManagerLockName;\n\n    // ======================== 获取当前 Session 中所有的 Task  ==============================\n    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {\n        // 为已有的 task 设置代理（在`生成NSURLSessionTask`细说）\n        for (NSURLSessionDataTask *task in dataTasks) {\n            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];\n        }\n\n        for (NSURLSessionUploadTask *uploadTask in uploadTasks) {\n            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];\n        }\n\n        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) {\n            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];\n        }\n    }];\n\n    return self;\n}\n```\n\n这就是 AFURLSessionManager 的初始化方法，主要对其属性进行出初始化。\n需要注意的是这两个私有属性：\n\n```objc\n@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;\n@property (readwrite, nonatomic, strong) NSLock *lock;\n```\nAFURLSessionManager 会给每个管理的 task 对应的创建一个 AFURLSessionManagerTaskDelegate 对象，Manager把 task 的具体处理交给 delegate 对象，这样一个 AFURLSessionManager 就能同时管理多个 task。\n\n### 生成 NSURLSessionTask\n初始化 AFURLSessionManager 实例后，通过👇的方法创建 **NSURLSessionDataTask**：\n\n```objc\n- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request\n                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock\n                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock\n                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;\n                            \n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request\n           fromFile:(NSURL *)fileURL\n           progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock\n  completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError  * _Nullable error))completionHandler;\n  \n- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request\n                                        progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock\n                                     destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination\n                               completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;\n                               \n......\n```\n这只是部分方法，这些方法都是类似的。\n\n这里以**- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]**方法类举例说明，分析它如何实例化返回一个 **NSURLSessionTask**：\n\n```objc\n- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request\n                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock\n                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock\n                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler {\n\n    __block NSURLSessionDataTask *dataTask = nil;\n    url_session_manager_create_task_safely(^{\n        dataTask = [self.session dataTaskWithRequest:request];\n    });\n\n    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];\n\n    return dataTask;\n}\n```\n> **url_session_manager_create_task_safely** 是 为了修复 iOS 8以下偶发的taskIdentifiers不唯一的 bug[#2093](https://github.com/AFNetworking/AFNetworking/issues/2093)。\n\n上述方法完成了：\n1. 调用**- [NSURLSession dataTaskWithRequest:]**方法传入 request 生成 NSURLSessionDataTask\n2. 调用**- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]**为该 dataTask 对象生成一个对应的 AFURLSessionManagerTaskDelegate 对象，并且关联起来。\n\n\n```objc\n- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask\n                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock\n              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock\n             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler\n{\n\t // 创建 AFURLSessionManagerTaskDelegate 对象\n\t AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];\n\t // AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系\n\t delegate.manager = self;\n\t // delegate 设置 完成block\n\t delegate.completionHandler = completionHandler;\n\t // 设置 task 的 taskDescription\n\t dataTask.taskDescription = self.taskDescriptionForSessionTasks;\n\t // 将 delegate 和 Task 关联起来\n\t [self setDelegate:delegate forTask:dataTask];\n\t // 设置 上传block 和 下载block\n\t delegate.uploadProgressBlock = uploadProgressBlock;\n\t delegate.downloadProgressBlock = downloadProgressBlock;\n}\n```\n将 **completionHandler**， **uploadProgressBlock** 和 **downloadProgressBlock** 传入该对象并在相应事件发生时进行回调。\n\nAFNetworking 通过封装 AFURLSessionManagerTaskDelegate 对象 ，让 delegate 对每个 task 进行管理，而 AFURLSessionManager 仅需要管理 保存 task 与 delegate 的 字典即可，实现了功能下放。\n\n这个方法里面调用了另一个方法**- [AFURLSessionManager setDelegate:forTask:]**设置代理：\n\n```objc\n- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate\n            forTask:(NSURLSessionTask *)task\n{\n\t// 检查参数\n\tNSParameterAssert(task);\n\tNSParameterAssert(delegate);\n\t// 上锁，保证线程安全\n\t[self.lock lock];\n\t// 把 delegate 放入字典，key 是 taskIdentifier\n\tself.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;\n\t// 监听 task 的 resume 和 Suspend\n\t[self addNotificationObserverForTask:task];\n\t// 解锁\n\t[self.lock unlock];\n}\n```\n\n## AFURLSessionManager 实现了 NSURLSessionDelegate 等多个协议\n\n在 AFURLSessionManager 的头文件中，遵循了很多协议，包括：\n* NSURLSessionDelegate\n* NSURLSessionTaskDelegate\n* NSURLSessionDataDelegate\n* NSURLSessionDownloadDelegate\n\n在初始化方法**- [AFURLSessionManager initWithSessionConfiguration:]**时，把 NSURLSession 的 delegate 指向了 self（AFURLSessionManager）。\n\nAFURLSessionManager 也为 所有的 delegate协议 提供了对应 block 接口设置：\n\n```objc\n- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;\n\n- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;\n\n......\n```\n👆只是其中一部分。\n\n拿 **- [AFNRLSessionManager setSessionDidBecomeInvalidBlock:]** 举例\n\nAFURLSessionManager 开放对外的接口，把 sessionDidBecomeInvalid 回调的 block 传入：\n\n```objc\n- (void)setSessionDidBecomeInvalidBlock:(void (^)(NSURLSession *session, NSError *error))block {\n    self.sessionDidBecomeInvalid = block;\n}\n```\n\n当 **- [URLSession:didBecomeInvalidWithError:]** 代理方法调用时，判断对应的 block 是否存在，就会执行对应的 block：\n\n```objc\n- (void)URLSession:(NSURLSession *)session\ndidBecomeInvalidWithError:(NSError *)error\n{\n    if (self.sessionDidBecomeInvalid) {\n        self.sessionDidBecomeInvalid(session, error);\n    }\n\n    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];\n}\n```\n\n其他的接口也类似这样的实现，只是实现的内容不一样。\n\n## AFURLSessionManagerTaskDelegate\n\n👆提到的 AFURLSessionManagerTaskDelegate 是管理 task 的类，在 **- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]** 的方法里面创建。\n\n首先看下它的初始化方法：\n\n```objc\n- (instancetype)initWithTask:(NSURLSessionTask *)task {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n    \n    // 创建 NSData 存放请求回来的数据\n    _mutableData = [NSMutableData data];\n    // 上传的进度\n    _uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil];\n    // 下载的进度\n    _downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil];\n    \n    __weak __typeof__(task) weakTask = task;\n    // 给两个进度设置 取消，暂停，启动block 回调\n    for (NSProgress *progress in @[ _uploadProgress, _downloadProgress ])\n    {\n        progress.totalUnitCount = NSURLSessionTransferSizeUnknown;\n        progress.cancellable = YES;\n        progress.cancellationHandler = ^{\n            [weakTask cancel];\n        };\n        progress.pausable = YES;\n        progress.pausingHandler = ^{\n            [weakTask suspend];\n        };\n        if ([progress respondsToSelector:@selector(setResumingHandler:)]) {\n            progress.resumingHandler = ^{\n                [weakTask resume];\n            };\n        }\n        // kVO 监听状态改变\n        [progress addObserver:self\n                   forKeyPath:NSStringFromSelector(@selector(fractionCompleted))\n                      options:NSKeyValueObservingOptionNew\n                      context:NULL];\n    }\n    return self;\n}\n```\n\n> 设置 block 回调，主要是在对应 NSProgress 的状态改变时，调用 resume suspend 等方法改变 task 的状态。\n\n在 **observeValueForKeypath:ofObject:change:context:** 方法中调用 block\n\n```objc\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {\n   if ([object isEqual:self.downloadProgress]) {\n        if (self.downloadProgressBlock) {\n            self.downloadProgressBlock(object);\n        }\n    }\n    else if ([object isEqual:self.uploadProgress]) {\n        if (self.uploadProgressBlock) {\n            self.uploadProgressBlock(object);\n        }\n    }\n}\n```\n当 Progress对象 某些属性改变时，调用block。\n\n往下看你会发现 AFURLSessionManagerTaskDelegate 中也实现了 **NSURLSession** 的一些协议\n{% asset_img Snip20170125_1.png AFURLSessionManagerTaskDelegate-NSURLSession %}\n\n\n之前在 AFURLSessionManager 中，也实现了 **NSURLSession** 的协议\n{% asset_img Snip20170125_2.png AFURLSessionManager-NSURLSession %}\n\n> 因为 AFURLSessionManager 所管理的 NSURLSession 对象的 delegate 被设置为 AFURLSessionManager 自身，所以所有的 NSURLSession 协议回调都是 AFURLSessionManager，然后 AFURLSessionManager 根据具体需要，将 响应的 delegate 传递到 AFURLSessionManagerTaskDelegate 里面。\n\n每当需要 AFURLSessionManagerTaskDelegate 具体处理的时候，AFURLSessionManager 都会取出相应的 taskDelegate 原封不动的传入。\n\n### 代理方法 URLSession:task:didCompleteWithError:\n\n当每一个 **NSURLSessionTask** 结束时都会进入这个回调方法中：\n\n```objc\n- (void)URLSession:(__unused NSURLSession *)session\n              task:(NSURLSessionTask *)task\ndidCompleteWithError:(NSError *)error\n{\n    #1：获取数据 `responseSerializer` 和 `downloadFileURL`，存储到字典里面\n\n    if (error) {\n        #2：在存在错误时调用 `completionHandler`\n    } else {\n        #3：调用 `completionHandler`\n    }\n}\n```\n👆是整体的思路，先看看第一部分：\n\n```objc\n__strong AFURLSessionManager *manager = self.manager;\n\n__block id responseObject = nil;\n\n__block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];\nuserInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;\n\n//Performance Improvement from #2672\nNSData *data = nil;\nif (self.mutableData) {\n// 从 mutableData 中取出数据 \n   data = [self.mutableData copy];\n   //We no longer need the reference, so nil it out to gain back some memory.\n   self.mutableData = nil;\n}\n\n// 设置 userInfo\nif (self.downloadFileURL) {\n   // 文件路径\n   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;\n} else if (data) {\n   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;\n}\n```\n\n第二部分：\n\n```objc\n// 错误存在，设置 userInfo 错误\nuserInfo[AFNetworkingTaskDidCompleteErrorKey] = error;\n\n// 如果 manager 持有的 completionGroup 存在，就使用 completionGroup，否则使用默认创建的 url_session_manager_completion_group() GCD组队列\n// 如果 manager 持有的 completionQueue 存在，就使用 completionQueue，否则使用 dispatch_get_main_queue() 主队列\ndispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{\n  // 调用完成block\n  if (self.completionHandler) {\n      self.completionHandler(task.response, responseObject, error);\n  }\n\n  // 子线程中发送 Task 结束通知 \n  dispatch_async(dispatch_get_main_queue(), ^{\n      [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];\n  });\n});\n```\n\n第三部分：\n\n```objc\ndispatch_async(url_session_manager_processing_queue(), ^{\n  NSError *serializationError = nil;\n  // 序列化响应数据\n  responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&serializationError];\n  // 👇还是设置 userInfo， 调用 block ，发出通知\n  if (self.downloadFileURL) {\n      responseObject = self.downloadFileURL;\n  }\n\n  if (responseObject) {\n      userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;\n  }\n\n  if (serializationError) {\n      userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;\n  }\n\n  dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{\n      if (self.completionHandler) {\n          self.completionHandler(task.response, responseObject, serializationError);\n      }\n\n      dispatch_async(dispatch_get_main_queue(), ^{\n          [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];\n      });\n  });\n});\n```\n\n### 代理方法 URLSession:dataTask:didReceiveData: 和 - URLSession:downloadTask:didFinishDownloadingToURL:\n\n\n```objc\n- (void)URLSession:(__unused NSURLSession *)session\n          dataTask:(__unused NSURLSessionDataTask *)dataTask\n    didReceiveData:(NSData *)data\n{\n    self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;\n    self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;\n    // 追加数据\n    [self.mutableData appendData:data];\n}\n\n- (void)URLSession:(NSURLSession *)session\n      downloadTask:(NSURLSessionDownloadTask *)downloadTask\ndidFinishDownloadingToURL:(NSURL *)location\n{\n    self.downloadFileURL = nil;\n\n    if (self.downloadTaskDidFinishDownloading) {\n        // 下载完成文件的路径\n        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);\n        if (self.downloadFileURL) {\n            NSError *fileManagerError = nil;\n            // 文件转移\n            if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&fileManagerError]) {\n                // 文件转移失败通知\n                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];\n            }\n        }\n    }\n}\n```\n\n## _AFURLSessionTaskSwizzling\n\n_AFURLSessionTaskSwizzling 的唯一功能就是修改 NSURLSessionTask 的 resume 和 suspend 方法，使用下面的方法替换原有的实现：\n\n```objc\n- (void)af_resume {\n    NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\");\n    NSURLSessionTaskState state = [self state];\n    // 经过 method swizzling 后，af_resume 就是之前的 resume ，所以这里是调用系统的 resume 方法\n    [self af_resume];\n    // 如果之前是其他状态，发出通知，更改回 resume 状态，通知调用 taskDidResume\n    if (state != NSURLSessionTaskStateRunning) {\n        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];\n    }\n}\n// 同上\n- (void)af_suspend {\n    NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\");\n    NSURLSessionTaskState state = [self state];\n    [self af_suspend];\n    \n    if (state != NSURLSessionTaskStateSuspended) {\n        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];\n    }\n}\n```\n\n👆这样做的目的是为了在方法 resume 或者 suspend 被调用是发出通知。\n\n具体方法调剂的过程发生在 **+load** 方法中进行\n> load 方法会在加载类的时候就被调用，也就是 iOS 应用启动的时候就会加载所有的类，就会调用每个类的 +load 方法。\n\n```objc\n+ (void)load {\n    // 判断当前 iOS 版本中是否存在 NSURLSessionTask\n    if (NSClassFromString(@\"NSURLSessionTask\")) {\n        // 1.创建 NSURLSession 实例，通过实例创建 NSURLSessionDataTask\n        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];\n        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wnonnull\"\n        // 因为 iOS7 和 iOS8 上对于 NSURLSessionTask 的实现不同，所以会通过 - [NSURLSession dataTaskWithURL:] 方法返回一个 NSURLSessionTask 实例\n        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];\n#pragma clang diagnostic pop\n        // 2.获取 af_resume 的方法实现指针\n        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));\n        Class currentClass = [localDataTask class];\n        \n        // 3.判断当前class是否实现了resume\n        while (class_getInstanceMethod(currentClass, @selector(resume))) {\n            // 4.获取当前class的父类\n            Class superClass = [currentClass superclass];\n            // 5.获取当前class的resume的方法实现指针\n            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));\n            // 6.获取当前class父类的resume的方法实现指针\n            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));\n            // 7.如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling\n            if (classResumeIMP != superclassResumeIMP &&\n                originalAFResumeIMP != classResumeIMP) {\n                [self swizzleResumeAndSuspendMethodForClass:currentClass];\n            }\n            // 8.设置当前操作的class为其父类class，重复while步骤3~8\n            currentClass = [currentClass superclass];\n        }\n        \n        [localDataTask cancel];\n        [session finishTasksAndInvalidate];\n    }\n}\n```\n这里复杂的实现是为了解决 bug[#2702](https://github.com/AFNetworking/AFNetworking/pull/2702)\n\n## NSSecureCoding和NSCopying\n\n### NSSecureCoding\n关于NSSecureCoding的讲解请参考[使用NSSecureCoding协议进行编解码](http://codingobjc.com/blog/2014/04/15/shi-yong-nssecurecodingxie-yi-jin-xing-bian-jie-ma/)。\n\n因为要支持secure coding，所以要在supportsSecureCoding返回YES。\n\nAFURLSessionManager保存的信息是其NSURLSessionConfiguration变量，然后根据获取到的configuration构建出AFURLSessionManager对象，节省了存储空间。\n\n```objc\n+ (BOOL)supportsSecureCoding {\n    return YES;\n}\n\n- (instancetype)initWithCoder:(NSCoder *)decoder {\n    NSURLSessionConfiguration *configuration = [decoder decodeObjectOfClass:[NSURLSessionConfiguration class] forKey:@\"sessionConfiguration\"];\n\n    self = [self initWithSessionConfiguration:configuration];\n    if (!self) {\n        return nil;\n    }\n\n    return self;\n}\n\n- (void)encodeWithCoder:(NSCoder *)coder {\n    [coder encodeObject:self.session.configuration forKey:@\"sessionConfiguration\"];\n}\n```\n\n### NSCopying\n\n先构建一个AFURLSessionManager空间，并使用原先session的configuration来初始化空间内容。\n```objc\n- (instancetype)copyWithZone:(NSZone *)zone {\n    return [[[self class] allocWithZone:zone] initWithSessionConfiguration:self.session.configuration];\n}\n```\n\n## 总结\nAFURLSessionManager 里面的内容大致讲完了，具体实现细节还是需要细细推敲的：\n1. AFURLSessionManager 是对 NSURLSession 的封装\n2. 它通过 - [AFURLSessionManager dataTaskWithRequest:completionHandler:] 等接口创建 NSURLSessionDataTask 的实例\n3. 通过一个字典 mutableTaskDelegatesKeyedByTaskIdentifier 来管理 dataTask 对象\n4. AFURLSessionManager 是通过 AFURLSessionManagerTaskDelegate 来对传入的 **uploadProgressBlock**， **downloadProgressBlock**， **completionHandler** 在合适的时间进行调用\n\n## 参考链接\n* [AFNetworking](https://github.com/AFNetworking/AFNetworking)\n* [AFNetworking源码阅读（四）](http://www.cnblogs.com/polobymulberry/p/5160946.html)\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/AFNetworking-AFURLSessionManager-2.md","raw":"---\ntitle: AFNetworking 核心 AFURLSessionManager（二）\ndate: 2016-12-24 10:33:37\ntags: AFNetworking\ncategory: Source Code Analyze\n---\n\n## 前言\n上一章对 AFNetworking进行了概述，这一章重点对 AFN 的核心 **AFURLSessionManager**进行分析\n\n## AFURLSessionManager属性\n\n主要属性：\n\n```objc\n/**\n AFURLSessionManager管理的Session对象\n */\n@property (readonly, nonatomic, strong) NSURLSession *session;\n\n/**\n delegate的回调所在队列\n */\n@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;\n\n/**\n 解析网络请求返回的数据，遵循AFURLResponseSerialization协议，并且不能为nil\n */\n@property (nonatomic, strong) id <AFURLResponseSerialization> responseSerializer;\n\n/**\n securityPolicy 是处理网络连接安全的对象，无特别的要求一般使用‘defaultPolicy’\n */\n@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;\n\n/**\n reachabilityManager 是用于监控网络状态的对象，默认使用‘sharedManager’\n */\n@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;\n\n/**\n Session中正在运行的 Task ，包括 dataTask，uploadTask，downloadTask\n */\n@property (readonly, nonatomic, strong) NSArray <NSURLSessionTask *> *tasks;\n\n/**\n Session中正在运行的 dataTask\n */\n@property (readonly, nonatomic, strong) NSArray <NSURLSessionDataTask *> *dataTasks;\n\n/**\n Session中正在运行的 uploadTask\n */\n@property (readonly, nonatomic, strong) NSArray <NSURLSessionUploadTask *> *uploadTasks;\n\n/**\n Session中正在运行的 downloadTask\n */\n@property (readonly, nonatomic, strong) NSArray <NSURLSessionDownloadTask *> *downloadTasks;\n\n/**\n completionBlock的回调GCD队列，如果未主动设置，默认是 main queue\n */\n@property (nonatomic, strong, nullable) dispatch_queue_t completionQueue;\n\n/**\n completionBlock的回调Group-GCD队列，如果未主动设置，默认是 private dispatch group\n */\n@property (nonatomic, strong, nullable) dispatch_group_t completionGroup;\n\n///---------------------------------\n/// @name Working Around System Bugs\n///---------------------------------\n\n/**\n 当在后台session创建 upload task 返回‘nil’的时候，是否尝试重新创建 upload tasks，默认是NO\n\n @bug 这是 iOS 7.0的 bug，这个 bug 是当在后台session 创建 upload task 时，upload task 有时候会初始化为‘nil’。作为一种替代方法，如果这个属性设置为 YES ，AFN 会按照 Apple 推荐的方式创建 Task。\n\n @详见 https://github.com/AFNetworking/AFNetworking/issues/1675\n */\n@property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions;\n```\n\nAFURLSessionManager 的属性不是很多，也不是很复杂，注释也非常详尽。\n\n## 使用AFURLSessionManager完成网络请求\n\n使用AFURLSessionManager完成网络获取网络数据，仅需要如下几个步骤：\n\n```objc\n// 1.初始化AFURLSessionManager对象\nNSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\nAFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];\n    \n// 初始请求\nNSURLRequest *request = [[NSURLRequest alloc] initWithURL:[[NSURL alloc] initWithString:@\"https://github.com\"]];\n    \n// 2.获取AFURLSessionManager的task对象\nNSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {\n   if (error) {\n       NSLog(@\"Error: %@\", error);\n   } else {\n       NSLog(@\"Get Net data success!\");\n   }\n}];\n// 3.启动task\n[dataTask resume];\n```\n除了初始化 NSURLRequest ，完成整个数据请求只需要的三步，👇逐步分析如何实现的\n\n### 初始化AFURLSessionManager\n\n调用这个方法来初始化 AFURLSessionManager\n```objc\n- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration\n```\n它只有一个 NSURLSessionConfiguration 参数。\n\n实现的代码：\n\n```objc\n- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n\n    // ======================== 设置NSURLSession ==============================\n    // 如果 configuration 为 ‘nil’，使用 defaultSessionConfiguration\n    if (!configuration) {\n        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    }\n\n    self.sessionConfiguration = configuration;\n\n    self.operationQueue = [[NSOperationQueue alloc] init];\n    // delegate 回调队列，最大并发数为 1\n    self.operationQueue.maxConcurrentOperationCount = 1;\n\n    // 初始化 Session\n    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];\n    \n    // ======================== 初始化 response 序列化 ==============================\n    self.responseSerializer = [AFJSONResponseSerializer serializer];\n    \n    // ======================== 初始化 网络安全策略 ==============================\n    self.securityPolicy = [AFSecurityPolicy defaultPolicy];\n\n    // ======================== 初始化 网络监控 ==============================\n#if !TARGET_OS_WATCH\n    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];\n#endif\n\n    // ======================== 初始化 Task 和 AFURLSessionManagerTaskDelegate 字典 ==============================\n    // key 为 taskId，value 为 AFURLSessionManagerTaskDelegate\n    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];\n\n    // ======================== 初始化 mutableTaskDelegatesKeyedByTaskIdentifier 字典锁  ==============================\n    // 保证 mutableTaskDelegatesKeyedByTaskIdentifier 的多线程安全\n    self.lock = [[NSLock alloc] init];\n    self.lock.name = AFURLSessionManagerLockName;\n\n    // ======================== 获取当前 Session 中所有的 Task  ==============================\n    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {\n        // 为已有的 task 设置代理（在`生成NSURLSessionTask`细说）\n        for (NSURLSessionDataTask *task in dataTasks) {\n            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];\n        }\n\n        for (NSURLSessionUploadTask *uploadTask in uploadTasks) {\n            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];\n        }\n\n        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) {\n            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];\n        }\n    }];\n\n    return self;\n}\n```\n\n这就是 AFURLSessionManager 的初始化方法，主要对其属性进行出初始化。\n需要注意的是这两个私有属性：\n\n```objc\n@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;\n@property (readwrite, nonatomic, strong) NSLock *lock;\n```\nAFURLSessionManager 会给每个管理的 task 对应的创建一个 AFURLSessionManagerTaskDelegate 对象，Manager把 task 的具体处理交给 delegate 对象，这样一个 AFURLSessionManager 就能同时管理多个 task。\n\n### 生成 NSURLSessionTask\n初始化 AFURLSessionManager 实例后，通过👇的方法创建 **NSURLSessionDataTask**：\n\n```objc\n- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request\n                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock\n                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock\n                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;\n                            \n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request\n           fromFile:(NSURL *)fileURL\n           progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock\n  completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError  * _Nullable error))completionHandler;\n  \n- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request\n                                        progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock\n                                     destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination\n                               completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;\n                               \n......\n```\n这只是部分方法，这些方法都是类似的。\n\n这里以**- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]**方法类举例说明，分析它如何实例化返回一个 **NSURLSessionTask**：\n\n```objc\n- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request\n                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock\n                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock\n                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler {\n\n    __block NSURLSessionDataTask *dataTask = nil;\n    url_session_manager_create_task_safely(^{\n        dataTask = [self.session dataTaskWithRequest:request];\n    });\n\n    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];\n\n    return dataTask;\n}\n```\n> **url_session_manager_create_task_safely** 是 为了修复 iOS 8以下偶发的taskIdentifiers不唯一的 bug[#2093](https://github.com/AFNetworking/AFNetworking/issues/2093)。\n\n上述方法完成了：\n1. 调用**- [NSURLSession dataTaskWithRequest:]**方法传入 request 生成 NSURLSessionDataTask\n2. 调用**- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]**为该 dataTask 对象生成一个对应的 AFURLSessionManagerTaskDelegate 对象，并且关联起来。\n\n\n```objc\n- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask\n                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock\n              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock\n             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler\n{\n\t // 创建 AFURLSessionManagerTaskDelegate 对象\n\t AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];\n\t // AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系\n\t delegate.manager = self;\n\t // delegate 设置 完成block\n\t delegate.completionHandler = completionHandler;\n\t // 设置 task 的 taskDescription\n\t dataTask.taskDescription = self.taskDescriptionForSessionTasks;\n\t // 将 delegate 和 Task 关联起来\n\t [self setDelegate:delegate forTask:dataTask];\n\t // 设置 上传block 和 下载block\n\t delegate.uploadProgressBlock = uploadProgressBlock;\n\t delegate.downloadProgressBlock = downloadProgressBlock;\n}\n```\n将 **completionHandler**， **uploadProgressBlock** 和 **downloadProgressBlock** 传入该对象并在相应事件发生时进行回调。\n\nAFNetworking 通过封装 AFURLSessionManagerTaskDelegate 对象 ，让 delegate 对每个 task 进行管理，而 AFURLSessionManager 仅需要管理 保存 task 与 delegate 的 字典即可，实现了功能下放。\n\n这个方法里面调用了另一个方法**- [AFURLSessionManager setDelegate:forTask:]**设置代理：\n\n```objc\n- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate\n            forTask:(NSURLSessionTask *)task\n{\n\t// 检查参数\n\tNSParameterAssert(task);\n\tNSParameterAssert(delegate);\n\t// 上锁，保证线程安全\n\t[self.lock lock];\n\t// 把 delegate 放入字典，key 是 taskIdentifier\n\tself.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;\n\t// 监听 task 的 resume 和 Suspend\n\t[self addNotificationObserverForTask:task];\n\t// 解锁\n\t[self.lock unlock];\n}\n```\n\n## AFURLSessionManager 实现了 NSURLSessionDelegate 等多个协议\n\n在 AFURLSessionManager 的头文件中，遵循了很多协议，包括：\n* NSURLSessionDelegate\n* NSURLSessionTaskDelegate\n* NSURLSessionDataDelegate\n* NSURLSessionDownloadDelegate\n\n在初始化方法**- [AFURLSessionManager initWithSessionConfiguration:]**时，把 NSURLSession 的 delegate 指向了 self（AFURLSessionManager）。\n\nAFURLSessionManager 也为 所有的 delegate协议 提供了对应 block 接口设置：\n\n```objc\n- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;\n\n- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;\n\n......\n```\n👆只是其中一部分。\n\n拿 **- [AFNRLSessionManager setSessionDidBecomeInvalidBlock:]** 举例\n\nAFURLSessionManager 开放对外的接口，把 sessionDidBecomeInvalid 回调的 block 传入：\n\n```objc\n- (void)setSessionDidBecomeInvalidBlock:(void (^)(NSURLSession *session, NSError *error))block {\n    self.sessionDidBecomeInvalid = block;\n}\n```\n\n当 **- [URLSession:didBecomeInvalidWithError:]** 代理方法调用时，判断对应的 block 是否存在，就会执行对应的 block：\n\n```objc\n- (void)URLSession:(NSURLSession *)session\ndidBecomeInvalidWithError:(NSError *)error\n{\n    if (self.sessionDidBecomeInvalid) {\n        self.sessionDidBecomeInvalid(session, error);\n    }\n\n    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];\n}\n```\n\n其他的接口也类似这样的实现，只是实现的内容不一样。\n\n## AFURLSessionManagerTaskDelegate\n\n👆提到的 AFURLSessionManagerTaskDelegate 是管理 task 的类，在 **- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]** 的方法里面创建。\n\n首先看下它的初始化方法：\n\n```objc\n- (instancetype)initWithTask:(NSURLSessionTask *)task {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n    \n    // 创建 NSData 存放请求回来的数据\n    _mutableData = [NSMutableData data];\n    // 上传的进度\n    _uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil];\n    // 下载的进度\n    _downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil];\n    \n    __weak __typeof__(task) weakTask = task;\n    // 给两个进度设置 取消，暂停，启动block 回调\n    for (NSProgress *progress in @[ _uploadProgress, _downloadProgress ])\n    {\n        progress.totalUnitCount = NSURLSessionTransferSizeUnknown;\n        progress.cancellable = YES;\n        progress.cancellationHandler = ^{\n            [weakTask cancel];\n        };\n        progress.pausable = YES;\n        progress.pausingHandler = ^{\n            [weakTask suspend];\n        };\n        if ([progress respondsToSelector:@selector(setResumingHandler:)]) {\n            progress.resumingHandler = ^{\n                [weakTask resume];\n            };\n        }\n        // kVO 监听状态改变\n        [progress addObserver:self\n                   forKeyPath:NSStringFromSelector(@selector(fractionCompleted))\n                      options:NSKeyValueObservingOptionNew\n                      context:NULL];\n    }\n    return self;\n}\n```\n\n> 设置 block 回调，主要是在对应 NSProgress 的状态改变时，调用 resume suspend 等方法改变 task 的状态。\n\n在 **observeValueForKeypath:ofObject:change:context:** 方法中调用 block\n\n```objc\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {\n   if ([object isEqual:self.downloadProgress]) {\n        if (self.downloadProgressBlock) {\n            self.downloadProgressBlock(object);\n        }\n    }\n    else if ([object isEqual:self.uploadProgress]) {\n        if (self.uploadProgressBlock) {\n            self.uploadProgressBlock(object);\n        }\n    }\n}\n```\n当 Progress对象 某些属性改变时，调用block。\n\n往下看你会发现 AFURLSessionManagerTaskDelegate 中也实现了 **NSURLSession** 的一些协议\n{% asset_img Snip20170125_1.png AFURLSessionManagerTaskDelegate-NSURLSession %}\n\n\n之前在 AFURLSessionManager 中，也实现了 **NSURLSession** 的协议\n{% asset_img Snip20170125_2.png AFURLSessionManager-NSURLSession %}\n\n> 因为 AFURLSessionManager 所管理的 NSURLSession 对象的 delegate 被设置为 AFURLSessionManager 自身，所以所有的 NSURLSession 协议回调都是 AFURLSessionManager，然后 AFURLSessionManager 根据具体需要，将 响应的 delegate 传递到 AFURLSessionManagerTaskDelegate 里面。\n\n每当需要 AFURLSessionManagerTaskDelegate 具体处理的时候，AFURLSessionManager 都会取出相应的 taskDelegate 原封不动的传入。\n\n### 代理方法 URLSession:task:didCompleteWithError:\n\n当每一个 **NSURLSessionTask** 结束时都会进入这个回调方法中：\n\n```objc\n- (void)URLSession:(__unused NSURLSession *)session\n              task:(NSURLSessionTask *)task\ndidCompleteWithError:(NSError *)error\n{\n    #1：获取数据 `responseSerializer` 和 `downloadFileURL`，存储到字典里面\n\n    if (error) {\n        #2：在存在错误时调用 `completionHandler`\n    } else {\n        #3：调用 `completionHandler`\n    }\n}\n```\n👆是整体的思路，先看看第一部分：\n\n```objc\n__strong AFURLSessionManager *manager = self.manager;\n\n__block id responseObject = nil;\n\n__block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];\nuserInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;\n\n//Performance Improvement from #2672\nNSData *data = nil;\nif (self.mutableData) {\n// 从 mutableData 中取出数据 \n   data = [self.mutableData copy];\n   //We no longer need the reference, so nil it out to gain back some memory.\n   self.mutableData = nil;\n}\n\n// 设置 userInfo\nif (self.downloadFileURL) {\n   // 文件路径\n   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;\n} else if (data) {\n   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;\n}\n```\n\n第二部分：\n\n```objc\n// 错误存在，设置 userInfo 错误\nuserInfo[AFNetworkingTaskDidCompleteErrorKey] = error;\n\n// 如果 manager 持有的 completionGroup 存在，就使用 completionGroup，否则使用默认创建的 url_session_manager_completion_group() GCD组队列\n// 如果 manager 持有的 completionQueue 存在，就使用 completionQueue，否则使用 dispatch_get_main_queue() 主队列\ndispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{\n  // 调用完成block\n  if (self.completionHandler) {\n      self.completionHandler(task.response, responseObject, error);\n  }\n\n  // 子线程中发送 Task 结束通知 \n  dispatch_async(dispatch_get_main_queue(), ^{\n      [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];\n  });\n});\n```\n\n第三部分：\n\n```objc\ndispatch_async(url_session_manager_processing_queue(), ^{\n  NSError *serializationError = nil;\n  // 序列化响应数据\n  responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&serializationError];\n  // 👇还是设置 userInfo， 调用 block ，发出通知\n  if (self.downloadFileURL) {\n      responseObject = self.downloadFileURL;\n  }\n\n  if (responseObject) {\n      userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;\n  }\n\n  if (serializationError) {\n      userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;\n  }\n\n  dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{\n      if (self.completionHandler) {\n          self.completionHandler(task.response, responseObject, serializationError);\n      }\n\n      dispatch_async(dispatch_get_main_queue(), ^{\n          [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];\n      });\n  });\n});\n```\n\n### 代理方法 URLSession:dataTask:didReceiveData: 和 - URLSession:downloadTask:didFinishDownloadingToURL:\n\n\n```objc\n- (void)URLSession:(__unused NSURLSession *)session\n          dataTask:(__unused NSURLSessionDataTask *)dataTask\n    didReceiveData:(NSData *)data\n{\n    self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;\n    self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;\n    // 追加数据\n    [self.mutableData appendData:data];\n}\n\n- (void)URLSession:(NSURLSession *)session\n      downloadTask:(NSURLSessionDownloadTask *)downloadTask\ndidFinishDownloadingToURL:(NSURL *)location\n{\n    self.downloadFileURL = nil;\n\n    if (self.downloadTaskDidFinishDownloading) {\n        // 下载完成文件的路径\n        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);\n        if (self.downloadFileURL) {\n            NSError *fileManagerError = nil;\n            // 文件转移\n            if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&fileManagerError]) {\n                // 文件转移失败通知\n                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];\n            }\n        }\n    }\n}\n```\n\n## _AFURLSessionTaskSwizzling\n\n_AFURLSessionTaskSwizzling 的唯一功能就是修改 NSURLSessionTask 的 resume 和 suspend 方法，使用下面的方法替换原有的实现：\n\n```objc\n- (void)af_resume {\n    NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\");\n    NSURLSessionTaskState state = [self state];\n    // 经过 method swizzling 后，af_resume 就是之前的 resume ，所以这里是调用系统的 resume 方法\n    [self af_resume];\n    // 如果之前是其他状态，发出通知，更改回 resume 状态，通知调用 taskDidResume\n    if (state != NSURLSessionTaskStateRunning) {\n        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];\n    }\n}\n// 同上\n- (void)af_suspend {\n    NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\");\n    NSURLSessionTaskState state = [self state];\n    [self af_suspend];\n    \n    if (state != NSURLSessionTaskStateSuspended) {\n        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];\n    }\n}\n```\n\n👆这样做的目的是为了在方法 resume 或者 suspend 被调用是发出通知。\n\n具体方法调剂的过程发生在 **+load** 方法中进行\n> load 方法会在加载类的时候就被调用，也就是 iOS 应用启动的时候就会加载所有的类，就会调用每个类的 +load 方法。\n\n```objc\n+ (void)load {\n    // 判断当前 iOS 版本中是否存在 NSURLSessionTask\n    if (NSClassFromString(@\"NSURLSessionTask\")) {\n        // 1.创建 NSURLSession 实例，通过实例创建 NSURLSessionDataTask\n        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];\n        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wnonnull\"\n        // 因为 iOS7 和 iOS8 上对于 NSURLSessionTask 的实现不同，所以会通过 - [NSURLSession dataTaskWithURL:] 方法返回一个 NSURLSessionTask 实例\n        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];\n#pragma clang diagnostic pop\n        // 2.获取 af_resume 的方法实现指针\n        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));\n        Class currentClass = [localDataTask class];\n        \n        // 3.判断当前class是否实现了resume\n        while (class_getInstanceMethod(currentClass, @selector(resume))) {\n            // 4.获取当前class的父类\n            Class superClass = [currentClass superclass];\n            // 5.获取当前class的resume的方法实现指针\n            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));\n            // 6.获取当前class父类的resume的方法实现指针\n            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));\n            // 7.如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling\n            if (classResumeIMP != superclassResumeIMP &&\n                originalAFResumeIMP != classResumeIMP) {\n                [self swizzleResumeAndSuspendMethodForClass:currentClass];\n            }\n            // 8.设置当前操作的class为其父类class，重复while步骤3~8\n            currentClass = [currentClass superclass];\n        }\n        \n        [localDataTask cancel];\n        [session finishTasksAndInvalidate];\n    }\n}\n```\n这里复杂的实现是为了解决 bug[#2702](https://github.com/AFNetworking/AFNetworking/pull/2702)\n\n## NSSecureCoding和NSCopying\n\n### NSSecureCoding\n关于NSSecureCoding的讲解请参考[使用NSSecureCoding协议进行编解码](http://codingobjc.com/blog/2014/04/15/shi-yong-nssecurecodingxie-yi-jin-xing-bian-jie-ma/)。\n\n因为要支持secure coding，所以要在supportsSecureCoding返回YES。\n\nAFURLSessionManager保存的信息是其NSURLSessionConfiguration变量，然后根据获取到的configuration构建出AFURLSessionManager对象，节省了存储空间。\n\n```objc\n+ (BOOL)supportsSecureCoding {\n    return YES;\n}\n\n- (instancetype)initWithCoder:(NSCoder *)decoder {\n    NSURLSessionConfiguration *configuration = [decoder decodeObjectOfClass:[NSURLSessionConfiguration class] forKey:@\"sessionConfiguration\"];\n\n    self = [self initWithSessionConfiguration:configuration];\n    if (!self) {\n        return nil;\n    }\n\n    return self;\n}\n\n- (void)encodeWithCoder:(NSCoder *)coder {\n    [coder encodeObject:self.session.configuration forKey:@\"sessionConfiguration\"];\n}\n```\n\n### NSCopying\n\n先构建一个AFURLSessionManager空间，并使用原先session的configuration来初始化空间内容。\n```objc\n- (instancetype)copyWithZone:(NSZone *)zone {\n    return [[[self class] allocWithZone:zone] initWithSessionConfiguration:self.session.configuration];\n}\n```\n\n## 总结\nAFURLSessionManager 里面的内容大致讲完了，具体实现细节还是需要细细推敲的：\n1. AFURLSessionManager 是对 NSURLSession 的封装\n2. 它通过 - [AFURLSessionManager dataTaskWithRequest:completionHandler:] 等接口创建 NSURLSessionDataTask 的实例\n3. 通过一个字典 mutableTaskDelegatesKeyedByTaskIdentifier 来管理 dataTask 对象\n4. AFURLSessionManager 是通过 AFURLSessionManagerTaskDelegate 来对传入的 **uploadProgressBlock**， **downloadProgressBlock**， **completionHandler** 在合适的时间进行调用\n\n## 参考链接\n* [AFNetworking](https://github.com/AFNetworking/AFNetworking)\n* [AFNetworking源码阅读（四）](http://www.cnblogs.com/polobymulberry/p/5160946.html)\n\n\n\n\n\n\n\n\n\n\n","slug":"AFNetworking-AFURLSessionManager-2","published":1,"updated":"2017-01-25T10:57:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7qe005n8jpbs2aqc7lc","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一章对 AFNetworking进行了概述，这一章重点对 AFN 的核心 <strong>AFURLSessionManager</strong>进行分析</p>\n<h2 id=\"AFURLSessionManager属性\"><a href=\"#AFURLSessionManager属性\" class=\"headerlink\" title=\"AFURLSessionManager属性\"></a>AFURLSessionManager属性</h2><p>主要属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> AFURLSessionManager管理的Session对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSURLSession</span> *session;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> delegate的回调所在队列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSOperationQueue</span> *operationQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 解析网络请求返回的数据，遵循AFURLResponseSerialization协议，并且不能为nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"keyword\">id</span> &lt;AFURLResponseSerialization&gt; responseSerializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> securityPolicy 是处理网络连接安全的对象，无特别的要求一般使用‘defaultPolicy’</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> reachabilityManager 是用于监控网络状态的对象，默认使用‘sharedManager’</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) AFNetworkReachabilityManager *reachabilityManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Session中正在运行的 Task ，包括 dataTask，uploadTask，downloadTask</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> &lt;<span class=\"built_in\">NSURLSessionTask</span> *&gt; *tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Session中正在运行的 dataTask</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> &lt;<span class=\"built_in\">NSURLSessionDataTask</span> *&gt; *dataTasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Session中正在运行的 uploadTask</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> &lt;<span class=\"built_in\">NSURLSessionUploadTask</span> *&gt; *uploadTasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Session中正在运行的 downloadTask</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> &lt;<span class=\"built_in\">NSURLSessionDownloadTask</span> *&gt; *downloadTasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> completionBlock的回调GCD队列，如果未主动设置，默认是 main queue</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">nullable</span>) <span class=\"built_in\">dispatch_queue_t</span> completionQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> completionBlock的回调Group-GCD队列，如果未主动设置，默认是 private dispatch group</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">nullable</span>) dispatch_group_t completionGroup;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///---------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">/// @name Working Around System Bugs</span></span><br><span class=\"line\"><span class=\"comment\">///---------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 当在后台session创建 upload task 返回‘nil’的时候，是否尝试重新创建 upload tasks，默认是NO</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @bug 这是 iOS 7.0的 bug，这个 bug 是当在后台session 创建 upload task 时，upload task 有时候会初始化为‘nil’。作为一种替代方法，如果这个属性设置为 YES ，AFN 会按照 Apple 推荐的方式创建 Task。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @详见 https://github.com/AFNetworking/AFNetworking/issues/1675</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">BOOL</span> attemptsToRecreateUploadTasksForBackgroundSessions;</span><br></pre></td></tr></table></figure>\n<p>AFURLSessionManager 的属性不是很多，也不是很复杂，注释也非常详尽。</p>\n<h2 id=\"使用AFURLSessionManager完成网络请求\"><a href=\"#使用AFURLSessionManager完成网络请求\" class=\"headerlink\" title=\"使用AFURLSessionManager完成网络请求\"></a>使用AFURLSessionManager完成网络请求</h2><p>使用AFURLSessionManager完成网络获取网络数据，仅需要如下几个步骤：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.初始化AFURLSessionManager对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 初始请求</span></span><br><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> *request = [[<span class=\"built_in\">NSURLRequest</span> alloc] initWithURL:[[<span class=\"built_in\">NSURL</span> alloc] initWithString:<span class=\"string\">@\"https://github.com\"</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 2.获取AFURLSessionManager的task对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request uploadProgress:<span class=\"literal\">nil</span> downloadProgress:<span class=\"literal\">nil</span> completionHandler:^(<span class=\"built_in\">NSURLResponse</span> * _Nonnull response, <span class=\"keyword\">id</span>  _Nullable responseObject, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error: %@\"</span>, error);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Get Net data success!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"comment\">// 3.启动task</span></span><br><span class=\"line\">[dataTask resume];</span><br></pre></td></tr></table></figure>\n<p>除了初始化 NSURLRequest ，完成整个数据请求只需要的三步，👇逐步分析如何实现的</p>\n<h3 id=\"初始化AFURLSessionManager\"><a href=\"#初始化AFURLSessionManager\" class=\"headerlink\" title=\"初始化AFURLSessionManager\"></a>初始化AFURLSessionManager</h3><p>调用这个方法来初始化 AFURLSessionManager<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithSessionConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration</span><br></pre></td></tr></table></figure></p>\n<p>它只有一个 NSURLSessionConfiguration 参数。</p>\n<p>实现的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithSessionConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ======================== 设置NSURLSession ==============================</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 configuration 为 ‘nil’，使用 defaultSessionConfiguration</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!configuration) &#123;</span><br><span class=\"line\">        configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.sessionConfiguration = configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">    <span class=\"comment\">// delegate 回调队列，最大并发数为 1</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue.maxConcurrentOperationCount = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 Session</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:<span class=\"keyword\">self</span>.sessionConfiguration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"keyword\">self</span>.operationQueue];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ======================== 初始化 response 序列化 ==============================</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ======================== 初始化 网络安全策略 ==============================</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ======================== 初始化 网络监控 ==============================</span></span><br><span class=\"line\"><span class=\"meta\">#if !TARGET_OS_WATCH</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ======================== 初始化 Task 和 AFURLSessionManagerTaskDelegate 字典 ==============================</span></span><br><span class=\"line\">    <span class=\"comment\">// key 为 taskId，value 为 AFURLSessionManagerTaskDelegate</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class=\"built_in\">NSMutableDictionary</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ======================== 初始化 mutableTaskDelegatesKeyedByTaskIdentifier 字典锁  ==============================</span></span><br><span class=\"line\">    <span class=\"comment\">// 保证 mutableTaskDelegatesKeyedByTaskIdentifier 的多线程安全</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.lock = [[<span class=\"built_in\">NSLock</span> alloc] init];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ======================== 获取当前 Session 中所有的 Task  ==============================</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.session getTasksWithCompletionHandler:^(<span class=\"built_in\">NSArray</span> *dataTasks, <span class=\"built_in\">NSArray</span> *uploadTasks, <span class=\"built_in\">NSArray</span> *downloadTasks) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为已有的 task 设置代理（在`生成NSURLSessionTask`细说）</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSURLSessionDataTask</span> *task <span class=\"keyword\">in</span> dataTasks) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> addDelegateForDataTask:task uploadProgress:<span class=\"literal\">nil</span> downloadProgress:<span class=\"literal\">nil</span> completionHandler:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSURLSessionUploadTask</span> *uploadTask <span class=\"keyword\">in</span> uploadTasks) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> addDelegateForUploadTask:uploadTask progress:<span class=\"literal\">nil</span> completionHandler:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSURLSessionDownloadTask</span> *downloadTask <span class=\"keyword\">in</span> downloadTasks) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> addDelegateForDownloadTask:downloadTask progress:<span class=\"literal\">nil</span> destination:<span class=\"literal\">nil</span> completionHandler:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是 AFURLSessionManager 的初始化方法，主要对其属性进行出初始化。<br>需要注意的是这两个私有属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *mutableTaskDelegatesKeyedByTaskIdentifier;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSLock</span> *lock;</span><br></pre></td></tr></table></figure>\n<p>AFURLSessionManager 会给每个管理的 task 对应的创建一个 AFURLSessionManagerTaskDelegate 对象，Manager把 task 的具体处理交给 delegate 对象，这样一个 AFURLSessionManager 就能同时管理多个 task。</p>\n<h3 id=\"生成-NSURLSessionTask\"><a href=\"#生成-NSURLSessionTask\" class=\"headerlink\" title=\"生成 NSURLSessionTask\"></a>生成 NSURLSessionTask</h3><p>初始化 AFURLSessionManager 实例后，通过👇的方法创建 <strong>NSURLSessionDataTask</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request</span><br><span class=\"line\">                               uploadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class=\"line\">                             downloadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class=\"line\">                            completionHandler:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLResponse</span> *response, <span class=\"keyword\">id</span> _Nullable responseObject,  <span class=\"built_in\">NSError</span> * _Nullable error))completionHandler;</span><br><span class=\"line\">                            </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request</span><br><span class=\"line\">           fromFile:(<span class=\"built_in\">NSURL</span> *)fileURL</span><br><span class=\"line\">           progress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class=\"line\">  completionHandler:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLResponse</span> *response, <span class=\"keyword\">id</span> _Nullable responseObject, <span class=\"built_in\">NSError</span>  * _Nullable error))completionHandler;</span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request</span><br><span class=\"line\">                                        progress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class=\"line\">                                     destination:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSURL</span> * (^)(<span class=\"built_in\">NSURL</span> *targetPath, <span class=\"built_in\">NSURLResponse</span> *response))destination</span><br><span class=\"line\">                               completionHandler:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSURL</span> * _Nullable filePath, <span class=\"built_in\">NSError</span> * _Nullable error))completionHandler;</span><br><span class=\"line\">                               </span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>这只是部分方法，这些方法都是类似的。</p>\n<p>这里以<strong>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</strong>方法类举例说明，分析它如何实例化返回一个 <strong>NSURLSessionTask</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request</span><br><span class=\"line\">                               uploadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class=\"line\">                             downloadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class=\"line\">                            completionHandler:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLResponse</span> *response, <span class=\"keyword\">id</span> _Nullable responseObject,  <span class=\"built_in\">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    __block <span class=\"built_in\">NSURLSessionDataTask</span> *dataTask = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    url_session_manager_create_task_safely(^&#123;</span><br><span class=\"line\">        dataTask = [<span class=\"keyword\">self</span>.session dataTaskWithRequest:request];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataTask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>url_session_manager_create_task_safely</strong> 是 为了修复 iOS 8以下偶发的taskIdentifiers不唯一的 bug<a href=\"https://github.com/AFNetworking/AFNetworking/issues/2093\" target=\"_blank\" rel=\"noopener\">#2093</a>。</p>\n</blockquote>\n<p>上述方法完成了：</p>\n<ol>\n<li>调用<strong>- [NSURLSession dataTaskWithRequest:]</strong>方法传入 request 生成 NSURLSessionDataTask</li>\n<li>调用<strong>- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</strong>为该 dataTask 对象生成一个对应的 AFURLSessionManagerTaskDelegate 对象，并且关联起来。</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)addDelegateForDataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask</span><br><span class=\"line\">                uploadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class=\"line\">              downloadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class=\"line\">             completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLResponse</span> *response, <span class=\"keyword\">id</span> responseObject, <span class=\"built_in\">NSError</span> *error))completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t <span class=\"comment\">// 创建 AFURLSessionManagerTaskDelegate 对象</span></span><br><span class=\"line\">\t AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class=\"line\">\t <span class=\"comment\">// AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系</span></span><br><span class=\"line\">\t delegate.manager = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">\t <span class=\"comment\">// delegate 设置 完成block</span></span><br><span class=\"line\">\t delegate.completionHandler = completionHandler;</span><br><span class=\"line\">\t <span class=\"comment\">// 设置 task 的 taskDescription</span></span><br><span class=\"line\">\t dataTask.taskDescription = <span class=\"keyword\">self</span>.taskDescriptionForSessionTasks;</span><br><span class=\"line\">\t <span class=\"comment\">// 将 delegate 和 Task 关联起来</span></span><br><span class=\"line\">\t [<span class=\"keyword\">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class=\"line\">\t <span class=\"comment\">// 设置 上传block 和 下载block</span></span><br><span class=\"line\">\t delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class=\"line\">\t delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将 <strong>completionHandler</strong>， <strong>uploadProgressBlock</strong> 和 <strong>downloadProgressBlock</strong> 传入该对象并在相应事件发生时进行回调。</p>\n<p>AFNetworking 通过封装 AFURLSessionManagerTaskDelegate 对象 ，让 delegate 对每个 task 进行管理，而 AFURLSessionManager 仅需要管理 保存 task 与 delegate 的 字典即可，实现了功能下放。</p>\n<p>这个方法里面调用了另一个方法<strong>- [AFURLSessionManager setDelegate:forTask:]</strong>设置代理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class=\"line\">            forTask:(<span class=\"built_in\">NSURLSessionTask</span> *)task</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查参数</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSParameterAssert</span>(task);</span><br><span class=\"line\">\t<span class=\"built_in\">NSParameterAssert</span>(delegate);</span><br><span class=\"line\">\t<span class=\"comment\">// 上锁，保证线程安全</span></span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.lock lock];</span><br><span class=\"line\">\t<span class=\"comment\">// 把 delegate 放入字典，key 是 taskIdentifier</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class=\"line\">\t<span class=\"comment\">// 监听 task 的 resume 和 Suspend</span></span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> addNotificationObserverForTask:task];</span><br><span class=\"line\">\t<span class=\"comment\">// 解锁</span></span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.lock unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"AFURLSessionManager-实现了-NSURLSessionDelegate-等多个协议\"><a href=\"#AFURLSessionManager-实现了-NSURLSessionDelegate-等多个协议\" class=\"headerlink\" title=\"AFURLSessionManager 实现了 NSURLSessionDelegate 等多个协议\"></a>AFURLSessionManager 实现了 NSURLSessionDelegate 等多个协议</h2><p>在 AFURLSessionManager 的头文件中，遵循了很多协议，包括：</p>\n<ul>\n<li>NSURLSessionDelegate</li>\n<li>NSURLSessionTaskDelegate</li>\n<li>NSURLSessionDataDelegate</li>\n<li>NSURLSessionDownloadDelegate</li>\n</ul>\n<p>在初始化方法<strong>- [AFURLSessionManager initWithSessionConfiguration:]</strong>时，把 NSURLSession 的 delegate 指向了 self（AFURLSessionManager）。</p>\n<p>AFURLSessionManager 也为 所有的 delegate协议 提供了对应 block 接口设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setSessionDidBecomeInvalidBlock:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLSession</span> *session, <span class=\"built_in\">NSError</span> *error))block;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setSessionDidReceiveAuthenticationChallengeBlock:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSURLSessionAuthChallengeDisposition</span> (^)(<span class=\"built_in\">NSURLSession</span> *session, <span class=\"built_in\">NSURLAuthenticationChallenge</span> *challenge, <span class=\"built_in\">NSURLCredential</span> * _Nullable __autoreleasing * _Nullable credential))block;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>👆只是其中一部分。</p>\n<p>拿 <strong>- [AFNRLSessionManager setSessionDidBecomeInvalidBlock:]</strong> 举例</p>\n<p>AFURLSessionManager 开放对外的接口，把 sessionDidBecomeInvalid 回调的 block 传入：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setSessionDidBecomeInvalidBlock:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLSession</span> *session, <span class=\"built_in\">NSError</span> *error))block &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.sessionDidBecomeInvalid = block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <strong>- [URLSession:didBecomeInvalidWithError:]</strong> 代理方法调用时，判断对应的 block 是否存在，就会执行对应的 block：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session</span><br><span class=\"line\">didBecomeInvalidWithError:(<span class=\"built_in\">NSError</span> *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.sessionDidBecomeInvalid) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.sessionDidBecomeInvalid(session, error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其他的接口也类似这样的实现，只是实现的内容不一样。</p>\n<h2 id=\"AFURLSessionManagerTaskDelegate\"><a href=\"#AFURLSessionManagerTaskDelegate\" class=\"headerlink\" title=\"AFURLSessionManagerTaskDelegate\"></a>AFURLSessionManagerTaskDelegate</h2><p>👆提到的 AFURLSessionManagerTaskDelegate 是管理 task 的类，在 <strong>- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</strong> 的方法里面创建。</p>\n<p>首先看下它的初始化方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithTask:(<span class=\"built_in\">NSURLSessionTask</span> *)task &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 NSData 存放请求回来的数据</span></span><br><span class=\"line\">    _mutableData = [<span class=\"built_in\">NSMutableData</span> data];</span><br><span class=\"line\">    <span class=\"comment\">// 上传的进度</span></span><br><span class=\"line\">    _uploadProgress = [[<span class=\"built_in\">NSProgress</span> alloc] initWithParent:<span class=\"literal\">nil</span> userInfo:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 下载的进度</span></span><br><span class=\"line\">    _downloadProgress = [[<span class=\"built_in\">NSProgress</span> alloc] initWithParent:<span class=\"literal\">nil</span> userInfo:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> __typeof__(task) weakTask = task;</span><br><span class=\"line\">    <span class=\"comment\">// 给两个进度设置 取消，暂停，启动block 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSProgress</span> *progress <span class=\"keyword\">in</span> @[ _uploadProgress, _downloadProgress ])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        progress.totalUnitCount = <span class=\"built_in\">NSURLSessionTransferSizeUnknown</span>;</span><br><span class=\"line\">        progress.cancellable = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        progress.cancellationHandler = ^&#123;</span><br><span class=\"line\">            [weakTask cancel];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        progress.pausable = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        progress.pausingHandler = ^&#123;</span><br><span class=\"line\">            [weakTask suspend];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([progress respondsToSelector:<span class=\"keyword\">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class=\"line\">            progress.resumingHandler = ^&#123;</span><br><span class=\"line\">                [weakTask resume];</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// kVO 监听状态改变</span></span><br><span class=\"line\">        [progress addObserver:<span class=\"keyword\">self</span></span><br><span class=\"line\">                   forKeyPath:<span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(fractionCompleted))</span><br><span class=\"line\">                      options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span></span><br><span class=\"line\">                      context:<span class=\"literal\">NULL</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>设置 block 回调，主要是在对应 NSProgress 的状态改变时，调用 resume suspend 等方法改变 task 的状态。</p>\n</blockquote>\n<p>在 <strong>observeValueForKeypath:ofObject:change:context:</strong> 方法中调用 block</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *,<span class=\"keyword\">id</span>&gt; *)change context:(<span class=\"keyword\">void</span> *)context &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([object isEqual:<span class=\"keyword\">self</span>.downloadProgress]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.downloadProgressBlock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.downloadProgressBlock(object);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([object isEqual:<span class=\"keyword\">self</span>.uploadProgress]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.uploadProgressBlock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.uploadProgressBlock(object);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 Progress对象 某些属性改变时，调用block。</p>\n<p>往下看你会发现 AFURLSessionManagerTaskDelegate 中也实现了 <strong>NSURLSession</strong> 的一些协议<br><img src=\"/2016/12/24/AFNetworking-AFURLSessionManager-2/Snip20170125_1.png\" title=\"AFURLSessionManagerTaskDelegate-NSURLSession\"></p>\n<p>之前在 AFURLSessionManager 中，也实现了 <strong>NSURLSession</strong> 的协议<br><img src=\"/2016/12/24/AFNetworking-AFURLSessionManager-2/Snip20170125_2.png\" title=\"AFURLSessionManager-NSURLSession\"></p>\n<blockquote>\n<p>因为 AFURLSessionManager 所管理的 NSURLSession 对象的 delegate 被设置为 AFURLSessionManager 自身，所以所有的 NSURLSession 协议回调都是 AFURLSessionManager，然后 AFURLSessionManager 根据具体需要，将 响应的 delegate 传递到 AFURLSessionManagerTaskDelegate 里面。</p>\n</blockquote>\n<p>每当需要 AFURLSessionManagerTaskDelegate 具体处理的时候，AFURLSessionManager 都会取出相应的 taskDelegate 原封不动的传入。</p>\n<h3 id=\"代理方法-URLSession-task-didCompleteWithError\"><a href=\"#代理方法-URLSession-task-didCompleteWithError\" class=\"headerlink\" title=\"代理方法 URLSession:task:didCompleteWithError:\"></a>代理方法 URLSession:task:didCompleteWithError:</h3><p>当每一个 <strong>NSURLSessionTask</strong> 结束时都会进入这个回调方法中：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(__unused <span class=\"built_in\">NSURLSession</span> *)session</span><br><span class=\"line\">              task:(<span class=\"built_in\">NSURLSessionTask</span> *)task</span><br><span class=\"line\">didCompleteWithError:(<span class=\"built_in\">NSError</span> *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"meta\">#1：获取数据 `responseSerializer` 和 `downloadFileURL`，存储到字典里面</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">        <span class=\"meta\">#2：在存在错误时调用 `completionHandler`</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">#3：调用 `completionHandler`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆是整体的思路，先看看第一部分：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">strong</span> AFURLSessionManager *manager = <span class=\"keyword\">self</span>.manager;</span><br><span class=\"line\"></span><br><span class=\"line\">__block <span class=\"keyword\">id</span> responseObject = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">__block <span class=\"built_in\">NSMutableDictionary</span> *userInfo = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Performance Improvement from #2672</span></span><br><span class=\"line\"><span class=\"built_in\">NSData</span> *data = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.mutableData) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 从 mutableData 中取出数据 </span></span><br><span class=\"line\">   data = [<span class=\"keyword\">self</span>.mutableData <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">   <span class=\"comment\">//We no longer need the reference, so nil it out to gain back some memory.</span></span><br><span class=\"line\">   <span class=\"keyword\">self</span>.mutableData = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 userInfo</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.downloadFileURL) &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 文件路径</span></span><br><span class=\"line\">   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class=\"keyword\">self</span>.downloadFileURL;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二部分：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误存在，设置 userInfo 错误</span></span><br><span class=\"line\">userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果 manager 持有的 completionGroup 存在，就使用 completionGroup，否则使用默认创建的 url_session_manager_completion_group() GCD组队列</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 manager 持有的 completionQueue 存在，就使用 completionQueue，否则使用 dispatch_get_main_queue() 主队列</span></span><br><span class=\"line\">dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用完成block</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.completionHandler) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">self</span>.completionHandler(task.response, responseObject, error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 子线程中发送 Task 结束通知 </span></span><br><span class=\"line\">  <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">      [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>第三部分：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSError</span> *serializationError = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 序列化响应数据</span></span><br><span class=\"line\">  responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class=\"line\">  <span class=\"comment\">// 👇还是设置 userInfo， 调用 block ，发出通知</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.downloadFileURL) &#123;</span><br><span class=\"line\">      responseObject = <span class=\"keyword\">self</span>.downloadFileURL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (responseObject) &#123;</span><br><span class=\"line\">      userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (serializationError) &#123;</span><br><span class=\"line\">      userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.completionHandler) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">self</span>.completionHandler(task.response, responseObject, serializationError);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">          [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"代理方法-URLSession-dataTask-didReceiveData-和-URLSession-downloadTask-didFinishDownloadingToURL\"><a href=\"#代理方法-URLSession-dataTask-didReceiveData-和-URLSession-downloadTask-didFinishDownloadingToURL\" class=\"headerlink\" title=\"代理方法 URLSession:dataTask:didReceiveData: 和 - URLSession:downloadTask:didFinishDownloadingToURL:\"></a>代理方法 URLSession:dataTask:didReceiveData: 和 - URLSession:downloadTask:didFinishDownloadingToURL:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(__unused <span class=\"built_in\">NSURLSession</span> *)session</span><br><span class=\"line\">          dataTask:(__unused <span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask</span><br><span class=\"line\">    didReceiveData:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;</span><br><span class=\"line\">    <span class=\"comment\">// 追加数据</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.mutableData appendData:data];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session</span><br><span class=\"line\">      downloadTask:(<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class=\"line\">didFinishDownloadingToURL:(<span class=\"built_in\">NSURL</span> *)location</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.downloadFileURL = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 下载完成文件的路径</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.downloadFileURL = <span class=\"keyword\">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.downloadFileURL) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSError</span> *fileManagerError = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 文件转移</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (![[<span class=\"built_in\">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class=\"keyword\">self</span>.downloadFileURL error:&amp;fileManagerError]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 文件转移失败通知</span></span><br><span class=\"line\">                [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"AFURLSessionTaskSwizzling\"><a href=\"#AFURLSessionTaskSwizzling\" class=\"headerlink\" title=\"_AFURLSessionTaskSwizzling\"></a>_AFURLSessionTaskSwizzling</h2><p>_AFURLSessionTaskSwizzling 的唯一功能就是修改 NSURLSessionTask 的 resume 和 suspend 方法，使用下面的方法替换原有的实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)af_resume &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"keyword\">@selector</span>(state)], <span class=\"string\">@\"Does not respond to state\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionTaskState</span> state = [<span class=\"keyword\">self</span> state];</span><br><span class=\"line\">    <span class=\"comment\">// 经过 method swizzling 后，af_resume 就是之前的 resume ，所以这里是调用系统的 resume 方法</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> af_resume];</span><br><span class=\"line\">    <span class=\"comment\">// 如果之前是其他状态，发出通知，更改回 resume 状态，通知调用 taskDidResume</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != <span class=\"built_in\">NSURLSessionTaskStateRunning</span>) &#123;</span><br><span class=\"line\">        [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 同上</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)af_suspend &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"keyword\">@selector</span>(state)], <span class=\"string\">@\"Does not respond to state\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionTaskState</span> state = [<span class=\"keyword\">self</span> state];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> af_suspend];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != <span class=\"built_in\">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class=\"line\">        [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆这样做的目的是为了在方法 resume 或者 suspend 被调用是发出通知。</p>\n<p>具体方法调剂的过程发生在 <strong>+load</strong> 方法中进行</p>\n<blockquote>\n<p>load 方法会在加载类的时候就被调用，也就是 iOS 应用启动的时候就会加载所有的类，就会调用每个类的 +load 方法。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断当前 iOS 版本中是否存在 NSURLSessionTask</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"NSURLSessionTask\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.创建 NSURLSession 实例，通过实例创建 NSURLSessionDataTask</span></span><br><span class=\"line\">        <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class=\"line\">        <span class=\"built_in\">NSURLSession</span> * session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class=\"line\"><span class=\"meta\">#pragma GCC diagnostic push</span></span><br><span class=\"line\"><span class=\"meta\">#pragma GCC diagnostic ignored <span class=\"meta-string\">\"-Wnonnull\"</span></span></span><br><span class=\"line\">        <span class=\"comment\">// 因为 iOS7 和 iOS8 上对于 NSURLSessionTask 的实现不同，所以会通过 - [NSURLSession dataTaskWithURL:] 方法返回一个 NSURLSessionTask 实例</span></span><br><span class=\"line\">        <span class=\"built_in\">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic pop</span></span><br><span class=\"line\">        <span class=\"comment\">// 2.获取 af_resume 的方法实现指针</span></span><br><span class=\"line\">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(af_resume)));</span><br><span class=\"line\">        Class currentClass = [localDataTask <span class=\"keyword\">class</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 3.判断当前class是否实现了resume</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (class_getInstanceMethod(currentClass, <span class=\"keyword\">@selector</span>(resume))) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 4.获取当前class的父类</span></span><br><span class=\"line\">            Class superClass = [currentClass superclass];</span><br><span class=\"line\">            <span class=\"comment\">// 5.获取当前class的resume的方法实现指针</span></span><br><span class=\"line\">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class=\"keyword\">@selector</span>(resume)));</span><br><span class=\"line\">            <span class=\"comment\">// 6.获取当前class父类的resume的方法实现指针</span></span><br><span class=\"line\">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class=\"keyword\">@selector</span>(resume)));</span><br><span class=\"line\">            <span class=\"comment\">// 7.如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class=\"line\">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 8.设置当前操作的class为其父类class，重复while步骤3~8</span></span><br><span class=\"line\">            currentClass = [currentClass superclass];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [localDataTask cancel];</span><br><span class=\"line\">        [session finishTasksAndInvalidate];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里复杂的实现是为了解决 bug<a href=\"https://github.com/AFNetworking/AFNetworking/pull/2702\" target=\"_blank\" rel=\"noopener\">#2702</a></p>\n<h2 id=\"NSSecureCoding和NSCopying\"><a href=\"#NSSecureCoding和NSCopying\" class=\"headerlink\" title=\"NSSecureCoding和NSCopying\"></a>NSSecureCoding和NSCopying</h2><h3 id=\"NSSecureCoding\"><a href=\"#NSSecureCoding\" class=\"headerlink\" title=\"NSSecureCoding\"></a>NSSecureCoding</h3><p>关于NSSecureCoding的讲解请参考<a href=\"http://codingobjc.com/blog/2014/04/15/shi-yong-nssecurecodingxie-yi-jin-xing-bian-jie-ma/\" target=\"_blank\" rel=\"noopener\">使用NSSecureCoding协议进行编解码</a>。</p>\n<p>因为要支持secure coding，所以要在supportsSecureCoding返回YES。</p>\n<p>AFURLSessionManager保存的信息是其NSURLSessionConfiguration变量，然后根据获取到的configuration构建出AFURLSessionManager对象，节省了存储空间。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)supportsSecureCoding &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)decoder &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [decoder decodeObjectOfClass:[<span class=\"built_in\">NSURLSessionConfiguration</span> <span class=\"keyword\">class</span>] forKey:<span class=\"string\">@\"sessionConfiguration\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">self</span> initWithSessionConfiguration:configuration];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)coder &#123;</span><br><span class=\"line\">    [coder encodeObject:<span class=\"keyword\">self</span>.session.configuration forKey:<span class=\"string\">@\"sessionConfiguration\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NSCopying\"><a href=\"#NSCopying\" class=\"headerlink\" title=\"NSCopying\"></a>NSCopying</h3><p>先构建一个AFURLSessionManager空间，并使用原先session的configuration来初始化空间内容。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)copyWithZone:(<span class=\"built_in\">NSZone</span> *)zone &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] allocWithZone:zone] initWithSessionConfiguration:<span class=\"keyword\">self</span>.session.configuration];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>AFURLSessionManager 里面的内容大致讲完了，具体实现细节还是需要细细推敲的：</p>\n<ol>\n<li>AFURLSessionManager 是对 NSURLSession 的封装</li>\n<li>它通过 - [AFURLSessionManager dataTaskWithRequest:completionHandler:] 等接口创建 NSURLSessionDataTask 的实例</li>\n<li>通过一个字典 mutableTaskDelegatesKeyedByTaskIdentifier 来管理 dataTask 对象</li>\n<li>AFURLSessionManager 是通过 AFURLSessionManagerTaskDelegate 来对传入的 <strong>uploadProgressBlock</strong>， <strong>downloadProgressBlock</strong>， <strong>completionHandler</strong> 在合适的时间进行调用</li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a></li>\n<li><a href=\"http://www.cnblogs.com/polobymulberry/p/5160946.html\" target=\"_blank\" rel=\"noopener\">AFNetworking源码阅读（四）</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一章对 AFNetworking进行了概述，这一章重点对 AFN 的核心 <strong>AFURLSessionManager</strong>进行分析</p>\n<h2 id=\"AFURLSessionManager属性\"><a href=\"#AFURLSessionManager属性\" class=\"headerlink\" title=\"AFURLSessionManager属性\"></a>AFURLSessionManager属性</h2><p>主要属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> AFURLSessionManager管理的Session对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSURLSession</span> *session;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> delegate的回调所在队列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSOperationQueue</span> *operationQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 解析网络请求返回的数据，遵循AFURLResponseSerialization协议，并且不能为nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"keyword\">id</span> &lt;AFURLResponseSerialization&gt; responseSerializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> securityPolicy 是处理网络连接安全的对象，无特别的要求一般使用‘defaultPolicy’</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> reachabilityManager 是用于监控网络状态的对象，默认使用‘sharedManager’</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) AFNetworkReachabilityManager *reachabilityManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Session中正在运行的 Task ，包括 dataTask，uploadTask，downloadTask</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> &lt;<span class=\"built_in\">NSURLSessionTask</span> *&gt; *tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Session中正在运行的 dataTask</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> &lt;<span class=\"built_in\">NSURLSessionDataTask</span> *&gt; *dataTasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Session中正在运行的 uploadTask</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> &lt;<span class=\"built_in\">NSURLSessionUploadTask</span> *&gt; *uploadTasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Session中正在运行的 downloadTask</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> &lt;<span class=\"built_in\">NSURLSessionDownloadTask</span> *&gt; *downloadTasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> completionBlock的回调GCD队列，如果未主动设置，默认是 main queue</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">nullable</span>) <span class=\"built_in\">dispatch_queue_t</span> completionQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> completionBlock的回调Group-GCD队列，如果未主动设置，默认是 private dispatch group</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">nullable</span>) dispatch_group_t completionGroup;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///---------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">/// @name Working Around System Bugs</span></span><br><span class=\"line\"><span class=\"comment\">///---------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 当在后台session创建 upload task 返回‘nil’的时候，是否尝试重新创建 upload tasks，默认是NO</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @bug 这是 iOS 7.0的 bug，这个 bug 是当在后台session 创建 upload task 时，upload task 有时候会初始化为‘nil’。作为一种替代方法，如果这个属性设置为 YES ，AFN 会按照 Apple 推荐的方式创建 Task。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @详见 https://github.com/AFNetworking/AFNetworking/issues/1675</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">BOOL</span> attemptsToRecreateUploadTasksForBackgroundSessions;</span><br></pre></td></tr></table></figure>\n<p>AFURLSessionManager 的属性不是很多，也不是很复杂，注释也非常详尽。</p>\n<h2 id=\"使用AFURLSessionManager完成网络请求\"><a href=\"#使用AFURLSessionManager完成网络请求\" class=\"headerlink\" title=\"使用AFURLSessionManager完成网络请求\"></a>使用AFURLSessionManager完成网络请求</h2><p>使用AFURLSessionManager完成网络获取网络数据，仅需要如下几个步骤：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.初始化AFURLSessionManager对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 初始请求</span></span><br><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> *request = [[<span class=\"built_in\">NSURLRequest</span> alloc] initWithURL:[[<span class=\"built_in\">NSURL</span> alloc] initWithString:<span class=\"string\">@\"https://github.com\"</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 2.获取AFURLSessionManager的task对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request uploadProgress:<span class=\"literal\">nil</span> downloadProgress:<span class=\"literal\">nil</span> completionHandler:^(<span class=\"built_in\">NSURLResponse</span> * _Nonnull response, <span class=\"keyword\">id</span>  _Nullable responseObject, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error: %@\"</span>, error);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Get Net data success!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"comment\">// 3.启动task</span></span><br><span class=\"line\">[dataTask resume];</span><br></pre></td></tr></table></figure>\n<p>除了初始化 NSURLRequest ，完成整个数据请求只需要的三步，👇逐步分析如何实现的</p>\n<h3 id=\"初始化AFURLSessionManager\"><a href=\"#初始化AFURLSessionManager\" class=\"headerlink\" title=\"初始化AFURLSessionManager\"></a>初始化AFURLSessionManager</h3><p>调用这个方法来初始化 AFURLSessionManager<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithSessionConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration</span><br></pre></td></tr></table></figure></p>\n<p>它只有一个 NSURLSessionConfiguration 参数。</p>\n<p>实现的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithSessionConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ======================== 设置NSURLSession ==============================</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 configuration 为 ‘nil’，使用 defaultSessionConfiguration</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!configuration) &#123;</span><br><span class=\"line\">        configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.sessionConfiguration = configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">    <span class=\"comment\">// delegate 回调队列，最大并发数为 1</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue.maxConcurrentOperationCount = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 Session</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:<span class=\"keyword\">self</span>.sessionConfiguration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"keyword\">self</span>.operationQueue];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ======================== 初始化 response 序列化 ==============================</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ======================== 初始化 网络安全策略 ==============================</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ======================== 初始化 网络监控 ==============================</span></span><br><span class=\"line\"><span class=\"meta\">#if !TARGET_OS_WATCH</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ======================== 初始化 Task 和 AFURLSessionManagerTaskDelegate 字典 ==============================</span></span><br><span class=\"line\">    <span class=\"comment\">// key 为 taskId，value 为 AFURLSessionManagerTaskDelegate</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class=\"built_in\">NSMutableDictionary</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ======================== 初始化 mutableTaskDelegatesKeyedByTaskIdentifier 字典锁  ==============================</span></span><br><span class=\"line\">    <span class=\"comment\">// 保证 mutableTaskDelegatesKeyedByTaskIdentifier 的多线程安全</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.lock = [[<span class=\"built_in\">NSLock</span> alloc] init];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ======================== 获取当前 Session 中所有的 Task  ==============================</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.session getTasksWithCompletionHandler:^(<span class=\"built_in\">NSArray</span> *dataTasks, <span class=\"built_in\">NSArray</span> *uploadTasks, <span class=\"built_in\">NSArray</span> *downloadTasks) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为已有的 task 设置代理（在`生成NSURLSessionTask`细说）</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSURLSessionDataTask</span> *task <span class=\"keyword\">in</span> dataTasks) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> addDelegateForDataTask:task uploadProgress:<span class=\"literal\">nil</span> downloadProgress:<span class=\"literal\">nil</span> completionHandler:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSURLSessionUploadTask</span> *uploadTask <span class=\"keyword\">in</span> uploadTasks) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> addDelegateForUploadTask:uploadTask progress:<span class=\"literal\">nil</span> completionHandler:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSURLSessionDownloadTask</span> *downloadTask <span class=\"keyword\">in</span> downloadTasks) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> addDelegateForDownloadTask:downloadTask progress:<span class=\"literal\">nil</span> destination:<span class=\"literal\">nil</span> completionHandler:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是 AFURLSessionManager 的初始化方法，主要对其属性进行出初始化。<br>需要注意的是这两个私有属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *mutableTaskDelegatesKeyedByTaskIdentifier;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readwrite</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSLock</span> *lock;</span><br></pre></td></tr></table></figure>\n<p>AFURLSessionManager 会给每个管理的 task 对应的创建一个 AFURLSessionManagerTaskDelegate 对象，Manager把 task 的具体处理交给 delegate 对象，这样一个 AFURLSessionManager 就能同时管理多个 task。</p>\n<h3 id=\"生成-NSURLSessionTask\"><a href=\"#生成-NSURLSessionTask\" class=\"headerlink\" title=\"生成 NSURLSessionTask\"></a>生成 NSURLSessionTask</h3><p>初始化 AFURLSessionManager 实例后，通过👇的方法创建 <strong>NSURLSessionDataTask</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request</span><br><span class=\"line\">                               uploadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class=\"line\">                             downloadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class=\"line\">                            completionHandler:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLResponse</span> *response, <span class=\"keyword\">id</span> _Nullable responseObject,  <span class=\"built_in\">NSError</span> * _Nullable error))completionHandler;</span><br><span class=\"line\">                            </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request</span><br><span class=\"line\">           fromFile:(<span class=\"built_in\">NSURL</span> *)fileURL</span><br><span class=\"line\">           progress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class=\"line\">  completionHandler:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLResponse</span> *response, <span class=\"keyword\">id</span> _Nullable responseObject, <span class=\"built_in\">NSError</span>  * _Nullable error))completionHandler;</span><br><span class=\"line\">  </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request</span><br><span class=\"line\">                                        progress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class=\"line\">                                     destination:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSURL</span> * (^)(<span class=\"built_in\">NSURL</span> *targetPath, <span class=\"built_in\">NSURLResponse</span> *response))destination</span><br><span class=\"line\">                               completionHandler:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSURL</span> * _Nullable filePath, <span class=\"built_in\">NSError</span> * _Nullable error))completionHandler;</span><br><span class=\"line\">                               </span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>这只是部分方法，这些方法都是类似的。</p>\n<p>这里以<strong>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</strong>方法类举例说明，分析它如何实例化返回一个 <strong>NSURLSessionTask</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request</span><br><span class=\"line\">                               uploadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class=\"line\">                             downloadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class=\"line\">                            completionHandler:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLResponse</span> *response, <span class=\"keyword\">id</span> _Nullable responseObject,  <span class=\"built_in\">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    __block <span class=\"built_in\">NSURLSessionDataTask</span> *dataTask = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    url_session_manager_create_task_safely(^&#123;</span><br><span class=\"line\">        dataTask = [<span class=\"keyword\">self</span>.session dataTaskWithRequest:request];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataTask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>url_session_manager_create_task_safely</strong> 是 为了修复 iOS 8以下偶发的taskIdentifiers不唯一的 bug<a href=\"https://github.com/AFNetworking/AFNetworking/issues/2093\" target=\"_blank\" rel=\"noopener\">#2093</a>。</p>\n</blockquote>\n<p>上述方法完成了：</p>\n<ol>\n<li>调用<strong>- [NSURLSession dataTaskWithRequest:]</strong>方法传入 request 生成 NSURLSessionDataTask</li>\n<li>调用<strong>- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</strong>为该 dataTask 对象生成一个对应的 AFURLSessionManagerTaskDelegate 对象，并且关联起来。</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)addDelegateForDataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask</span><br><span class=\"line\">                uploadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class=\"line\">              downloadProgress:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class=\"line\">             completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLResponse</span> *response, <span class=\"keyword\">id</span> responseObject, <span class=\"built_in\">NSError</span> *error))completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t <span class=\"comment\">// 创建 AFURLSessionManagerTaskDelegate 对象</span></span><br><span class=\"line\">\t AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class=\"line\">\t <span class=\"comment\">// AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系</span></span><br><span class=\"line\">\t delegate.manager = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">\t <span class=\"comment\">// delegate 设置 完成block</span></span><br><span class=\"line\">\t delegate.completionHandler = completionHandler;</span><br><span class=\"line\">\t <span class=\"comment\">// 设置 task 的 taskDescription</span></span><br><span class=\"line\">\t dataTask.taskDescription = <span class=\"keyword\">self</span>.taskDescriptionForSessionTasks;</span><br><span class=\"line\">\t <span class=\"comment\">// 将 delegate 和 Task 关联起来</span></span><br><span class=\"line\">\t [<span class=\"keyword\">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class=\"line\">\t <span class=\"comment\">// 设置 上传block 和 下载block</span></span><br><span class=\"line\">\t delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class=\"line\">\t delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将 <strong>completionHandler</strong>， <strong>uploadProgressBlock</strong> 和 <strong>downloadProgressBlock</strong> 传入该对象并在相应事件发生时进行回调。</p>\n<p>AFNetworking 通过封装 AFURLSessionManagerTaskDelegate 对象 ，让 delegate 对每个 task 进行管理，而 AFURLSessionManager 仅需要管理 保存 task 与 delegate 的 字典即可，实现了功能下放。</p>\n<p>这个方法里面调用了另一个方法<strong>- [AFURLSessionManager setDelegate:forTask:]</strong>设置代理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class=\"line\">            forTask:(<span class=\"built_in\">NSURLSessionTask</span> *)task</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查参数</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSParameterAssert</span>(task);</span><br><span class=\"line\">\t<span class=\"built_in\">NSParameterAssert</span>(delegate);</span><br><span class=\"line\">\t<span class=\"comment\">// 上锁，保证线程安全</span></span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.lock lock];</span><br><span class=\"line\">\t<span class=\"comment\">// 把 delegate 放入字典，key 是 taskIdentifier</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class=\"line\">\t<span class=\"comment\">// 监听 task 的 resume 和 Suspend</span></span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> addNotificationObserverForTask:task];</span><br><span class=\"line\">\t<span class=\"comment\">// 解锁</span></span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.lock unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"AFURLSessionManager-实现了-NSURLSessionDelegate-等多个协议\"><a href=\"#AFURLSessionManager-实现了-NSURLSessionDelegate-等多个协议\" class=\"headerlink\" title=\"AFURLSessionManager 实现了 NSURLSessionDelegate 等多个协议\"></a>AFURLSessionManager 实现了 NSURLSessionDelegate 等多个协议</h2><p>在 AFURLSessionManager 的头文件中，遵循了很多协议，包括：</p>\n<ul>\n<li>NSURLSessionDelegate</li>\n<li>NSURLSessionTaskDelegate</li>\n<li>NSURLSessionDataDelegate</li>\n<li>NSURLSessionDownloadDelegate</li>\n</ul>\n<p>在初始化方法<strong>- [AFURLSessionManager initWithSessionConfiguration:]</strong>时，把 NSURLSession 的 delegate 指向了 self（AFURLSessionManager）。</p>\n<p>AFURLSessionManager 也为 所有的 delegate协议 提供了对应 block 接口设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setSessionDidBecomeInvalidBlock:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLSession</span> *session, <span class=\"built_in\">NSError</span> *error))block;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setSessionDidReceiveAuthenticationChallengeBlock:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSURLSessionAuthChallengeDisposition</span> (^)(<span class=\"built_in\">NSURLSession</span> *session, <span class=\"built_in\">NSURLAuthenticationChallenge</span> *challenge, <span class=\"built_in\">NSURLCredential</span> * _Nullable __autoreleasing * _Nullable credential))block;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>👆只是其中一部分。</p>\n<p>拿 <strong>- [AFNRLSessionManager setSessionDidBecomeInvalidBlock:]</strong> 举例</p>\n<p>AFURLSessionManager 开放对外的接口，把 sessionDidBecomeInvalid 回调的 block 传入：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setSessionDidBecomeInvalidBlock:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLSession</span> *session, <span class=\"built_in\">NSError</span> *error))block &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.sessionDidBecomeInvalid = block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <strong>- [URLSession:didBecomeInvalidWithError:]</strong> 代理方法调用时，判断对应的 block 是否存在，就会执行对应的 block：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session</span><br><span class=\"line\">didBecomeInvalidWithError:(<span class=\"built_in\">NSError</span> *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.sessionDidBecomeInvalid) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.sessionDidBecomeInvalid(session, error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其他的接口也类似这样的实现，只是实现的内容不一样。</p>\n<h2 id=\"AFURLSessionManagerTaskDelegate\"><a href=\"#AFURLSessionManagerTaskDelegate\" class=\"headerlink\" title=\"AFURLSessionManagerTaskDelegate\"></a>AFURLSessionManagerTaskDelegate</h2><p>👆提到的 AFURLSessionManagerTaskDelegate 是管理 task 的类，在 <strong>- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</strong> 的方法里面创建。</p>\n<p>首先看下它的初始化方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithTask:(<span class=\"built_in\">NSURLSessionTask</span> *)task &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 NSData 存放请求回来的数据</span></span><br><span class=\"line\">    _mutableData = [<span class=\"built_in\">NSMutableData</span> data];</span><br><span class=\"line\">    <span class=\"comment\">// 上传的进度</span></span><br><span class=\"line\">    _uploadProgress = [[<span class=\"built_in\">NSProgress</span> alloc] initWithParent:<span class=\"literal\">nil</span> userInfo:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 下载的进度</span></span><br><span class=\"line\">    _downloadProgress = [[<span class=\"built_in\">NSProgress</span> alloc] initWithParent:<span class=\"literal\">nil</span> userInfo:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> __typeof__(task) weakTask = task;</span><br><span class=\"line\">    <span class=\"comment\">// 给两个进度设置 取消，暂停，启动block 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSProgress</span> *progress <span class=\"keyword\">in</span> @[ _uploadProgress, _downloadProgress ])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        progress.totalUnitCount = <span class=\"built_in\">NSURLSessionTransferSizeUnknown</span>;</span><br><span class=\"line\">        progress.cancellable = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        progress.cancellationHandler = ^&#123;</span><br><span class=\"line\">            [weakTask cancel];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        progress.pausable = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        progress.pausingHandler = ^&#123;</span><br><span class=\"line\">            [weakTask suspend];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([progress respondsToSelector:<span class=\"keyword\">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class=\"line\">            progress.resumingHandler = ^&#123;</span><br><span class=\"line\">                [weakTask resume];</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// kVO 监听状态改变</span></span><br><span class=\"line\">        [progress addObserver:<span class=\"keyword\">self</span></span><br><span class=\"line\">                   forKeyPath:<span class=\"built_in\">NSStringFromSelector</span>(<span class=\"keyword\">@selector</span>(fractionCompleted))</span><br><span class=\"line\">                      options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span></span><br><span class=\"line\">                      context:<span class=\"literal\">NULL</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>设置 block 回调，主要是在对应 NSProgress 的状态改变时，调用 resume suspend 等方法改变 task 的状态。</p>\n</blockquote>\n<p>在 <strong>observeValueForKeypath:ofObject:change:context:</strong> 方法中调用 block</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *,<span class=\"keyword\">id</span>&gt; *)change context:(<span class=\"keyword\">void</span> *)context &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ([object isEqual:<span class=\"keyword\">self</span>.downloadProgress]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.downloadProgressBlock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.downloadProgressBlock(object);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([object isEqual:<span class=\"keyword\">self</span>.uploadProgress]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.uploadProgressBlock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.uploadProgressBlock(object);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 Progress对象 某些属性改变时，调用block。</p>\n<p>往下看你会发现 AFURLSessionManagerTaskDelegate 中也实现了 <strong>NSURLSession</strong> 的一些协议<br><img src=\"/2016/12/24/AFNetworking-AFURLSessionManager-2/Snip20170125_1.png\" title=\"AFURLSessionManagerTaskDelegate-NSURLSession\"></p>\n<p>之前在 AFURLSessionManager 中，也实现了 <strong>NSURLSession</strong> 的协议<br><img src=\"/2016/12/24/AFNetworking-AFURLSessionManager-2/Snip20170125_2.png\" title=\"AFURLSessionManager-NSURLSession\"></p>\n<blockquote>\n<p>因为 AFURLSessionManager 所管理的 NSURLSession 对象的 delegate 被设置为 AFURLSessionManager 自身，所以所有的 NSURLSession 协议回调都是 AFURLSessionManager，然后 AFURLSessionManager 根据具体需要，将 响应的 delegate 传递到 AFURLSessionManagerTaskDelegate 里面。</p>\n</blockquote>\n<p>每当需要 AFURLSessionManagerTaskDelegate 具体处理的时候，AFURLSessionManager 都会取出相应的 taskDelegate 原封不动的传入。</p>\n<h3 id=\"代理方法-URLSession-task-didCompleteWithError\"><a href=\"#代理方法-URLSession-task-didCompleteWithError\" class=\"headerlink\" title=\"代理方法 URLSession:task:didCompleteWithError:\"></a>代理方法 URLSession:task:didCompleteWithError:</h3><p>当每一个 <strong>NSURLSessionTask</strong> 结束时都会进入这个回调方法中：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(__unused <span class=\"built_in\">NSURLSession</span> *)session</span><br><span class=\"line\">              task:(<span class=\"built_in\">NSURLSessionTask</span> *)task</span><br><span class=\"line\">didCompleteWithError:(<span class=\"built_in\">NSError</span> *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"meta\">#1：获取数据 `responseSerializer` 和 `downloadFileURL`，存储到字典里面</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">        <span class=\"meta\">#2：在存在错误时调用 `completionHandler`</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">#3：调用 `completionHandler`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆是整体的思路，先看看第一部分：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">strong</span> AFURLSessionManager *manager = <span class=\"keyword\">self</span>.manager;</span><br><span class=\"line\"></span><br><span class=\"line\">__block <span class=\"keyword\">id</span> responseObject = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">__block <span class=\"built_in\">NSMutableDictionary</span> *userInfo = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Performance Improvement from #2672</span></span><br><span class=\"line\"><span class=\"built_in\">NSData</span> *data = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.mutableData) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 从 mutableData 中取出数据 </span></span><br><span class=\"line\">   data = [<span class=\"keyword\">self</span>.mutableData <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">   <span class=\"comment\">//We no longer need the reference, so nil it out to gain back some memory.</span></span><br><span class=\"line\">   <span class=\"keyword\">self</span>.mutableData = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 userInfo</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.downloadFileURL) &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 文件路径</span></span><br><span class=\"line\">   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class=\"keyword\">self</span>.downloadFileURL;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二部分：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误存在，设置 userInfo 错误</span></span><br><span class=\"line\">userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果 manager 持有的 completionGroup 存在，就使用 completionGroup，否则使用默认创建的 url_session_manager_completion_group() GCD组队列</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 manager 持有的 completionQueue 存在，就使用 completionQueue，否则使用 dispatch_get_main_queue() 主队列</span></span><br><span class=\"line\">dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用完成block</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.completionHandler) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">self</span>.completionHandler(task.response, responseObject, error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 子线程中发送 Task 结束通知 </span></span><br><span class=\"line\">  <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">      [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>第三部分：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSError</span> *serializationError = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 序列化响应数据</span></span><br><span class=\"line\">  responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class=\"line\">  <span class=\"comment\">// 👇还是设置 userInfo， 调用 block ，发出通知</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.downloadFileURL) &#123;</span><br><span class=\"line\">      responseObject = <span class=\"keyword\">self</span>.downloadFileURL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (responseObject) &#123;</span><br><span class=\"line\">      userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (serializationError) &#123;</span><br><span class=\"line\">      userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.completionHandler) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">self</span>.completionHandler(task.response, responseObject, serializationError);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">          [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"代理方法-URLSession-dataTask-didReceiveData-和-URLSession-downloadTask-didFinishDownloadingToURL\"><a href=\"#代理方法-URLSession-dataTask-didReceiveData-和-URLSession-downloadTask-didFinishDownloadingToURL\" class=\"headerlink\" title=\"代理方法 URLSession:dataTask:didReceiveData: 和 - URLSession:downloadTask:didFinishDownloadingToURL:\"></a>代理方法 URLSession:dataTask:didReceiveData: 和 - URLSession:downloadTask:didFinishDownloadingToURL:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(__unused <span class=\"built_in\">NSURLSession</span> *)session</span><br><span class=\"line\">          dataTask:(__unused <span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask</span><br><span class=\"line\">    didReceiveData:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;</span><br><span class=\"line\">    <span class=\"comment\">// 追加数据</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.mutableData appendData:data];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session</span><br><span class=\"line\">      downloadTask:(<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class=\"line\">didFinishDownloadingToURL:(<span class=\"built_in\">NSURL</span> *)location</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.downloadFileURL = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 下载完成文件的路径</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.downloadFileURL = <span class=\"keyword\">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.downloadFileURL) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSError</span> *fileManagerError = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 文件转移</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (![[<span class=\"built_in\">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class=\"keyword\">self</span>.downloadFileURL error:&amp;fileManagerError]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 文件转移失败通知</span></span><br><span class=\"line\">                [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"AFURLSessionTaskSwizzling\"><a href=\"#AFURLSessionTaskSwizzling\" class=\"headerlink\" title=\"_AFURLSessionTaskSwizzling\"></a>_AFURLSessionTaskSwizzling</h2><p>_AFURLSessionTaskSwizzling 的唯一功能就是修改 NSURLSessionTask 的 resume 和 suspend 方法，使用下面的方法替换原有的实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)af_resume &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"keyword\">@selector</span>(state)], <span class=\"string\">@\"Does not respond to state\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionTaskState</span> state = [<span class=\"keyword\">self</span> state];</span><br><span class=\"line\">    <span class=\"comment\">// 经过 method swizzling 后，af_resume 就是之前的 resume ，所以这里是调用系统的 resume 方法</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> af_resume];</span><br><span class=\"line\">    <span class=\"comment\">// 如果之前是其他状态，发出通知，更改回 resume 状态，通知调用 taskDidResume</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != <span class=\"built_in\">NSURLSessionTaskStateRunning</span>) &#123;</span><br><span class=\"line\">        [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 同上</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)af_suspend &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"keyword\">@selector</span>(state)], <span class=\"string\">@\"Does not respond to state\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionTaskState</span> state = [<span class=\"keyword\">self</span> state];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> af_suspend];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != <span class=\"built_in\">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class=\"line\">        [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👆这样做的目的是为了在方法 resume 或者 suspend 被调用是发出通知。</p>\n<p>具体方法调剂的过程发生在 <strong>+load</strong> 方法中进行</p>\n<blockquote>\n<p>load 方法会在加载类的时候就被调用，也就是 iOS 应用启动的时候就会加载所有的类，就会调用每个类的 +load 方法。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断当前 iOS 版本中是否存在 NSURLSessionTask</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"NSURLSessionTask\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.创建 NSURLSession 实例，通过实例创建 NSURLSessionDataTask</span></span><br><span class=\"line\">        <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class=\"line\">        <span class=\"built_in\">NSURLSession</span> * session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class=\"line\"><span class=\"meta\">#pragma GCC diagnostic push</span></span><br><span class=\"line\"><span class=\"meta\">#pragma GCC diagnostic ignored <span class=\"meta-string\">\"-Wnonnull\"</span></span></span><br><span class=\"line\">        <span class=\"comment\">// 因为 iOS7 和 iOS8 上对于 NSURLSessionTask 的实现不同，所以会通过 - [NSURLSession dataTaskWithURL:] 方法返回一个 NSURLSessionTask 实例</span></span><br><span class=\"line\">        <span class=\"built_in\">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic pop</span></span><br><span class=\"line\">        <span class=\"comment\">// 2.获取 af_resume 的方法实现指针</span></span><br><span class=\"line\">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(af_resume)));</span><br><span class=\"line\">        Class currentClass = [localDataTask <span class=\"keyword\">class</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 3.判断当前class是否实现了resume</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (class_getInstanceMethod(currentClass, <span class=\"keyword\">@selector</span>(resume))) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 4.获取当前class的父类</span></span><br><span class=\"line\">            Class superClass = [currentClass superclass];</span><br><span class=\"line\">            <span class=\"comment\">// 5.获取当前class的resume的方法实现指针</span></span><br><span class=\"line\">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class=\"keyword\">@selector</span>(resume)));</span><br><span class=\"line\">            <span class=\"comment\">// 6.获取当前class父类的resume的方法实现指针</span></span><br><span class=\"line\">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class=\"keyword\">@selector</span>(resume)));</span><br><span class=\"line\">            <span class=\"comment\">// 7.如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class=\"line\">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 8.设置当前操作的class为其父类class，重复while步骤3~8</span></span><br><span class=\"line\">            currentClass = [currentClass superclass];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [localDataTask cancel];</span><br><span class=\"line\">        [session finishTasksAndInvalidate];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里复杂的实现是为了解决 bug<a href=\"https://github.com/AFNetworking/AFNetworking/pull/2702\" target=\"_blank\" rel=\"noopener\">#2702</a></p>\n<h2 id=\"NSSecureCoding和NSCopying\"><a href=\"#NSSecureCoding和NSCopying\" class=\"headerlink\" title=\"NSSecureCoding和NSCopying\"></a>NSSecureCoding和NSCopying</h2><h3 id=\"NSSecureCoding\"><a href=\"#NSSecureCoding\" class=\"headerlink\" title=\"NSSecureCoding\"></a>NSSecureCoding</h3><p>关于NSSecureCoding的讲解请参考<a href=\"http://codingobjc.com/blog/2014/04/15/shi-yong-nssecurecodingxie-yi-jin-xing-bian-jie-ma/\" target=\"_blank\" rel=\"noopener\">使用NSSecureCoding协议进行编解码</a>。</p>\n<p>因为要支持secure coding，所以要在supportsSecureCoding返回YES。</p>\n<p>AFURLSessionManager保存的信息是其NSURLSessionConfiguration变量，然后根据获取到的configuration构建出AFURLSessionManager对象，节省了存储空间。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)supportsSecureCoding &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)decoder &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [decoder decodeObjectOfClass:[<span class=\"built_in\">NSURLSessionConfiguration</span> <span class=\"keyword\">class</span>] forKey:<span class=\"string\">@\"sessionConfiguration\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">self</span> initWithSessionConfiguration:configuration];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)coder &#123;</span><br><span class=\"line\">    [coder encodeObject:<span class=\"keyword\">self</span>.session.configuration forKey:<span class=\"string\">@\"sessionConfiguration\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NSCopying\"><a href=\"#NSCopying\" class=\"headerlink\" title=\"NSCopying\"></a>NSCopying</h3><p>先构建一个AFURLSessionManager空间，并使用原先session的configuration来初始化空间内容。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)copyWithZone:(<span class=\"built_in\">NSZone</span> *)zone &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] allocWithZone:zone] initWithSessionConfiguration:<span class=\"keyword\">self</span>.session.configuration];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>AFURLSessionManager 里面的内容大致讲完了，具体实现细节还是需要细细推敲的：</p>\n<ol>\n<li>AFURLSessionManager 是对 NSURLSession 的封装</li>\n<li>它通过 - [AFURLSessionManager dataTaskWithRequest:completionHandler:] 等接口创建 NSURLSessionDataTask 的实例</li>\n<li>通过一个字典 mutableTaskDelegatesKeyedByTaskIdentifier 来管理 dataTask 对象</li>\n<li>AFURLSessionManager 是通过 AFURLSessionManagerTaskDelegate 来对传入的 <strong>uploadProgressBlock</strong>， <strong>downloadProgressBlock</strong>， <strong>completionHandler</strong> 在合适的时间进行调用</li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"_blank\" rel=\"noopener\">AFNetworking</a></li>\n<li><a href=\"http://www.cnblogs.com/polobymulberry/p/5160946.html\" target=\"_blank\" rel=\"noopener\">AFNetworking源码阅读（四）</a></li>\n</ul>\n"},{"title":"YYCache 源码分析","date":"2018-02-24T03:50:51.000Z","_content":"\n## 前言\n\niOS 开发中总会用到各种缓存，本文介绍的是 **YYCache** 是一个线程安全的高性能键值缓存（该项目是 YYKit 组件之一）。YYKit 作者是 @ibireme 。\n\n[YYCache](https://github.com/ibireme/YYCache) 的代码逻辑清晰，注释详尽，加上自身不算太大的代码量使得其阅读非常简单，更加厉害的是它的性能还非常高。\n\n详情请看：[《YYCache 设计思路与技术细节》](https://blog.ibireme.com/2015/10/26/yycache/)\n\n我把 YYCache 从头到尾看了一遍，最大的感触就是代码风格干净整洁，代码思路清晰明了，注释详细。\n\n我们先来简单看一下 YYCache 的代码结构，YYCache 是由 YYMemoryCache 与 YYDiskCache 两部分组成的，其中 YYMemoryCache 作为高速内存缓存，而 YYDiskCache 则作为低速磁盘缓存。\n\n\n```\nYYCache\n \tYYMemoryCache\n \t\t_YYLinkedMap\n\t\t_YYLinkedMapNode\n\tYYDiskCache\n\t\tYYKVStorage\n  \t\tYYKVStorageItem\n```\n\n👆是 YYCache 的主要结构，通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但相对低速的持久化存储。\n\n## YYCache\n\n\n```objc\n@interface YYCache : NSObject\n\n@property (copy, readonly) NSString *name;\n@property (strong, readonly) YYMemoryCache *memoryCache;\n@property (strong, readonly) YYDiskCache *diskCache;\n\n- (BOOL)containsObjectForKey:(NSString *)key;\n- (nullable id<NSCoding>)objectForKey:(NSString *)key;\n- (void)setObject:(nullable id<NSCoding>)object forKey:(NSString *)key;\n- (void)removeObjectForKey:(NSString *)key;\n\n@end\n\n```\n\n我将 YYCache 里的代码精简了一下，总的来说就这些增删改查的方法， 里面有 YYMemoryCache 与 YYDiskCache，并且对外提供了一些接口。这些接口基本都是基于 Key 和 Value 设计的，和字典的操作类似。\n\n## YYMemoryCache \n\n```objc\n@interface YYMemoryCache : NSObject\n\n#pragma mark - Attribute\n/**\n    cache 的名称，默认为nil\n */\n@property (nullable, copy) NSString *name;\n\n/**\n    memory 中的消息总数\n */\n@property (readonly) NSUInteger totalCount;\n\n/**\n    memory 中的消息总开销\n */\n@property (readonly) NSUInteger totalCost;\n\n\n#pragma mark - Limit\n\n/**\n 消息池子 cache 中存储的最大数量\n 默认的值为 NSUIntegerMax 表示无限制\n 如果超过此限制，则稍后在后台线程将清除一些对象\n */\n@property NSUInteger countLimit;\n\n/**\n 消息池子cache中容许的最大开销\n 默认的值为 NSUIntegerMax 表示无限制\n 如果超过此限制，则稍后在后台线程将清除一些对象\n */\n@property NSUInteger costLimit;\n\n/**\n 消息池子cache中容许的时间限制\n 默认的值为 DBL_MAX 表示无限制\n 如果超过此限制，则稍后在后台线程将清除一些对象\n */\n@property NSTimeInterval ageLimit;\n\n/**\n 自动检测容器限制 默认时间 5.0s\n cache 消息池子持有 Timer，以确保 cache 是否达到上限 如果达到上限则进行削减\n */\n@property NSTimeInterval autoTrimInterval;\n\n/**\n 如果是 YES 则收到内存报警时会删除所有的 cache 消息对象\n 默认值是 YES\n */\n@property BOOL shouldRemoveAllObjectsOnMemoryWarning;\n\n/**\n 如果是 YES 则收到app进入后台时会删除所有的cache消息对象\n 默认值是 YES\n */\n@property BOOL shouldRemoveAllObjectsWhenEnteringBackground;\n\n/** \n app 收到报警时执行的 block 默认为 nil\n */\n@property (nullable, copy) void(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);\n\n/** \n app 收到进入后台时执行的 block 默认为 nil\n */\n@property (nullable, copy) void(^didEnterBackgroundBlock)(YYMemoryCache *cache);\n\n/**\n 键值对是否在主线程删除 默认值为NO.\n 仅仅当键值对中包含 UIView、CALayer 等非线程安全对象时，将值设为YES\n */\n@property BOOL releaseOnMainThread;\n\n/**\n 键值对异步的释放 默认值为 YES\n 避免堵塞访问方法 否则将在 removeObjectForKey: 等方法中释放 默认是 YES\n */\n@property BOOL releaseAsynchronously;\n\n\n#pragma mark - Access Methods\n\n/** \n 判断消息池子是否包含指定key的消息\n key 消息对象关联的key. 如果是nil则返回NO\n 是否包含指定key的消息\n */\n- (BOOL)containsObjectForKey:(id)key;\n\n/**\n 获取与key关联的消息对象\n key 关联消息对象的 key,如果是 nil 则返回 nil\n 返回与 key 关联的消息对象, 如果未找到则返回 nil\n */\n- (nullable id)objectForKey:(id)key;\n\n/**\n 根据指定的 key 存储消息对象\n message 需要存储到池子的对象. 如果是nil则调用 `removeMessageForKey`.\n key 存储对象关联的key. 如果是nil则不执行任何操作\n 与NSMutableDictionary相比, cache池子不会拷贝容器中的键值对\n */\n- (void)setObject:(nullable id)object forKey:(id)key;\n\n/**\n 根据指定的key和开销cost存储消息\n object 需要存储到池子的对象. 如果是nil则调用 `removeObjectForKey`.\n key 存储对象关联的key. 如果是nil则不执行任何操作\n cost 关联键值对的开销\n 与NSMutableDictionary相比, cache池子不会拷贝容器中的键值对\n */\n- (void)setObject:(nullable id)object forKey:(id)key withCost:(NSUInteger)cost;\n\n/**\n 根据指定的key删除消息\n key 需要删除的object的key. 如果是nil则不执行任何操作\n */\n- (void)removeObjectForKey:(id)key;\n\n/**\n 删除所有的消息\n */\n- (void)removeAllObjects;\n\n\n#pragma mark - Trim\n\n/**\n 用 LRU 算法删除对象，直到 totalCount <= count\n */\n- (void)trimToCount:(NSUInteger)count;\n\n/**\n 用 LRU 算法删除对象，直到 totalCost <= cost\n */\n- (void)trimToCost:(NSUInteger)cost;\n\n/**\n 用 LRU 算法删除对象，直到所有到期对象全部被删除\n */\n- (void)trimToAge:(NSTimeInterval)age;\n\n@end\n```\n\n上面是 YYMemoryCache.h 的主要属性和接口，加上了注释。\n\n### _YYLinkedMapNode 和 _YYLinkedMap\n\nYYMemoryCache 内部其实是通过 **_YYLinkedMapNode** 和 **_YYLinkedMap** 这两个对象操作缓存的。\n\n\n```objc\n/**\n _YYLinkedMap 中的一个节点。\n 通常情况下我们不应该使用这个类。\n */\n@interface _YYLinkedMapNode : NSObject {\n    @package\n    __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic 前一个消息 && 被字典保留\n    __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic 后一个消息 && 被字典保留\n    id _key;    /// 消息的key\n    id _value;  /// 消息\n    NSUInteger _cost;   /// 消息开销\n    NSTimeInterval _time;   /// 消息时间\n}\n@end\n\n/**\n YYMemoryCache 内的一个链表。\n _YYLinkedMap 不是一个线程安全的类，而且它也不对参数做校验。\n 通常情况下我们不应该使用这个类。\n */\n@interface _YYLinkedMap : NSObject {\n    @package\n    CFMutableDictionaryRef _dic; // do not set object directly 保存消息的字典，外部不要直接设置\n    NSUInteger _totalCost;  // 消息总开销\n    NSUInteger _totalCount; // 消息总量\n    _YYLinkedMapNode *_head; // MRU, do not change it directly MRU最近最常使用, 外部不要直接修改\n    _YYLinkedMapNode *_tail; // LRU, do not change it directly LRU最近最少使用, 外部不要直接修改\n    BOOL _releaseOnMainThread;  // 是否在主线程release\n    BOOL _releaseAsynchronously;    // 是否异步release\n}\n```\n\n可以看出来 _YYLinkedMapNode 是双向链表， _YYLinkedMap 是双向链表的节点。\n\n_YYLinkedMapNode 记录着它的前一个节点 **_prev** 和 后一个节点 **_next**，并且记录着缓存信息的 **_key** 和 **_value**，这样一个节点就保存缓存数据，可以理解为一个节点就是一个缓存对象。\n\n_YYLinkedMap 使用 **CFMutableDictionaryRef _dic** 字典存储 _YYLinkedMapNode。这样即强引用了节点，又能够利用字典的 Hash 快速定位用户要访问的缓存对象，并且当需要是否手动释放字典的时候，能够通过 CFRelease 手动释放。\n\n### 线程安全\n\n```objc\n@implementation YYMemoryCache {\n    pthread_mutex_t _lock; // 线程锁，保证线程安全\n    _YYLinkedMap *_lru;\t// YYMemoryCache 通过操作Map来管理缓存\n    dispatch_queue_t _queue;\t// 串行队列，用于后台 trim（清扫工作）\n}\n```\n\n在 YYMemoryCache 中作者是使用 `pthread_mutex` 来保证线程安全的，但是最开始的版本并不是用 pthread_mutex ，而是使用自旋锁 **OSSpinLock**，可以查看[YYCache 设计思路](https://blog.ibireme.com/2015/10/26/yycache/)得知改动的原因。\n\n### LRU\n\nLRU(least-recently-used) 算法翻译过来是”最近最少使用“，顾名思义这种缓存替换策略是基于用户最近访问过的缓存对象而建立。\n\n- 从代码实现上看缓存替换策略的核心思想在于：LRU 认为用户最新使用（访问）过的缓存对象为高频缓存对象，即用户很可能还会再次使用（访问）该缓存对象；而反之，用户很久之前使用（访问）过的缓存对象（期间一直没有再次访问）为低频缓存对象，即用户很可能不会再去使用（访问）该缓存对象，通常在资源不足时会先去释放低频缓存对象。\n\n### _YYLinkedMapNode 和 _YYLinkedMap 使用 LRU\n\n从双向链表可以知道，链表存在两个节点：\n\n* 头结点：用户最近使用的数据，MRU\n* 尾节点：用户很久之前使用的数据，LRU\n\n\n```objc\n- (id)objectForKey:(id)key {\n    if (!key) return nil;\n    pthread_mutex_lock(&_lock);\n    // 找到节点\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    if (node) {\n    \t\t// 更新节点的时间戳\n        node->_time = CACurrentMediaTime();\n        // 将节点移动到头结点\n        [_lru bringNodeToHead:node];\n    }\n    pthread_mutex_unlock(&_lock);\n    return node ? node->_value : nil;\n}\n```\n\n每次根据 Key 获取某个节点的时候，都会更新节点的时间戳并移动到头结点。\n\n\n```objc\n- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost {\n    if (!key) return;\n    if (!object) {\n        [self removeObjectForKey:key];\n        return;\n    }\n    pthread_mutex_lock(&_lock);\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    NSTimeInterval now = CACurrentMediaTime();\n    // 判断节点是否存在\n    if (node) {\n    \t\t// 存在更新节点，并移动至头节点\n        _lru->_totalCost -= node->_cost;\n        _lru->_totalCost += cost;\n        node->_cost = cost;\n        node->_time = now;\n        node->_value = object;\n        [_lru bringNodeToHead:node];\n    } else {\n        // 不存在，创建一个新的节点，插入头节点\n        node = [_YYLinkedMapNode new];\n        node->_cost = cost;\n        node->_time = now;\n        node->_key = key;\n        node->_value = object;\n        [_lru insertNodeAtHead:node];\n    }\n    if (_lru->_totalCost > _costLimit) {\n        dispatch_async(_queue, ^{\n            [self trimToCost:_costLimit];\n        });\n    }\n    if (_lru->_totalCount > _countLimit) {\n        _YYLinkedMapNode *node = [_lru removeTailNode];\n        if (_lru->_releaseAsynchronously) {\n            dispatch_queue_t queue = _lru->_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n            dispatch_async(queue, ^{\n                [node class]; //hold and release in queue\n            });\n        } else if (_lru->_releaseOnMainThread && !pthread_main_np()) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [node class]; //hold and release in queue\n            });\n        }\n    }\n    pthread_mutex_unlock(&_lock);\n}\n```\n\n当设置新节点时，判断节点是否存在，存在更新节点，并移动至头节点；不存在，创建一个新的节点，插入头节点。\n\n\n```objc\n/**\n 消息池子按照数量限制清扫\n */\n- (void)_trimToCount:(NSUInteger)countLimit {\n    BOOL finish = NO;\n    pthread_mutex_lock(&_lock);\n    if (countLimit == 0) {\n        [_lru removeAll];\n        finish = YES;\n    } else if (_lru->_totalCount <= countLimit) {\n        finish = YES;\n    }\n    pthread_mutex_unlock(&_lock);\n    if (finish) return;\n    \n    NSMutableArray *holder = [NSMutableArray new];\n    while (!finish) {\n        if (pthread_mutex_trylock(&_lock) == 0) {\n            if (_lru->_totalCount > countLimit) {\n            \t  // 当缓存数量超出限制的时候，先从尾节点（LRU）开始清除，释放资源\n                _YYLinkedMapNode *node = [_lru removeTailNode];\n                if (node) [holder addObject:node];\n            } else {\n                finish = YES;\n            }\n            pthread_mutex_unlock(&_lock);\n        } else {\n            // 使用 usleep 以微秒为单位挂起线程，在短时间间隔挂起线程\n            // 对比 sleep 用 usleep 能更好的利用 CPU 时间\n            usleep(10 * 1000); //10 ms\n        }\n    }\n    if (holder.count) {\n        // 判断是否在主线程释放对象\n        dispatch_queue_t queue = _lru->_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n        dispatch_async(queue, ^{\n            [holder count]; // release in queue\n        });\n    }\n}\n```\n\n清除的代码其实不是太难，YYCache 从 count 、cost 和 age 三个维度去做清除工作，具体请去查阅源码。\n\n\n在代码底部判断是否在主线程释放资源，是作者另一篇文章[iOS 保持界面流畅的技巧](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)中提到：\n\n> 对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。\n\n\n```objc\nNSArray *tmp = self.array;\nself.array = nil;\ndispatch_async(queue, ^{\n    [tmp class];\n});\n```\n\n## YYDiskCache\n\n\n```objc\n/**\n YYDiskCache 是一个线程安全的磁盘缓存，用于存储由 SQLite 和文件系统支持的键值对（类似于 NSURLCache 的磁盘缓存）。\n\nYYDiskCache 具有以下功能：\n\n* 它使用 LRU(least-recently-used) 来删除对象。\n* 支持按 cost，count 和 age 进行控制。\n* 它可以被配置为当没有可用的磁盘空间时自动驱逐缓存对象。\n* 它可以自动抉择每个缓存对象的存储类型（sqlite/file）以便提供更好的性能表现。\n\n你可以编译最新版本的 sqlite 并忽略 iOS 系统中的 libsqlite3.dylib 来获得 2x〜4x 的速度提升\n */\n@interface YYDiskCache : NSObject\n\n#pragma mark - Attribute\n/**\n The name of the cache. Default is nil.\n 磁盘cache的名称\n */\n@property (nullable, copy) NSString *name;\n\n/**\n The path of the cache (read-only).\n 磁盘cache的文件路径\n */\n@property (readonly) NSString *path;\n\n/**\n 如果存入的消息超过此值，则消息会存入文件file，否则存入sqlite\n 0 意味着所有的消息会存入不同的文件file, NSUIntegerMax 意味着所有的消息会存入 sqlite.\n 默认的值为 20480 (20KB).\n */\n@property (readonly) NSUInteger inlineThreshold;\n\n/**\n 如果block为nil 则会使用NSKeyedArchiver归档消息 使用此block以支持未遵循`NSCoding` 协议的对象存储\n 默认值为nil\n */\n@property (nullable, copy) NSData *(^customArchiveBlock)(id object);\n\n/**\n block不为nil则使用自定义的解归档方法替代 NSKeyedUnarchiver. 使用此block以支持未遵循`NSCoding` 协议的对象\n 默认值为nil\n */\n@property (nullable, copy) id (^customUnarchiveBlock)(NSData *data);\n\n/**\n 当需要写文件时, block 会生成文件名和一个key，如果block是nil 则cache使用MD5生成默认的文件名\n 默认值为nil\n */\n@property (nullable, copy) NSString *(^customFileNameBlock)(NSString *key);\n\n\n\n#pragma mark - Limit\n\n/**\n 消息池子cache中存储的最大数量\n 默认的值为 NSUIntegerMax 表示无限制\n 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。\n */\n@property NSUInteger countLimit;\n\n/**\n 消息池子cache中容许的最大开销\n 默认的值为 NSUIntegerMax 表示无限制\n 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。\n */\n@property NSUInteger costLimit;\n\n/**\n 消息池子cache中容许的时间限制\n 默认的值为 DBL_MAX 表示无限制\n 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。\n */\n@property NSTimeInterval ageLimit;\n\n/**\n cache保证的最小磁盘disk空闲\n 默认值为 0, 意味着无限制\n 如果disk空闲容量小于此值，将移除对象释放内存\n */\n@property NSUInteger freeDiskSpaceLimit;\n\n/**\n 自动检测容器限制 默认时间60.0s\n cache消息池子持有Timer,以确保cache是否达到上限 如果达到上限则进行削减\n */\n@property NSTimeInterval autoTrimInterval;\n\n/**\n 设置`YES` 容许错误log\n */\n@property BOOL errorLogsEnabled;\n\n#pragma mark - Initializer\n\n- (instancetype)init UNAVAILABLE_ATTRIBUTE;\n+ (instancetype)new UNAVAILABLE_ATTRIBUTE;\n\n/**\n 根据path实例化磁盘cache对象\n path cache写入消息的全路径 实例化后，不要在此路径读写数据\n 返回 cache 对象, 如果发生错误返回nil\n 如果path已经存在内存中，则会直接返回cache对象 取代创建对象\n */\n- (nullable instancetype)initWithPath:(NSString *)path;\n\n/**\n 推荐的实例化方法\n path cache写入消息的全路径 实例化后，不要在此路径读写数据\n threshold  存入数据尺寸的限制. 如果存入sqlite数据字节数超过此值 则会写入文件,\n 0 意味着所有的消息会存入不同的文件file, NSUIntegerMax 意味着所有的消息会存入 sqlite 推荐值为20480\n 返回 cache 对象, 如果发生错误返回nil\n 如果path已经存在内存中，则会直接返回cache对象 取代创建对象\n */\n- (nullable instancetype)initWithPath:(NSString *)path\n                      inlineThreshold:(NSUInteger)threshold NS_DESIGNATED_INITIALIZER;\n\n\n#pragma mark - Access Methods\n\n/**\n 返回一个boolean 表示给定的key是否存在disk的cache中 此方法会堵塞直到返回\n key 标识消息对象的key 如果为nil 则返回NO\n 返回key是否存在cache中\n */\n- (BOOL)containsObjectForKey:(NSString *)key;\n\n/**\n 返回一个boolean 表示给定的key是否存在disk的cache中 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n key   标识消息对象的key 如果为nil 则返回NO\n block 在后台线程执行完成后的回调block\n */\n- (void)containsObjectForKey:(NSString *)key withBlock:(void(^)(NSString *key, BOOL contains))block;\n\n/**\n 返回指定key对应的消息 此方法会堵塞直到返回\n key 标识消息对象的key 如果为nil 则返回nil\n 返回key对应的, 如果未找到，则返回nil\n */\n- (nullable id<NSCoding>)objectForKey:(NSString *)key;\n\n/**\n 返回指定key对应的消息  此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n key 标识消息对象的key 如果为nil 则返回nil\n block 在后台线程执行完成后的回调block\n */\n- (void)objectForKey:(NSString *)key withBlock:(void(^)(NSString *key, id<NSCoding> _Nullable object))block;\n\n/**\n 将消息和对应的key值存入cache中 此方法会堵塞直到写入数据完成\n object 存入cache中的消息对象. 如果是nil则会调用`removeObjectForKey:`.\n key    和消息对象关联的key. 如果为nil则不会操作\n */\n- (void)setObject:(nullable id<NSCoding>)object forKey:(NSString *)key;\n\n/**\n 将消息和对应的key值存入cache中 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n object 存入cache中的消息对象. 如果是nil则会调用`removeObjectForKey:`.\n key    和消息对象关联的key. 如果为nil则不会操作\n block  在后台执行完后的回调block\n */\n- (void)setObject:(nullable id<NSCoding>)object forKey:(NSString *)key withBlock:(void(^)(void))block;\n\n/**\n 删除cache中指定key对应的消息 此方法会堵塞直到文件删除完成\n key 标识删除对象的key 如果为nil则不会操作\n */\n- (void)removeObjectForKey:(NSString *)key;\n\n/**\n 删除cache中指定key对应的消息 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n key 标识删除对象的key 如果为nil则不会操作\n block  在后台执行完后的回调block\n */\n- (void)removeObjectForKey:(NSString *)key withBlock:(void(^)(NSString *key))block;\n\n/**\n 删除cache中所有的对象 此方法会堵塞直到cache清除完成\n */\n- (void)removeAllObjects;\n\n/**\n 删除cache中所有的对象 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n block  在后台执行完后的回调block\n */\n- (void)removeAllObjectsWithBlock:(void(^)(void))block;\n\n/**\n 删除cache中所有的对象 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n 不要在block中对该对象发送消息\n progress 删除过程中执行, nil的话忽略\n end      删除完成后执行, nil的话忽略\n */\n- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress\n                                 endBlock:(nullable void(^)(BOOL error))end;\n\n\n/**\n 返回cache中的消息总数量 此方法会堵塞直到读取完成\n 返回消息总数\n */\n- (NSInteger)totalCount;\n\n/**\n 获取cache中的消息总数量 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n block  在后台执行完后的回调block\n */\n- (void)totalCountWithBlock:(void(^)(NSInteger totalCount))block;\n\n/**\n 返回cache中的消息总开销（字节） 此方法会堵塞直到读取完成\n 返回消息总开销（字节）\n */\n- (NSInteger)totalCost;\n\n/**\n 返回cache中的消息总开销（字节）此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n block  在后台执行完后的回调block\n */\n- (void)totalCostWithBlock:(void(^)(NSInteger totalCost))block;\n\n\n#pragma mark - Trim\n\n/**\n 一旦 `totalCount` 高于总数限制，则删除消息 将LRU对象放入缓存区 此方法会堵塞直到完成\n count  清除消息后容许的消息总数量\n */\n- (void)trimToCount:(NSUInteger)count;\n\n/**\n 一旦 `totalCount` 高于总数限制，则删除消息 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n count  清除消息后容许的消息总数量\n block 完成后的回调\n */\n- (void)trimToCount:(NSUInteger)count withBlock:(void(^)(void))block;\n\n/**\n 一旦 `totalCount` 高于总开销限制，则删除消息 将LRU对象放入缓存区 此方法会堵塞直到完成\n count  清除消息后容许的消息总开销\n */\n- (void)trimToCost:(NSUInteger)cost;\n\n/**\n 一旦 `totalCount` 高于总开销限制，则删除消息 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n count  清除消息后容许的消息总开销\n block 完成后的回调\n */\n- (void)trimToCost:(NSUInteger)cost withBlock:(void(^)(void))block;\n\n/**\n 按照时间限制削减 （LRU对象进入缓冲区）此方法会堵塞\n age  最大的时间 seconds.\n */\n- (void)trimToAge:(NSTimeInterval)age;\n\n/**\n 一旦 按照时间限制削减 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n age  最大的时间 seconds.\n block 完成后的回调\n */\n- (void)trimToAge:(NSTimeInterval)age withBlock:(void(^)(void))block;\n\n\n#pragma mark - Extended Data\n\n/**\n 获取消息的拓展数据\n 详见'setExtendedData:toObject:'\n object 消息对象\n 拓展数据\n */\n+ (nullable NSData *)getExtendedDataFromObject:(id)object;\n\n/**\n 设置消息的拓展数据\n 当保存消息到cache之前可以设置消息的拓展数据 拓展数据会同样存入cache中 你可以使用\"getExtendedDataFromObject:\"获取拓展数据\n extendedData 拓展数据 (如果是nil 则删除数据)\n object       对应的消息\n */\n+ (void)setExtendedData:(nullable NSData *)extendedData toObject:(id)object;\n\n@end\n```\n\n👆是 YYDiskCache 的接口和属性，我都加上了注释。\n\nYYDiskCache 是分成 sqlite 和 file 存储的，作者设计的时候是根据文件大小来划分存储方式：\n\n* sqlite: 对于小数据（例如 NSNumber）的存取效率明显高于 file。\n* file: 对于较大数据（例如高质量图片）的存取效率优于 sqlite。\n\nYYDiskCache 使用两个相互配合的方式提高存储性能。\n\n### _YYDiskCacheGetGlobal 和 _YYDiskCacheSetGlobal\n\n```objc\n- (instancetype)initWithPath:(NSString *)path\n             inlineThreshold:(NSUInteger)threshold {\n    self = [super init];\n    if (!self) return nil;\n    \n    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);\n    ``````\n}\n```\n\n根据公开初始化方法初始化 YYDiskCache 时，发现内部是调用静态方法去创建实例：\n\n```objc\n/**\n Map表保存cache实例，管理所有根据 path 创建的 YYDiskCache 实例\n */\nstatic NSMapTable *_globalInstances;\n/**\n 线程信号\n */\nstatic dispatch_semaphore_t _globalInstancesLock;\n\n/**\n 静态变量实例化\n */\nstatic void _YYDiskCacheInitGlobal() {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        // 初始化信号量\n        _globalInstancesLock = dispatch_semaphore_create(1);\n        // 创建 NSMapTable，Key 强引用，Value 弱引用\n        _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];\n    });\n}\n\n/**\n 获取 NSMapTable 中的 YYDiskCache 实例\n */\nstatic YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) {\n    if (path.length == 0) return nil;\n    _YYDiskCacheInitGlobal();\n    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);\n    // 通过 NSMapTable 获取 YYDiskCache\n    id cache = [_globalInstances objectForKey:path];\n    dispatch_semaphore_signal(_globalInstancesLock);\n    return cache;\n}\n\n/**\n 设置 NSMapTable 中的 YYDiskCache 实例，key 值为 cache 路径\n */\nstatic void _YYDiskCacheSetGlobal(YYDiskCache *cache) {\n    if (cache.path.length == 0) return;\n    _YYDiskCacheInitGlobal();\n    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);\n    // 通过 NSMapTable 设置 YYDiskCache\n    [_globalInstances setObject:cache forKey:cache.path];\n    dispatch_semaphore_signal(_globalInstancesLock);\n}\n```\n\n👆代码里面创建 YYDiskCache 的时候使用了 **NSMapTable** 来保存实例对象，并且创建的过程都有加上**信号锁**。\n\n它是 iOS 6 才引入的数据结构集合，用法类似 NSDictionary，但是**它可以对 Value 弱引用**。关于 NSMapTable 更多的语义和使用参考[《iOS中的NSHashTable和NSMapTable》](https://www.jianshu.com/p/dcd222900fa9) 和 [《NSMapTable 官方文档》](https://developer.apple.com/documentation/foundation/nsmaptable?language=objc)。\n\n每当一个 YYDiskCache 被初始化时，其实会先到 NSMapTable 中获取对应 path 的 YYDiskCache 实例，如果获取不到才会去真正的初始化一个 YYDiskCache 实例，并且将其引用在 NSMapTable 中，这样做提升不少性能。\n\n\n> Note：dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。\n\n\n### YYKVStorageItem 和 YYKVStorage\n\n由于 YYDiskCache 有时候是操作 sqlite ，有时候是操作 file，所以使用 YYKVStorage 来统一管理缓存对象（sqlite/file），YYKVStorage 其实就是对应着 _YYLinkedMap，YYKVStorageItem 对应 _YYLinkedMapNode。\n\n```objc\n/**\n YYKVStorageItem 用来存储键值对数据及拓展数据，通常不应该直接使用它\n */\n@interface YYKVStorageItem : NSObject\n\n/**\n 消息key值\n */\n@property (nonatomic, strong) NSString *key;                ///< key\n\n/**\n 消息data数据\n */\n@property (nonatomic, strong) NSData *value;                ///< value\n\n/**\n 消息文件名\n */\n@property (nullable, nonatomic, strong) NSString *filename; ///< filename (nil if inline)\n\n/**\n 消息大小（字节）\n */\n@property (nonatomic) int size;                             ///< value's size in bytes\n\n/**\n 消息修改时间\n */\n@property (nonatomic) int modTime;                          ///< modification unix timestamp\n\n/**\n 消息导入时间\n */\n@property (nonatomic) int accessTime;                       ///< last access unix timestamp\n\n/**\n 拓展数据\n */\n@property (nullable, nonatomic, strong) NSData *extendedData; ///< extended data (nil if no extended data)\n@end\n\n/**\n 消息存储类型，表示存储“YYKVStorageItem.value”的位置。\n \n 一般而言,数据存入sqlite比写文件更快，但读取数据的性能依赖数据大小 以iPhone 6 64G为例\n 数据超过20KB，则从文件读取数据比sqlite读取更快\n 存储较小的数据使用 YYKVStorageTypeSQLite 获得更好的性能\n 如果存储较大的数据 如图片数据, 使用 YYKVStorageTypeFile 获取更好的性能\n 使用 LSMessageDiskStorageTypeMixed 将针对每一个item采用不同的存储方式\n 详见 http://www.sqlite.org/intern-v-extern-blob.html\n \n */\ntypedef NS_ENUM(NSUInteger, YYKVStorageType) {\n    \n    /// The `value` is stored as a file in file system.\n    /// 消息存入文件\n    YYKVStorageTypeFile = 0,\n    \n    /// The `value` is stored in sqlite with blob type.\n    /// 消息存入sqlite，采用blob的类型\n    YYKVStorageTypeSQLite = 1,\n    \n    /// The `value` is stored in file system or sqlite based on your choice.\n    /// 根据选择选取存入方式\n    YYKVStorageTypeMixed = 2,\n};\n\n\n\n/** \n 消息写入file/sqlite的管理类\n @discussion 键值对的方式将消息存入文件和sqlite 使用`initWithPath:type:`进行初始化\n 初始化后 不要再对生成的path进行读写操作 使用最新的sqlite版本获取2-4倍的速度提升\n 产生的实例并不是线程安全的，应该在同一时间在同一的线程使用，数据较大时，应该对数据进行拆分成多个片段进行存储\n */\n@interface YYKVStorage : NSObject\n\n#pragma mark - Attribute\n\n/**\n 消息存入的路径\n */\n@property (nonatomic, readonly) NSString *path;        ///< The path of this storage.\n\n/**\n 消息存储类型\n */\n@property (nonatomic, readonly) YYKVStorageType type;  ///< The type of this storage.\n\n/**\n 是否打印log\n */\n@property (nonatomic) BOOL errorLogsEnabled;           ///< Set `YES` to enable error logs for debug.\n\n#pragma mark - 初始化\n- (instancetype)init UNAVAILABLE_ATTRIBUTE;\n+ (instancetype)new UNAVAILABLE_ATTRIBUTE;\n\n/**\n 推荐的实例化方法\n path  写数据的路径. 如果路径存在，则会在此路径读写数据 否则建立一个新路径\n type  存储类型  一旦设置后不要修改\n 返回一个存储管理实例, 发生错误返回nil\n 多个实例操作同一个路径 会导致错误\n */\n- (nullable instancetype)initWithPath:(NSString *)path type:(YYKVStorageType)type NS_DESIGNATED_INITIALIZER;\n\n\n#pragma mark - 保存消息\n\n/**\n 保存item key值存在时更新item\n @discussion 此方法会将 item.key, item.value, item.filename 和\n item.extendedData 写入文件或sqlite, 其他属性会忽略. item.key\n 和 item.value 不应该为空 (nil || length == 0).\n item  消息item\n 返回是否成功\n */\n- (BOOL)saveItem:(YYKVStorageItem *)item;\n\n/**\n 保存item key值存在时更新item\n 此方法会保存键值对到 sqlite. 如果存储类型为 YYKVStorageTypeFile , 此方法会失败\n key   key值不能为空\n value value不能为空\n 返回是否成功\n */\n- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value;\n\n/**\n 保存item key值存在时更新item\n 如果写入类型为LSMessageDiskStorageTypeFile,filename 不能为空\n 如果写入类型为LSMessageDiskStorageTypeSQLite, filename 会被忽略\n 如果写入类型为LSMessageDiskStorageTypeMixed, 如果filename不为空 则value会被存入文件 否则存入sqlite\n key           key值不能为空\n value         value不能为空\n filename      文件名\n extendedData  item的拓展数据 如果是nil则忽略\n Whether succeed.\n */\n- (BOOL)saveItemWithKey:(NSString *)key\n                  value:(NSData *)value\n               filename:(nullable NSString *)filename\n           extendedData:(nullable NSData *)extendedData;\n\n#pragma mark - 删除消息\n\n/** \n 根据key值删除item\n keys 特定的key值\n 返回是否删除成功\n */\n- (BOOL)removeItemForKey:(NSString *)key;\n\n/**\n 根据keys数组删除items\n keys keys数组\n 返回是否删除成功\n */\n- (BOOL)removeItemForKeys:(NSArray<NSString *> *)keys;\n\n/**\n 根据消息value的开销限制删除items\n size 消息value的最大限制\n 返回是否删除成功\n */\n- (BOOL)removeItemsLargerThanSize:(int)size;\n\n/**\n 删除比指定时间更早存入的消息\n time  指定的时间\n 返回是否删除成功\n */\n- (BOOL)removeItemsEarlierThanTime:(int)time;\n\n/**\n 根据消息开销限制删除items (LRU对象优先删除)\n maxCount 最大的消息开销\n 返回是否删除成功\n */\n- (BOOL)removeItemsToFitSize:(int)maxSize;\n\n/**\n 根据消息数量限制删除items (LRU对象优先删除)\n maxCount 最大的消息数量\n 返回是否删除成功\n */\n- (BOOL)removeItemsToFitCount:(int)maxCount;\n\n/**\n 在后台队列中，删除所有的item\n @discussion 此方法会删除 files 和 sqlite database 进入回收站 并在后台清除回收站数据\n 比`removeAllItemsWithProgressBlock:endBlock:`方法更快\n @return 返回是否删除成功\n */\n- (BOOL)removeAllItems;\n\n/**\n 删除所有的item\n @warning 在block中不要对该实例发送消息\n progress 删除时执行的block，nil则不执行\n end      删除结束执行的block，nil则不执行\n */\n- (void)removeAllItemsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress\n                               endBlock:(nullable void(^)(BOOL error))end;\n\n\n#pragma mark - 获取消息\n\n/**\n 根据key获取item\n key  特定的key值\n 返回item, 发送错误返回nil\n */\n- (nullable YYKVStorageItem *)getItemForKey:(NSString *)key;\n\n/**\n 根据key获取item的信息（value会被忽略）\n key  特定的key值\n 返回item的信息, 发送错误返回nil\n */\n- (nullable YYKVStorageItem *)getItemInfoForKey:(NSString *)key;\n\n/**\n 根据key获取item的value\n key  特定的key值\n 返回item的value, 发送错误返回nil\n */\n- (nullable NSData *)getItemValueForKey:(NSString *)key;\n\n/**\n 根据key的数组获取item的信息\n keys  key值的数组\n 包含`YYKVStorageItem`的数组 发生错误返回nil\n */\n- (nullable NSArray<YYKVStorageItem *> *)getItemForKeys:(NSArray<NSString *> *)keys;\n\n/**\n 根据key的数组获取item的信息（value会被忽略）\n keys  key值的数组\n 包含`LSMessageDiskStorageItem`的数组 发生错误返回nil\n */\n- (nullable NSArray<YYKVStorageItem *> *)getItemInfoForKeys:(NSArray<NSString *> *)keys;\n\n/**\n 根据一个key值数组获取item和key的字典\n keys  key值的数组\n 返回一个字典 key->item对应 发生错误返回nil\n */\n- (nullable NSDictionary<NSString *, NSData *> *)getItemValueForKeys:(NSArray<NSString *> *)keys;\n\n#pragma mark - 获取存储属性\n\n/**\n 根据key值查找item是否存在\n key  特定的key\n 返回item是否存在\n */\n- (BOOL)itemExistsForKey:(NSString *)key;\n\n/**\n 获取item的总数\n 返回总数，如果发生错误返回-1\n */\n- (int)getItemsCount;\n\n/**\n 获取items的总大小（字节）\n 返回总大小，如果发生错误返回-1\n */\n- (int)getItemsSize;\n\n@end\n```\n\n当 YYDiskCache 存储对象的时候，会判断存储数据库的文件大小最大阈值，超过了会生成文件名，写入文件，然后将文件名存储到 sqlite 中。\n\n```objc\n/// YYDiskCache.m\n\n- (void)setObject:(id<NSCoding>)object forKey:(NSString *)key {\n    if (!key) return;\n    if (!object) {\n        [self removeObjectForKey:key];\n        return;\n    }\n    \n    NSData *extendedData = [YYDiskCache getExtendedDataFromObject:object];\n    NSData *value = nil;\n    if (_customArchiveBlock) {\n        value = _customArchiveBlock(object);\n    } else {\n        @try {\n            value = [NSKeyedArchiver archivedDataWithRootObject:object];\n        }\n        @catch (NSException *exception) {\n            // nothing to do...\n        }\n    }\n    if (!value) return;\n    NSString *filename = nil;\n    if (_kv.type != YYKVStorageTypeSQLite) {\n        // 如果超过数据库写入大小限制，生成文件名\n        if (value.length > _inlineThreshold) {\n            filename = [self _filenameForKey:key];\n        }\n    }\n    \n    Lock();\n    [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData];\n    Unlock();\n}\n\n/// YYKVStorage.m\n/**\n 保存item key值存在时更新item\n */\n- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData {\n    // 没有 Key，也没有 Value 直接返回 NO\n    if (key.length == 0 || value.length == 0) return NO;\n    // 存文件，但是没有文件名，也直接返回 NO\n    if (_type == YYKVStorageTypeFile && filename.length == 0) {\n        return NO;\n    }\n    \n    if (filename.length) {\n        // 写文件失败，返回 NO\n        if (![self _fileWriteWithName:filename data:value]) {\n            return NO;\n        }\n        // 将文件名写入数据库，之后方便根据 Key 去查找文件\n        if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) {\n            // 如果写入数据库失败，把之前写入的文件删除\n            [self _fileDeleteWithName:filename];\n            return NO;\n        }\n        return YES;\n    } else {\n        if (_type != YYKVStorageTypeSQLite) {\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                [self _fileDeleteWithName:filename];\n            }\n        }\n        return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData];\n    }\n}\n\n```\n\n### YYKVStorage 性能优化细节\n\n\n```objc\n\nCFMutableDictionaryRef _dbStmtCache;\n\n/**\n db设置sqlite3_stmt\n */\n- (sqlite3_stmt *)_dbPrepareStmt:(NSString *)sql {\n    if (![self _dbCheck] || sql.length == 0 || !_dbStmtCache) return NULL;\n    // 先尝试从 _dbStmtCache 根据入参 sql 取出已缓存 sqlite3_stmt\n    sqlite3_stmt *stmt = (sqlite3_stmt *)CFDictionaryGetValue(_dbStmtCache, (__bridge const void *)(sql));\n    if (!stmt) {\n        // 如果没有缓存再从新生成一个 sqlite3_stmt\n        int result = sqlite3_prepare_v2(_db, sql.UTF8String, -1, &stmt, NULL);\n        // 生成结果异常则根据错误日志开启标识打印日志\n        if (result != SQLITE_OK) {\n            if (_errorLogsEnabled) NSLog(@\"%s line:%d sqlite stmt prepare error (%d): %s\", __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));\n            return NULL;\n        }\n        // 生成成功则放入 _dbStmtCache 缓存\n        CFDictionarySetValue(_dbStmtCache, (__bridge const void *)(sql), stmt);\n    } else {\n        sqlite3_reset(stmt);\n    }\n    return stmt;\n}\n```\n\n每次操作 sqlite 的时候，都有调用 _dbPrepareStmt 方法获取 sqlite3_stmt 缓存，sqlite3_stmt 保存在 _dbStmtCache 字典中，每次都先从字典里面获取缓存，这样不需要重复生成 sqlite3_stmt。\n\n> sqlite3_stmt: 该对象的实例表示已经编译成二进制形式并准备执行的单个 SQL 语句。\n\n\n## 总结\n\nYYCache 的设计相当清晰，功能相当强大，具备了优秀缓存的能力：\n\n* 内存缓存和磁盘缓存\n* 线程安全\n* 缓存控制\n* 缓存替换策略\n* 性能\n\n### 内存缓存和磁盘缓存\n\n内存缓存 YYMemoryCache 与磁盘缓存 YYDiskCache 相互配合组成的，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。这样的设计支持用户在缓存不同对象时都能够有很好的体验。\n\n在 YYCache 中使用接口访问缓存对象时，会先去尝试从内存缓存 YYMemoryCache 中访问，如果访问不到（没有使用该 key 缓存过对象或者该对象已经从容量有限的 YYMemoryCache 中淘汰掉）才会去从 YYDiskCache 访问，如果访问到（表示之前确实使用该 key 缓存过对象，该对象已经从容量有限的 YYMemoryCache 中淘汰掉成立）会先在 YYMemoryCache 中更新一次该缓存对象的访问信息之后才返回给接口。\n\n### 线程安全\n\nYYMemoryCache 使用了 pthread_mutex 线程锁来确保线程安全，而 YYDiskCache 则选择了更适合它的 dispatch_semaphore\n\n### 缓存控制\n\n提供了 cost、count、age 三个维度去控制缓存，满足绝大多数的需求。\n\n### 缓存替换策略\n\n使用了 LRU(least-recently-used) 策略去提高缓存效率。\n\n### 性能\n\n从上面的分析就可以看出来了：\n\n* 异步释放缓存对象\n* 锁的选择\n* 使用 NSMapTable 单例管理的 YYDiskCache\n* YYKVStorage 中的 _dbStmtCache\n* 使用 CoreFoundation 来换取手动释放内存提高效率\n\n[YYCache](https://github.com/piglikeYoung/YYCache) 这个是我 fork 的库，加了一些代码注释，可以参考下。\n\n\n","source":"_posts/2018-02-24-YYCache-analysis.md","raw":"---\ntitle: YYCache 源码分析\ndate: 2018-02-24 11:50:51\ntags: YYCache\ncategory: Source Code Analyze\n---\n\n## 前言\n\niOS 开发中总会用到各种缓存，本文介绍的是 **YYCache** 是一个线程安全的高性能键值缓存（该项目是 YYKit 组件之一）。YYKit 作者是 @ibireme 。\n\n[YYCache](https://github.com/ibireme/YYCache) 的代码逻辑清晰，注释详尽，加上自身不算太大的代码量使得其阅读非常简单，更加厉害的是它的性能还非常高。\n\n详情请看：[《YYCache 设计思路与技术细节》](https://blog.ibireme.com/2015/10/26/yycache/)\n\n我把 YYCache 从头到尾看了一遍，最大的感触就是代码风格干净整洁，代码思路清晰明了，注释详细。\n\n我们先来简单看一下 YYCache 的代码结构，YYCache 是由 YYMemoryCache 与 YYDiskCache 两部分组成的，其中 YYMemoryCache 作为高速内存缓存，而 YYDiskCache 则作为低速磁盘缓存。\n\n\n```\nYYCache\n \tYYMemoryCache\n \t\t_YYLinkedMap\n\t\t_YYLinkedMapNode\n\tYYDiskCache\n\t\tYYKVStorage\n  \t\tYYKVStorageItem\n```\n\n👆是 YYCache 的主要结构，通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但相对低速的持久化存储。\n\n## YYCache\n\n\n```objc\n@interface YYCache : NSObject\n\n@property (copy, readonly) NSString *name;\n@property (strong, readonly) YYMemoryCache *memoryCache;\n@property (strong, readonly) YYDiskCache *diskCache;\n\n- (BOOL)containsObjectForKey:(NSString *)key;\n- (nullable id<NSCoding>)objectForKey:(NSString *)key;\n- (void)setObject:(nullable id<NSCoding>)object forKey:(NSString *)key;\n- (void)removeObjectForKey:(NSString *)key;\n\n@end\n\n```\n\n我将 YYCache 里的代码精简了一下，总的来说就这些增删改查的方法， 里面有 YYMemoryCache 与 YYDiskCache，并且对外提供了一些接口。这些接口基本都是基于 Key 和 Value 设计的，和字典的操作类似。\n\n## YYMemoryCache \n\n```objc\n@interface YYMemoryCache : NSObject\n\n#pragma mark - Attribute\n/**\n    cache 的名称，默认为nil\n */\n@property (nullable, copy) NSString *name;\n\n/**\n    memory 中的消息总数\n */\n@property (readonly) NSUInteger totalCount;\n\n/**\n    memory 中的消息总开销\n */\n@property (readonly) NSUInteger totalCost;\n\n\n#pragma mark - Limit\n\n/**\n 消息池子 cache 中存储的最大数量\n 默认的值为 NSUIntegerMax 表示无限制\n 如果超过此限制，则稍后在后台线程将清除一些对象\n */\n@property NSUInteger countLimit;\n\n/**\n 消息池子cache中容许的最大开销\n 默认的值为 NSUIntegerMax 表示无限制\n 如果超过此限制，则稍后在后台线程将清除一些对象\n */\n@property NSUInteger costLimit;\n\n/**\n 消息池子cache中容许的时间限制\n 默认的值为 DBL_MAX 表示无限制\n 如果超过此限制，则稍后在后台线程将清除一些对象\n */\n@property NSTimeInterval ageLimit;\n\n/**\n 自动检测容器限制 默认时间 5.0s\n cache 消息池子持有 Timer，以确保 cache 是否达到上限 如果达到上限则进行削减\n */\n@property NSTimeInterval autoTrimInterval;\n\n/**\n 如果是 YES 则收到内存报警时会删除所有的 cache 消息对象\n 默认值是 YES\n */\n@property BOOL shouldRemoveAllObjectsOnMemoryWarning;\n\n/**\n 如果是 YES 则收到app进入后台时会删除所有的cache消息对象\n 默认值是 YES\n */\n@property BOOL shouldRemoveAllObjectsWhenEnteringBackground;\n\n/** \n app 收到报警时执行的 block 默认为 nil\n */\n@property (nullable, copy) void(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);\n\n/** \n app 收到进入后台时执行的 block 默认为 nil\n */\n@property (nullable, copy) void(^didEnterBackgroundBlock)(YYMemoryCache *cache);\n\n/**\n 键值对是否在主线程删除 默认值为NO.\n 仅仅当键值对中包含 UIView、CALayer 等非线程安全对象时，将值设为YES\n */\n@property BOOL releaseOnMainThread;\n\n/**\n 键值对异步的释放 默认值为 YES\n 避免堵塞访问方法 否则将在 removeObjectForKey: 等方法中释放 默认是 YES\n */\n@property BOOL releaseAsynchronously;\n\n\n#pragma mark - Access Methods\n\n/** \n 判断消息池子是否包含指定key的消息\n key 消息对象关联的key. 如果是nil则返回NO\n 是否包含指定key的消息\n */\n- (BOOL)containsObjectForKey:(id)key;\n\n/**\n 获取与key关联的消息对象\n key 关联消息对象的 key,如果是 nil 则返回 nil\n 返回与 key 关联的消息对象, 如果未找到则返回 nil\n */\n- (nullable id)objectForKey:(id)key;\n\n/**\n 根据指定的 key 存储消息对象\n message 需要存储到池子的对象. 如果是nil则调用 `removeMessageForKey`.\n key 存储对象关联的key. 如果是nil则不执行任何操作\n 与NSMutableDictionary相比, cache池子不会拷贝容器中的键值对\n */\n- (void)setObject:(nullable id)object forKey:(id)key;\n\n/**\n 根据指定的key和开销cost存储消息\n object 需要存储到池子的对象. 如果是nil则调用 `removeObjectForKey`.\n key 存储对象关联的key. 如果是nil则不执行任何操作\n cost 关联键值对的开销\n 与NSMutableDictionary相比, cache池子不会拷贝容器中的键值对\n */\n- (void)setObject:(nullable id)object forKey:(id)key withCost:(NSUInteger)cost;\n\n/**\n 根据指定的key删除消息\n key 需要删除的object的key. 如果是nil则不执行任何操作\n */\n- (void)removeObjectForKey:(id)key;\n\n/**\n 删除所有的消息\n */\n- (void)removeAllObjects;\n\n\n#pragma mark - Trim\n\n/**\n 用 LRU 算法删除对象，直到 totalCount <= count\n */\n- (void)trimToCount:(NSUInteger)count;\n\n/**\n 用 LRU 算法删除对象，直到 totalCost <= cost\n */\n- (void)trimToCost:(NSUInteger)cost;\n\n/**\n 用 LRU 算法删除对象，直到所有到期对象全部被删除\n */\n- (void)trimToAge:(NSTimeInterval)age;\n\n@end\n```\n\n上面是 YYMemoryCache.h 的主要属性和接口，加上了注释。\n\n### _YYLinkedMapNode 和 _YYLinkedMap\n\nYYMemoryCache 内部其实是通过 **_YYLinkedMapNode** 和 **_YYLinkedMap** 这两个对象操作缓存的。\n\n\n```objc\n/**\n _YYLinkedMap 中的一个节点。\n 通常情况下我们不应该使用这个类。\n */\n@interface _YYLinkedMapNode : NSObject {\n    @package\n    __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic 前一个消息 && 被字典保留\n    __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic 后一个消息 && 被字典保留\n    id _key;    /// 消息的key\n    id _value;  /// 消息\n    NSUInteger _cost;   /// 消息开销\n    NSTimeInterval _time;   /// 消息时间\n}\n@end\n\n/**\n YYMemoryCache 内的一个链表。\n _YYLinkedMap 不是一个线程安全的类，而且它也不对参数做校验。\n 通常情况下我们不应该使用这个类。\n */\n@interface _YYLinkedMap : NSObject {\n    @package\n    CFMutableDictionaryRef _dic; // do not set object directly 保存消息的字典，外部不要直接设置\n    NSUInteger _totalCost;  // 消息总开销\n    NSUInteger _totalCount; // 消息总量\n    _YYLinkedMapNode *_head; // MRU, do not change it directly MRU最近最常使用, 外部不要直接修改\n    _YYLinkedMapNode *_tail; // LRU, do not change it directly LRU最近最少使用, 外部不要直接修改\n    BOOL _releaseOnMainThread;  // 是否在主线程release\n    BOOL _releaseAsynchronously;    // 是否异步release\n}\n```\n\n可以看出来 _YYLinkedMapNode 是双向链表， _YYLinkedMap 是双向链表的节点。\n\n_YYLinkedMapNode 记录着它的前一个节点 **_prev** 和 后一个节点 **_next**，并且记录着缓存信息的 **_key** 和 **_value**，这样一个节点就保存缓存数据，可以理解为一个节点就是一个缓存对象。\n\n_YYLinkedMap 使用 **CFMutableDictionaryRef _dic** 字典存储 _YYLinkedMapNode。这样即强引用了节点，又能够利用字典的 Hash 快速定位用户要访问的缓存对象，并且当需要是否手动释放字典的时候，能够通过 CFRelease 手动释放。\n\n### 线程安全\n\n```objc\n@implementation YYMemoryCache {\n    pthread_mutex_t _lock; // 线程锁，保证线程安全\n    _YYLinkedMap *_lru;\t// YYMemoryCache 通过操作Map来管理缓存\n    dispatch_queue_t _queue;\t// 串行队列，用于后台 trim（清扫工作）\n}\n```\n\n在 YYMemoryCache 中作者是使用 `pthread_mutex` 来保证线程安全的，但是最开始的版本并不是用 pthread_mutex ，而是使用自旋锁 **OSSpinLock**，可以查看[YYCache 设计思路](https://blog.ibireme.com/2015/10/26/yycache/)得知改动的原因。\n\n### LRU\n\nLRU(least-recently-used) 算法翻译过来是”最近最少使用“，顾名思义这种缓存替换策略是基于用户最近访问过的缓存对象而建立。\n\n- 从代码实现上看缓存替换策略的核心思想在于：LRU 认为用户最新使用（访问）过的缓存对象为高频缓存对象，即用户很可能还会再次使用（访问）该缓存对象；而反之，用户很久之前使用（访问）过的缓存对象（期间一直没有再次访问）为低频缓存对象，即用户很可能不会再去使用（访问）该缓存对象，通常在资源不足时会先去释放低频缓存对象。\n\n### _YYLinkedMapNode 和 _YYLinkedMap 使用 LRU\n\n从双向链表可以知道，链表存在两个节点：\n\n* 头结点：用户最近使用的数据，MRU\n* 尾节点：用户很久之前使用的数据，LRU\n\n\n```objc\n- (id)objectForKey:(id)key {\n    if (!key) return nil;\n    pthread_mutex_lock(&_lock);\n    // 找到节点\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    if (node) {\n    \t\t// 更新节点的时间戳\n        node->_time = CACurrentMediaTime();\n        // 将节点移动到头结点\n        [_lru bringNodeToHead:node];\n    }\n    pthread_mutex_unlock(&_lock);\n    return node ? node->_value : nil;\n}\n```\n\n每次根据 Key 获取某个节点的时候，都会更新节点的时间戳并移动到头结点。\n\n\n```objc\n- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost {\n    if (!key) return;\n    if (!object) {\n        [self removeObjectForKey:key];\n        return;\n    }\n    pthread_mutex_lock(&_lock);\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    NSTimeInterval now = CACurrentMediaTime();\n    // 判断节点是否存在\n    if (node) {\n    \t\t// 存在更新节点，并移动至头节点\n        _lru->_totalCost -= node->_cost;\n        _lru->_totalCost += cost;\n        node->_cost = cost;\n        node->_time = now;\n        node->_value = object;\n        [_lru bringNodeToHead:node];\n    } else {\n        // 不存在，创建一个新的节点，插入头节点\n        node = [_YYLinkedMapNode new];\n        node->_cost = cost;\n        node->_time = now;\n        node->_key = key;\n        node->_value = object;\n        [_lru insertNodeAtHead:node];\n    }\n    if (_lru->_totalCost > _costLimit) {\n        dispatch_async(_queue, ^{\n            [self trimToCost:_costLimit];\n        });\n    }\n    if (_lru->_totalCount > _countLimit) {\n        _YYLinkedMapNode *node = [_lru removeTailNode];\n        if (_lru->_releaseAsynchronously) {\n            dispatch_queue_t queue = _lru->_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n            dispatch_async(queue, ^{\n                [node class]; //hold and release in queue\n            });\n        } else if (_lru->_releaseOnMainThread && !pthread_main_np()) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [node class]; //hold and release in queue\n            });\n        }\n    }\n    pthread_mutex_unlock(&_lock);\n}\n```\n\n当设置新节点时，判断节点是否存在，存在更新节点，并移动至头节点；不存在，创建一个新的节点，插入头节点。\n\n\n```objc\n/**\n 消息池子按照数量限制清扫\n */\n- (void)_trimToCount:(NSUInteger)countLimit {\n    BOOL finish = NO;\n    pthread_mutex_lock(&_lock);\n    if (countLimit == 0) {\n        [_lru removeAll];\n        finish = YES;\n    } else if (_lru->_totalCount <= countLimit) {\n        finish = YES;\n    }\n    pthread_mutex_unlock(&_lock);\n    if (finish) return;\n    \n    NSMutableArray *holder = [NSMutableArray new];\n    while (!finish) {\n        if (pthread_mutex_trylock(&_lock) == 0) {\n            if (_lru->_totalCount > countLimit) {\n            \t  // 当缓存数量超出限制的时候，先从尾节点（LRU）开始清除，释放资源\n                _YYLinkedMapNode *node = [_lru removeTailNode];\n                if (node) [holder addObject:node];\n            } else {\n                finish = YES;\n            }\n            pthread_mutex_unlock(&_lock);\n        } else {\n            // 使用 usleep 以微秒为单位挂起线程，在短时间间隔挂起线程\n            // 对比 sleep 用 usleep 能更好的利用 CPU 时间\n            usleep(10 * 1000); //10 ms\n        }\n    }\n    if (holder.count) {\n        // 判断是否在主线程释放对象\n        dispatch_queue_t queue = _lru->_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n        dispatch_async(queue, ^{\n            [holder count]; // release in queue\n        });\n    }\n}\n```\n\n清除的代码其实不是太难，YYCache 从 count 、cost 和 age 三个维度去做清除工作，具体请去查阅源码。\n\n\n在代码底部判断是否在主线程释放资源，是作者另一篇文章[iOS 保持界面流畅的技巧](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)中提到：\n\n> 对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。\n\n\n```objc\nNSArray *tmp = self.array;\nself.array = nil;\ndispatch_async(queue, ^{\n    [tmp class];\n});\n```\n\n## YYDiskCache\n\n\n```objc\n/**\n YYDiskCache 是一个线程安全的磁盘缓存，用于存储由 SQLite 和文件系统支持的键值对（类似于 NSURLCache 的磁盘缓存）。\n\nYYDiskCache 具有以下功能：\n\n* 它使用 LRU(least-recently-used) 来删除对象。\n* 支持按 cost，count 和 age 进行控制。\n* 它可以被配置为当没有可用的磁盘空间时自动驱逐缓存对象。\n* 它可以自动抉择每个缓存对象的存储类型（sqlite/file）以便提供更好的性能表现。\n\n你可以编译最新版本的 sqlite 并忽略 iOS 系统中的 libsqlite3.dylib 来获得 2x〜4x 的速度提升\n */\n@interface YYDiskCache : NSObject\n\n#pragma mark - Attribute\n/**\n The name of the cache. Default is nil.\n 磁盘cache的名称\n */\n@property (nullable, copy) NSString *name;\n\n/**\n The path of the cache (read-only).\n 磁盘cache的文件路径\n */\n@property (readonly) NSString *path;\n\n/**\n 如果存入的消息超过此值，则消息会存入文件file，否则存入sqlite\n 0 意味着所有的消息会存入不同的文件file, NSUIntegerMax 意味着所有的消息会存入 sqlite.\n 默认的值为 20480 (20KB).\n */\n@property (readonly) NSUInteger inlineThreshold;\n\n/**\n 如果block为nil 则会使用NSKeyedArchiver归档消息 使用此block以支持未遵循`NSCoding` 协议的对象存储\n 默认值为nil\n */\n@property (nullable, copy) NSData *(^customArchiveBlock)(id object);\n\n/**\n block不为nil则使用自定义的解归档方法替代 NSKeyedUnarchiver. 使用此block以支持未遵循`NSCoding` 协议的对象\n 默认值为nil\n */\n@property (nullable, copy) id (^customUnarchiveBlock)(NSData *data);\n\n/**\n 当需要写文件时, block 会生成文件名和一个key，如果block是nil 则cache使用MD5生成默认的文件名\n 默认值为nil\n */\n@property (nullable, copy) NSString *(^customFileNameBlock)(NSString *key);\n\n\n\n#pragma mark - Limit\n\n/**\n 消息池子cache中存储的最大数量\n 默认的值为 NSUIntegerMax 表示无限制\n 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。\n */\n@property NSUInteger countLimit;\n\n/**\n 消息池子cache中容许的最大开销\n 默认的值为 NSUIntegerMax 表示无限制\n 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。\n */\n@property NSUInteger costLimit;\n\n/**\n 消息池子cache中容许的时间限制\n 默认的值为 DBL_MAX 表示无限制\n 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。\n */\n@property NSTimeInterval ageLimit;\n\n/**\n cache保证的最小磁盘disk空闲\n 默认值为 0, 意味着无限制\n 如果disk空闲容量小于此值，将移除对象释放内存\n */\n@property NSUInteger freeDiskSpaceLimit;\n\n/**\n 自动检测容器限制 默认时间60.0s\n cache消息池子持有Timer,以确保cache是否达到上限 如果达到上限则进行削减\n */\n@property NSTimeInterval autoTrimInterval;\n\n/**\n 设置`YES` 容许错误log\n */\n@property BOOL errorLogsEnabled;\n\n#pragma mark - Initializer\n\n- (instancetype)init UNAVAILABLE_ATTRIBUTE;\n+ (instancetype)new UNAVAILABLE_ATTRIBUTE;\n\n/**\n 根据path实例化磁盘cache对象\n path cache写入消息的全路径 实例化后，不要在此路径读写数据\n 返回 cache 对象, 如果发生错误返回nil\n 如果path已经存在内存中，则会直接返回cache对象 取代创建对象\n */\n- (nullable instancetype)initWithPath:(NSString *)path;\n\n/**\n 推荐的实例化方法\n path cache写入消息的全路径 实例化后，不要在此路径读写数据\n threshold  存入数据尺寸的限制. 如果存入sqlite数据字节数超过此值 则会写入文件,\n 0 意味着所有的消息会存入不同的文件file, NSUIntegerMax 意味着所有的消息会存入 sqlite 推荐值为20480\n 返回 cache 对象, 如果发生错误返回nil\n 如果path已经存在内存中，则会直接返回cache对象 取代创建对象\n */\n- (nullable instancetype)initWithPath:(NSString *)path\n                      inlineThreshold:(NSUInteger)threshold NS_DESIGNATED_INITIALIZER;\n\n\n#pragma mark - Access Methods\n\n/**\n 返回一个boolean 表示给定的key是否存在disk的cache中 此方法会堵塞直到返回\n key 标识消息对象的key 如果为nil 则返回NO\n 返回key是否存在cache中\n */\n- (BOOL)containsObjectForKey:(NSString *)key;\n\n/**\n 返回一个boolean 表示给定的key是否存在disk的cache中 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n key   标识消息对象的key 如果为nil 则返回NO\n block 在后台线程执行完成后的回调block\n */\n- (void)containsObjectForKey:(NSString *)key withBlock:(void(^)(NSString *key, BOOL contains))block;\n\n/**\n 返回指定key对应的消息 此方法会堵塞直到返回\n key 标识消息对象的key 如果为nil 则返回nil\n 返回key对应的, 如果未找到，则返回nil\n */\n- (nullable id<NSCoding>)objectForKey:(NSString *)key;\n\n/**\n 返回指定key对应的消息  此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n key 标识消息对象的key 如果为nil 则返回nil\n block 在后台线程执行完成后的回调block\n */\n- (void)objectForKey:(NSString *)key withBlock:(void(^)(NSString *key, id<NSCoding> _Nullable object))block;\n\n/**\n 将消息和对应的key值存入cache中 此方法会堵塞直到写入数据完成\n object 存入cache中的消息对象. 如果是nil则会调用`removeObjectForKey:`.\n key    和消息对象关联的key. 如果为nil则不会操作\n */\n- (void)setObject:(nullable id<NSCoding>)object forKey:(NSString *)key;\n\n/**\n 将消息和对应的key值存入cache中 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n object 存入cache中的消息对象. 如果是nil则会调用`removeObjectForKey:`.\n key    和消息对象关联的key. 如果为nil则不会操作\n block  在后台执行完后的回调block\n */\n- (void)setObject:(nullable id<NSCoding>)object forKey:(NSString *)key withBlock:(void(^)(void))block;\n\n/**\n 删除cache中指定key对应的消息 此方法会堵塞直到文件删除完成\n key 标识删除对象的key 如果为nil则不会操作\n */\n- (void)removeObjectForKey:(NSString *)key;\n\n/**\n 删除cache中指定key对应的消息 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n key 标识删除对象的key 如果为nil则不会操作\n block  在后台执行完后的回调block\n */\n- (void)removeObjectForKey:(NSString *)key withBlock:(void(^)(NSString *key))block;\n\n/**\n 删除cache中所有的对象 此方法会堵塞直到cache清除完成\n */\n- (void)removeAllObjects;\n\n/**\n 删除cache中所有的对象 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n block  在后台执行完后的回调block\n */\n- (void)removeAllObjectsWithBlock:(void(^)(void))block;\n\n/**\n 删除cache中所有的对象 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n 不要在block中对该对象发送消息\n progress 删除过程中执行, nil的话忽略\n end      删除完成后执行, nil的话忽略\n */\n- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress\n                                 endBlock:(nullable void(^)(BOOL error))end;\n\n\n/**\n 返回cache中的消息总数量 此方法会堵塞直到读取完成\n 返回消息总数\n */\n- (NSInteger)totalCount;\n\n/**\n 获取cache中的消息总数量 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n block  在后台执行完后的回调block\n */\n- (void)totalCountWithBlock:(void(^)(NSInteger totalCount))block;\n\n/**\n 返回cache中的消息总开销（字节） 此方法会堵塞直到读取完成\n 返回消息总开销（字节）\n */\n- (NSInteger)totalCost;\n\n/**\n 返回cache中的消息总开销（字节）此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n block  在后台执行完后的回调block\n */\n- (void)totalCostWithBlock:(void(^)(NSInteger totalCost))block;\n\n\n#pragma mark - Trim\n\n/**\n 一旦 `totalCount` 高于总数限制，则删除消息 将LRU对象放入缓存区 此方法会堵塞直到完成\n count  清除消息后容许的消息总数量\n */\n- (void)trimToCount:(NSUInteger)count;\n\n/**\n 一旦 `totalCount` 高于总数限制，则删除消息 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n count  清除消息后容许的消息总数量\n block 完成后的回调\n */\n- (void)trimToCount:(NSUInteger)count withBlock:(void(^)(void))block;\n\n/**\n 一旦 `totalCount` 高于总开销限制，则删除消息 将LRU对象放入缓存区 此方法会堵塞直到完成\n count  清除消息后容许的消息总开销\n */\n- (void)trimToCost:(NSUInteger)cost;\n\n/**\n 一旦 `totalCount` 高于总开销限制，则删除消息 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n count  清除消息后容许的消息总开销\n block 完成后的回调\n */\n- (void)trimToCost:(NSUInteger)cost withBlock:(void(^)(void))block;\n\n/**\n 按照时间限制削减 （LRU对象进入缓冲区）此方法会堵塞\n age  最大的时间 seconds.\n */\n- (void)trimToAge:(NSTimeInterval)age;\n\n/**\n 一旦 按照时间限制削减 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调\n age  最大的时间 seconds.\n block 完成后的回调\n */\n- (void)trimToAge:(NSTimeInterval)age withBlock:(void(^)(void))block;\n\n\n#pragma mark - Extended Data\n\n/**\n 获取消息的拓展数据\n 详见'setExtendedData:toObject:'\n object 消息对象\n 拓展数据\n */\n+ (nullable NSData *)getExtendedDataFromObject:(id)object;\n\n/**\n 设置消息的拓展数据\n 当保存消息到cache之前可以设置消息的拓展数据 拓展数据会同样存入cache中 你可以使用\"getExtendedDataFromObject:\"获取拓展数据\n extendedData 拓展数据 (如果是nil 则删除数据)\n object       对应的消息\n */\n+ (void)setExtendedData:(nullable NSData *)extendedData toObject:(id)object;\n\n@end\n```\n\n👆是 YYDiskCache 的接口和属性，我都加上了注释。\n\nYYDiskCache 是分成 sqlite 和 file 存储的，作者设计的时候是根据文件大小来划分存储方式：\n\n* sqlite: 对于小数据（例如 NSNumber）的存取效率明显高于 file。\n* file: 对于较大数据（例如高质量图片）的存取效率优于 sqlite。\n\nYYDiskCache 使用两个相互配合的方式提高存储性能。\n\n### _YYDiskCacheGetGlobal 和 _YYDiskCacheSetGlobal\n\n```objc\n- (instancetype)initWithPath:(NSString *)path\n             inlineThreshold:(NSUInteger)threshold {\n    self = [super init];\n    if (!self) return nil;\n    \n    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);\n    ``````\n}\n```\n\n根据公开初始化方法初始化 YYDiskCache 时，发现内部是调用静态方法去创建实例：\n\n```objc\n/**\n Map表保存cache实例，管理所有根据 path 创建的 YYDiskCache 实例\n */\nstatic NSMapTable *_globalInstances;\n/**\n 线程信号\n */\nstatic dispatch_semaphore_t _globalInstancesLock;\n\n/**\n 静态变量实例化\n */\nstatic void _YYDiskCacheInitGlobal() {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        // 初始化信号量\n        _globalInstancesLock = dispatch_semaphore_create(1);\n        // 创建 NSMapTable，Key 强引用，Value 弱引用\n        _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];\n    });\n}\n\n/**\n 获取 NSMapTable 中的 YYDiskCache 实例\n */\nstatic YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) {\n    if (path.length == 0) return nil;\n    _YYDiskCacheInitGlobal();\n    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);\n    // 通过 NSMapTable 获取 YYDiskCache\n    id cache = [_globalInstances objectForKey:path];\n    dispatch_semaphore_signal(_globalInstancesLock);\n    return cache;\n}\n\n/**\n 设置 NSMapTable 中的 YYDiskCache 实例，key 值为 cache 路径\n */\nstatic void _YYDiskCacheSetGlobal(YYDiskCache *cache) {\n    if (cache.path.length == 0) return;\n    _YYDiskCacheInitGlobal();\n    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);\n    // 通过 NSMapTable 设置 YYDiskCache\n    [_globalInstances setObject:cache forKey:cache.path];\n    dispatch_semaphore_signal(_globalInstancesLock);\n}\n```\n\n👆代码里面创建 YYDiskCache 的时候使用了 **NSMapTable** 来保存实例对象，并且创建的过程都有加上**信号锁**。\n\n它是 iOS 6 才引入的数据结构集合，用法类似 NSDictionary，但是**它可以对 Value 弱引用**。关于 NSMapTable 更多的语义和使用参考[《iOS中的NSHashTable和NSMapTable》](https://www.jianshu.com/p/dcd222900fa9) 和 [《NSMapTable 官方文档》](https://developer.apple.com/documentation/foundation/nsmaptable?language=objc)。\n\n每当一个 YYDiskCache 被初始化时，其实会先到 NSMapTable 中获取对应 path 的 YYDiskCache 实例，如果获取不到才会去真正的初始化一个 YYDiskCache 实例，并且将其引用在 NSMapTable 中，这样做提升不少性能。\n\n\n> Note：dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。\n\n\n### YYKVStorageItem 和 YYKVStorage\n\n由于 YYDiskCache 有时候是操作 sqlite ，有时候是操作 file，所以使用 YYKVStorage 来统一管理缓存对象（sqlite/file），YYKVStorage 其实就是对应着 _YYLinkedMap，YYKVStorageItem 对应 _YYLinkedMapNode。\n\n```objc\n/**\n YYKVStorageItem 用来存储键值对数据及拓展数据，通常不应该直接使用它\n */\n@interface YYKVStorageItem : NSObject\n\n/**\n 消息key值\n */\n@property (nonatomic, strong) NSString *key;                ///< key\n\n/**\n 消息data数据\n */\n@property (nonatomic, strong) NSData *value;                ///< value\n\n/**\n 消息文件名\n */\n@property (nullable, nonatomic, strong) NSString *filename; ///< filename (nil if inline)\n\n/**\n 消息大小（字节）\n */\n@property (nonatomic) int size;                             ///< value's size in bytes\n\n/**\n 消息修改时间\n */\n@property (nonatomic) int modTime;                          ///< modification unix timestamp\n\n/**\n 消息导入时间\n */\n@property (nonatomic) int accessTime;                       ///< last access unix timestamp\n\n/**\n 拓展数据\n */\n@property (nullable, nonatomic, strong) NSData *extendedData; ///< extended data (nil if no extended data)\n@end\n\n/**\n 消息存储类型，表示存储“YYKVStorageItem.value”的位置。\n \n 一般而言,数据存入sqlite比写文件更快，但读取数据的性能依赖数据大小 以iPhone 6 64G为例\n 数据超过20KB，则从文件读取数据比sqlite读取更快\n 存储较小的数据使用 YYKVStorageTypeSQLite 获得更好的性能\n 如果存储较大的数据 如图片数据, 使用 YYKVStorageTypeFile 获取更好的性能\n 使用 LSMessageDiskStorageTypeMixed 将针对每一个item采用不同的存储方式\n 详见 http://www.sqlite.org/intern-v-extern-blob.html\n \n */\ntypedef NS_ENUM(NSUInteger, YYKVStorageType) {\n    \n    /// The `value` is stored as a file in file system.\n    /// 消息存入文件\n    YYKVStorageTypeFile = 0,\n    \n    /// The `value` is stored in sqlite with blob type.\n    /// 消息存入sqlite，采用blob的类型\n    YYKVStorageTypeSQLite = 1,\n    \n    /// The `value` is stored in file system or sqlite based on your choice.\n    /// 根据选择选取存入方式\n    YYKVStorageTypeMixed = 2,\n};\n\n\n\n/** \n 消息写入file/sqlite的管理类\n @discussion 键值对的方式将消息存入文件和sqlite 使用`initWithPath:type:`进行初始化\n 初始化后 不要再对生成的path进行读写操作 使用最新的sqlite版本获取2-4倍的速度提升\n 产生的实例并不是线程安全的，应该在同一时间在同一的线程使用，数据较大时，应该对数据进行拆分成多个片段进行存储\n */\n@interface YYKVStorage : NSObject\n\n#pragma mark - Attribute\n\n/**\n 消息存入的路径\n */\n@property (nonatomic, readonly) NSString *path;        ///< The path of this storage.\n\n/**\n 消息存储类型\n */\n@property (nonatomic, readonly) YYKVStorageType type;  ///< The type of this storage.\n\n/**\n 是否打印log\n */\n@property (nonatomic) BOOL errorLogsEnabled;           ///< Set `YES` to enable error logs for debug.\n\n#pragma mark - 初始化\n- (instancetype)init UNAVAILABLE_ATTRIBUTE;\n+ (instancetype)new UNAVAILABLE_ATTRIBUTE;\n\n/**\n 推荐的实例化方法\n path  写数据的路径. 如果路径存在，则会在此路径读写数据 否则建立一个新路径\n type  存储类型  一旦设置后不要修改\n 返回一个存储管理实例, 发生错误返回nil\n 多个实例操作同一个路径 会导致错误\n */\n- (nullable instancetype)initWithPath:(NSString *)path type:(YYKVStorageType)type NS_DESIGNATED_INITIALIZER;\n\n\n#pragma mark - 保存消息\n\n/**\n 保存item key值存在时更新item\n @discussion 此方法会将 item.key, item.value, item.filename 和\n item.extendedData 写入文件或sqlite, 其他属性会忽略. item.key\n 和 item.value 不应该为空 (nil || length == 0).\n item  消息item\n 返回是否成功\n */\n- (BOOL)saveItem:(YYKVStorageItem *)item;\n\n/**\n 保存item key值存在时更新item\n 此方法会保存键值对到 sqlite. 如果存储类型为 YYKVStorageTypeFile , 此方法会失败\n key   key值不能为空\n value value不能为空\n 返回是否成功\n */\n- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value;\n\n/**\n 保存item key值存在时更新item\n 如果写入类型为LSMessageDiskStorageTypeFile,filename 不能为空\n 如果写入类型为LSMessageDiskStorageTypeSQLite, filename 会被忽略\n 如果写入类型为LSMessageDiskStorageTypeMixed, 如果filename不为空 则value会被存入文件 否则存入sqlite\n key           key值不能为空\n value         value不能为空\n filename      文件名\n extendedData  item的拓展数据 如果是nil则忽略\n Whether succeed.\n */\n- (BOOL)saveItemWithKey:(NSString *)key\n                  value:(NSData *)value\n               filename:(nullable NSString *)filename\n           extendedData:(nullable NSData *)extendedData;\n\n#pragma mark - 删除消息\n\n/** \n 根据key值删除item\n keys 特定的key值\n 返回是否删除成功\n */\n- (BOOL)removeItemForKey:(NSString *)key;\n\n/**\n 根据keys数组删除items\n keys keys数组\n 返回是否删除成功\n */\n- (BOOL)removeItemForKeys:(NSArray<NSString *> *)keys;\n\n/**\n 根据消息value的开销限制删除items\n size 消息value的最大限制\n 返回是否删除成功\n */\n- (BOOL)removeItemsLargerThanSize:(int)size;\n\n/**\n 删除比指定时间更早存入的消息\n time  指定的时间\n 返回是否删除成功\n */\n- (BOOL)removeItemsEarlierThanTime:(int)time;\n\n/**\n 根据消息开销限制删除items (LRU对象优先删除)\n maxCount 最大的消息开销\n 返回是否删除成功\n */\n- (BOOL)removeItemsToFitSize:(int)maxSize;\n\n/**\n 根据消息数量限制删除items (LRU对象优先删除)\n maxCount 最大的消息数量\n 返回是否删除成功\n */\n- (BOOL)removeItemsToFitCount:(int)maxCount;\n\n/**\n 在后台队列中，删除所有的item\n @discussion 此方法会删除 files 和 sqlite database 进入回收站 并在后台清除回收站数据\n 比`removeAllItemsWithProgressBlock:endBlock:`方法更快\n @return 返回是否删除成功\n */\n- (BOOL)removeAllItems;\n\n/**\n 删除所有的item\n @warning 在block中不要对该实例发送消息\n progress 删除时执行的block，nil则不执行\n end      删除结束执行的block，nil则不执行\n */\n- (void)removeAllItemsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress\n                               endBlock:(nullable void(^)(BOOL error))end;\n\n\n#pragma mark - 获取消息\n\n/**\n 根据key获取item\n key  特定的key值\n 返回item, 发送错误返回nil\n */\n- (nullable YYKVStorageItem *)getItemForKey:(NSString *)key;\n\n/**\n 根据key获取item的信息（value会被忽略）\n key  特定的key值\n 返回item的信息, 发送错误返回nil\n */\n- (nullable YYKVStorageItem *)getItemInfoForKey:(NSString *)key;\n\n/**\n 根据key获取item的value\n key  特定的key值\n 返回item的value, 发送错误返回nil\n */\n- (nullable NSData *)getItemValueForKey:(NSString *)key;\n\n/**\n 根据key的数组获取item的信息\n keys  key值的数组\n 包含`YYKVStorageItem`的数组 发生错误返回nil\n */\n- (nullable NSArray<YYKVStorageItem *> *)getItemForKeys:(NSArray<NSString *> *)keys;\n\n/**\n 根据key的数组获取item的信息（value会被忽略）\n keys  key值的数组\n 包含`LSMessageDiskStorageItem`的数组 发生错误返回nil\n */\n- (nullable NSArray<YYKVStorageItem *> *)getItemInfoForKeys:(NSArray<NSString *> *)keys;\n\n/**\n 根据一个key值数组获取item和key的字典\n keys  key值的数组\n 返回一个字典 key->item对应 发生错误返回nil\n */\n- (nullable NSDictionary<NSString *, NSData *> *)getItemValueForKeys:(NSArray<NSString *> *)keys;\n\n#pragma mark - 获取存储属性\n\n/**\n 根据key值查找item是否存在\n key  特定的key\n 返回item是否存在\n */\n- (BOOL)itemExistsForKey:(NSString *)key;\n\n/**\n 获取item的总数\n 返回总数，如果发生错误返回-1\n */\n- (int)getItemsCount;\n\n/**\n 获取items的总大小（字节）\n 返回总大小，如果发生错误返回-1\n */\n- (int)getItemsSize;\n\n@end\n```\n\n当 YYDiskCache 存储对象的时候，会判断存储数据库的文件大小最大阈值，超过了会生成文件名，写入文件，然后将文件名存储到 sqlite 中。\n\n```objc\n/// YYDiskCache.m\n\n- (void)setObject:(id<NSCoding>)object forKey:(NSString *)key {\n    if (!key) return;\n    if (!object) {\n        [self removeObjectForKey:key];\n        return;\n    }\n    \n    NSData *extendedData = [YYDiskCache getExtendedDataFromObject:object];\n    NSData *value = nil;\n    if (_customArchiveBlock) {\n        value = _customArchiveBlock(object);\n    } else {\n        @try {\n            value = [NSKeyedArchiver archivedDataWithRootObject:object];\n        }\n        @catch (NSException *exception) {\n            // nothing to do...\n        }\n    }\n    if (!value) return;\n    NSString *filename = nil;\n    if (_kv.type != YYKVStorageTypeSQLite) {\n        // 如果超过数据库写入大小限制，生成文件名\n        if (value.length > _inlineThreshold) {\n            filename = [self _filenameForKey:key];\n        }\n    }\n    \n    Lock();\n    [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData];\n    Unlock();\n}\n\n/// YYKVStorage.m\n/**\n 保存item key值存在时更新item\n */\n- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData {\n    // 没有 Key，也没有 Value 直接返回 NO\n    if (key.length == 0 || value.length == 0) return NO;\n    // 存文件，但是没有文件名，也直接返回 NO\n    if (_type == YYKVStorageTypeFile && filename.length == 0) {\n        return NO;\n    }\n    \n    if (filename.length) {\n        // 写文件失败，返回 NO\n        if (![self _fileWriteWithName:filename data:value]) {\n            return NO;\n        }\n        // 将文件名写入数据库，之后方便根据 Key 去查找文件\n        if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) {\n            // 如果写入数据库失败，把之前写入的文件删除\n            [self _fileDeleteWithName:filename];\n            return NO;\n        }\n        return YES;\n    } else {\n        if (_type != YYKVStorageTypeSQLite) {\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                [self _fileDeleteWithName:filename];\n            }\n        }\n        return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData];\n    }\n}\n\n```\n\n### YYKVStorage 性能优化细节\n\n\n```objc\n\nCFMutableDictionaryRef _dbStmtCache;\n\n/**\n db设置sqlite3_stmt\n */\n- (sqlite3_stmt *)_dbPrepareStmt:(NSString *)sql {\n    if (![self _dbCheck] || sql.length == 0 || !_dbStmtCache) return NULL;\n    // 先尝试从 _dbStmtCache 根据入参 sql 取出已缓存 sqlite3_stmt\n    sqlite3_stmt *stmt = (sqlite3_stmt *)CFDictionaryGetValue(_dbStmtCache, (__bridge const void *)(sql));\n    if (!stmt) {\n        // 如果没有缓存再从新生成一个 sqlite3_stmt\n        int result = sqlite3_prepare_v2(_db, sql.UTF8String, -1, &stmt, NULL);\n        // 生成结果异常则根据错误日志开启标识打印日志\n        if (result != SQLITE_OK) {\n            if (_errorLogsEnabled) NSLog(@\"%s line:%d sqlite stmt prepare error (%d): %s\", __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));\n            return NULL;\n        }\n        // 生成成功则放入 _dbStmtCache 缓存\n        CFDictionarySetValue(_dbStmtCache, (__bridge const void *)(sql), stmt);\n    } else {\n        sqlite3_reset(stmt);\n    }\n    return stmt;\n}\n```\n\n每次操作 sqlite 的时候，都有调用 _dbPrepareStmt 方法获取 sqlite3_stmt 缓存，sqlite3_stmt 保存在 _dbStmtCache 字典中，每次都先从字典里面获取缓存，这样不需要重复生成 sqlite3_stmt。\n\n> sqlite3_stmt: 该对象的实例表示已经编译成二进制形式并准备执行的单个 SQL 语句。\n\n\n## 总结\n\nYYCache 的设计相当清晰，功能相当强大，具备了优秀缓存的能力：\n\n* 内存缓存和磁盘缓存\n* 线程安全\n* 缓存控制\n* 缓存替换策略\n* 性能\n\n### 内存缓存和磁盘缓存\n\n内存缓存 YYMemoryCache 与磁盘缓存 YYDiskCache 相互配合组成的，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。这样的设计支持用户在缓存不同对象时都能够有很好的体验。\n\n在 YYCache 中使用接口访问缓存对象时，会先去尝试从内存缓存 YYMemoryCache 中访问，如果访问不到（没有使用该 key 缓存过对象或者该对象已经从容量有限的 YYMemoryCache 中淘汰掉）才会去从 YYDiskCache 访问，如果访问到（表示之前确实使用该 key 缓存过对象，该对象已经从容量有限的 YYMemoryCache 中淘汰掉成立）会先在 YYMemoryCache 中更新一次该缓存对象的访问信息之后才返回给接口。\n\n### 线程安全\n\nYYMemoryCache 使用了 pthread_mutex 线程锁来确保线程安全，而 YYDiskCache 则选择了更适合它的 dispatch_semaphore\n\n### 缓存控制\n\n提供了 cost、count、age 三个维度去控制缓存，满足绝大多数的需求。\n\n### 缓存替换策略\n\n使用了 LRU(least-recently-used) 策略去提高缓存效率。\n\n### 性能\n\n从上面的分析就可以看出来了：\n\n* 异步释放缓存对象\n* 锁的选择\n* 使用 NSMapTable 单例管理的 YYDiskCache\n* YYKVStorage 中的 _dbStmtCache\n* 使用 CoreFoundation 来换取手动释放内存提高效率\n\n[YYCache](https://github.com/piglikeYoung/YYCache) 这个是我 fork 的库，加了一些代码注释，可以参考下。\n\n\n","slug":"2018-02-24-YYCache-analysis","published":1,"updated":"2018-09-02T03:36:39.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjseuc7rn005q8jpbhaqcfe3b","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>iOS 开发中总会用到各种缓存，本文介绍的是 <strong>YYCache</strong> 是一个线程安全的高性能键值缓存（该项目是 YYKit 组件之一）。YYKit 作者是 @ibireme 。</p>\n<p><a href=\"https://github.com/ibireme/YYCache\" target=\"_blank\" rel=\"noopener\">YYCache</a> 的代码逻辑清晰，注释详尽，加上自身不算太大的代码量使得其阅读非常简单，更加厉害的是它的性能还非常高。</p>\n<p>详情请看：<a href=\"https://blog.ibireme.com/2015/10/26/yycache/\" target=\"_blank\" rel=\"noopener\">《YYCache 设计思路与技术细节》</a></p>\n<p>我把 YYCache 从头到尾看了一遍，最大的感触就是代码风格干净整洁，代码思路清晰明了，注释详细。</p>\n<p>我们先来简单看一下 YYCache 的代码结构，YYCache 是由 YYMemoryCache 与 YYDiskCache 两部分组成的，其中 YYMemoryCache 作为高速内存缓存，而 YYDiskCache 则作为低速磁盘缓存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YYCache</span><br><span class=\"line\"> \tYYMemoryCache</span><br><span class=\"line\"> \t\t_YYLinkedMap</span><br><span class=\"line\">\t\t_YYLinkedMapNode</span><br><span class=\"line\">\tYYDiskCache</span><br><span class=\"line\">\t\tYYKVStorage</span><br><span class=\"line\">  \t\tYYKVStorageItem</span><br></pre></td></tr></table></figure>\n<p>👆是 YYCache 的主要结构，通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但相对低速的持久化存储。</p>\n<h2 id=\"YYCache\"><a href=\"#YYCache\" class=\"headerlink\" title=\"YYCache\"></a>YYCache</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYCache</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) YYMemoryCache *memoryCache;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) YYDiskCache *diskCache;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)containsObjectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)objectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)object forKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>我将 YYCache 里的代码精简了一下，总的来说就这些增删改查的方法， 里面有 YYMemoryCache 与 YYDiskCache，并且对外提供了一些接口。这些接口基本都是基于 Key 和 Value 设计的，和字典的操作类似。</p>\n<h2 id=\"YYMemoryCache\"><a href=\"#YYMemoryCache\" class=\"headerlink\" title=\"YYMemoryCache\"></a>YYMemoryCache</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYMemoryCache</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Attribute</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    cache 的名称，默认为nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    memory 中的消息总数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSUInteger</span> totalCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    memory 中的消息总开销</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSUInteger</span> totalCost;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Limit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子 cache 中存储的最大数量</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 NSUIntegerMax 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 如果超过此限制，则稍后在后台线程将清除一些对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> countLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子cache中容许的最大开销</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 NSUIntegerMax 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 如果超过此限制，则稍后在后台线程将清除一些对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> costLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子cache中容许的时间限制</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 DBL_MAX 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 如果超过此限制，则稍后在后台线程将清除一些对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span> ageLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 自动检测容器限制 默认时间 5.0s</span></span><br><span class=\"line\"><span class=\"comment\"> cache 消息池子持有 Timer，以确保 cache 是否达到上限 如果达到上限则进行削减</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span> autoTrimInterval;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果是 YES 则收到内存报警时会删除所有的 cache 消息对象</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值是 YES</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> shouldRemoveAllObjectsOnMemoryWarning;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果是 YES 则收到app进入后台时会删除所有的cache消息对象</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值是 YES</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> shouldRemoveAllObjectsWhenEnteringBackground;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> app 收到报警时执行的 block 默认为 nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"keyword\">void</span>(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> app 收到进入后台时执行的 block 默认为 nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"keyword\">void</span>(^didEnterBackgroundBlock)(YYMemoryCache *cache);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 键值对是否在主线程删除 默认值为NO.</span></span><br><span class=\"line\"><span class=\"comment\"> 仅仅当键值对中包含 UIView、CALayer 等非线程安全对象时，将值设为YES</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> releaseOnMainThread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 键值对异步的释放 默认值为 YES</span></span><br><span class=\"line\"><span class=\"comment\"> 避免堵塞访问方法 否则将在 removeObjectForKey: 等方法中释放 默认是 YES</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> releaseAsynchronously;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Access Methods</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> 判断消息池子是否包含指定key的消息</span></span><br><span class=\"line\"><span class=\"comment\"> key 消息对象关联的key. 如果是nil则返回NO</span></span><br><span class=\"line\"><span class=\"comment\"> 是否包含指定key的消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)containsObjectForKey:(<span class=\"keyword\">id</span>)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取与key关联的消息对象</span></span><br><span class=\"line\"><span class=\"comment\"> key 关联消息对象的 key,如果是 nil 则返回 nil</span></span><br><span class=\"line\"><span class=\"comment\"> 返回与 key 关联的消息对象, 如果未找到则返回 nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)objectForKey:(<span class=\"keyword\">id</span>)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据指定的 key 存储消息对象</span></span><br><span class=\"line\"><span class=\"comment\"> message 需要存储到池子的对象. 如果是nil则调用 `removeMessageForKey`.</span></span><br><span class=\"line\"><span class=\"comment\"> key 存储对象关联的key. 如果是nil则不执行任何操作</span></span><br><span class=\"line\"><span class=\"comment\"> 与NSMutableDictionary相比, cache池子不会拷贝容器中的键值对</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)object forKey:(<span class=\"keyword\">id</span>)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据指定的key和开销cost存储消息</span></span><br><span class=\"line\"><span class=\"comment\"> object 需要存储到池子的对象. 如果是nil则调用 `removeObjectForKey`.</span></span><br><span class=\"line\"><span class=\"comment\"> key 存储对象关联的key. 如果是nil则不执行任何操作</span></span><br><span class=\"line\"><span class=\"comment\"> cost 关联键值对的开销</span></span><br><span class=\"line\"><span class=\"comment\"> 与NSMutableDictionary相比, cache池子不会拷贝容器中的键值对</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)object forKey:(<span class=\"keyword\">id</span>)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据指定的key删除消息</span></span><br><span class=\"line\"><span class=\"comment\"> key 需要删除的object的key. 如果是nil则不执行任何操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"keyword\">id</span>)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除所有的消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeAllObjects;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Trim</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 用 LRU 算法删除对象，直到 totalCount &lt;= count</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCount:(<span class=\"built_in\">NSUInteger</span>)count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 用 LRU 算法删除对象，直到 totalCost &lt;= cost</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCost:(<span class=\"built_in\">NSUInteger</span>)cost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 用 LRU 算法删除对象，直到所有到期对象全部被删除</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToAge:(<span class=\"built_in\">NSTimeInterval</span>)age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>上面是 YYMemoryCache.h 的主要属性和接口，加上了注释。</p>\n<h3 id=\"YYLinkedMapNode-和-YYLinkedMap\"><a href=\"#YYLinkedMapNode-和-YYLinkedMap\" class=\"headerlink\" title=\"_YYLinkedMapNode 和 _YYLinkedMap\"></a>_YYLinkedMapNode 和 _YYLinkedMap</h3><p>YYMemoryCache 内部其实是通过 <strong>_YYLinkedMapNode</strong> 和 <strong>_YYLinkedMap</strong> 这两个对象操作缓存的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> _YYLinkedMap 中的一个节点。</span></span><br><span class=\"line\"><span class=\"comment\"> 通常情况下我们不应该使用这个类。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">_YYLinkedMapNode</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@package</span></span><br><span class=\"line\">    __<span class=\"keyword\">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class=\"comment\">// retained by dic 前一个消息 &amp;&amp; 被字典保留</span></span><br><span class=\"line\">    __<span class=\"keyword\">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class=\"comment\">// retained by dic 后一个消息 &amp;&amp; 被字典保留</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> _key;    <span class=\"comment\">/// 消息的key</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> _value;  <span class=\"comment\">/// 消息</span></span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> _cost;   <span class=\"comment\">/// 消息开销</span></span><br><span class=\"line\">    <span class=\"built_in\">NSTimeInterval</span> _time;   <span class=\"comment\">/// 消息时间</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> YYMemoryCache 内的一个链表。</span></span><br><span class=\"line\"><span class=\"comment\"> _YYLinkedMap 不是一个线程安全的类，而且它也不对参数做校验。</span></span><br><span class=\"line\"><span class=\"comment\"> 通常情况下我们不应该使用这个类。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">_YYLinkedMap</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@package</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableDictionaryRef</span> _dic; <span class=\"comment\">// do not set object directly 保存消息的字典，外部不要直接设置</span></span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> _totalCost;  <span class=\"comment\">// 消息总开销</span></span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> _totalCount; <span class=\"comment\">// 消息总量</span></span><br><span class=\"line\">    _YYLinkedMapNode *_head; <span class=\"comment\">// MRU, do not change it directly MRU最近最常使用, 外部不要直接修改</span></span><br><span class=\"line\">    _YYLinkedMapNode *_tail; <span class=\"comment\">// LRU, do not change it directly LRU最近最少使用, 外部不要直接修改</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> _releaseOnMainThread;  <span class=\"comment\">// 是否在主线程release</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> _releaseAsynchronously;    <span class=\"comment\">// 是否异步release</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出来 _YYLinkedMapNode 是双向链表， _YYLinkedMap 是双向链表的节点。</p>\n<p>_YYLinkedMapNode 记录着它的前一个节点 <strong>_prev</strong> 和 后一个节点 <strong>_next</strong>，并且记录着缓存信息的 <strong>_key</strong> 和 <strong>_value</strong>，这样一个节点就保存缓存数据，可以理解为一个节点就是一个缓存对象。</p>\n<p>_YYLinkedMap 使用 <strong>CFMutableDictionaryRef _dic</strong> 字典存储 _YYLinkedMapNode。这样即强引用了节点，又能够利用字典的 Hash 快速定位用户要访问的缓存对象，并且当需要是否手动释放字典的时候，能够通过 CFRelease 手动释放。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYMemoryCache</span> </span>&#123;</span><br><span class=\"line\">    pthread_mutex_t _lock; <span class=\"comment\">// 线程锁，保证线程安全</span></span><br><span class=\"line\">    _YYLinkedMap *_lru;\t<span class=\"comment\">// YYMemoryCache 通过操作Map来管理缓存</span></span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> _queue;\t<span class=\"comment\">// 串行队列，用于后台 trim（清扫工作）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 YYMemoryCache 中作者是使用 <code>pthread_mutex</code> 来保证线程安全的，但是最开始的版本并不是用 pthread_mutex ，而是使用自旋锁 <strong>OSSpinLock</strong>，可以查看<a href=\"https://blog.ibireme.com/2015/10/26/yycache/\" target=\"_blank\" rel=\"noopener\">YYCache 设计思路</a>得知改动的原因。</p>\n<h3 id=\"LRU\"><a href=\"#LRU\" class=\"headerlink\" title=\"LRU\"></a>LRU</h3><p>LRU(least-recently-used) 算法翻译过来是”最近最少使用“，顾名思义这种缓存替换策略是基于用户最近访问过的缓存对象而建立。</p>\n<ul>\n<li>从代码实现上看缓存替换策略的核心思想在于：LRU 认为用户最新使用（访问）过的缓存对象为高频缓存对象，即用户很可能还会再次使用（访问）该缓存对象；而反之，用户很久之前使用（访问）过的缓存对象（期间一直没有再次访问）为低频缓存对象，即用户很可能不会再去使用（访问）该缓存对象，通常在资源不足时会先去释放低频缓存对象。</li>\n</ul>\n<h3 id=\"YYLinkedMapNode-和-YYLinkedMap-使用-LRU\"><a href=\"#YYLinkedMapNode-和-YYLinkedMap-使用-LRU\" class=\"headerlink\" title=\"_YYLinkedMapNode 和 _YYLinkedMap 使用 LRU\"></a>_YYLinkedMapNode 和 _YYLinkedMap 使用 LRU</h3><p>从双向链表可以知道，链表存在两个节点：</p>\n<ul>\n<li>头结点：用户最近使用的数据，MRU</li>\n<li>尾节点：用户很久之前使用的数据，LRU</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)objectForKey:(<span class=\"keyword\">id</span>)key &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;_lock);</span><br><span class=\"line\">    <span class=\"comment\">// 找到节点</span></span><br><span class=\"line\">    _YYLinkedMapNode *node = <span class=\"built_in\">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)(key));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">    \t\t<span class=\"comment\">// 更新节点的时间戳</span></span><br><span class=\"line\">        node-&gt;_time = <span class=\"built_in\">CACurrentMediaTime</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 将节点移动到头结点</span></span><br><span class=\"line\">        [_lru bringNodeToHead:node];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;_lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node ? node-&gt;_value : <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次根据 Key 获取某个节点的时候，都会更新节点的时间戳并移动到头结点。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"keyword\">id</span>)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!object) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> removeObjectForKey:key];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;_lock);</span><br><span class=\"line\">    _YYLinkedMapNode *node = <span class=\"built_in\">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)(key));</span><br><span class=\"line\">    <span class=\"built_in\">NSTimeInterval</span> now = <span class=\"built_in\">CACurrentMediaTime</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 判断节点是否存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">    \t\t<span class=\"comment\">// 存在更新节点，并移动至头节点</span></span><br><span class=\"line\">        _lru-&gt;_totalCost -= node-&gt;_cost;</span><br><span class=\"line\">        _lru-&gt;_totalCost += cost;</span><br><span class=\"line\">        node-&gt;_cost = cost;</span><br><span class=\"line\">        node-&gt;_time = now;</span><br><span class=\"line\">        node-&gt;_value = object;</span><br><span class=\"line\">        [_lru bringNodeToHead:node];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不存在，创建一个新的节点，插入头节点</span></span><br><span class=\"line\">        node = [_YYLinkedMapNode new];</span><br><span class=\"line\">        node-&gt;_cost = cost;</span><br><span class=\"line\">        node-&gt;_time = now;</span><br><span class=\"line\">        node-&gt;_key = key;</span><br><span class=\"line\">        node-&gt;_value = object;</span><br><span class=\"line\">        [_lru insertNodeAtHead:node];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_lru-&gt;_totalCost &gt; _costLimit) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">dispatch_async</span>(_queue, ^&#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> trimToCost:_costLimit];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_lru-&gt;_totalCount &gt; _countLimit) &#123;</span><br><span class=\"line\">        _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class=\"line\">            <span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">                [node <span class=\"keyword\">class</span>]; <span class=\"comment\">//hold and release in queue</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                [node <span class=\"keyword\">class</span>]; <span class=\"comment\">//hold and release in queue</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;_lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当设置新节点时，判断节点是否存在，存在更新节点，并移动至头节点；不存在，创建一个新的节点，插入头节点。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子按照数量限制清扫</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)_trimToCount:(<span class=\"built_in\">NSUInteger</span>)countLimit &#123;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> finish = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (countLimit == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        [_lru removeAll];</span><br><span class=\"line\">        finish = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_lru-&gt;_totalCount &lt;= countLimit) &#123;</span><br><span class=\"line\">        finish = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (finish) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *holder = [<span class=\"built_in\">NSMutableArray</span> new];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!finish) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pthread_mutex_trylock(&amp;_lock) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_lru-&gt;_totalCount &gt; countLimit) &#123;</span><br><span class=\"line\">            \t  <span class=\"comment\">// 当缓存数量超出限制的时候，先从尾节点（LRU）开始清除，释放资源</span></span><br><span class=\"line\">                _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node) [holder addObject:node];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                finish = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pthread_mutex_unlock(&amp;_lock);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用 usleep 以微秒为单位挂起线程，在短时间间隔挂起线程</span></span><br><span class=\"line\">            <span class=\"comment\">// 对比 sleep 用 usleep 能更好的利用 CPU 时间</span></span><br><span class=\"line\">            usleep(<span class=\"number\">10</span> * <span class=\"number\">1000</span>); <span class=\"comment\">//10 ms</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (holder.count) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否在主线程释放对象</span></span><br><span class=\"line\">        <span class=\"built_in\">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class=\"line\">        <span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">            [holder count]; <span class=\"comment\">// release in queue</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>清除的代码其实不是太难，YYCache 从 count 、cost 和 age 三个维度去做清除工作，具体请去查阅源码。</p>\n<p>在代码底部判断是否在主线程释放资源，是作者另一篇文章<a href=\"https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"noopener\">iOS 保持界面流畅的技巧</a>中提到：</p>\n<blockquote>\n<p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *tmp = <span class=\"keyword\">self</span>.array;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.array = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">    [tmp <span class=\"keyword\">class</span>];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"YYDiskCache\"><a href=\"#YYDiskCache\" class=\"headerlink\" title=\"YYDiskCache\"></a>YYDiskCache</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> YYDiskCache 是一个线程安全的磁盘缓存，用于存储由 SQLite 和文件系统支持的键值对（类似于 NSURLCache 的磁盘缓存）。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">YYDiskCache 具有以下功能：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">* 它使用 LRU(least-recently-used) 来删除对象。</span></span><br><span class=\"line\"><span class=\"comment\">* 支持按 cost，count 和 age 进行控制。</span></span><br><span class=\"line\"><span class=\"comment\">* 它可以被配置为当没有可用的磁盘空间时自动驱逐缓存对象。</span></span><br><span class=\"line\"><span class=\"comment\">* 它可以自动抉择每个缓存对象的存储类型（sqlite/file）以便提供更好的性能表现。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">你可以编译最新版本的 sqlite 并忽略 iOS 系统中的 libsqlite3.dylib 来获得 2x〜4x 的速度提升</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYDiskCache</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Attribute</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> The name of the cache. Default is nil.</span></span><br><span class=\"line\"><span class=\"comment\"> 磁盘cache的名称</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> The path of the cache (read-only).</span></span><br><span class=\"line\"><span class=\"comment\"> 磁盘cache的文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果存入的消息超过此值，则消息会存入文件file，否则存入sqlite</span></span><br><span class=\"line\"><span class=\"comment\"> 0 意味着所有的消息会存入不同的文件file, NSUIntegerMax 意味着所有的消息会存入 sqlite.</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 20480 (20KB).</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSUInteger</span> inlineThreshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果block为nil 则会使用NSKeyedArchiver归档消息 使用此block以支持未遵循`NSCoding` 协议的对象存储</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值为nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSData</span> *(^customArchiveBlock)(<span class=\"keyword\">id</span> object);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> block不为nil则使用自定义的解归档方法替代 NSKeyedUnarchiver. 使用此block以支持未遵循`NSCoding` 协议的对象</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值为nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"keyword\">id</span> (^customUnarchiveBlock)(<span class=\"built_in\">NSData</span> *data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 当需要写文件时, block 会生成文件名和一个key，如果block是nil 则cache使用MD5生成默认的文件名</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值为nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *(^customFileNameBlock)(<span class=\"built_in\">NSString</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Limit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子cache中存储的最大数量</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 NSUIntegerMax 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> countLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子cache中容许的最大开销</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 NSUIntegerMax 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> costLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子cache中容许的时间限制</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 DBL_MAX 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span> ageLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> cache保证的最小磁盘disk空闲</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值为 0, 意味着无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 如果disk空闲容量小于此值，将移除对象释放内存</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> freeDiskSpaceLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 自动检测容器限制 默认时间60.0s</span></span><br><span class=\"line\"><span class=\"comment\"> cache消息池子持有Timer,以确保cache是否达到上限 如果达到上限则进行削减</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span> autoTrimInterval;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置`YES` 容许错误log</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> errorLogsEnabled;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Initializer</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据path实例化磁盘cache对象</span></span><br><span class=\"line\"><span class=\"comment\"> path cache写入消息的全路径 实例化后，不要在此路径读写数据</span></span><br><span class=\"line\"><span class=\"comment\"> 返回 cache 对象, 如果发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> 如果path已经存在内存中，则会直接返回cache对象 取代创建对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithPath:(<span class=\"built_in\">NSString</span> *)path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 推荐的实例化方法</span></span><br><span class=\"line\"><span class=\"comment\"> path cache写入消息的全路径 实例化后，不要在此路径读写数据</span></span><br><span class=\"line\"><span class=\"comment\"> threshold  存入数据尺寸的限制. 如果存入sqlite数据字节数超过此值 则会写入文件,</span></span><br><span class=\"line\"><span class=\"comment\"> 0 意味着所有的消息会存入不同的文件file, NSUIntegerMax 意味着所有的消息会存入 sqlite 推荐值为20480</span></span><br><span class=\"line\"><span class=\"comment\"> 返回 cache 对象, 如果发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> 如果path已经存在内存中，则会直接返回cache对象 取代创建对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithPath:(<span class=\"built_in\">NSString</span> *)path</span><br><span class=\"line\">                      inlineThreshold:(<span class=\"built_in\">NSUInteger</span>)threshold <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Access Methods</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回一个boolean 表示给定的key是否存在disk的cache中 此方法会堵塞直到返回</span></span><br><span class=\"line\"><span class=\"comment\"> key 标识消息对象的key 如果为nil 则返回NO</span></span><br><span class=\"line\"><span class=\"comment\"> 返回key是否存在cache中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)containsObjectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回一个boolean 表示给定的key是否存在disk的cache中 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> key   标识消息对象的key 如果为nil 则返回NO</span></span><br><span class=\"line\"><span class=\"comment\"> block 在后台线程执行完成后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)containsObjectForKey:(<span class=\"built_in\">NSString</span> *)key withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSString</span> *key, <span class=\"built_in\">BOOL</span> contains))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回指定key对应的消息 此方法会堵塞直到返回</span></span><br><span class=\"line\"><span class=\"comment\"> key 标识消息对象的key 如果为nil 则返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> 返回key对应的, 如果未找到，则返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)objectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回指定key对应的消息  此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> key 标识消息对象的key 如果为nil 则返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> block 在后台线程执行完成后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)objectForKey:(<span class=\"built_in\">NSString</span> *)key withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSString</span> *key, <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt; _Nullable object))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将消息和对应的key值存入cache中 此方法会堵塞直到写入数据完成</span></span><br><span class=\"line\"><span class=\"comment\"> object 存入cache中的消息对象. 如果是nil则会调用`removeObjectForKey:`.</span></span><br><span class=\"line\"><span class=\"comment\"> key    和消息对象关联的key. 如果为nil则不会操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)object forKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将消息和对应的key值存入cache中 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> object 存入cache中的消息对象. 如果是nil则会调用`removeObjectForKey:`.</span></span><br><span class=\"line\"><span class=\"comment\"> key    和消息对象关联的key. 如果为nil则不会操作</span></span><br><span class=\"line\"><span class=\"comment\"> block  在后台执行完后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)object forKey:(<span class=\"built_in\">NSString</span> *)key withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除cache中指定key对应的消息 此方法会堵塞直到文件删除完成</span></span><br><span class=\"line\"><span class=\"comment\"> key 标识删除对象的key 如果为nil则不会操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除cache中指定key对应的消息 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> key 标识删除对象的key 如果为nil则不会操作</span></span><br><span class=\"line\"><span class=\"comment\"> block  在后台执行完后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSString</span> *key))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除cache中所有的对象 此方法会堵塞直到cache清除完成</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeAllObjects;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除cache中所有的对象 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> block  在后台执行完后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeAllObjectsWithBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除cache中所有的对象 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> 不要在block中对该对象发送消息</span></span><br><span class=\"line\"><span class=\"comment\"> progress 删除过程中执行, nil的话忽略</span></span><br><span class=\"line\"><span class=\"comment\"> end      删除完成后执行, nil的话忽略</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeAllObjectsWithProgressBlock:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span>(^)(<span class=\"keyword\">int</span> removedCount, <span class=\"keyword\">int</span> totalCount))progress</span><br><span class=\"line\">                                 endBlock:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span>(^)(<span class=\"built_in\">BOOL</span> error))end;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回cache中的消息总数量 此方法会堵塞直到读取完成</span></span><br><span class=\"line\"><span class=\"comment\"> 返回消息总数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSInteger</span>)totalCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取cache中的消息总数量 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> block  在后台执行完后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)totalCountWithBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSInteger</span> totalCount))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回cache中的消息总开销（字节） 此方法会堵塞直到读取完成</span></span><br><span class=\"line\"><span class=\"comment\"> 返回消息总开销（字节）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSInteger</span>)totalCost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回cache中的消息总开销（字节）此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> block  在后台执行完后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)totalCostWithBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSInteger</span> totalCost))block;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Trim</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 一旦 `totalCount` 高于总数限制，则删除消息 将LRU对象放入缓存区 此方法会堵塞直到完成</span></span><br><span class=\"line\"><span class=\"comment\"> count  清除消息后容许的消息总数量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCount:(<span class=\"built_in\">NSUInteger</span>)count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 一旦 `totalCount` 高于总数限制，则删除消息 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> count  清除消息后容许的消息总数量</span></span><br><span class=\"line\"><span class=\"comment\"> block 完成后的回调</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCount:(<span class=\"built_in\">NSUInteger</span>)count withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 一旦 `totalCount` 高于总开销限制，则删除消息 将LRU对象放入缓存区 此方法会堵塞直到完成</span></span><br><span class=\"line\"><span class=\"comment\"> count  清除消息后容许的消息总开销</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCost:(<span class=\"built_in\">NSUInteger</span>)cost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 一旦 `totalCount` 高于总开销限制，则删除消息 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> count  清除消息后容许的消息总开销</span></span><br><span class=\"line\"><span class=\"comment\"> block 完成后的回调</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCost:(<span class=\"built_in\">NSUInteger</span>)cost withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 按照时间限制削减 （LRU对象进入缓冲区）此方法会堵塞</span></span><br><span class=\"line\"><span class=\"comment\"> age  最大的时间 seconds.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToAge:(<span class=\"built_in\">NSTimeInterval</span>)age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 一旦 按照时间限制削减 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> age  最大的时间 seconds.</span></span><br><span class=\"line\"><span class=\"comment\"> block 完成后的回调</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToAge:(<span class=\"built_in\">NSTimeInterval</span>)age withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Extended Data</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取消息的拓展数据</span></span><br><span class=\"line\"><span class=\"comment\"> 详见'setExtendedData:toObject:'</span></span><br><span class=\"line\"><span class=\"comment\"> object 消息对象</span></span><br><span class=\"line\"><span class=\"comment\"> 拓展数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)getExtendedDataFromObject:(<span class=\"keyword\">id</span>)object;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置消息的拓展数据</span></span><br><span class=\"line\"><span class=\"comment\"> 当保存消息到cache之前可以设置消息的拓展数据 拓展数据会同样存入cache中 你可以使用\"getExtendedDataFromObject:\"获取拓展数据</span></span><br><span class=\"line\"><span class=\"comment\"> extendedData 拓展数据 (如果是nil 则删除数据)</span></span><br><span class=\"line\"><span class=\"comment\"> object       对应的消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)setExtendedData:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)extendedData toObject:(<span class=\"keyword\">id</span>)object;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>👆是 YYDiskCache 的接口和属性，我都加上了注释。</p>\n<p>YYDiskCache 是分成 sqlite 和 file 存储的，作者设计的时候是根据文件大小来划分存储方式：</p>\n<ul>\n<li>sqlite: 对于小数据（例如 NSNumber）的存取效率明显高于 file。</li>\n<li>file: 对于较大数据（例如高质量图片）的存取效率优于 sqlite。</li>\n</ul>\n<p>YYDiskCache 使用两个相互配合的方式提高存储性能。</p>\n<h3 id=\"YYDiskCacheGetGlobal-和-YYDiskCacheSetGlobal\"><a href=\"#YYDiskCacheGetGlobal-和-YYDiskCacheSetGlobal\" class=\"headerlink\" title=\"_YYDiskCacheGetGlobal 和 _YYDiskCacheSetGlobal\"></a>_YYDiskCacheGetGlobal 和 _YYDiskCacheSetGlobal</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithPath:(<span class=\"built_in\">NSString</span> *)path</span><br><span class=\"line\">             inlineThreshold:(<span class=\"built_in\">NSUInteger</span>)threshold &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);</span><br><span class=\"line\">    ```</span><br></pre></td></tr></table></figure>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">根据公开初始化方法初始化 YYDiskCache 时，发现内部是调用静态方法去创建实例：</span><br><span class=\"line\"></span><br><span class=\"line\">```objc</span><br><span class=\"line\">/**</span><br><span class=\"line\"> Map表保存cache实例，管理所有根据 path 创建的 YYDiskCache 实例</span><br><span class=\"line\"> */</span><br><span class=\"line\">static NSMapTable *_globalInstances;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> 线程信号</span><br><span class=\"line\"> */</span><br><span class=\"line\">static dispatch_semaphore_t _globalInstancesLock;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 静态变量实例化</span><br><span class=\"line\"> */</span><br><span class=\"line\">static void _YYDiskCacheInitGlobal() &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        // 初始化信号量</span><br><span class=\"line\">        _globalInstancesLock = dispatch_semaphore_create(1);</span><br><span class=\"line\">        // 创建 NSMapTable，Key 强引用，Value 弱引用</span><br><span class=\"line\">        _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 获取 NSMapTable 中的 YYDiskCache 实例</span><br><span class=\"line\"> */</span><br><span class=\"line\">static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123;</span><br><span class=\"line\">    if (path.length == 0) return nil;</span><br><span class=\"line\">    _YYDiskCacheInitGlobal();</span><br><span class=\"line\">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">    // 通过 NSMapTable 获取 YYDiskCache</span><br><span class=\"line\">    id cache = [_globalInstances objectForKey:path];</span><br><span class=\"line\">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class=\"line\">    return cache;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 设置 NSMapTable 中的 YYDiskCache 实例，key 值为 cache 路径</span><br><span class=\"line\"> */</span><br><span class=\"line\">static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123;</span><br><span class=\"line\">    if (cache.path.length == 0) return;</span><br><span class=\"line\">    _YYDiskCacheInitGlobal();</span><br><span class=\"line\">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">    // 通过 NSMapTable 设置 YYDiskCache</span><br><span class=\"line\">    [_globalInstances setObject:cache forKey:cache.path];</span><br><span class=\"line\">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>👆代码里面创建 YYDiskCache 的时候使用了 <strong>NSMapTable</strong> 来保存实例对象，并且创建的过程都有加上<strong>信号锁</strong>。</p>\n<p>它是 iOS 6 才引入的数据结构集合，用法类似 NSDictionary，但是<strong>它可以对 Value 弱引用</strong>。关于 NSMapTable 更多的语义和使用参考<a href=\"https://www.jianshu.com/p/dcd222900fa9\" target=\"_blank\" rel=\"noopener\">《iOS中的NSHashTable和NSMapTable》</a> 和 <a href=\"https://developer.apple.com/documentation/foundation/nsmaptable?language=objc\" target=\"_blank\" rel=\"noopener\">《NSMapTable 官方文档》</a>。</p>\n<p>每当一个 YYDiskCache 被初始化时，其实会先到 NSMapTable 中获取对应 path 的 YYDiskCache 实例，如果获取不到才会去真正的初始化一个 YYDiskCache 实例，并且将其引用在 NSMapTable 中，这样做提升不少性能。</p>\n<blockquote>\n<p>Note：dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p>\n</blockquote>\n<h3 id=\"YYKVStorageItem-和-YYKVStorage\"><a href=\"#YYKVStorageItem-和-YYKVStorage\" class=\"headerlink\" title=\"YYKVStorageItem 和 YYKVStorage\"></a>YYKVStorageItem 和 YYKVStorage</h3><p>由于 YYDiskCache 有时候是操作 sqlite ，有时候是操作 file，所以使用 YYKVStorage 来统一管理缓存对象（sqlite/file），YYKVStorage 其实就是对应着 _YYLinkedMap，YYKVStorageItem 对应 _YYLinkedMapNode。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> YYKVStorageItem 用来存储键值对数据及拓展数据，通常不应该直接使用它</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYKVStorageItem</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息key值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *key;                <span class=\"comment\">///&lt; key</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息data数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSData</span> *value;                <span class=\"comment\">///&lt; value</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息文件名</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *filename; <span class=\"comment\">///&lt; filename (nil if inline)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息大小（字节）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">int</span> size;                             <span class=\"comment\">///&lt; value's size in bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息修改时间</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">int</span> modTime;                          <span class=\"comment\">///&lt; modification unix timestamp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息导入时间</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">int</span> accessTime;                       <span class=\"comment\">///&lt; last access unix timestamp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 拓展数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSData</span> *extendedData; <span class=\"comment\">///&lt; extended data (nil if no extended data)</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息存储类型，表示存储“YYKVStorageItem.value”的位置。</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> 一般而言,数据存入sqlite比写文件更快，但读取数据的性能依赖数据大小 以iPhone 6 64G为例</span></span><br><span class=\"line\"><span class=\"comment\"> 数据超过20KB，则从文件读取数据比sqlite读取更快</span></span><br><span class=\"line\"><span class=\"comment\"> 存储较小的数据使用 YYKVStorageTypeSQLite 获得更好的性能</span></span><br><span class=\"line\"><span class=\"comment\"> 如果存储较大的数据 如图片数据, 使用 YYKVStorageTypeFile 获取更好的性能</span></span><br><span class=\"line\"><span class=\"comment\"> 使用 LSMessageDiskStorageTypeMixed 将针对每一个item采用不同的存储方式</span></span><br><span class=\"line\"><span class=\"comment\"> 详见 http://www.sqlite.org/intern-v-extern-blob.html</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, YYKVStorageType) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// The `value` is stored as a file in file system.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 消息存入文件</span></span><br><span class=\"line\">    YYKVStorageTypeFile = <span class=\"number\">0</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// The `value` is stored in sqlite with blob type.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 消息存入sqlite，采用blob的类型</span></span><br><span class=\"line\">    YYKVStorageTypeSQLite = <span class=\"number\">1</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// The `value` is stored in file system or sqlite based on your choice.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 根据选择选取存入方式</span></span><br><span class=\"line\">    YYKVStorageTypeMixed = <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> 消息写入file/sqlite的管理类</span></span><br><span class=\"line\"><span class=\"comment\"> @discussion 键值对的方式将消息存入文件和sqlite 使用`initWithPath:type:`进行初始化</span></span><br><span class=\"line\"><span class=\"comment\"> 初始化后 不要再对生成的path进行读写操作 使用最新的sqlite版本获取2-4倍的速度提升</span></span><br><span class=\"line\"><span class=\"comment\"> 产生的实例并不是线程安全的，应该在同一时间在同一的线程使用，数据较大时，应该对数据进行拆分成多个片段进行存储</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYKVStorage</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Attribute</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息存入的路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *path;        <span class=\"comment\">///&lt; The path of this storage.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息存储类型</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) YYKVStorageType type;  <span class=\"comment\">///&lt; The type of this storage.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 是否打印log</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> errorLogsEnabled;           <span class=\"comment\">///&lt; Set `YES` to enable error logs for debug.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - 初始化</span></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 推荐的实例化方法</span></span><br><span class=\"line\"><span class=\"comment\"> path  写数据的路径. 如果路径存在，则会在此路径读写数据 否则建立一个新路径</span></span><br><span class=\"line\"><span class=\"comment\"> type  存储类型  一旦设置后不要修改</span></span><br><span class=\"line\"><span class=\"comment\"> 返回一个存储管理实例, 发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> 多个实例操作同一个路径 会导致错误</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithPath:(<span class=\"built_in\">NSString</span> *)path type:(YYKVStorageType)type <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - 保存消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 保存item key值存在时更新item</span></span><br><span class=\"line\"><span class=\"comment\"> @discussion 此方法会将 item.key, item.value, item.filename 和</span></span><br><span class=\"line\"><span class=\"comment\"> item.extendedData 写入文件或sqlite, 其他属性会忽略. item.key</span></span><br><span class=\"line\"><span class=\"comment\"> 和 item.value 不应该为空 (nil || length == 0).</span></span><br><span class=\"line\"><span class=\"comment\"> item  消息item</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)saveItem:(YYKVStorageItem *)item;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 保存item key值存在时更新item</span></span><br><span class=\"line\"><span class=\"comment\"> 此方法会保存键值对到 sqlite. 如果存储类型为 YYKVStorageTypeFile , 此方法会失败</span></span><br><span class=\"line\"><span class=\"comment\"> key   key值不能为空</span></span><br><span class=\"line\"><span class=\"comment\"> value value不能为空</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)saveItemWithKey:(<span class=\"built_in\">NSString</span> *)key value:(<span class=\"built_in\">NSData</span> *)value;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 保存item key值存在时更新item</span></span><br><span class=\"line\"><span class=\"comment\"> 如果写入类型为LSMessageDiskStorageTypeFile,filename 不能为空</span></span><br><span class=\"line\"><span class=\"comment\"> 如果写入类型为LSMessageDiskStorageTypeSQLite, filename 会被忽略</span></span><br><span class=\"line\"><span class=\"comment\"> 如果写入类型为LSMessageDiskStorageTypeMixed, 如果filename不为空 则value会被存入文件 否则存入sqlite</span></span><br><span class=\"line\"><span class=\"comment\"> key           key值不能为空</span></span><br><span class=\"line\"><span class=\"comment\"> value         value不能为空</span></span><br><span class=\"line\"><span class=\"comment\"> filename      文件名</span></span><br><span class=\"line\"><span class=\"comment\"> extendedData  item的拓展数据 如果是nil则忽略</span></span><br><span class=\"line\"><span class=\"comment\"> Whether succeed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)saveItemWithKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\">                  value:(<span class=\"built_in\">NSData</span> *)value</span><br><span class=\"line\">               filename:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSString</span> *)filename</span><br><span class=\"line\">           extendedData:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)extendedData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - 删除消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> 根据key值删除item</span></span><br><span class=\"line\"><span class=\"comment\"> keys 特定的key值</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据keys数组删除items</span></span><br><span class=\"line\"><span class=\"comment\"> keys keys数组</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据消息value的开销限制删除items</span></span><br><span class=\"line\"><span class=\"comment\"> size 消息value的最大限制</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemsLargerThanSize:(<span class=\"keyword\">int</span>)size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除比指定时间更早存入的消息</span></span><br><span class=\"line\"><span class=\"comment\"> time  指定的时间</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemsEarlierThanTime:(<span class=\"keyword\">int</span>)time;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据消息开销限制删除items (LRU对象优先删除)</span></span><br><span class=\"line\"><span class=\"comment\"> maxCount 最大的消息开销</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemsToFitSize:(<span class=\"keyword\">int</span>)maxSize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据消息数量限制删除items (LRU对象优先删除)</span></span><br><span class=\"line\"><span class=\"comment\"> maxCount 最大的消息数量</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemsToFitCount:(<span class=\"keyword\">int</span>)maxCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 在后台队列中，删除所有的item</span></span><br><span class=\"line\"><span class=\"comment\"> @discussion 此方法会删除 files 和 sqlite database 进入回收站 并在后台清除回收站数据</span></span><br><span class=\"line\"><span class=\"comment\"> 比`removeAllItemsWithProgressBlock:endBlock:`方法更快</span></span><br><span class=\"line\"><span class=\"comment\"> @return 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeAllItems;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除所有的item</span></span><br><span class=\"line\"><span class=\"comment\"> @warning 在block中不要对该实例发送消息</span></span><br><span class=\"line\"><span class=\"comment\"> progress 删除时执行的block，nil则不执行</span></span><br><span class=\"line\"><span class=\"comment\"> end      删除结束执行的block，nil则不执行</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeAllItemsWithProgressBlock:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span>(^)(<span class=\"keyword\">int</span> removedCount, <span class=\"keyword\">int</span> totalCount))progress</span><br><span class=\"line\">                               endBlock:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span>(^)(<span class=\"built_in\">BOOL</span> error))end;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - 获取消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key获取item</span></span><br><span class=\"line\"><span class=\"comment\"> key  特定的key值</span></span><br><span class=\"line\"><span class=\"comment\"> 返回item, 发送错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> YYKVStorageItem *)getItemForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key获取item的信息（value会被忽略）</span></span><br><span class=\"line\"><span class=\"comment\"> key  特定的key值</span></span><br><span class=\"line\"><span class=\"comment\"> 返回item的信息, 发送错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> YYKVStorageItem *)getItemInfoForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key获取item的value</span></span><br><span class=\"line\"><span class=\"comment\"> key  特定的key值</span></span><br><span class=\"line\"><span class=\"comment\"> 返回item的value, 发送错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)getItemValueForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key的数组获取item的信息</span></span><br><span class=\"line\"><span class=\"comment\"> keys  key值的数组</span></span><br><span class=\"line\"><span class=\"comment\"> 包含`YYKVStorageItem`的数组 发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSArray</span>&lt;YYKVStorageItem *&gt; *)getItemForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key的数组获取item的信息（value会被忽略）</span></span><br><span class=\"line\"><span class=\"comment\"> keys  key值的数组</span></span><br><span class=\"line\"><span class=\"comment\"> 包含`LSMessageDiskStorageItem`的数组 发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSArray</span>&lt;YYKVStorageItem *&gt; *)getItemInfoForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据一个key值数组获取item和key的字典</span></span><br><span class=\"line\"><span class=\"comment\"> keys  key值的数组</span></span><br><span class=\"line\"><span class=\"comment\"> 返回一个字典 key-&gt;item对应 发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"built_in\">NSData</span> *&gt; *)getItemValueForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - 获取存储属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key值查找item是否存在</span></span><br><span class=\"line\"><span class=\"comment\"> key  特定的key</span></span><br><span class=\"line\"><span class=\"comment\"> 返回item是否存在</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)itemExistsForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取item的总数</span></span><br><span class=\"line\"><span class=\"comment\"> 返回总数，如果发生错误返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">int</span>)getItemsCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取items的总大小（字节）</span></span><br><span class=\"line\"><span class=\"comment\"> 返回总大小，如果发生错误返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">int</span>)getItemsSize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>当 YYDiskCache 存储对象的时候，会判断存储数据库的文件大小最大阈值，超过了会生成文件名，写入文件，然后将文件名存储到 sqlite 中。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// YYDiskCache.m</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)object forKey:(<span class=\"built_in\">NSString</span> *)key &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!object) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> removeObjectForKey:key];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *extendedData = [YYDiskCache getExtendedDataFromObject:object];</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *value = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_customArchiveBlock) &#123;</span><br><span class=\"line\">        value = _customArchiveBlock(object);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\">            value = [<span class=\"built_in\">NSKeyedArchiver</span> archivedDataWithRootObject:object];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">@catch</span> (<span class=\"built_in\">NSException</span> *exception) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// nothing to do...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!value) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *filename = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_kv.type != YYKVStorageTypeSQLite) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果超过数据库写入大小限制，生成文件名</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value.length &gt; _inlineThreshold) &#123;</span><br><span class=\"line\">            filename = [<span class=\"keyword\">self</span> _filenameForKey:key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Lock();</span><br><span class=\"line\">    [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData];</span><br><span class=\"line\">    Unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// YYKVStorage.m</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 保存item key值存在时更新item</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)saveItemWithKey:(<span class=\"built_in\">NSString</span> *)key value:(<span class=\"built_in\">NSData</span> *)value filename:(<span class=\"built_in\">NSString</span> *)filename extendedData:(<span class=\"built_in\">NSData</span> *)extendedData &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 没有 Key，也没有 Value 直接返回 NO</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key.length == <span class=\"number\">0</span> || value.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 存文件，但是没有文件名，也直接返回 NO</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_type == YYKVStorageTypeFile &amp;&amp; filename.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filename.length) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 写文件失败，返回 NO</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> _fileWriteWithName:filename data:value]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将文件名写入数据库，之后方便根据 Key 去查找文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果写入数据库失败，把之前写入的文件删除</span></span><br><span class=\"line\">            [<span class=\"keyword\">self</span> _fileDeleteWithName:filename];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_type != YYKVStorageTypeSQLite) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSString</span> *filename = [<span class=\"keyword\">self</span> _dbGetFilenameWithKey:key];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (filename) &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span> _fileDeleteWithName:filename];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> _dbSaveWithKey:key value:value fileName:<span class=\"literal\">nil</span> extendedData:extendedData];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"YYKVStorage-性能优化细节\"><a href=\"#YYKVStorage-性能优化细节\" class=\"headerlink\" title=\"YYKVStorage 性能优化细节\"></a>YYKVStorage 性能优化细节</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFMutableDictionaryRef</span> _dbStmtCache;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> db设置sqlite3_stmt</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (sqlite3_stmt *)_dbPrepareStmt:(<span class=\"built_in\">NSString</span> *)sql &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> _dbCheck] || sql.length == <span class=\"number\">0</span> || !_dbStmtCache) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 先尝试从 _dbStmtCache 根据入参 sql 取出已缓存 sqlite3_stmt</span></span><br><span class=\"line\">    sqlite3_stmt *stmt = (sqlite3_stmt *)<span class=\"built_in\">CFDictionaryGetValue</span>(_dbStmtCache, (__bridge <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)(sql));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!stmt) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有缓存再从新生成一个 sqlite3_stmt</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = sqlite3_prepare_v2(_db, sql.UTF8String, <span class=\"number\">-1</span>, &amp;stmt, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 生成结果异常则根据错误日志开启标识打印日志</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != SQLITE_OK) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_errorLogsEnabled) <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s line:%d sqlite stmt prepare error (%d): %s\"</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 生成成功则放入 _dbStmtCache 缓存</span></span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(_dbStmtCache, (__bridge <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)(sql), stmt);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        sqlite3_reset(stmt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stmt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次操作 sqlite 的时候，都有调用 _dbPrepareStmt 方法获取 sqlite3_stmt 缓存，sqlite3_stmt 保存在 _dbStmtCache 字典中，每次都先从字典里面获取缓存，这样不需要重复生成 sqlite3_stmt。</p>\n<blockquote>\n<p>sqlite3_stmt: 该对象的实例表示已经编译成二进制形式并准备执行的单个 SQL 语句。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>YYCache 的设计相当清晰，功能相当强大，具备了优秀缓存的能力：</p>\n<ul>\n<li>内存缓存和磁盘缓存</li>\n<li>线程安全</li>\n<li>缓存控制</li>\n<li>缓存替换策略</li>\n<li>性能</li>\n</ul>\n<h3 id=\"内存缓存和磁盘缓存\"><a href=\"#内存缓存和磁盘缓存\" class=\"headerlink\" title=\"内存缓存和磁盘缓存\"></a>内存缓存和磁盘缓存</h3><p>内存缓存 YYMemoryCache 与磁盘缓存 YYDiskCache 相互配合组成的，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。这样的设计支持用户在缓存不同对象时都能够有很好的体验。</p>\n<p>在 YYCache 中使用接口访问缓存对象时，会先去尝试从内存缓存 YYMemoryCache 中访问，如果访问不到（没有使用该 key 缓存过对象或者该对象已经从容量有限的 YYMemoryCache 中淘汰掉）才会去从 YYDiskCache 访问，如果访问到（表示之前确实使用该 key 缓存过对象，该对象已经从容量有限的 YYMemoryCache 中淘汰掉成立）会先在 YYMemoryCache 中更新一次该缓存对象的访问信息之后才返回给接口。</p>\n<h3 id=\"线程安全-1\"><a href=\"#线程安全-1\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>YYMemoryCache 使用了 pthread_mutex 线程锁来确保线程安全，而 YYDiskCache 则选择了更适合它的 dispatch_semaphore</p>\n<h3 id=\"缓存控制\"><a href=\"#缓存控制\" class=\"headerlink\" title=\"缓存控制\"></a>缓存控制</h3><p>提供了 cost、count、age 三个维度去控制缓存，满足绝大多数的需求。</p>\n<h3 id=\"缓存替换策略\"><a href=\"#缓存替换策略\" class=\"headerlink\" title=\"缓存替换策略\"></a>缓存替换策略</h3><p>使用了 LRU(least-recently-used) 策略去提高缓存效率。</p>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>从上面的分析就可以看出来了：</p>\n<ul>\n<li>异步释放缓存对象</li>\n<li>锁的选择</li>\n<li>使用 NSMapTable 单例管理的 YYDiskCache</li>\n<li>YYKVStorage 中的 _dbStmtCache</li>\n<li>使用 CoreFoundation 来换取手动释放内存提高效率</li>\n</ul>\n<p><a href=\"https://github.com/piglikeYoung/YYCache\" target=\"_blank\" rel=\"noopener\">YYCache</a> 这个是我 fork 的库，加了一些代码注释，可以参考下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>iOS 开发中总会用到各种缓存，本文介绍的是 <strong>YYCache</strong> 是一个线程安全的高性能键值缓存（该项目是 YYKit 组件之一）。YYKit 作者是 @ibireme 。</p>\n<p><a href=\"https://github.com/ibireme/YYCache\" target=\"_blank\" rel=\"noopener\">YYCache</a> 的代码逻辑清晰，注释详尽，加上自身不算太大的代码量使得其阅读非常简单，更加厉害的是它的性能还非常高。</p>\n<p>详情请看：<a href=\"https://blog.ibireme.com/2015/10/26/yycache/\" target=\"_blank\" rel=\"noopener\">《YYCache 设计思路与技术细节》</a></p>\n<p>我把 YYCache 从头到尾看了一遍，最大的感触就是代码风格干净整洁，代码思路清晰明了，注释详细。</p>\n<p>我们先来简单看一下 YYCache 的代码结构，YYCache 是由 YYMemoryCache 与 YYDiskCache 两部分组成的，其中 YYMemoryCache 作为高速内存缓存，而 YYDiskCache 则作为低速磁盘缓存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YYCache</span><br><span class=\"line\"> \tYYMemoryCache</span><br><span class=\"line\"> \t\t_YYLinkedMap</span><br><span class=\"line\">\t\t_YYLinkedMapNode</span><br><span class=\"line\">\tYYDiskCache</span><br><span class=\"line\">\t\tYYKVStorage</span><br><span class=\"line\">  \t\tYYKVStorageItem</span><br></pre></td></tr></table></figure>\n<p>👆是 YYCache 的主要结构，通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但相对低速的持久化存储。</p>\n<h2 id=\"YYCache\"><a href=\"#YYCache\" class=\"headerlink\" title=\"YYCache\"></a>YYCache</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYCache</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) YYMemoryCache *memoryCache;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) YYDiskCache *diskCache;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)containsObjectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)objectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)object forKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>我将 YYCache 里的代码精简了一下，总的来说就这些增删改查的方法， 里面有 YYMemoryCache 与 YYDiskCache，并且对外提供了一些接口。这些接口基本都是基于 Key 和 Value 设计的，和字典的操作类似。</p>\n<h2 id=\"YYMemoryCache\"><a href=\"#YYMemoryCache\" class=\"headerlink\" title=\"YYMemoryCache\"></a>YYMemoryCache</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYMemoryCache</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Attribute</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    cache 的名称，默认为nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    memory 中的消息总数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSUInteger</span> totalCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    memory 中的消息总开销</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSUInteger</span> totalCost;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Limit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子 cache 中存储的最大数量</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 NSUIntegerMax 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 如果超过此限制，则稍后在后台线程将清除一些对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> countLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子cache中容许的最大开销</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 NSUIntegerMax 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 如果超过此限制，则稍后在后台线程将清除一些对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> costLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子cache中容许的时间限制</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 DBL_MAX 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 如果超过此限制，则稍后在后台线程将清除一些对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span> ageLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 自动检测容器限制 默认时间 5.0s</span></span><br><span class=\"line\"><span class=\"comment\"> cache 消息池子持有 Timer，以确保 cache 是否达到上限 如果达到上限则进行削减</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span> autoTrimInterval;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果是 YES 则收到内存报警时会删除所有的 cache 消息对象</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值是 YES</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> shouldRemoveAllObjectsOnMemoryWarning;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果是 YES 则收到app进入后台时会删除所有的cache消息对象</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值是 YES</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> shouldRemoveAllObjectsWhenEnteringBackground;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> app 收到报警时执行的 block 默认为 nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"keyword\">void</span>(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> app 收到进入后台时执行的 block 默认为 nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"keyword\">void</span>(^didEnterBackgroundBlock)(YYMemoryCache *cache);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 键值对是否在主线程删除 默认值为NO.</span></span><br><span class=\"line\"><span class=\"comment\"> 仅仅当键值对中包含 UIView、CALayer 等非线程安全对象时，将值设为YES</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> releaseOnMainThread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 键值对异步的释放 默认值为 YES</span></span><br><span class=\"line\"><span class=\"comment\"> 避免堵塞访问方法 否则将在 removeObjectForKey: 等方法中释放 默认是 YES</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> releaseAsynchronously;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Access Methods</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> 判断消息池子是否包含指定key的消息</span></span><br><span class=\"line\"><span class=\"comment\"> key 消息对象关联的key. 如果是nil则返回NO</span></span><br><span class=\"line\"><span class=\"comment\"> 是否包含指定key的消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)containsObjectForKey:(<span class=\"keyword\">id</span>)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取与key关联的消息对象</span></span><br><span class=\"line\"><span class=\"comment\"> key 关联消息对象的 key,如果是 nil 则返回 nil</span></span><br><span class=\"line\"><span class=\"comment\"> 返回与 key 关联的消息对象, 如果未找到则返回 nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)objectForKey:(<span class=\"keyword\">id</span>)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据指定的 key 存储消息对象</span></span><br><span class=\"line\"><span class=\"comment\"> message 需要存储到池子的对象. 如果是nil则调用 `removeMessageForKey`.</span></span><br><span class=\"line\"><span class=\"comment\"> key 存储对象关联的key. 如果是nil则不执行任何操作</span></span><br><span class=\"line\"><span class=\"comment\"> 与NSMutableDictionary相比, cache池子不会拷贝容器中的键值对</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)object forKey:(<span class=\"keyword\">id</span>)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据指定的key和开销cost存储消息</span></span><br><span class=\"line\"><span class=\"comment\"> object 需要存储到池子的对象. 如果是nil则调用 `removeObjectForKey`.</span></span><br><span class=\"line\"><span class=\"comment\"> key 存储对象关联的key. 如果是nil则不执行任何操作</span></span><br><span class=\"line\"><span class=\"comment\"> cost 关联键值对的开销</span></span><br><span class=\"line\"><span class=\"comment\"> 与NSMutableDictionary相比, cache池子不会拷贝容器中的键值对</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)object forKey:(<span class=\"keyword\">id</span>)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据指定的key删除消息</span></span><br><span class=\"line\"><span class=\"comment\"> key 需要删除的object的key. 如果是nil则不执行任何操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"keyword\">id</span>)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除所有的消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeAllObjects;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Trim</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 用 LRU 算法删除对象，直到 totalCount &lt;= count</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCount:(<span class=\"built_in\">NSUInteger</span>)count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 用 LRU 算法删除对象，直到 totalCost &lt;= cost</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCost:(<span class=\"built_in\">NSUInteger</span>)cost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 用 LRU 算法删除对象，直到所有到期对象全部被删除</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToAge:(<span class=\"built_in\">NSTimeInterval</span>)age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>上面是 YYMemoryCache.h 的主要属性和接口，加上了注释。</p>\n<h3 id=\"YYLinkedMapNode-和-YYLinkedMap\"><a href=\"#YYLinkedMapNode-和-YYLinkedMap\" class=\"headerlink\" title=\"_YYLinkedMapNode 和 _YYLinkedMap\"></a>_YYLinkedMapNode 和 _YYLinkedMap</h3><p>YYMemoryCache 内部其实是通过 <strong>_YYLinkedMapNode</strong> 和 <strong>_YYLinkedMap</strong> 这两个对象操作缓存的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> _YYLinkedMap 中的一个节点。</span></span><br><span class=\"line\"><span class=\"comment\"> 通常情况下我们不应该使用这个类。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">_YYLinkedMapNode</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@package</span></span><br><span class=\"line\">    __<span class=\"keyword\">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class=\"comment\">// retained by dic 前一个消息 &amp;&amp; 被字典保留</span></span><br><span class=\"line\">    __<span class=\"keyword\">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class=\"comment\">// retained by dic 后一个消息 &amp;&amp; 被字典保留</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> _key;    <span class=\"comment\">/// 消息的key</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> _value;  <span class=\"comment\">/// 消息</span></span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> _cost;   <span class=\"comment\">/// 消息开销</span></span><br><span class=\"line\">    <span class=\"built_in\">NSTimeInterval</span> _time;   <span class=\"comment\">/// 消息时间</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> YYMemoryCache 内的一个链表。</span></span><br><span class=\"line\"><span class=\"comment\"> _YYLinkedMap 不是一个线程安全的类，而且它也不对参数做校验。</span></span><br><span class=\"line\"><span class=\"comment\"> 通常情况下我们不应该使用这个类。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">_YYLinkedMap</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@package</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableDictionaryRef</span> _dic; <span class=\"comment\">// do not set object directly 保存消息的字典，外部不要直接设置</span></span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> _totalCost;  <span class=\"comment\">// 消息总开销</span></span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> _totalCount; <span class=\"comment\">// 消息总量</span></span><br><span class=\"line\">    _YYLinkedMapNode *_head; <span class=\"comment\">// MRU, do not change it directly MRU最近最常使用, 外部不要直接修改</span></span><br><span class=\"line\">    _YYLinkedMapNode *_tail; <span class=\"comment\">// LRU, do not change it directly LRU最近最少使用, 外部不要直接修改</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> _releaseOnMainThread;  <span class=\"comment\">// 是否在主线程release</span></span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> _releaseAsynchronously;    <span class=\"comment\">// 是否异步release</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出来 _YYLinkedMapNode 是双向链表， _YYLinkedMap 是双向链表的节点。</p>\n<p>_YYLinkedMapNode 记录着它的前一个节点 <strong>_prev</strong> 和 后一个节点 <strong>_next</strong>，并且记录着缓存信息的 <strong>_key</strong> 和 <strong>_value</strong>，这样一个节点就保存缓存数据，可以理解为一个节点就是一个缓存对象。</p>\n<p>_YYLinkedMap 使用 <strong>CFMutableDictionaryRef _dic</strong> 字典存储 _YYLinkedMapNode。这样即强引用了节点，又能够利用字典的 Hash 快速定位用户要访问的缓存对象，并且当需要是否手动释放字典的时候，能够通过 CFRelease 手动释放。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYMemoryCache</span> </span>&#123;</span><br><span class=\"line\">    pthread_mutex_t _lock; <span class=\"comment\">// 线程锁，保证线程安全</span></span><br><span class=\"line\">    _YYLinkedMap *_lru;\t<span class=\"comment\">// YYMemoryCache 通过操作Map来管理缓存</span></span><br><span class=\"line\">    <span class=\"built_in\">dispatch_queue_t</span> _queue;\t<span class=\"comment\">// 串行队列，用于后台 trim（清扫工作）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 YYMemoryCache 中作者是使用 <code>pthread_mutex</code> 来保证线程安全的，但是最开始的版本并不是用 pthread_mutex ，而是使用自旋锁 <strong>OSSpinLock</strong>，可以查看<a href=\"https://blog.ibireme.com/2015/10/26/yycache/\" target=\"_blank\" rel=\"noopener\">YYCache 设计思路</a>得知改动的原因。</p>\n<h3 id=\"LRU\"><a href=\"#LRU\" class=\"headerlink\" title=\"LRU\"></a>LRU</h3><p>LRU(least-recently-used) 算法翻译过来是”最近最少使用“，顾名思义这种缓存替换策略是基于用户最近访问过的缓存对象而建立。</p>\n<ul>\n<li>从代码实现上看缓存替换策略的核心思想在于：LRU 认为用户最新使用（访问）过的缓存对象为高频缓存对象，即用户很可能还会再次使用（访问）该缓存对象；而反之，用户很久之前使用（访问）过的缓存对象（期间一直没有再次访问）为低频缓存对象，即用户很可能不会再去使用（访问）该缓存对象，通常在资源不足时会先去释放低频缓存对象。</li>\n</ul>\n<h3 id=\"YYLinkedMapNode-和-YYLinkedMap-使用-LRU\"><a href=\"#YYLinkedMapNode-和-YYLinkedMap-使用-LRU\" class=\"headerlink\" title=\"_YYLinkedMapNode 和 _YYLinkedMap 使用 LRU\"></a>_YYLinkedMapNode 和 _YYLinkedMap 使用 LRU</h3><p>从双向链表可以知道，链表存在两个节点：</p>\n<ul>\n<li>头结点：用户最近使用的数据，MRU</li>\n<li>尾节点：用户很久之前使用的数据，LRU</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)objectForKey:(<span class=\"keyword\">id</span>)key &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;_lock);</span><br><span class=\"line\">    <span class=\"comment\">// 找到节点</span></span><br><span class=\"line\">    _YYLinkedMapNode *node = <span class=\"built_in\">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)(key));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">    \t\t<span class=\"comment\">// 更新节点的时间戳</span></span><br><span class=\"line\">        node-&gt;_time = <span class=\"built_in\">CACurrentMediaTime</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 将节点移动到头结点</span></span><br><span class=\"line\">        [_lru bringNodeToHead:node];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;_lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node ? node-&gt;_value : <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次根据 Key 获取某个节点的时候，都会更新节点的时间戳并移动到头结点。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"keyword\">id</span>)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!object) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> removeObjectForKey:key];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;_lock);</span><br><span class=\"line\">    _YYLinkedMapNode *node = <span class=\"built_in\">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)(key));</span><br><span class=\"line\">    <span class=\"built_in\">NSTimeInterval</span> now = <span class=\"built_in\">CACurrentMediaTime</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 判断节点是否存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">    \t\t<span class=\"comment\">// 存在更新节点，并移动至头节点</span></span><br><span class=\"line\">        _lru-&gt;_totalCost -= node-&gt;_cost;</span><br><span class=\"line\">        _lru-&gt;_totalCost += cost;</span><br><span class=\"line\">        node-&gt;_cost = cost;</span><br><span class=\"line\">        node-&gt;_time = now;</span><br><span class=\"line\">        node-&gt;_value = object;</span><br><span class=\"line\">        [_lru bringNodeToHead:node];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不存在，创建一个新的节点，插入头节点</span></span><br><span class=\"line\">        node = [_YYLinkedMapNode new];</span><br><span class=\"line\">        node-&gt;_cost = cost;</span><br><span class=\"line\">        node-&gt;_time = now;</span><br><span class=\"line\">        node-&gt;_key = key;</span><br><span class=\"line\">        node-&gt;_value = object;</span><br><span class=\"line\">        [_lru insertNodeAtHead:node];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_lru-&gt;_totalCost &gt; _costLimit) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">dispatch_async</span>(_queue, ^&#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> trimToCost:_costLimit];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_lru-&gt;_totalCount &gt; _countLimit) &#123;</span><br><span class=\"line\">        _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class=\"line\">            <span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">                [node <span class=\"keyword\">class</span>]; <span class=\"comment\">//hold and release in queue</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                [node <span class=\"keyword\">class</span>]; <span class=\"comment\">//hold and release in queue</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;_lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当设置新节点时，判断节点是否存在，存在更新节点，并移动至头节点；不存在，创建一个新的节点，插入头节点。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子按照数量限制清扫</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)_trimToCount:(<span class=\"built_in\">NSUInteger</span>)countLimit &#123;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> finish = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (countLimit == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        [_lru removeAll];</span><br><span class=\"line\">        finish = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_lru-&gt;_totalCount &lt;= countLimit) &#123;</span><br><span class=\"line\">        finish = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (finish) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *holder = [<span class=\"built_in\">NSMutableArray</span> new];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!finish) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pthread_mutex_trylock(&amp;_lock) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_lru-&gt;_totalCount &gt; countLimit) &#123;</span><br><span class=\"line\">            \t  <span class=\"comment\">// 当缓存数量超出限制的时候，先从尾节点（LRU）开始清除，释放资源</span></span><br><span class=\"line\">                _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node) [holder addObject:node];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                finish = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pthread_mutex_unlock(&amp;_lock);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用 usleep 以微秒为单位挂起线程，在短时间间隔挂起线程</span></span><br><span class=\"line\">            <span class=\"comment\">// 对比 sleep 用 usleep 能更好的利用 CPU 时间</span></span><br><span class=\"line\">            usleep(<span class=\"number\">10</span> * <span class=\"number\">1000</span>); <span class=\"comment\">//10 ms</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (holder.count) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否在主线程释放对象</span></span><br><span class=\"line\">        <span class=\"built_in\">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class=\"line\">        <span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">            [holder count]; <span class=\"comment\">// release in queue</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>清除的代码其实不是太难，YYCache 从 count 、cost 和 age 三个维度去做清除工作，具体请去查阅源码。</p>\n<p>在代码底部判断是否在主线程释放资源，是作者另一篇文章<a href=\"https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"noopener\">iOS 保持界面流畅的技巧</a>中提到：</p>\n<blockquote>\n<p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *tmp = <span class=\"keyword\">self</span>.array;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.array = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">    [tmp <span class=\"keyword\">class</span>];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"YYDiskCache\"><a href=\"#YYDiskCache\" class=\"headerlink\" title=\"YYDiskCache\"></a>YYDiskCache</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> YYDiskCache 是一个线程安全的磁盘缓存，用于存储由 SQLite 和文件系统支持的键值对（类似于 NSURLCache 的磁盘缓存）。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">YYDiskCache 具有以下功能：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">* 它使用 LRU(least-recently-used) 来删除对象。</span></span><br><span class=\"line\"><span class=\"comment\">* 支持按 cost，count 和 age 进行控制。</span></span><br><span class=\"line\"><span class=\"comment\">* 它可以被配置为当没有可用的磁盘空间时自动驱逐缓存对象。</span></span><br><span class=\"line\"><span class=\"comment\">* 它可以自动抉择每个缓存对象的存储类型（sqlite/file）以便提供更好的性能表现。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">你可以编译最新版本的 sqlite 并忽略 iOS 系统中的 libsqlite3.dylib 来获得 2x〜4x 的速度提升</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYDiskCache</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Attribute</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> The name of the cache. Default is nil.</span></span><br><span class=\"line\"><span class=\"comment\"> 磁盘cache的名称</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> The path of the cache (read-only).</span></span><br><span class=\"line\"><span class=\"comment\"> 磁盘cache的文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果存入的消息超过此值，则消息会存入文件file，否则存入sqlite</span></span><br><span class=\"line\"><span class=\"comment\"> 0 意味着所有的消息会存入不同的文件file, NSUIntegerMax 意味着所有的消息会存入 sqlite.</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 20480 (20KB).</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSUInteger</span> inlineThreshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果block为nil 则会使用NSKeyedArchiver归档消息 使用此block以支持未遵循`NSCoding` 协议的对象存储</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值为nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSData</span> *(^customArchiveBlock)(<span class=\"keyword\">id</span> object);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> block不为nil则使用自定义的解归档方法替代 NSKeyedUnarchiver. 使用此block以支持未遵循`NSCoding` 协议的对象</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值为nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"keyword\">id</span> (^customUnarchiveBlock)(<span class=\"built_in\">NSData</span> *data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 当需要写文件时, block 会生成文件名和一个key，如果block是nil 则cache使用MD5生成默认的文件名</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值为nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *(^customFileNameBlock)(<span class=\"built_in\">NSString</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Limit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子cache中存储的最大数量</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 NSUIntegerMax 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> countLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子cache中容许的最大开销</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 NSUIntegerMax 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> costLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息池子cache中容许的时间限制</span></span><br><span class=\"line\"><span class=\"comment\"> 默认的值为 DBL_MAX 表示无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 它并不是一个严格的限制 - 如果缓存超过限制，那么一些缓存对象就会在后台队列中被回收。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span> ageLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> cache保证的最小磁盘disk空闲</span></span><br><span class=\"line\"><span class=\"comment\"> 默认值为 0, 意味着无限制</span></span><br><span class=\"line\"><span class=\"comment\"> 如果disk空闲容量小于此值，将移除对象释放内存</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> freeDiskSpaceLimit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 自动检测容器限制 默认时间60.0s</span></span><br><span class=\"line\"><span class=\"comment\"> cache消息池子持有Timer,以确保cache是否达到上限 如果达到上限则进行削减</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span> autoTrimInterval;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置`YES` 容许错误log</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> errorLogsEnabled;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Initializer</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据path实例化磁盘cache对象</span></span><br><span class=\"line\"><span class=\"comment\"> path cache写入消息的全路径 实例化后，不要在此路径读写数据</span></span><br><span class=\"line\"><span class=\"comment\"> 返回 cache 对象, 如果发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> 如果path已经存在内存中，则会直接返回cache对象 取代创建对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithPath:(<span class=\"built_in\">NSString</span> *)path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 推荐的实例化方法</span></span><br><span class=\"line\"><span class=\"comment\"> path cache写入消息的全路径 实例化后，不要在此路径读写数据</span></span><br><span class=\"line\"><span class=\"comment\"> threshold  存入数据尺寸的限制. 如果存入sqlite数据字节数超过此值 则会写入文件,</span></span><br><span class=\"line\"><span class=\"comment\"> 0 意味着所有的消息会存入不同的文件file, NSUIntegerMax 意味着所有的消息会存入 sqlite 推荐值为20480</span></span><br><span class=\"line\"><span class=\"comment\"> 返回 cache 对象, 如果发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> 如果path已经存在内存中，则会直接返回cache对象 取代创建对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithPath:(<span class=\"built_in\">NSString</span> *)path</span><br><span class=\"line\">                      inlineThreshold:(<span class=\"built_in\">NSUInteger</span>)threshold <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Access Methods</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回一个boolean 表示给定的key是否存在disk的cache中 此方法会堵塞直到返回</span></span><br><span class=\"line\"><span class=\"comment\"> key 标识消息对象的key 如果为nil 则返回NO</span></span><br><span class=\"line\"><span class=\"comment\"> 返回key是否存在cache中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)containsObjectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回一个boolean 表示给定的key是否存在disk的cache中 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> key   标识消息对象的key 如果为nil 则返回NO</span></span><br><span class=\"line\"><span class=\"comment\"> block 在后台线程执行完成后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)containsObjectForKey:(<span class=\"built_in\">NSString</span> *)key withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSString</span> *key, <span class=\"built_in\">BOOL</span> contains))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回指定key对应的消息 此方法会堵塞直到返回</span></span><br><span class=\"line\"><span class=\"comment\"> key 标识消息对象的key 如果为nil 则返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> 返回key对应的, 如果未找到，则返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)objectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回指定key对应的消息  此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> key 标识消息对象的key 如果为nil 则返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> block 在后台线程执行完成后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)objectForKey:(<span class=\"built_in\">NSString</span> *)key withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSString</span> *key, <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt; _Nullable object))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将消息和对应的key值存入cache中 此方法会堵塞直到写入数据完成</span></span><br><span class=\"line\"><span class=\"comment\"> object 存入cache中的消息对象. 如果是nil则会调用`removeObjectForKey:`.</span></span><br><span class=\"line\"><span class=\"comment\"> key    和消息对象关联的key. 如果为nil则不会操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)object forKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将消息和对应的key值存入cache中 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> object 存入cache中的消息对象. 如果是nil则会调用`removeObjectForKey:`.</span></span><br><span class=\"line\"><span class=\"comment\"> key    和消息对象关联的key. 如果为nil则不会操作</span></span><br><span class=\"line\"><span class=\"comment\"> block  在后台执行完后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)object forKey:(<span class=\"built_in\">NSString</span> *)key withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除cache中指定key对应的消息 此方法会堵塞直到文件删除完成</span></span><br><span class=\"line\"><span class=\"comment\"> key 标识删除对象的key 如果为nil则不会操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除cache中指定key对应的消息 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> key 标识删除对象的key 如果为nil则不会操作</span></span><br><span class=\"line\"><span class=\"comment\"> block  在后台执行完后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSString</span> *key))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除cache中所有的对象 此方法会堵塞直到cache清除完成</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeAllObjects;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除cache中所有的对象 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> block  在后台执行完后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeAllObjectsWithBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除cache中所有的对象 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> 不要在block中对该对象发送消息</span></span><br><span class=\"line\"><span class=\"comment\"> progress 删除过程中执行, nil的话忽略</span></span><br><span class=\"line\"><span class=\"comment\"> end      删除完成后执行, nil的话忽略</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeAllObjectsWithProgressBlock:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span>(^)(<span class=\"keyword\">int</span> removedCount, <span class=\"keyword\">int</span> totalCount))progress</span><br><span class=\"line\">                                 endBlock:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span>(^)(<span class=\"built_in\">BOOL</span> error))end;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回cache中的消息总数量 此方法会堵塞直到读取完成</span></span><br><span class=\"line\"><span class=\"comment\"> 返回消息总数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSInteger</span>)totalCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取cache中的消息总数量 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> block  在后台执行完后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)totalCountWithBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSInteger</span> totalCount))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回cache中的消息总开销（字节） 此方法会堵塞直到读取完成</span></span><br><span class=\"line\"><span class=\"comment\"> 返回消息总开销（字节）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSInteger</span>)totalCost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 返回cache中的消息总开销（字节）此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> block  在后台执行完后的回调block</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)totalCostWithBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSInteger</span> totalCost))block;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Trim</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 一旦 `totalCount` 高于总数限制，则删除消息 将LRU对象放入缓存区 此方法会堵塞直到完成</span></span><br><span class=\"line\"><span class=\"comment\"> count  清除消息后容许的消息总数量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCount:(<span class=\"built_in\">NSUInteger</span>)count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 一旦 `totalCount` 高于总数限制，则删除消息 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> count  清除消息后容许的消息总数量</span></span><br><span class=\"line\"><span class=\"comment\"> block 完成后的回调</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCount:(<span class=\"built_in\">NSUInteger</span>)count withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 一旦 `totalCount` 高于总开销限制，则删除消息 将LRU对象放入缓存区 此方法会堵塞直到完成</span></span><br><span class=\"line\"><span class=\"comment\"> count  清除消息后容许的消息总开销</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCost:(<span class=\"built_in\">NSUInteger</span>)cost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 一旦 `totalCount` 高于总开销限制，则删除消息 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> count  清除消息后容许的消息总开销</span></span><br><span class=\"line\"><span class=\"comment\"> block 完成后的回调</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToCost:(<span class=\"built_in\">NSUInteger</span>)cost withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 按照时间限制削减 （LRU对象进入缓冲区）此方法会堵塞</span></span><br><span class=\"line\"><span class=\"comment\"> age  最大的时间 seconds.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToAge:(<span class=\"built_in\">NSTimeInterval</span>)age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 一旦 按照时间限制削减 将LRU对象放入缓存区 此方法会立即返回，并在后台线程中执行，直到执行完成调用block回调</span></span><br><span class=\"line\"><span class=\"comment\"> age  最大的时间 seconds.</span></span><br><span class=\"line\"><span class=\"comment\"> block 完成后的回调</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)trimToAge:(<span class=\"built_in\">NSTimeInterval</span>)age withBlock:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Extended Data</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取消息的拓展数据</span></span><br><span class=\"line\"><span class=\"comment\"> 详见'setExtendedData:toObject:'</span></span><br><span class=\"line\"><span class=\"comment\"> object 消息对象</span></span><br><span class=\"line\"><span class=\"comment\"> 拓展数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)getExtendedDataFromObject:(<span class=\"keyword\">id</span>)object;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 设置消息的拓展数据</span></span><br><span class=\"line\"><span class=\"comment\"> 当保存消息到cache之前可以设置消息的拓展数据 拓展数据会同样存入cache中 你可以使用\"getExtendedDataFromObject:\"获取拓展数据</span></span><br><span class=\"line\"><span class=\"comment\"> extendedData 拓展数据 (如果是nil 则删除数据)</span></span><br><span class=\"line\"><span class=\"comment\"> object       对应的消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)setExtendedData:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)extendedData toObject:(<span class=\"keyword\">id</span>)object;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>👆是 YYDiskCache 的接口和属性，我都加上了注释。</p>\n<p>YYDiskCache 是分成 sqlite 和 file 存储的，作者设计的时候是根据文件大小来划分存储方式：</p>\n<ul>\n<li>sqlite: 对于小数据（例如 NSNumber）的存取效率明显高于 file。</li>\n<li>file: 对于较大数据（例如高质量图片）的存取效率优于 sqlite。</li>\n</ul>\n<p>YYDiskCache 使用两个相互配合的方式提高存储性能。</p>\n<h3 id=\"YYDiskCacheGetGlobal-和-YYDiskCacheSetGlobal\"><a href=\"#YYDiskCacheGetGlobal-和-YYDiskCacheSetGlobal\" class=\"headerlink\" title=\"_YYDiskCacheGetGlobal 和 _YYDiskCacheSetGlobal\"></a>_YYDiskCacheGetGlobal 和 _YYDiskCacheSetGlobal</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithPath:(<span class=\"built_in\">NSString</span> *)path</span><br><span class=\"line\">             inlineThreshold:(<span class=\"built_in\">NSUInteger</span>)threshold &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);</span><br><span class=\"line\">    ```</span><br></pre></td></tr></table></figure>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">根据公开初始化方法初始化 YYDiskCache 时，发现内部是调用静态方法去创建实例：</span><br><span class=\"line\"></span><br><span class=\"line\">```objc</span><br><span class=\"line\">/**</span><br><span class=\"line\"> Map表保存cache实例，管理所有根据 path 创建的 YYDiskCache 实例</span><br><span class=\"line\"> */</span><br><span class=\"line\">static NSMapTable *_globalInstances;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> 线程信号</span><br><span class=\"line\"> */</span><br><span class=\"line\">static dispatch_semaphore_t _globalInstancesLock;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 静态变量实例化</span><br><span class=\"line\"> */</span><br><span class=\"line\">static void _YYDiskCacheInitGlobal() &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        // 初始化信号量</span><br><span class=\"line\">        _globalInstancesLock = dispatch_semaphore_create(1);</span><br><span class=\"line\">        // 创建 NSMapTable，Key 强引用，Value 弱引用</span><br><span class=\"line\">        _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 获取 NSMapTable 中的 YYDiskCache 实例</span><br><span class=\"line\"> */</span><br><span class=\"line\">static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123;</span><br><span class=\"line\">    if (path.length == 0) return nil;</span><br><span class=\"line\">    _YYDiskCacheInitGlobal();</span><br><span class=\"line\">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">    // 通过 NSMapTable 获取 YYDiskCache</span><br><span class=\"line\">    id cache = [_globalInstances objectForKey:path];</span><br><span class=\"line\">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class=\"line\">    return cache;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 设置 NSMapTable 中的 YYDiskCache 实例，key 值为 cache 路径</span><br><span class=\"line\"> */</span><br><span class=\"line\">static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123;</span><br><span class=\"line\">    if (cache.path.length == 0) return;</span><br><span class=\"line\">    _YYDiskCacheInitGlobal();</span><br><span class=\"line\">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">    // 通过 NSMapTable 设置 YYDiskCache</span><br><span class=\"line\">    [_globalInstances setObject:cache forKey:cache.path];</span><br><span class=\"line\">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>👆代码里面创建 YYDiskCache 的时候使用了 <strong>NSMapTable</strong> 来保存实例对象，并且创建的过程都有加上<strong>信号锁</strong>。</p>\n<p>它是 iOS 6 才引入的数据结构集合，用法类似 NSDictionary，但是<strong>它可以对 Value 弱引用</strong>。关于 NSMapTable 更多的语义和使用参考<a href=\"https://www.jianshu.com/p/dcd222900fa9\" target=\"_blank\" rel=\"noopener\">《iOS中的NSHashTable和NSMapTable》</a> 和 <a href=\"https://developer.apple.com/documentation/foundation/nsmaptable?language=objc\" target=\"_blank\" rel=\"noopener\">《NSMapTable 官方文档》</a>。</p>\n<p>每当一个 YYDiskCache 被初始化时，其实会先到 NSMapTable 中获取对应 path 的 YYDiskCache 实例，如果获取不到才会去真正的初始化一个 YYDiskCache 实例，并且将其引用在 NSMapTable 中，这样做提升不少性能。</p>\n<blockquote>\n<p>Note：dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p>\n</blockquote>\n<h3 id=\"YYKVStorageItem-和-YYKVStorage\"><a href=\"#YYKVStorageItem-和-YYKVStorage\" class=\"headerlink\" title=\"YYKVStorageItem 和 YYKVStorage\"></a>YYKVStorageItem 和 YYKVStorage</h3><p>由于 YYDiskCache 有时候是操作 sqlite ，有时候是操作 file，所以使用 YYKVStorage 来统一管理缓存对象（sqlite/file），YYKVStorage 其实就是对应着 _YYLinkedMap，YYKVStorageItem 对应 _YYLinkedMapNode。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> YYKVStorageItem 用来存储键值对数据及拓展数据，通常不应该直接使用它</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYKVStorageItem</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息key值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *key;                <span class=\"comment\">///&lt; key</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息data数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSData</span> *value;                <span class=\"comment\">///&lt; value</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息文件名</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *filename; <span class=\"comment\">///&lt; filename (nil if inline)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息大小（字节）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">int</span> size;                             <span class=\"comment\">///&lt; value's size in bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息修改时间</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">int</span> modTime;                          <span class=\"comment\">///&lt; modification unix timestamp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息导入时间</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">int</span> accessTime;                       <span class=\"comment\">///&lt; last access unix timestamp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 拓展数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSData</span> *extendedData; <span class=\"comment\">///&lt; extended data (nil if no extended data)</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息存储类型，表示存储“YYKVStorageItem.value”的位置。</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> 一般而言,数据存入sqlite比写文件更快，但读取数据的性能依赖数据大小 以iPhone 6 64G为例</span></span><br><span class=\"line\"><span class=\"comment\"> 数据超过20KB，则从文件读取数据比sqlite读取更快</span></span><br><span class=\"line\"><span class=\"comment\"> 存储较小的数据使用 YYKVStorageTypeSQLite 获得更好的性能</span></span><br><span class=\"line\"><span class=\"comment\"> 如果存储较大的数据 如图片数据, 使用 YYKVStorageTypeFile 获取更好的性能</span></span><br><span class=\"line\"><span class=\"comment\"> 使用 LSMessageDiskStorageTypeMixed 将针对每一个item采用不同的存储方式</span></span><br><span class=\"line\"><span class=\"comment\"> 详见 http://www.sqlite.org/intern-v-extern-blob.html</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, YYKVStorageType) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// The `value` is stored as a file in file system.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 消息存入文件</span></span><br><span class=\"line\">    YYKVStorageTypeFile = <span class=\"number\">0</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// The `value` is stored in sqlite with blob type.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 消息存入sqlite，采用blob的类型</span></span><br><span class=\"line\">    YYKVStorageTypeSQLite = <span class=\"number\">1</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// The `value` is stored in file system or sqlite based on your choice.</span></span><br><span class=\"line\">    <span class=\"comment\">/// 根据选择选取存入方式</span></span><br><span class=\"line\">    YYKVStorageTypeMixed = <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> 消息写入file/sqlite的管理类</span></span><br><span class=\"line\"><span class=\"comment\"> @discussion 键值对的方式将消息存入文件和sqlite 使用`initWithPath:type:`进行初始化</span></span><br><span class=\"line\"><span class=\"comment\"> 初始化后 不要再对生成的path进行读写操作 使用最新的sqlite版本获取2-4倍的速度提升</span></span><br><span class=\"line\"><span class=\"comment\"> 产生的实例并不是线程安全的，应该在同一时间在同一的线程使用，数据较大时，应该对数据进行拆分成多个片段进行存储</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYKVStorage</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Attribute</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息存入的路径</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *path;        <span class=\"comment\">///&lt; The path of this storage.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 消息存储类型</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) YYKVStorageType type;  <span class=\"comment\">///&lt; The type of this storage.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 是否打印log</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> errorLogsEnabled;           <span class=\"comment\">///&lt; Set `YES` to enable error logs for debug.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - 初始化</span></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 推荐的实例化方法</span></span><br><span class=\"line\"><span class=\"comment\"> path  写数据的路径. 如果路径存在，则会在此路径读写数据 否则建立一个新路径</span></span><br><span class=\"line\"><span class=\"comment\"> type  存储类型  一旦设置后不要修改</span></span><br><span class=\"line\"><span class=\"comment\"> 返回一个存储管理实例, 发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> 多个实例操作同一个路径 会导致错误</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithPath:(<span class=\"built_in\">NSString</span> *)path type:(YYKVStorageType)type <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - 保存消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 保存item key值存在时更新item</span></span><br><span class=\"line\"><span class=\"comment\"> @discussion 此方法会将 item.key, item.value, item.filename 和</span></span><br><span class=\"line\"><span class=\"comment\"> item.extendedData 写入文件或sqlite, 其他属性会忽略. item.key</span></span><br><span class=\"line\"><span class=\"comment\"> 和 item.value 不应该为空 (nil || length == 0).</span></span><br><span class=\"line\"><span class=\"comment\"> item  消息item</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)saveItem:(YYKVStorageItem *)item;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 保存item key值存在时更新item</span></span><br><span class=\"line\"><span class=\"comment\"> 此方法会保存键值对到 sqlite. 如果存储类型为 YYKVStorageTypeFile , 此方法会失败</span></span><br><span class=\"line\"><span class=\"comment\"> key   key值不能为空</span></span><br><span class=\"line\"><span class=\"comment\"> value value不能为空</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)saveItemWithKey:(<span class=\"built_in\">NSString</span> *)key value:(<span class=\"built_in\">NSData</span> *)value;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 保存item key值存在时更新item</span></span><br><span class=\"line\"><span class=\"comment\"> 如果写入类型为LSMessageDiskStorageTypeFile,filename 不能为空</span></span><br><span class=\"line\"><span class=\"comment\"> 如果写入类型为LSMessageDiskStorageTypeSQLite, filename 会被忽略</span></span><br><span class=\"line\"><span class=\"comment\"> 如果写入类型为LSMessageDiskStorageTypeMixed, 如果filename不为空 则value会被存入文件 否则存入sqlite</span></span><br><span class=\"line\"><span class=\"comment\"> key           key值不能为空</span></span><br><span class=\"line\"><span class=\"comment\"> value         value不能为空</span></span><br><span class=\"line\"><span class=\"comment\"> filename      文件名</span></span><br><span class=\"line\"><span class=\"comment\"> extendedData  item的拓展数据 如果是nil则忽略</span></span><br><span class=\"line\"><span class=\"comment\"> Whether succeed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)saveItemWithKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\">                  value:(<span class=\"built_in\">NSData</span> *)value</span><br><span class=\"line\">               filename:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSString</span> *)filename</span><br><span class=\"line\">           extendedData:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)extendedData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - 删除消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> 根据key值删除item</span></span><br><span class=\"line\"><span class=\"comment\"> keys 特定的key值</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据keys数组删除items</span></span><br><span class=\"line\"><span class=\"comment\"> keys keys数组</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据消息value的开销限制删除items</span></span><br><span class=\"line\"><span class=\"comment\"> size 消息value的最大限制</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemsLargerThanSize:(<span class=\"keyword\">int</span>)size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除比指定时间更早存入的消息</span></span><br><span class=\"line\"><span class=\"comment\"> time  指定的时间</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemsEarlierThanTime:(<span class=\"keyword\">int</span>)time;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据消息开销限制删除items (LRU对象优先删除)</span></span><br><span class=\"line\"><span class=\"comment\"> maxCount 最大的消息开销</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemsToFitSize:(<span class=\"keyword\">int</span>)maxSize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据消息数量限制删除items (LRU对象优先删除)</span></span><br><span class=\"line\"><span class=\"comment\"> maxCount 最大的消息数量</span></span><br><span class=\"line\"><span class=\"comment\"> 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeItemsToFitCount:(<span class=\"keyword\">int</span>)maxCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 在后台队列中，删除所有的item</span></span><br><span class=\"line\"><span class=\"comment\"> @discussion 此方法会删除 files 和 sqlite database 进入回收站 并在后台清除回收站数据</span></span><br><span class=\"line\"><span class=\"comment\"> 比`removeAllItemsWithProgressBlock:endBlock:`方法更快</span></span><br><span class=\"line\"><span class=\"comment\"> @return 返回是否删除成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)removeAllItems;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 删除所有的item</span></span><br><span class=\"line\"><span class=\"comment\"> @warning 在block中不要对该实例发送消息</span></span><br><span class=\"line\"><span class=\"comment\"> progress 删除时执行的block，nil则不执行</span></span><br><span class=\"line\"><span class=\"comment\"> end      删除结束执行的block，nil则不执行</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeAllItemsWithProgressBlock:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span>(^)(<span class=\"keyword\">int</span> removedCount, <span class=\"keyword\">int</span> totalCount))progress</span><br><span class=\"line\">                               endBlock:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span>(^)(<span class=\"built_in\">BOOL</span> error))end;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - 获取消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key获取item</span></span><br><span class=\"line\"><span class=\"comment\"> key  特定的key值</span></span><br><span class=\"line\"><span class=\"comment\"> 返回item, 发送错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> YYKVStorageItem *)getItemForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key获取item的信息（value会被忽略）</span></span><br><span class=\"line\"><span class=\"comment\"> key  特定的key值</span></span><br><span class=\"line\"><span class=\"comment\"> 返回item的信息, 发送错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> YYKVStorageItem *)getItemInfoForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key获取item的value</span></span><br><span class=\"line\"><span class=\"comment\"> key  特定的key值</span></span><br><span class=\"line\"><span class=\"comment\"> 返回item的value, 发送错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSData</span> *)getItemValueForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key的数组获取item的信息</span></span><br><span class=\"line\"><span class=\"comment\"> keys  key值的数组</span></span><br><span class=\"line\"><span class=\"comment\"> 包含`YYKVStorageItem`的数组 发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSArray</span>&lt;YYKVStorageItem *&gt; *)getItemForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key的数组获取item的信息（value会被忽略）</span></span><br><span class=\"line\"><span class=\"comment\"> keys  key值的数组</span></span><br><span class=\"line\"><span class=\"comment\"> 包含`LSMessageDiskStorageItem`的数组 发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSArray</span>&lt;YYKVStorageItem *&gt; *)getItemInfoForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据一个key值数组获取item和key的字典</span></span><br><span class=\"line\"><span class=\"comment\"> keys  key值的数组</span></span><br><span class=\"line\"><span class=\"comment\"> 返回一个字典 key-&gt;item对应 发生错误返回nil</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"built_in\">NSData</span> *&gt; *)getItemValueForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - 获取存储属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 根据key值查找item是否存在</span></span><br><span class=\"line\"><span class=\"comment\"> key  特定的key</span></span><br><span class=\"line\"><span class=\"comment\"> 返回item是否存在</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)itemExistsForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取item的总数</span></span><br><span class=\"line\"><span class=\"comment\"> 返回总数，如果发生错误返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">int</span>)getItemsCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 获取items的总大小（字节）</span></span><br><span class=\"line\"><span class=\"comment\"> 返回总大小，如果发生错误返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">int</span>)getItemsSize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>当 YYDiskCache 存储对象的时候，会判断存储数据库的文件大小最大阈值，超过了会生成文件名，写入文件，然后将文件名存储到 sqlite 中。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// YYDiskCache.m</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt;)object forKey:(<span class=\"built_in\">NSString</span> *)key &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!object) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> removeObjectForKey:key];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *extendedData = [YYDiskCache getExtendedDataFromObject:object];</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *value = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_customArchiveBlock) &#123;</span><br><span class=\"line\">        value = _customArchiveBlock(object);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\">            value = [<span class=\"built_in\">NSKeyedArchiver</span> archivedDataWithRootObject:object];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">@catch</span> (<span class=\"built_in\">NSException</span> *exception) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// nothing to do...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!value) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *filename = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_kv.type != YYKVStorageTypeSQLite) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果超过数据库写入大小限制，生成文件名</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value.length &gt; _inlineThreshold) &#123;</span><br><span class=\"line\">            filename = [<span class=\"keyword\">self</span> _filenameForKey:key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Lock();</span><br><span class=\"line\">    [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData];</span><br><span class=\"line\">    Unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// YYKVStorage.m</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 保存item key值存在时更新item</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)saveItemWithKey:(<span class=\"built_in\">NSString</span> *)key value:(<span class=\"built_in\">NSData</span> *)value filename:(<span class=\"built_in\">NSString</span> *)filename extendedData:(<span class=\"built_in\">NSData</span> *)extendedData &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 没有 Key，也没有 Value 直接返回 NO</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key.length == <span class=\"number\">0</span> || value.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 存文件，但是没有文件名，也直接返回 NO</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_type == YYKVStorageTypeFile &amp;&amp; filename.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filename.length) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 写文件失败，返回 NO</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> _fileWriteWithName:filename data:value]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将文件名写入数据库，之后方便根据 Key 去查找文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果写入数据库失败，把之前写入的文件删除</span></span><br><span class=\"line\">            [<span class=\"keyword\">self</span> _fileDeleteWithName:filename];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_type != YYKVStorageTypeSQLite) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSString</span> *filename = [<span class=\"keyword\">self</span> _dbGetFilenameWithKey:key];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (filename) &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span> _fileDeleteWithName:filename];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> _dbSaveWithKey:key value:value fileName:<span class=\"literal\">nil</span> extendedData:extendedData];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"YYKVStorage-性能优化细节\"><a href=\"#YYKVStorage-性能优化细节\" class=\"headerlink\" title=\"YYKVStorage 性能优化细节\"></a>YYKVStorage 性能优化细节</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFMutableDictionaryRef</span> _dbStmtCache;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> db设置sqlite3_stmt</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (sqlite3_stmt *)_dbPrepareStmt:(<span class=\"built_in\">NSString</span> *)sql &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![<span class=\"keyword\">self</span> _dbCheck] || sql.length == <span class=\"number\">0</span> || !_dbStmtCache) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 先尝试从 _dbStmtCache 根据入参 sql 取出已缓存 sqlite3_stmt</span></span><br><span class=\"line\">    sqlite3_stmt *stmt = (sqlite3_stmt *)<span class=\"built_in\">CFDictionaryGetValue</span>(_dbStmtCache, (__bridge <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)(sql));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!stmt) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有缓存再从新生成一个 sqlite3_stmt</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = sqlite3_prepare_v2(_db, sql.UTF8String, <span class=\"number\">-1</span>, &amp;stmt, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 生成结果异常则根据错误日志开启标识打印日志</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != SQLITE_OK) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_errorLogsEnabled) <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s line:%d sqlite stmt prepare error (%d): %s\"</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 生成成功则放入 _dbStmtCache 缓存</span></span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(_dbStmtCache, (__bridge <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *)(sql), stmt);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        sqlite3_reset(stmt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stmt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次操作 sqlite 的时候，都有调用 _dbPrepareStmt 方法获取 sqlite3_stmt 缓存，sqlite3_stmt 保存在 _dbStmtCache 字典中，每次都先从字典里面获取缓存，这样不需要重复生成 sqlite3_stmt。</p>\n<blockquote>\n<p>sqlite3_stmt: 该对象的实例表示已经编译成二进制形式并准备执行的单个 SQL 语句。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>YYCache 的设计相当清晰，功能相当强大，具备了优秀缓存的能力：</p>\n<ul>\n<li>内存缓存和磁盘缓存</li>\n<li>线程安全</li>\n<li>缓存控制</li>\n<li>缓存替换策略</li>\n<li>性能</li>\n</ul>\n<h3 id=\"内存缓存和磁盘缓存\"><a href=\"#内存缓存和磁盘缓存\" class=\"headerlink\" title=\"内存缓存和磁盘缓存\"></a>内存缓存和磁盘缓存</h3><p>内存缓存 YYMemoryCache 与磁盘缓存 YYDiskCache 相互配合组成的，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。这样的设计支持用户在缓存不同对象时都能够有很好的体验。</p>\n<p>在 YYCache 中使用接口访问缓存对象时，会先去尝试从内存缓存 YYMemoryCache 中访问，如果访问不到（没有使用该 key 缓存过对象或者该对象已经从容量有限的 YYMemoryCache 中淘汰掉）才会去从 YYDiskCache 访问，如果访问到（表示之前确实使用该 key 缓存过对象，该对象已经从容量有限的 YYMemoryCache 中淘汰掉成立）会先在 YYMemoryCache 中更新一次该缓存对象的访问信息之后才返回给接口。</p>\n<h3 id=\"线程安全-1\"><a href=\"#线程安全-1\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>YYMemoryCache 使用了 pthread_mutex 线程锁来确保线程安全，而 YYDiskCache 则选择了更适合它的 dispatch_semaphore</p>\n<h3 id=\"缓存控制\"><a href=\"#缓存控制\" class=\"headerlink\" title=\"缓存控制\"></a>缓存控制</h3><p>提供了 cost、count、age 三个维度去控制缓存，满足绝大多数的需求。</p>\n<h3 id=\"缓存替换策略\"><a href=\"#缓存替换策略\" class=\"headerlink\" title=\"缓存替换策略\"></a>缓存替换策略</h3><p>使用了 LRU(least-recently-used) 策略去提高缓存效率。</p>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>从上面的分析就可以看出来了：</p>\n<ul>\n<li>异步释放缓存对象</li>\n<li>锁的选择</li>\n<li>使用 NSMapTable 单例管理的 YYDiskCache</li>\n<li>YYKVStorage 中的 _dbStmtCache</li>\n<li>使用 CoreFoundation 来换取手动释放内存提高效率</li>\n</ul>\n<p><a href=\"https://github.com/piglikeYoung/YYCache\" target=\"_blank\" rel=\"noopener\">YYCache</a> 这个是我 fork 的库，加了一些代码注释，可以参考下。</p>\n"}],"PostAsset":[{"_id":"source/_posts/AFNetworking-Summary-1/Snip20170107_1.png","slug":"Snip20170107_1.png","post":"cjseuc7kk000a8jpbihq7uv7s","modified":1,"renderable":0},{"_id":"source/_posts/Using-Grand-Central-Dispatch-2/Snip20161005_1.png","slug":"Snip20161005_1.png","post":"cjseuc7o5004o8jpbtq6bcp6m","modified":1,"renderable":0},{"_id":"source/_posts/use-UIActivityItemSource/WX20170513_234019.png","slug":"WX20170513_234019.png","post":"cjseuc7lu002d8jpb4q8hbhft","modified":1,"renderable":0},{"_id":"source/_posts/modify-mutable-array/Snip20160911_1.png","slug":"Snip20160911_1.png","post":"cjseuc7lf001t8jpbpuiqyv0k","modified":1,"renderable":0},{"_id":"source/_posts/2019-02-16-ARTS/2019-02-16-ARTS-1@2x.png","post":"cjseuc7kh00068jpbqw0ojbgh","slug":"2019-02-16-ARTS-1@2x.png","modified":1,"renderable":1},{"_id":"source/_posts/Learn-ReactNative-1/Snip20170305_2.png","post":"cjseuc7ks000h8jpb1b0x70t5","slug":"Snip20170305_2.png","modified":1,"renderable":1},{"_id":"source/_posts/bool-BOOL/Snip20170305_1.png","post":"cjseuc7l8001b8jpbff2s4ojs","slug":"Snip20170305_1.png","modified":1,"renderable":1},{"_id":"source/_posts/moya-analysis-1/WechatIMG32.jpeg","post":"cjseuc7lh001x8jpb30tq6mlh","slug":"WechatIMG32.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/nsstring-cropped/emoji-substring-error.jpg","post":"cjseuc7li00208jpb9xe69nlu","slug":"emoji-substring-error.jpg","modified":1,"renderable":1},{"_id":"source/_posts/performWithoutAnimation-cancel-implicit-animation/Snip20160906_8.png","post":"cjseuc7ln002a8jpba4scfz13","slug":"Snip20160906_8.png","modified":1,"renderable":1},{"_id":"source/_posts/AFNetworking-Summary-1/Snip20170107_3.png","post":"cjseuc7kk000a8jpbihq7uv7s","slug":"Snip20170107_3.png","modified":1,"renderable":1},{"_id":"source/_posts/NSTimer-2/Snip20161127_2.png","slug":"Snip20161127_2.png","post":"cjseuc7kx000o8jpbefnpmfl0","modified":1,"renderable":0},{"_id":"source/_posts/NSTimer-2/Snip20161127_3.png","post":"cjseuc7kx000o8jpbefnpmfl0","slug":"Snip20161127_3.png","modified":1,"renderable":1},{"_id":"source/_posts/block-tips/Snip20160904_1.png","post":"cjseuc7l700188jpbb6jynqb5","slug":"Snip20160904_1.png","modified":1,"renderable":1},{"_id":"source/_posts/block-tips/Snip20160904_2.png","post":"cjseuc7l700188jpbb6jynqb5","slug":"Snip20160904_2.png","modified":1,"renderable":1},{"_id":"source/_posts/use-fastlane/WX20170514-140038.png","post":"cjseuc7m4002g8jpboap5sbvd","slug":"WX20170514-140038.png","modified":1,"renderable":1},{"_id":"source/_posts/use-fastlane/WX20170514-142857.png","post":"cjseuc7m4002g8jpboap5sbvd","slug":"WX20170514-142857.png","modified":1,"renderable":1},{"_id":"source/_posts/collect-tips/AVMakeRectWithAspectRatioInsideRect.jpeg","post":"cjseuc7lb001j8jpbk4d43fd0","slug":"AVMakeRectWithAspectRatioInsideRect.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/collect-tips/calculate-the-number-of-calls.jpg","post":"cjseuc7lb001j8jpbk4d43fd0","slug":"calculate-the-number-of-calls.jpg","modified":1,"renderable":1},{"_id":"source/_posts/collect-tips/debug-frame.gif","slug":"debug-frame.gif","post":"cjseuc7lb001j8jpbk4d43fd0","modified":1,"renderable":0},{"_id":"source/_posts/collect-tips/take-screenshot-fast.jpg","post":"cjseuc7lb001j8jpbk4d43fd0","slug":"take-screenshot-fast.jpg","modified":1,"renderable":1},{"_id":"source/_posts/collect-tips/take-screenshot.jpg","post":"cjseuc7lb001j8jpbk4d43fd0","slug":"take-screenshot.jpg","modified":1,"renderable":1},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_0.png","post":"cjseuc7l1000y8jpbi871cc0n","slug":"uidebugginginformationoverlay_0.png","modified":1,"renderable":1},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_VCHierarchy.jpeg","post":"cjseuc7l1000y8jpbi871cc0n","slug":"uidebugginginformationoverlay_VCHierarchy.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_ivarexplorer.jpeg","post":"cjseuc7l1000y8jpbi871cc0n","slug":"uidebugginginformationoverlay_ivarexplorer.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_measure2.jpeg","post":"cjseuc7l1000y8jpbi871cc0n","slug":"uidebugginginformationoverlay_measure2.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_speccompareoverlay.png","post":"cjseuc7l1000y8jpbi871cc0n","slug":"uidebugginginformationoverlay_speccompareoverlay.png","modified":1,"renderable":1},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_speccomparepicker.png","post":"cjseuc7l1000y8jpbi871cc0n","slug":"uidebugginginformationoverlay_speccomparepicker.png","modified":1,"renderable":1},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_viewhierarchy.png","post":"cjseuc7l1000y8jpbi871cc0n","slug":"uidebugginginformationoverlay_viewhierarchy.png","modified":1,"renderable":1},{"_id":"source/_posts/UIDebuggingInformationOverlay/uidebugginginformationoverlay_viewhierarchyinfo.png","post":"cjseuc7l1000y8jpbi871cc0n","slug":"uidebugginginformationoverlay_viewhierarchyinfo.png","modified":1,"renderable":1},{"_id":"source/_posts/learn-CALayer-2/AxialGradientLayerType.gif","slug":"AxialGradientLayerType.gif","post":"cjseuc7of004u8jpbdivgqwx8","modified":1,"renderable":0},{"_id":"source/_posts/AFNetworking-AFNetworkReachabilityManager-3/Snip20170125_3.png","post":"cjseuc7ns003v8jpb39vluf73","slug":"Snip20170125_3.png","modified":1,"renderable":1},{"_id":"source/_posts/Learn-ReactNative-4/WX20170501-114928@2x.png","post":"cjseuc7nz004b8jpbuege6njy","slug":"WX20170501-114928@2x.png","modified":1,"renderable":1},{"_id":"source/_posts/learn-CALayer-1/Snip20161029_1.png","post":"cjseuc7od004r8jpbvtrwsx2d","slug":"Snip20161029_1.png","modified":1,"renderable":1},{"_id":"source/_posts/Learn-ReactNative-3/box-model.gif","post":"cjseuc7ny00488jpb08azqm12","slug":"box-model.gif","modified":1,"renderable":1},{"_id":"source/_posts/Learn-ReactNative-3/flexBox-model.jpg","post":"cjseuc7ny00488jpb08azqm12","slug":"flexBox-model.jpg","modified":1,"renderable":1},{"_id":"source/_posts/NSTimer-1/Snip20161126_2.png","post":"cjseuc7o2004i8jpbxuwsekft","slug":"Snip20161126_2.png","modified":1,"renderable":1},{"_id":"source/_posts/NSTimer-1/Snip20161126_3.png","post":"cjseuc7o2004i8jpbxuwsekft","slug":"Snip20161126_3.png","modified":1,"renderable":1},{"_id":"source/_posts/learn-CALayer-2/CAGradientLayer-500x500.png","post":"cjseuc7of004u8jpbdivgqwx8","slug":"CAGradientLayer-500x500.png","modified":1,"renderable":1},{"_id":"source/_posts/learn-CALayer-2/CAReplicatorLayer.gif","post":"cjseuc7of004u8jpbdivgqwx8","slug":"CAReplicatorLayer.gif","modified":1,"renderable":1},{"_id":"source/_posts/learn-CALayer-3/evenodd.png","post":"cjseuc7og004y8jpbmzo2d79z","slug":"evenodd.png","modified":1,"renderable":1},{"_id":"source/_posts/learn-CALayer-3/lineCap.png","post":"cjseuc7og004y8jpbmzo2d79z","slug":"lineCap.png","modified":1,"renderable":1},{"_id":"source/_posts/learn-CALayer-3/lineJoin.png","post":"cjseuc7og004y8jpbmzo2d79z","slug":"lineJoin.png","modified":1,"renderable":1},{"_id":"source/_posts/learn-CALayer-3/nonzero.png","post":"cjseuc7og004y8jpbmzo2d79z","slug":"nonzero.png","modified":1,"renderable":1},{"_id":"source/_posts/GitHub-Pages-Hexo搭建博客/Snip20160831_1.png","slug":"Snip20160831_1.png","post":"cjseuc7nv00418jpbpl5zj52u","modified":1,"renderable":0},{"_id":"source/_posts/GitHub-Pages-Hexo搭建博客/Snip20160831_2.png","post":"cjseuc7nv00418jpbpl5zj52u","slug":"Snip20160831_2.png","modified":1,"renderable":1},{"_id":"source/_posts/GitHub-Pages-Hexo搭建博客/Snip20160901_1.png","post":"cjseuc7nv00418jpbpl5zj52u","slug":"Snip20160901_1.png","modified":1,"renderable":1},{"_id":"source/_posts/GitHub-Pages-Hexo搭建博客/Snip20160901_2.png","post":"cjseuc7nv00418jpbpl5zj52u","slug":"Snip20160901_2.png","modified":1,"renderable":1},{"_id":"source/_posts/GitHub-Pages-Hexo搭建博客/Snip20160902_4.png","post":"cjseuc7nv00418jpbpl5zj52u","slug":"Snip20160902_4.png","modified":1,"renderable":1},{"_id":"source/_posts/AFNetworking-AFURLSerialization-4/Snip20170126_3.png","slug":"Snip20170126_3.png","post":"cjseuc7pt005b8jpbzvsph2xx","modified":1,"renderable":0},{"_id":"source/_posts/AFNetworking-AFURLSessionManager-2/Snip20170125_1.png","post":"cjseuc7qe005n8jpbs2aqc7lc","slug":"Snip20170125_1.png","modified":1,"renderable":1},{"_id":"source/_posts/AFNetworking-AFURLSessionManager-2/Snip20170125_2.png","post":"cjseuc7qe005n8jpbs2aqc7lc","slug":"Snip20170125_2.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjseuc7k100008jpbu4w33xul","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7ko000d8jpbf8ox0uwf"},{"post_id":"cjseuc7k800018jpb2i6sp80u","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7kt000j8jpb17v1lv04"},{"post_id":"cjseuc7kn000b8jpbr8i06rku","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7kw000m8jpbe12gkwif"},{"post_id":"cjseuc7kp000f8jpbrb8zonfd","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7ky000p8jpb9o39gvlm"},{"post_id":"cjseuc7ke00048jpbeml7l18l","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7kz000t8jpb7dbv2ai4"},{"post_id":"cjseuc7kf00058jpb032b4b3p","category_id":"cjseuc7kt000i8jpb3xtx8wa8","_id":"cjseuc7l1000w8jpbzvjogftr"},{"post_id":"cjseuc7kx000o8jpbefnpmfl0","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7l200108jpbeav8pb1v"},{"post_id":"cjseuc7kz000s8jpbgcgogziy","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7l400138jpb8gitg84w"},{"post_id":"cjseuc7kh00068jpbqw0ojbgh","category_id":"cjseuc7ky000q8jpbbuwg0v5r","_id":"cjseuc7l600168jpbcn8fsbwg"},{"post_id":"cjseuc7l0000v8jpbrv1ltdhh","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7l8001a8jpb6mjdq6d5"},{"post_id":"cjseuc7l1000y8jpbi871cc0n","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7l9001d8jpbdsf6c4ry"},{"post_id":"cjseuc7kk000a8jpbihq7uv7s","category_id":"cjseuc7l1000x8jpbxjjumjzv","_id":"cjseuc7lb001h8jpbhifmgpvt"},{"post_id":"cjseuc7l300128jpbsb6jqxar","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7lc001l8jpbg2wclwr6"},{"post_id":"cjseuc7l400158jpbrgmwhlgu","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7ld001o8jpb3ehrrmm9"},{"post_id":"cjseuc7ks000h8jpb1b0x70t5","category_id":"cjseuc7l400148jpbiar5dv4o","_id":"cjseuc7le001r8jpb1atsib8l"},{"post_id":"cjseuc7ku000l8jpbejaoxhr7","category_id":"cjseuc7l9001c8jpbficrawsa","_id":"cjseuc7lg001v8jpb6silnxcs"},{"post_id":"cjseuc7lc001n8jpbmggph3fp","category_id":"cjseuc7lc001k8jpbrua2vapx","_id":"cjseuc7lh001y8jpbzsyzj7k5"},{"post_id":"cjseuc7l700188jpbb6jynqb5","category_id":"cjseuc7lc001k8jpbrua2vapx","_id":"cjseuc7lj00218jpbz7xm35r2"},{"post_id":"cjseuc7ld001q8jpbg27hm8yo","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7ll00258jpbzltipcrk"},{"post_id":"cjseuc7lf001t8jpbpuiqyv0k","category_id":"cjseuc7lc001k8jpbrua2vapx","_id":"cjseuc7lm00288jpbndu5zae0"},{"post_id":"cjseuc7l8001b8jpbff2s4ojs","category_id":"cjseuc7l9001c8jpbficrawsa","_id":"cjseuc7lo002b8jpbuqr5u2uj"},{"post_id":"cjseuc7lh001x8jpb30tq6mlh","category_id":"cjseuc7l1000x8jpbxjjumjzv","_id":"cjseuc7lw002e8jpb3yfo40an"},{"post_id":"cjseuc7li00208jpb9xe69nlu","category_id":"cjseuc7lc001k8jpbrua2vapx","_id":"cjseuc7m6002h8jpb79j1eiaq"},{"post_id":"cjseuc7la001g8jpboeklfkqx","category_id":"cjseuc7lc001k8jpbrua2vapx","_id":"cjseuc7mf002k8jpbr8rwjwr6"},{"post_id":"cjseuc7lk00238jpbw0w5mhpi","category_id":"cjseuc7l1000x8jpbxjjumjzv","_id":"cjseuc7mp002m8jpb0i9wju6y"},{"post_id":"cjseuc7ll00278jpbp4u4fwo3","category_id":"cjseuc7l9001c8jpbficrawsa","_id":"cjseuc7mq002o8jpblt10p4hp"},{"post_id":"cjseuc7lb001j8jpbk4d43fd0","category_id":"cjseuc7lc001k8jpbrua2vapx","_id":"cjseuc7mr002q8jpbl65uiccd"},{"post_id":"cjseuc7ln002a8jpba4scfz13","category_id":"cjseuc7lc001k8jpbrua2vapx","_id":"cjseuc7mr002s8jpbf70gorjx"},{"post_id":"cjseuc7lu002d8jpb4q8hbhft","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7ms002u8jpbuq6posw6"},{"post_id":"cjseuc7m4002g8jpboap5sbvd","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7ms002w8jpbn0cu9431"},{"post_id":"cjseuc7md002j8jpbqvqihg3u","category_id":"cjseuc7lc001k8jpbrua2vapx","_id":"cjseuc7ms002x8jpb5rc64zf4"},{"post_id":"cjseuc7nj003r8jpbi56v3ddi","category_id":"cjseuc7lc001k8jpbrua2vapx","_id":"cjseuc7nt003w8jpbgx6ibps9"},{"post_id":"cjseuc7nm003s8jpbhl2jqb8k","category_id":"cjseuc7lc001k8jpbrua2vapx","_id":"cjseuc7nv003y8jpbftsf8o2h"},{"post_id":"cjseuc7nq003u8jpbyrtf8sn8","category_id":"cjseuc7l1000x8jpbxjjumjzv","_id":"cjseuc7nw00428jpbe2elbzff"},{"post_id":"cjseuc7ns003v8jpb39vluf73","category_id":"cjseuc7l1000x8jpbxjjumjzv","_id":"cjseuc7nx00458jpbbupj8yg0"},{"post_id":"cjseuc7nu003x8jpbqordghof","category_id":"cjseuc7l1000x8jpbxjjumjzv","_id":"cjseuc7ny00498jpbolozn4py"},{"post_id":"cjseuc7nv00418jpbpl5zj52u","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7nz004c8jpbkc1cf2ng"},{"post_id":"cjseuc7nw00448jpbpu5xa771","category_id":"cjseuc7l400148jpbiar5dv4o","_id":"cjseuc7o1004g8jpb42uqvxsg"},{"post_id":"cjseuc7ny00488jpb08azqm12","category_id":"cjseuc7l400148jpbiar5dv4o","_id":"cjseuc7o3004j8jpb4z46al5z"},{"post_id":"cjseuc7nz004b8jpbuege6njy","category_id":"cjseuc7l400148jpbiar5dv4o","_id":"cjseuc7o4004m8jpbt1hjcmph"},{"post_id":"cjseuc7o1004f8jpbwchvsjq7","category_id":"cjseuc7l400148jpbiar5dv4o","_id":"cjseuc7od004p8jpbam9y6jjk"},{"post_id":"cjseuc7o2004i8jpbxuwsekft","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7oe004s8jpbiio06t0r"},{"post_id":"cjseuc7o3004l8jpbovohxgn0","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7of004v8jpb79v5wv71"},{"post_id":"cjseuc7o5004o8jpbtq6bcp6m","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7og004z8jpb62chtyey"},{"post_id":"cjseuc7od004r8jpbvtrwsx2d","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7oh00518jpb5cibz93g"},{"post_id":"cjseuc7of004u8jpbdivgqwx8","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7oh00548jpbj9rw7ygl"},{"post_id":"cjseuc7og004y8jpbmzo2d79z","category_id":"cjseuc7kb00028jpbyeto5b8b","_id":"cjseuc7oi00568jpbjjmyynja"},{"post_id":"cjseuc7ps005a8jpb8atyrb5l","category_id":"cjseuc7l1000x8jpbxjjumjzv","_id":"cjseuc7pw005g8jpb1m46wugn"},{"post_id":"cjseuc7pt005b8jpbzvsph2xx","category_id":"cjseuc7l1000x8jpbxjjumjzv","_id":"cjseuc7px005i8jpbrgesq3jv"},{"post_id":"cjseuc7pu005d8jpbmas5bxkc","category_id":"cjseuc7l400148jpbiar5dv4o","_id":"cjseuc7py005k8jpbedqdgsuk"},{"post_id":"cjseuc7pv005f8jpbb4s9ihmd","category_id":"cjseuc7l1000x8jpbxjjumjzv","_id":"cjseuc7qa005m8jpblhz6bh9q"},{"post_id":"cjseuc7qe005n8jpbs2aqc7lc","category_id":"cjseuc7l1000x8jpbxjjumjzv","_id":"cjseuc7qh005p8jpbo2vwat7v"},{"post_id":"cjseuc7rn005q8jpbhaqcfe3b","category_id":"cjseuc7l1000x8jpbxjjumjzv","_id":"cjseuc7ru005s8jpb5hgbwa5h"}],"PostTag":[{"post_id":"cjseuc7k100008jpbu4w33xul","tag_id":"cjseuc7kd00038jpbf0vbinmb","_id":"cjseuc7kk00098jpbeepefe2u"},{"post_id":"cjseuc7k800018jpb2i6sp80u","tag_id":"cjseuc7ki00088jpb7w5574y4","_id":"cjseuc7kr000g8jpbppo6pweq"},{"post_id":"cjseuc7ke00048jpbeml7l18l","tag_id":"cjseuc7kp000e8jpbf5e5800e","_id":"cjseuc7kw000n8jpbcgbl8awd"},{"post_id":"cjseuc7kf00058jpb032b4b3p","tag_id":"cjseuc7ku000k8jpbxs72sawn","_id":"cjseuc7l0000u8jpbqx927he4"},{"post_id":"cjseuc7kh00068jpbqw0ojbgh","tag_id":"cjseuc7ky000r8jpboblnvx7m","_id":"cjseuc7l300118jpb8bci2qzg"},{"post_id":"cjseuc7kk000a8jpbihq7uv7s","tag_id":"cjseuc7l2000z8jpbdsz0t6y7","_id":"cjseuc7l700198jpbqnuhcpcn"},{"post_id":"cjseuc7l700188jpbb6jynqb5","tag_id":"cjseuc7l600178jpbfezxqrwr","_id":"cjseuc7l9001f8jpbp0c8li9x"},{"post_id":"cjseuc7kn000b8jpbr8i06rku","tag_id":"cjseuc7l600178jpbfezxqrwr","_id":"cjseuc7lb001i8jpb1hav6uch"},{"post_id":"cjseuc7kp000f8jpbrb8zonfd","tag_id":"cjseuc7l9001e8jpbeyawjwnx","_id":"cjseuc7ld001p8jpbpubudhbr"},{"post_id":"cjseuc7ks000h8jpb1b0x70t5","tag_id":"cjseuc7lc001m8jpbowcp2ppn","_id":"cjseuc7lg001w8jpbuawovu1j"},{"post_id":"cjseuc7ku000l8jpbejaoxhr7","tag_id":"cjseuc7lg001u8jpb6avj24g6","_id":"cjseuc7lk00248jpbqbvezf6z"},{"post_id":"cjseuc7kx000o8jpbefnpmfl0","tag_id":"cjseuc7lj00228jpbql8dpvtn","_id":"cjseuc7lo002c8jpbear8ioju"},{"post_id":"cjseuc7kz000s8jpbgcgogziy","tag_id":"cjseuc7lm00298jpb20co994a","_id":"cjseuc7md002i8jpbftpy5063"},{"post_id":"cjseuc7l0000v8jpbrv1ltdhh","tag_id":"cjseuc7lm00298jpb20co994a","_id":"cjseuc7mq002n8jpbfvm2g204"},{"post_id":"cjseuc7l1000y8jpbi871cc0n","tag_id":"cjseuc7mo002l8jpb6f2eeqf8","_id":"cjseuc7mr002r8jpbo7t97j2p"},{"post_id":"cjseuc7l300128jpbsb6jqxar","tag_id":"cjseuc7l9001e8jpbeyawjwnx","_id":"cjseuc7ms002v8jpbhjpjb6mz"},{"post_id":"cjseuc7l400158jpbrgmwhlgu","tag_id":"cjseuc7ms002t8jpbxcy939a6","_id":"cjseuc7mt002z8jpb8dmkmkca"},{"post_id":"cjseuc7l8001b8jpbff2s4ojs","tag_id":"cjseuc7lg001u8jpb6avj24g6","_id":"cjseuc7mt00318jpbaftutzx1"},{"post_id":"cjseuc7la001g8jpboeklfkqx","tag_id":"cjseuc7mt00308jpb9n3qg7lz","_id":"cjseuc7mu00338jpbv8x87b6j"},{"post_id":"cjseuc7lb001j8jpbk4d43fd0","tag_id":"cjseuc7mo002l8jpb6f2eeqf8","_id":"cjseuc7mu00358jpbuna50fc6"},{"post_id":"cjseuc7lc001n8jpbmggph3fp","tag_id":"cjseuc7mu00348jpboq2l1egt","_id":"cjseuc7mu00378jpb51oetawa"},{"post_id":"cjseuc7ld001q8jpbg27hm8yo","tag_id":"cjseuc7mu00368jpbhp7dhtj0","_id":"cjseuc7mv00398jpbhjkyvofx"},{"post_id":"cjseuc7lf001t8jpbpuiqyv0k","tag_id":"cjseuc7mv00388jpbh2f173hu","_id":"cjseuc7mv003b8jpb6uyvm9dn"},{"post_id":"cjseuc7lh001x8jpb30tq6mlh","tag_id":"cjseuc7mv003a8jpbpjomh1hw","_id":"cjseuc7mv003d8jpbincrqiyw"},{"post_id":"cjseuc7li00208jpb9xe69nlu","tag_id":"cjseuc7mv003c8jpbbqqhumm6","_id":"cjseuc7mw003f8jpb1fy1f9ry"},{"post_id":"cjseuc7lk00238jpbw0w5mhpi","tag_id":"cjseuc7mv003a8jpbpjomh1hw","_id":"cjseuc7mw003h8jpb3boo5w6m"},{"post_id":"cjseuc7ll00278jpbp4u4fwo3","tag_id":"cjseuc7mw003g8jpbls1jnj3d","_id":"cjseuc7mx003j8jpbwvdytgj9"},{"post_id":"cjseuc7ln002a8jpba4scfz13","tag_id":"cjseuc7mw003i8jpbu158d4yw","_id":"cjseuc7mx003l8jpbs95lhk3h"},{"post_id":"cjseuc7lu002d8jpb4q8hbhft","tag_id":"cjseuc7mx003k8jpb064cd4se","_id":"cjseuc7mx003n8jpbe941o6jl"},{"post_id":"cjseuc7m4002g8jpboap5sbvd","tag_id":"cjseuc7mx003m8jpb7ve8ihu4","_id":"cjseuc7mx003p8jpbtin2g7ul"},{"post_id":"cjseuc7md002j8jpbqvqihg3u","tag_id":"cjseuc7mx003o8jpbk39zp29o","_id":"cjseuc7mz003q8jpbgr8yjphr"},{"post_id":"cjseuc7ns003v8jpb39vluf73","tag_id":"cjseuc7l2000z8jpbdsz0t6y7","_id":"cjseuc7nv00408jpb7ij77pbb"},{"post_id":"cjseuc7nj003r8jpbi56v3ddi","tag_id":"cjseuc7nq003t8jpbioa3pcqi","_id":"cjseuc7nw00438jpb4jmd1jn3"},{"post_id":"cjseuc7nu003x8jpbqordghof","tag_id":"cjseuc7l2000z8jpbdsz0t6y7","_id":"cjseuc7ny00478jpbjrt528a1"},{"post_id":"cjseuc7nm003s8jpbhl2jqb8k","tag_id":"cjseuc7nq003t8jpbioa3pcqi","_id":"cjseuc7nz004a8jpbj57yx3t7"},{"post_id":"cjseuc7nw00448jpbpu5xa771","tag_id":"cjseuc7lc001m8jpbowcp2ppn","_id":"cjseuc7o0004e8jpbvt219jjl"},{"post_id":"cjseuc7ny00488jpb08azqm12","tag_id":"cjseuc7lc001m8jpbowcp2ppn","_id":"cjseuc7o2004h8jpbzx4jhrpb"},{"post_id":"cjseuc7nq003u8jpbyrtf8sn8","tag_id":"cjseuc7nx00468jpbg0fqlqq0","_id":"cjseuc7o3004k8jpb8goddv7y"},{"post_id":"cjseuc7nz004b8jpbuege6njy","tag_id":"cjseuc7lc001m8jpbowcp2ppn","_id":"cjseuc7o5004n8jpbvsu59bl9"},{"post_id":"cjseuc7o1004f8jpbwchvsjq7","tag_id":"cjseuc7lc001m8jpbowcp2ppn","_id":"cjseuc7od004q8jpb9z9fi0hp"},{"post_id":"cjseuc7nv00418jpbpl5zj52u","tag_id":"cjseuc7o0004d8jpbiq0pfhsc","_id":"cjseuc7of004t8jpbwp7zraq2"},{"post_id":"cjseuc7o2004i8jpbxuwsekft","tag_id":"cjseuc7lj00228jpbql8dpvtn","_id":"cjseuc7og004x8jpbj1d58y4h"},{"post_id":"cjseuc7o3004l8jpbovohxgn0","tag_id":"cjseuc7l9001e8jpbeyawjwnx","_id":"cjseuc7oh00508jpbnc1bkrsn"},{"post_id":"cjseuc7o5004o8jpbtq6bcp6m","tag_id":"cjseuc7l9001e8jpbeyawjwnx","_id":"cjseuc7oh00528jpbf039u8za"},{"post_id":"cjseuc7od004r8jpbvtrwsx2d","tag_id":"cjseuc7of004w8jpbzbib8osk","_id":"cjseuc7oi00558jpbotj7ikwr"},{"post_id":"cjseuc7of004u8jpbdivgqwx8","tag_id":"cjseuc7of004w8jpbzbib8osk","_id":"cjseuc7ok00588jpb4wlvw1cx"},{"post_id":"cjseuc7og004y8jpbmzo2d79z","tag_id":"cjseuc7of004w8jpbzbib8osk","_id":"cjseuc7p500598jpbxlfrjzz2"},{"post_id":"cjseuc7pt005b8jpbzvsph2xx","tag_id":"cjseuc7l2000z8jpbdsz0t6y7","_id":"cjseuc7pv005e8jpb8jzy2uox"},{"post_id":"cjseuc7pu005d8jpbmas5bxkc","tag_id":"cjseuc7lc001m8jpbowcp2ppn","_id":"cjseuc7px005h8jpbvojv1e2u"},{"post_id":"cjseuc7pv005f8jpbb4s9ihmd","tag_id":"cjseuc7mv003a8jpbpjomh1hw","_id":"cjseuc7py005j8jpbsjgeyzh5"},{"post_id":"cjseuc7ps005a8jpb8atyrb5l","tag_id":"cjseuc7pu005c8jpbgw8hcqlv","_id":"cjseuc7qa005l8jpb8z8fhnnd"},{"post_id":"cjseuc7qe005n8jpbs2aqc7lc","tag_id":"cjseuc7l2000z8jpbdsz0t6y7","_id":"cjseuc7qg005o8jpbmblx0lv5"},{"post_id":"cjseuc7rn005q8jpbhaqcfe3b","tag_id":"cjseuc7ro005r8jpb8er67tvq","_id":"cjseuc7ru005t8jpb1osz2i4c"}],"Tag":[{"name":"iTerm2","_id":"cjseuc7kd00038jpbf0vbinmb"},{"name":"Cocoapods","_id":"cjseuc7ki00088jpb7w5574y4"},{"name":"Charles","_id":"cjseuc7kp000e8jpbf5e5800e"},{"name":"个人总结","_id":"cjseuc7ku000k8jpbxs72sawn"},{"name":"ARTS","_id":"cjseuc7ky000r8jpboblnvx7m"},{"name":"AFNetworking","_id":"cjseuc7l2000z8jpbdsz0t6y7"},{"name":"Block","_id":"cjseuc7l600178jpbfezxqrwr"},{"name":"GCD","_id":"cjseuc7l9001e8jpbeyawjwnx"},{"name":"RN","_id":"cjseuc7lc001m8jpbowcp2ppn"},{"name":"基础数据类型","_id":"cjseuc7lg001u8jpb6avj24g6"},{"name":"NSTimer","_id":"cjseuc7lj00228jpbql8dpvtn"},{"name":"Objective-C 锁","_id":"cjseuc7lm00298jpb20co994a"},{"name":"Debug","_id":"cjseuc7mo002l8jpb6f2eeqf8"},{"name":"正则表达式","_id":"cjseuc7ms002t8jpbxcy939a6"},{"name":"效率","_id":"cjseuc7mt00308jpb9n3qg7lz"},{"name":"Bug","_id":"cjseuc7mu00348jpboq2l1egt"},{"name":"本地化","_id":"cjseuc7mu00368jpbhp7dhtj0"},{"name":"数组","_id":"cjseuc7mv00388jpbh2f173hu"},{"name":"Moya","_id":"cjseuc7mv003a8jpbpjomh1hw"},{"name":"emoji","_id":"cjseuc7mv003c8jpbbqqhumm6"},{"name":"nil","_id":"cjseuc7mw003g8jpbls1jnj3d"},{"name":"动画","_id":"cjseuc7mw003i8jpbu158d4yw"},{"name":"UIActivityItemSource","_id":"cjseuc7mx003k8jpb064cd4se"},{"name":"fastlane","_id":"cjseuc7mx003m8jpb7ve8ihu4"},{"name":"preferredStatusBarStyle","_id":"cjseuc7mx003o8jpbk39zp29o"},{"name":"Swift","_id":"cjseuc7nq003t8jpbioa3pcqi"},{"name":"MJRefresh","_id":"cjseuc7nx00468jpbg0fqlqq0"},{"name":"Hexo","_id":"cjseuc7o0004d8jpbiq0pfhsc"},{"name":"CALayer","_id":"cjseuc7of004w8jpbzbib8osk"},{"name":"Masonry","_id":"cjseuc7pu005c8jpbgw8hcqlv"},{"name":"YYCache","_id":"cjseuc7ro005r8jpb8er67tvq"}]}}